{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651448545669,"user_tz":-540,"elapsed":21855,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d61455fe-3892-4429-9640-9669ca5574c4"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1651448575936,"user_tz":-540,"elapsed":30270,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","import IPython\n","import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":22,"metadata":{"id":"QmhLikYlSuzi","executionInfo":{"status":"ok","timestamp":1651449069327,"user_tz":-540,"elapsed":353,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    # upper = talib.MAX(res_df_.high, timeperiod=20)\n","    # lower = talib.MAX(res_df_.low, timeperiod=20)\n","    \n","    # # bb_width_v2(df, period=bb_period, multiple=1)\n","    # # # df = bb_line(df, df_5T, '5T')\n","    # # # df = bb_line(df, df_15T, '15T')\n","    # # print(\"bb phase done\")\n","\n","    c_itv = '15T'\n","\n","    # wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":23,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"status":"ok","timestamp":1651449118242,"user_tz":-540,"elapsed":866,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"f367f285-9ae3-424f-fd38-65059731d49d"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                         open_5T  high_5T   low_5T  close_5T  open_15T  high_15T  low_15T  close_15T  cu_es_15T1  co_es_15T1\n","index                                                                                                                       \n","2022-04-27 08:41:59.999  2803.60  2806.33  2798.63   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014\n","2022-04-27 08:42:59.999  2803.60  2806.33  2798.63   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014\n","2022-04-27 08:43:59.999  2803.60  2806.33  2798.63   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014\n","2022-04-27 08:44:59.999  2803.60  2806.33  2798.63   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014\n","2022-04-27 08:45:59.999  2803.55  2803.97  2799.26   2800.43   2803.55   2803.97  2799.26    2800.43    1.413160    0.226473"],"text/html":["\n","  <div id=\"df-9512d58b-f61f-4484-80b0-b24748038375\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>open_5T</th>\n","      <th>high_5T</th>\n","      <th>low_5T</th>\n","      <th>close_5T</th>\n","      <th>open_15T</th>\n","      <th>high_15T</th>\n","      <th>low_15T</th>\n","      <th>close_15T</th>\n","      <th>cu_es_15T1</th>\n","      <th>co_es_15T1</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2803.60</td>\n","      <td>2806.33</td>\n","      <td>2798.63</td>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2803.60</td>\n","      <td>2806.33</td>\n","      <td>2798.63</td>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2803.60</td>\n","      <td>2806.33</td>\n","      <td>2798.63</td>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2803.60</td>\n","      <td>2806.33</td>\n","      <td>2798.63</td>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2803.55</td>\n","      <td>2803.97</td>\n","      <td>2799.26</td>\n","      <td>2800.43</td>\n","      <td>2803.55</td>\n","      <td>2803.97</td>\n","      <td>2799.26</td>\n","      <td>2800.43</td>\n","      <td>1.413160</td>\n","      <td>0.226473</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-9512d58b-f61f-4484-80b0-b24748038375')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-9512d58b-f61f-4484-80b0-b24748038375 button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-9512d58b-f61f-4484-80b0-b24748038375');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":23}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":24,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":880,"status":"ok","timestamp":1651449128652,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"2927f888-05d5-4238-b29b-31acfcef6fc6"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651448577947,"user_tz":-540,"elapsed":2015,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0c46e03f-2ea6-406a-c68e-33cc156b6204"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 1.4465866088867188\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":20,"metadata":{"id":"RQH_l4opEh_O","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651449055641,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"844e33b3-c8cf-44bc-b219-300c186304d3"},"outputs":[{"output_type":"execute_result","data":{"text/plain":["open             float64\n","high             float64\n","low              float64\n","close            float64\n","volume           float64\n","dc_upper_3T20    float64\n","dc_lower_3T20    float64\n","dc_base_3T20     float64\n","dc_upper_H20     float64\n","dc_lower_H20     float64\n","dc_base_H20      float64\n","dc_upper_15T1    float64\n","dc_lower_15T1    float64\n","dc_base_15T1     float64\n","open_5T          float64\n","high_5T          float64\n","low_5T           float64\n","close_5T         float64\n","open_15T         float64\n","high_15T         float64\n","low_15T          float64\n","close_15T        float64\n","dtype: object"]},"metadata":{},"execution_count":20}],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":19,"metadata":{"id":"x9wkWw15XCAm","executionInfo":{"status":"ok","timestamp":1651449054300,"user_tz":-540,"elapsed":493,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP","executionInfo":{"status":"ok","timestamp":1651449032985,"user_tz":-540,"elapsed":350,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":18,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PV-dlAVZfehP"},"outputs":[],"source":["def to_value_index(prev_wave_point_idx2, len_df_range):\n","  valid_idx = ~np.isnan(prev_wave_point_idx2)\n","  # np.sum(~np.isnan(prev_wave_point_idx2))\n","  prevwp_valid_value = prev_wave_point_idx2[valid_idx].astype(int)   # inner box value\n","  prev_wave_point_ = np.full(len(valid_idx), False)\n","  prev_wave_point_[prevwp_valid_value] = True\n","\n","  return np.where(prev_wave_point_, len_df_range, np.nan)\n","\n","def get_index_bybool(bool_arr, len_df_range):\n","  return np.where(bool_arr, len_df_range, np.nan)\n","\n","\n","def using_clump(a):\n","    return [a[s].astype(int) for s in np.ma.clump_unmasked(np.ma.masked_invalid(a))]\n","\n","def fill_arr(arr_, mode='ffill'):\n","  if mode == 'ffill':\n","    return pd.Series(arr_).ffill().to_numpy()\n","  else:\n","    return pd.Series(arr_).bfill().to_numpy()\n","\n","def roll_wave_hl(t_df, len_df, itv, period1, roll_hl_cnt=4):\n","        \n","  wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(itv, period1)].to_numpy()\n","  wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(itv, period1)].to_numpy()\n","  cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)].to_numpy()\n","  co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(itv, period1)].to_numpy()\n","  \n","  valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","  valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","  cu_roll_hl_idx_arr = np.array([valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","  co_roll_hl_idx_arr = np.array([valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","  cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","  cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","  co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","  co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","  cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","  cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","  co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","  co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","  return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()\n","\n","def wave_range_v11(t_df, period1, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = cu_idx > cu_prime_idx_fill_\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","\n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  valid_idx = co_idx > co_prime_idx_fill_\n","\n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # point_missing 으로 인한 low 갱신 회피\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","\n","plot_size = 100\n","t_df = res_df.iloc[i - plot_size:i]\n","# t_df = res_df.iloc[i - plot_size:i - 22]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-Dr_tTk9csFm"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","itv, period1, period2 = 'T', 5, 5\n","t_df = wave_range_v11(t_df, period1, ltf_df=None)\n","# prev_point_period = 100\n","# t_df = get_prev_wave_hl(t_df, itv, period1, period2, prev_point_period)\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(itv, period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(itv, period1)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(itv, period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(itv, period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# plt.step(len_df_range, wave_high_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_fill_, alpha=1.0, color='yellow', linewidth=2)\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","plt.xlim(0, len_df)\n","\n","plt.show()"]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["roll_wave_hl(t_df, itv, period1)[0][150]"],"metadata":{"id":"G5jpriueRpxH"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["itv, period1, period2 = 'T', 5, 5\n","t_df = donchian_channel_v4(t_df, period1) \n","\n","# dc_lower_ = t_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","# dc_upper_ = t_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","# short_open_res = np.ones(len_df)\n","# long_open_res = np.ones(len_df)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","b1_close = t_df.close.shift(1).to_numpy()\n","\n","\n","# ------ define co, cu ------ #\n","co_bool = (b1_close < dc_base_) & (dc_base_ < close)\n","cu_bool = (b1_close > dc_base_) & (dc_base_ > close)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","# ------ get co, cu terms ------ #\n","high_bool = cu_fill_idx < co_fill_idx\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","# ------ get valid_idx range (inner len_df) ------ #\n","paired_cu_idx = high_terms[:, 1]\n","paired_co_idx = low_terms[:, 1]\n","\n","valid_cu_bool = paired_cu_idx < len_df\n","valid_co_bool = paired_co_idx < len_df\n","\n","paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","# ------ get wave_hl & terms ------ #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ check update high & low (occurs by point missing) ------ # \n","cu_prime_idx = np.full(len_df, np.nan)\n","cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","valid_idx = cu_idx > cu_prime_idx_fill_\n","\n","update_low = np.full(len_df, np.nan)\n","update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","\n","co_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","valid_idx = co_idx > co_prime_idx_fill_\n","\n","update_high = np.full(len_df, np.nan)\n","update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]"],"metadata":{"id":"TqMmmSAGuChM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","roll_hl_cnt = 4\n","cu_roll_hl_idx_arr = np.array([valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","co_roll_hl_idx_arr = np.array([valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","cu_roll_high_fill_ = cu_roll_high_.ffill().to_numpy()\n","cu_roll_low_fill_ = cu_roll_low_.ffill().to_numpy()\n","co_roll_high_fill_ = co_roll_high_.ffill().to_numpy()\n","co_roll_low_fill_ = co_roll_low_.ffill().to_numpy()"],"metadata":{"id":"nZRVW90lbAy1"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1651448667086,"user_tz":-540,"elapsed":3427,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":6,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1651448668153,"user_tz":-540,"elapsed":1071,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","sys_log = logging.getLogger()\n","\n","def get_line(touch_idx, rtc_):\n","    touch_idx_copy = touch_idx.copy()\n","\n","    nan_idx = np.isnan(touch_idx_copy)\n","    touch_idx_copy[nan_idx] = 0  # for indexing array\n","    touch_line = rtc_[touch_idx_copy.astype(int)].copy()\n","    touch_line[nan_idx] = np.nan  # for true comp.\n","\n","    return touch_line\n","\n","\n","def enlist_rtc(res_df, config, np_timeidx):\n","    selection_id = config.selection_id\n","    # ------------ rtc_gap ------------ #\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","    \n","    res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(p1_itv1, p1_period1)]\n","    res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(p1_itv1, p1_period1)]\n","    res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(p1_itv1, p1_period1)]\n","    res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(p1_itv1, p1_period1)]\n","\n","    # res_df[short_tp_1_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","    # res_df[short_tp_0_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","    # res_df[long_tp_1_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","    # res_df[long_tp_0_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","\n","    if config.tr_set.p2_itv1 != \"None\":\n","        p2_period1 = config.tr_set.p2_period1\n","        p2_period2 = config.tr_set.p2_period2\n","        res_df[short_epout_1_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[short_epout_0_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","        res_df[long_epout_1_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[long_epout_0_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","    else:\n","        res_df[short_epout_1_] = res_df['low_{}'.format(config.loc_set.point.tf_entry)]\n","        res_df[short_epout_0_] = res_df['high_{}'.format(config.loc_set.point.tf_entry)]\n","        res_df[long_epout_1_] = res_df['high_{}'.format(config.loc_set.point.tf_entry)]\n","        res_df[long_epout_0_] = res_df['low_{}'.format(config.loc_set.point.tf_entry)]\n","\n","        # res_df[short_epout_1_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","        # res_df[short_epout_0_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","        # res_df[long_epout_1_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","        # res_df[long_epout_0_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df[short_tp_1_] - res_df[short_tp_0_])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df[long_tp_1_] - res_df[long_tp_0_])\n","    res_df['short_epout_gap_{}'.format(selection_id)] = abs(res_df[short_epout_1_] - res_df[short_epout_0_])\n","    res_df['long_epout_gap_{}'.format(selection_id)] = abs(res_df[long_epout_1_] - res_df[long_epout_0_])\n","\n","    # ------------ dtk_gap ------------ #\n","    # res_df['short_dtk_1_{}'.format(selection_id)] = res_df['bb_lower_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['short_dtk_0_{}'.format(selection_id)] = res_df['dc_upper_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['long_dtk_1_{}'.format(selection_id)] = res_df['bb_upper_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['long_dtk_0_{}'.format(selection_id)] = res_df['dc_lower_%s' % config.loc_set.zone.dtk_itv]\n","\n","    # res_df['short_dtk_gap_{}'.format(selection_id)] = abs(\n","    #     res_df['short_dtk_0_{}'.format(selection_id)] - res_df['short_dtk_1_{}'.format(selection_id)])\n","    # res_df['long_dtk_gap_{}'.format(selection_id)] = abs(\n","    #     res_df['long_dtk_1_{}'.format(selection_id)] - res_df['long_dtk_0_{}'.format(selection_id)])\n","\n","    return res_df\n","\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","    selection_id = config.selection_id\n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","    short_open_res = np.ones(len_df)\n","    long_open_res = np.ones(len_df)\n","\n","    short_tp_1_col, short_tp_0_col, short_tp_gap_col = 'short_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(\n","        selection_id), 'short_tp_gap_{}'.format(selection_id)\n","    long_tp_1_col, long_tp_0_col, long_tp_gap_col = 'long_tp_1_{}'.format(selection_id), 'long_tp_0_{}'.format(\n","        selection_id), 'long_tp_gap_{}'.format(selection_id)\n","    short_epout_1_col, short_epout_0_col, short_epout_gap_col = 'short_epout_1_{}'.format(selection_id), 'short_epout_0_{}'.format(\n","        selection_id), 'short_epout_gap_{}'.format(selection_id)\n","    long_epout_1_col, long_epout_0_col, long_epout_gap_col = 'long_epout_1_{}'.format(selection_id), 'long_epout_0_{}'.format(\n","        selection_id), 'long_epout_gap_{}'.format(selection_id)\n","\n","    tp_cols = [short_tp_1_col, short_tp_0_col, short_tp_gap_col, long_tp_1_col, long_tp_0_col, long_tp_gap_col]  # Todo - public_indi 이전에 해야할지도 모름\n","    epout_cols = [short_epout_1_col, short_epout_0_col, short_epout_gap_col, long_epout_1_col, long_epout_0_col,\n","                  long_epout_gap_col]  # Todo - public_indi 이전에 해야할지도 모름\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","\n","    short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_ = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_ = [res_df[col_].to_numpy() for col_ in epout_cols]\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ---------------- point - support_confirmer---------------- #\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","\n","    if p2_itv1 != \"None\":\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","    else:  \n","        # ------ p1 only ------ #\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = 0  # default\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = 0 \n","        \n","        # ====== wave_point ====== #\n","        # short_open_res *= res_df['wave_co_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # long_open_res *= res_df['wave_cu_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # ------ wave_mm ------ #\n","        # wave_high_terms_cnt_fill_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # wave_low_terms_cnt_fill_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # short_open_res *= (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater) & (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater)\n","        # long_open_res *= (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater) & (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher high (long) ------ #\n","        # cu_roll_high_, cu_roll_low_, co_roll_high_, co_roll_low_ = roll_wave_hl(res_df, len_df, p1_itv1, p1_period1, roll_hl_cnt=4)\n","\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))        \n","\n","        # ------ tf_entry ------ #\n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        open_ = res_df['open_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","        short_open_res *= (open_ > dc_base_) & (dc_base_ > close_)\n","        long_open_res *= (open_ < dc_base_) & (dc_base_ < close_)\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res\n","\n","    # ------------------ tr_set ------------------ #\n","    # ------------ tpep ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = short_tp_1_ - short_tp_gap_ * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = long_tp_1_ + long_tp_gap_ * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg = config.tr_set.ep_gap\n","        res_df['short_ep_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * epg\n","        res_df['long_ep_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * epg\n","\n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep_{}'.format(selection_id)] = res_df['close']\n","        res_df['long_ep_{}'.format(selection_id)] = res_df['close']\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    res_df['short_out_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * outg\n","    res_df['long_out_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * outg\n","\n","    # ------------ point validation ------------ #\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","    short_open_res *= (short_tp_ < short_ep_) & (short_ep_ < short_out_)\n","    # short_open_res *= close < short_ep_   # reject open_execution\n","    short_open_res *= close < short_out_    # reject open_execution\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res * (not config.pos_set.short_ban)\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","    long_open_res *= (long_tp_ > long_ep_) & (long_ep_ > long_out_)\n","    # long_open_res *= close > long_ep_   # reject open_execution\n","    long_open_res *= close > long_out_    # reject open_execution\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res * (not config.pos_set.long_ban)\n","\n","    if show_detail:\n","      sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","      sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","    \n","    # ------------ wave_bias ------------ #\n","    wb_tpg = config.tr_set.wb_tp_gap\n","    wb_outg = config.tr_set.wb_out_gap\n","    res_df['short_wave_1_{}'.format(selection_id)] = short_tp_1_ - short_tp_gap_ * wb_tpg\n","    res_df['long_wave_1_{}'.format(selection_id)] = long_tp_1_ + long_tp_gap_ * wb_tpg\n","    res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * wb_outg\n","    res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * wb_outg\n","\n","    # ------ tr ------ #\n","    res_df['short_tr_{}'.format(selection_id)] = abs(\n","        (short_ep_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep_ / short_out_ - config.trader_set.market_fee - 1))\n","    res_df['long_tr_{}'.format(selection_id)] = abs(\n","        (long_tp_ / long_ep_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    if config.tr_set.c_ep_gap != \"None\":\n","        # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","        # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","        res_df['short_ep2_{}'.format(selection_id)] = short_epout_1_ + short_epout_gap_ * config.tr_set.c_ep_gap\n","        res_df['long_ep2_{}'.format(selection_id)] = long_epout_1_ - long_epout_gap_ * config.tr_set.c_ep_gap\n","\n","    # ------ zoned_out ------ #\n","    if config.tr_set.t_out_gap != \"None\":\n","        # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","        # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","        res_df['short_out2_{}'.format(selection_id)] = res_df['short_epout_0_{}'.format(selection_id)] + res_df[\n","            'short_epout_gap_{}'.format(selection_id)] * config.tr_set.t_out_gap\n","        res_df['long_out2_{}'.format(selection_id)] = res_df['long_epout_0_{}'.format(selection_id)] - res_df[\n","            'long_epout_gap_{}'.format(selection_id)] * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":31,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1651449343027,"user_tz":-540,"elapsed":2908,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","    wave_period = config.tr_set.wave_period\n","\n","    t_df = wave_range_v11(res_df, wave_period)  # Todo, currently only T itv allowed\n","\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def ep_out_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_out(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_out_v2(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k or h[e_j] >= short_tp_0_[tp_j] - short_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()\n","            long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k or l[e_j] <= long_tp_0_[tp_j] + long_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","    allow_ep_in = 1\n","    if config.selection_id in ['v5_2']:\n","        if side == OrderSide.SELL:\n","            dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","            dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","            allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","                           (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","        else:\n","            dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","            dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","            allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","                           (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","    if config.selection_id in ['v3_4']:\n","        wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","        wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","        close = res_df['close'].to_numpy()\n","        if side == OrderSide.SELL:\n","            sup_T = res_df['sup_T'].to_numpy()\n","            allow_ep_in *= close[i] < sup_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","        else:\n","            resi_T = res_df['resi_T'].to_numpy()\n","            allow_ep_in *= close[i] > resi_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","    if allow_ep_in:\n","        out_j = i\n","    return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    if config.loc_set.point.wick_ratio != \"None\":\n","      itv_num = to_itvnum(config.loc_set.point.wick_itv)\n","      if ep_loc_side == OrderSide.SELL:\n","          b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","          mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","          mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    # -------------- tr_thresh -------------- #\n","    if config.loc_set.point.short_tr_thresh != \"None\":\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point.short_tr_thresh\n","            mr_res *= short_tr_ <= config.loc_set.point.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point.long_tr_thresh\n","            mr_res *= long_tr_ <= config.loc_set.point.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point.long_tr_thresh, mr_res[c_i]))\n","\n","    # -------------- spread - independent to tr_set -------------- #  --> Todo, 사용 안하고 싶은 wave_point\n","    if config.loc_set.point.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point.long_spread, mr_res[c_i]))                  \n","\n","    # ------------ ratios ------------ #\n","    # ------ enough_space ------ #\n","    if config.loc_set.point.es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1\n","      if ep_loc_side == OrderSide.SELL:\n","        cu_es_ = res_df['cu_es_{}{}'.format(itv, period1)].to_numpy()\n","        mr_res *= cu_es_ >= config.loc_set.point.es\n","        if show_detail:\n","            sys_log.warning(\"cu_es_ >= config.loc_set.point.es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.es, mr_res[c_i]))\n","      else:\n","        co_es_ = res_df['co_es_{}{}'.format(itv, period1)].to_numpy()\n","        mr_res *= co_es_ >= config.loc_set.point.es\n","        if show_detail:\n","            sys_log.warning(\"co_es_ >= config.loc_set.point.es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.es, mr_res[c_i]))\n","\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    if config.loc_set.point.crr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","      mr_res *= b1_crr_ >= config.loc_set.point.crr\n","      if show_detail:\n","          sys_log.warning(\"b1_crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n"," \n","    # ------------ rtc_zone  ------------ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ------------ zone ------------ #\n","    # config 로 통제할 수 없는 zone 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일)\n","    if config.loc_set.zone.use_zone:\n","\n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["\n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":8,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1651448669814,"user_tz":-540,"elapsed":4,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_2\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-04-08\\\\2022-04-08 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 0.0002,\n","    \"market_fee\": 0.0004,\n","    \"initial_asset\": 10,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"api_retry_term\": 3,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"wick_ratio\": \"None\",\n","      \"wick_itv\": \"15T\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"wave_period\": 5,\n","    \"wave_lesser\": 1,\n","    \"wave_greater\": 15,\n","    \"p1_itv1\": \"15T\",\n","    \"p1_itv0\": \"T\",\n","    \"p1_period1\": 1,\n","    \"p1_period2\": 5,\n","    \"p2_itv1\": \"None\",\n","    \"p2_itv0\": \"T\",\n","    \"p2_period1\": 20,\n","    \"p2_period2\": 40,\n","    \"ei_k\": 0.0,\n","    \"ep_out_tick\": 5,\n","    \"tp_gap\": 0.0,\n","    \"decay_gap\": \"None\",\n","    \"ep_gap\": -1.0,\n","    \"out_gap\": 0,\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 240\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":9,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651448676221,"user_tz":-540,"elapsed":362,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"9c0738c1-6be9-461a-fe87-cfe639ab32e4"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_2\" {\n"," \"point\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"wick_ratio\": \"None\",\n","  \"wick_itv\": \"15T\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"wave_period\": 5,\n"," \"wave_lesser\": 1,\n"," \"wave_greater\": 15,\n"," \"p1_itv1\": \"15T\",\n"," \"p1_itv0\": \"T\",\n"," \"p1_period1\": 1,\n"," \"p1_period2\": 5,\n"," \"p2_itv1\": \"None\",\n"," \"p2_itv0\": \"T\",\n"," \"p2_period1\": 20,\n"," \"p2_period2\": 40,\n"," \"ei_k\": 0.0,\n"," \"ep_out_tick\": 5,\n"," \"tp_gap\": 0.0,\n"," \"decay_gap\": \"None\",\n"," \"ep_gap\": -1.0,\n"," \"out_gap\": 0,\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 240\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [ep_out_v2, ep_loc_point2_v2, lvrg_set]  # ep_out for p1 & p2\n","funcs = [ep_out, ep_loc_point2_v2, lvrg_set]     # ep_out for p1-only\n","# funcs = [ep_out_v0, ep_loc_point2_v2, lvrg_set]  # ep_out for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","# ['selection_id', 'pos_set', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\""]},{"cell_type":"code","execution_count":25,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3833,"status":"ok","timestamp":1651449139569,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"a5150c12-ce44-4d4c-8088-19a69804dcbb"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 2.2996177673339844\n","make data_list elapsed time : 0.00019049644470214844\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_iYcJk8nK8Yq"},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_greater = 5\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap = -1.\n","# config_list[0].tr_set.out_gap = -0.5\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 240"]},{"cell_type":"code","execution_count":26,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1651449140400,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"5ba472f9-2264-4730-8b8b-3ec7563e9247"},"outputs":[{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 57539\n","np.sum(long_open_res == 1) : 57539\n","np.sum(short_open_res == 1) : 9908\n","np.sum(long_open_res == 1) : 9982\n","np.sum(short_open_res == 1) : 3822\n","np.sum(long_open_res == 1) : 4049\n"]},{"output_type":"stream","name":"stdout","text":["enlist_rtc elapsed time : 0.03810596466064453\n","enlist_tr elapsed time : 0.13007640838623047\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  start_0 = time.time()\n","  res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":32,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1651449349589,"user_tz":-540,"elapsed":337,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point.es = 0.8\n","# config_list[0].loc_set.point.crr = 2\n","# config_list[0].loc_set.point.wick_ratio = 0.5\n","# config_list[0].loc_set.point.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point.abs_ratio = \"None\"  # 0.7\n","# config_list[0].loc_set.point.short_tr_thresh = \"None\" #  0.8 # # 0.7 # tr_thresh 엄청 민감함\n","# config_list[0].loc_set.point.long_tr_thresh = 0.85 #  0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":33,"metadata":{"executionInfo":{"elapsed":869,"status":"ok","timestamp":1651449351770,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"d6694c6d-1ae9-489d-910d-6466a8b9b021"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_es_ >= config.loc_set.point.es : 0.86314 0.80000 (1.0)\n","co_es_ >= config.loc_set.point.es : -0.01901 0.80000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9620611667633057\n"]}],"source":["open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.ei_k = -0.5\n","# config_list[0].tr_set.ep_out_tick = 5\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# # config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# # config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# # config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# # config_list[0].tp_set.p_qty_ratio = \"[0.1, 0.9]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","# config_list[0].lvrg_set.leverage = 1\n","# config_list[0].lvrg_set.static_lvrg = 0\n","# config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":34,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":644},"executionInfo":{"elapsed":3327,"status":"ok","timestamp":1651449361405,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"d2a197c8-b955-4f7b-9253-519eb23b160c"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.20252156257629395\n","short_obj.shape : (191, 5)\n","long_obj.shape : (219, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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Yvz48QQFBT3Q1YpTU1PZv38/L774okX/gAEDOHz4MHFxcfc0X//+/YmIiCA0NDTbvgsXLnD58mXq1avH008/zapVq8z7rK2t+fnnn6lfvz49evQgIiKicCeUD/amDNiCLMKVEdDs1Cpvu9KCLkuygksFXUMhKjqNqGipb1he+HP/dfwPWj4K6e6ai7Eg5EBF0lgT9vb2tGzZ0ry4yV9//UWXLl0s2pw5cwDo2bOn+dFKQcgP0djyxaoV54mKSCLNkBlMsrdXM2AjEnOvnykIUP719e+//yY6OpqnnnrKwq5r164FKqMgCPdCcemr1IAVKjwxMTGcPXuWzp07mx8XVBSFQ4cO0atXL7755ptCz92pUyf27t1L165ds9XgycrMmTM5cOAACxcuZOvWrfj6+uLr60uPHj3MNrVq1SI4OJjhw4fz/fdqodFNmzbxzz//cPr0aaytrRkwYAB+fn688847Fnc4p06dyrlz54iMjKRp06ZMmzaNjRs38scff5htli5dyrPPPsuYMWPw9PTE09PTvO/EiROkpmbWqrofTFmt95IBO3kUrNoMl8OKxIUHhmTAwlA/tfbCdxtvl7AnwoPC1bHosieE8k9511g/Pz969uzJrl27uHHjhrkGbNWqVVmwYAEAUVFRHDx40MIn0yOW/v7+FgukCEJeiMaWT1JT083v6/na8e/WeqQYykoBLqGkKO/6ajAY+Pjjj5k7dy6xsbEEBATQr18/OnXqROfOnc3za7VafH19AahevTouLi7069cPgB07djyQJzqF8kdx6asEYAUB9QKoSZMmFgLj7+9Pr169sj26cS9oNBpsbGyyPTpxN4cOHaJ///7MmjWL0aNHExISwsCBA9mzZ0+2uayyPI9//vx5hg8fTs2aNdFoNJw9e5YhQ4bwww8/WMzv6enJF198gZeXF2FhYcybN4/58+db2HTv3h2ARYsWZfOvdu3aeWb7FBRb28zAa4EW4Spji61rs5Txq6gB2GFycVjuqe6h5+kuzkREGDj1X3JJuyOUAcqzxp47d47BgwezYMEC3N3duXnzJkePHqVVq1acPXu20OcmCDkhGls+MWTJgI24cpU0w8NYaaTcj5A/5VlfAb788kusrKx45513mDFjBufPn6d///4W51a5cmU2bdpkMc60XVTXsEL5pzj1VSmJFhAQUCLHlSZNWsk1FycU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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.6062407493591309\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_point1_arr, long_en_tp1, long_en_out0 = \\\n","get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=False)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":14,"metadata":{"id":"HHjIdn2MC4VE","executionInfo":{"status":"ok","timestamp":1651448707488,"user_tz":-540,"elapsed":843,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_open_i = short_obj[-1].astype(int)\n","long_open_i = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_0 = res_df['short_epout_0_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_epout_0 = res_df['long_epout_0_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_gap = res_df['short_epout_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_epout_gap = res_df['long_epout_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","# ------ pairing 된 en, ex_idx 기준으로 survey 진행 ------ #\n","# 0. high, low (exit_done 까지의) -> partial (tpg) 과 outg survey 목표\n","#   a. short -> tpg - low, outg - high\n","#   b. long -> tpg - high, outg - low\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","\n","# ------ 0. tp 까지 도달하는 최소 idx 도출, en_idx 부터 ------ #\n","#   a. bias_info_tick 의 limit 을 정해주지 않으면 굉장히 길어질 수 있다고 봄\n","# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","\n","current_tpg= config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":29,"metadata":{"id":"gnSvYKIzC4VF","executionInfo":{"status":"ok","timestamp":1651449168019,"user_tz":-540,"elapsed":328,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","public_cols = ['co_es_15T1', 'cu_es_15T1']\n","# 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = -20\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","  \n","  short_true_valid_idx *= short_true_data > xmin\n","  short_false_valid_idx *= short_false_data > xmin\n","  long_true_valid_idx *= long_true_data > xmin\n","  long_false_valid_idx *= long_false_data > xmin\n","    \n","  plt.subplot(inner_gs[0])\n","  v, c = np.unique(short_true_data[short_true_valid_idx], return_counts=True)\n","  plt.hist(v, weights=c, bins=num_samples, alpha=alpha, color='#00ff00', edgecolor='black')\n","  v, c = np.unique(short_false_data[short_false_valid_idx], return_counts=True)\n","  plt.hist(v, weights=c, bins=num_samples, alpha=alpha, color='#ff0000', edgecolor='black')\n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[1])\n","  v, c = np.unique(long_true_data[long_true_valid_idx], return_counts=True)\n","  plt.hist(v, weights=c, bins=num_samples, alpha=alpha, color='#00ff00', edgecolor='black')\n","  v, c = np.unique(long_false_data[long_false_valid_idx], return_counts=True)\n","  plt.hist(v, weights=c, bins=num_samples, alpha=alpha, color='#ff0000', edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1651449171256,"user_tz":-540,"elapsed":1107,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"8bddd5c2-f4f5-4b1a-ab25-a0e06ebf6848"},"execution_count":30,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1296 with 6 Axes>"],"image/png":"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hg8frv/3//6ffve73zncrrm5WX/4wx+0YMECXXvttbr99tuVkJDg1D6rqqp06623dqne6OhohYeHy8vLS8OGDdN///d/a+vWraqvr+9wu9TUVM2ePVtTpkzRiRMnurRvoDMINbCs8PBw3X///fLz89M333yjr7/+Ws3NzR1uk5+fr7Nnz+r555+Xr6+vJk6cqOnTpysnJ6fdbaqrq53uDDrT9mrjxo3TXXfdJW9vb11//fV67bXXZLPZdODAgQ63mz17thYtWqQHH3xQZWVlXdo3AMA1XnnlFX322Wfas2eP9u7dq88//9ypKZIlKSUlRUOGDFFVVZVWrlypd99916khZAsWLFB2drZOnjypH/7wh52q99Zbb9VHH32khoYGFRcX69y5cy2GbLfn1Vdf1c0336zS0lL7bQpefPHFTu0b6Cy3X9jDwtKV5c477zT5+fmmvr7eHD9+3HzwwQfmpptuMmlpaWblypX2dpcv1r984eW4cePMJ598Yk6dOmX27dtnZsyYYW/b1qQAt912myksLDQnT540a9eu7bCm73//+6a8vNycPHnSPPfcc6323dFy//33m4MHD5rTp0+b6upqs3btWnPbbbc53O7IkSOmsbHRNDQ02Jdly5a5/d+HhYWFhaV3l8WLF5vly5e7vQ4WFk9YvC79AAAAAA92++23y8/PT3v37lVUVJTWr1+vf/qnf1Jubq67SwPcjuFnAAAAFnDDDTfoD3/4g86cOaP33ntPr732mnJzc3XffffZh3hdvTjjxRdfbHPb9evXd7hde/u87777euLtAp3CmRqgE0JCQrR///42nxs3bpzDWc5mz56tt956q9X68vJy3XHHHe1uV1xc3GK2nMvmzZunVatWOagaAACgbyPUAAAAALA0X3cXIEk1NTUtbkQFAHC90NBQfetb33J3GR6JfgoA3K+jfsojQk15ebmioqLcXQYA9GsFBQXuLsFj0U8BgPt11E8xUQAAAAAASyPUAAAAALA0Qg0AAAAASyPUAAAAALA0Qg0AAAAASyPUAAAAALA0Qg0AAAAASyPUAAAAALA0Qg0AAAAASyPUAAAAALA0Qg0AAAAASyPUAAAAALA0X3cX0CMGS/Jz0KZRUr0LagEA4GrO9FMSfRUAdFHfCDV+kjY4aBPnikIAAGiDM/2URF8FAF3E8DMAAAAAlkaoAQAAAGBp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LbfcYnbv3m12795tiouL7f9WnlT7/Pnz7b/nO3bsaNFptPV75km1SxdnKXz33XdbbOcJx72vL93pszy57vb6LHcvznzmX148JdQ4W/drr71m9u3bZ/bs2WN+9KMfub1mZ+oeO3as+fTTT83u3btNYWGhefDBB91es9S9PtaT626vj3X34szxvrz0ZKjxuvQDAAAAAFiSR19TAwAAAACOEGoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAAIClEWoAAAAAWBqhBgAAoANlZWWaPHmyu8sA0AFCDTxKWlqaVq5c6e4yAACAA+PHj9dHH32kr776SsaYVs9v3bpVX3/9tRoaGtTQ0KCDBw9Kkl588UX7uq+//loXLlywPy4uLpYk/fKXv9SePXt0/vx5paWlufR9wZoINejTsrKytHDhQneX0W2BgYHKzc2VzWaTMUahoaEtns/KytK5c+fsnUJDQ4O8vb01e/Zs++OzZ8+qqampRRtJmj9/vgoKCvTNN98oKyvLHW8PAGBB58+f1+rVq5WUlNRum5SUFN1www264YYbNGbMGEnSq6++al/35JNPaseOHfbHd9xxhySptLRUzz//vNatW+eS9wLrI9Sgz/L27ju/3s3Nzfroo4/06KOPttvmV7/6lb1TuOGGG9Tc3KxVq1bZH8fFxenYsWMt2kjSsWPH9Morr+jtt9921dsBAEvy8/NTenq6bDabbDab0tPT5efnJ0maOHGiKioq9Oyzz6q6ulrHjh3TE088Yd922LBhysvLU11dnXbt2qWFCxdq27ZtDvc5btw4bdy4UcePH1dVVZVefPFFh7V05OGHH1ZhYaFOnjyp7du3684777Q/9/zzz6uyslL19fU6ePCgHnjggQ5f69ChQ3r77be1b98+h/vtrBUrVuijjz6yfwEHONJ3/uqD5bT34enn56fs7GzV19eruLhYd999t32bMWPGaOvWrTp58qSKi4s1ffp0+3NZWVl68803tW7d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xo221x3qYzBu3DijpqbGuPrqq22v1479P3eLxAGIZo7BrFmzjOeee86QZIwYMcI4cuSIcfnll9teeyiPwbZt24zs7GxDOjMg1e/32153sLdRo0b1ONjy5ptv7jRRQGlpqe31snW/1dbWRt1EAeeenxYvXmy88MILttcU6m3WrFnGgQMHDI/HY3stdm6ReJ7uaevv3zCRuvV27grCZv8Omt0yMjKMDz74wKipqTGWLl1qSDJ+9atfGbfccoshybjwwguNTZs2GdXV1UZpaakxZswY22sO9THYsWOHEQgEjPLycqO8vNzYunWr7TWHcv/P3SL1l6WZY/Dkk08aBw4cMPbt22fcfvvtttcc6mMwduxY46233jLef/99o7y83JgxY4btNQdz27Bhg3H06FGjpaXFqKurM+69915j0aJFxqJFizraPPXUU0ZNTY2xb9++iPz/IFK2aAw1L774orF//36joqLCKCoqMkaOHGl7TaHeqqurjSNHjnScq6NtBrg5c+YYdXV1xueff24EAgHjlVdesb2mUGzdnbuiaevu3BXM9x/y5RcAAAAA4EiOmf0MAAAAALpDqAEAAADgaIQaAAAAAI5GqAEAAADgaIQaAAAAAI5GqAEAAADgaIQaAAAAAI72/wGcL8Dz2+y75gAAAABJRU5ErkJggg==\n"},"metadata":{}}]},{"cell_type":"code","source":["# v, c\n","ns, bins, patches = plt.hist(v, weights=c, bins=num_samples, alpha=alpha, color='#00ff00', edgecolor='black')"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":0},"id":"GFHMcig0FCXh","executionInfo":{"status":"ok","timestamp":1651450047743,"user_tz":-540,"elapsed":5,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"b18070e3-07ed-4158-f0cf-11d473bb0bc6"},"execution_count":43,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 432x288 with 1 Axes>"],"image/png":"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3rZtm+c1ebFcd911dkFBgf3RRx/ZN998s+f1pGpJS0uzu7q67Ly8PHvevHn2119/bS9ZssTzulK93Hrrrbbf77dbW1vdOc5CyoyOjsZeX3TRRbJt28NqvNPY2KiTJ09Kkj777DPl5OR4XJE3Ojo6dPjwYa/LSLk/T0/yxx9/xKYnOd80NTVpZGTEte0z5W+K/eMf/9DGjRt1/Phx3X777V6X47lNmzZp7969XpeBFMrOzlY0Go297+3t1bJlyzysyEz03JOssbFRra2tU5Y1a9ZIkv7+979r4cKFqq2tVUVFhcfVumem4yBJVVVVGh8fV21trYeVusvJcQDcQM89yVatWuVovdraWr333nt67rnn3C3IIzMdh/Lyct1999264447UlSRN5z+ezifMD1JatBzT6Frrrkm9rq0tFQdHR0eVuOd1atX66mnntKaNWv0+++/e10OUozpSVLH87PG58vy5ptv2q2trXZLS4vd0NBgX3XVVZ7X5MXS2dlp//jjj3YkErEjkch5e9XQ2rVr7Wg0av/nP/+xBwYG7Pfff9/zmlK1lJSU2N9//73d1dVlV1VVeV6PF0tdXZ197Ngxe2xszI5Go/amTZuSun2mHwAAAzEsAwAGItwBwECEOwAYiHAHAAMR7gBgIMIdAAxEuAOAgf4LohtAQipvRd0AAAAASUVORK5CYII=\n"},"metadata":{}}]},{"cell_type":"code","source":["len(list_)\n","ns, bins, patche"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"mAazco-dF4_b","executionInfo":{"status":"ok","timestamp":1651450029963,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"9fb783f5-1bf3-4cd3-a3a4-83549ca2670c"},"execution_count":41,"outputs":[{"output_type":"execute_result","data":{"text/plain":["3"]},"metadata":{},"execution_count":41}]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg survey for partial"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF"},"outputs":[],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_true_open_idxth], short_max_tpg]\n","long_max_datas = [long_max_outg[long_true_open_idxth], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v3"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oVifICO4-Grk"},"outputs":[],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","val_list = np.arange(-0.0, 1.0, 0.03)  # prcn 2\n","# val_list = np.arange(-0.695, -0.75, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.ei_k = set_val\n","  # config_list_copy[0].ep_set.ep_out_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    # enlist_rtc(res_df, config_, np_timeidx)\n","    enlist_tr(res_df, config_, np_timeidx)\n","  open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","\n","  try:\n","    result.append(get_res_v5(res_df, open_info_df, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx = open_info_df.index.to_numpy()\n","  len_df = len(res_df)\n","  s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","  s_open_info_df = open_info_df[s_idx]\n","  s_open_idx = open_idx[s_idx]\n","\n","  open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","  side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v5(res_df, s_open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v13(res_df, len_df, config_list[0], high, low, s_open_idx, side_arr, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8LiKwfiJ4bvM"},"outputs":[],"source":["def plot_info_v6(gs, gs_idx, sample_len, tr, prcn, rc, bars_in, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    # title_str = \"prcn : {:.3f} rc : {:.3f}\\n len_pr : {} dpf : {:.3f}\\n wr : {:.3f} sr : {:.3f}\\n acc_pr : {:.3f} sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f} liqd : {:.3f}\\n acc_mdd : -{:.3f} sum_mdd : -{:.3f}\\n leverage {}\"\n","    # title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n rc : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n wave_bias : {:.3f}\\n bars_in : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    plt.title(title_str.format(tr, prcn, rc, bars_in, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"]},{"cell_type":"code","source":["def ffill_line(line_, idx_):\n","  len_line = len(line_)\n","  total_en_idx = np.zeros(len_line)\n","  total_en_idx[idx_] = 1\n","  idx_line_ = np.where(total_en_idx, line_, np.nan)\n","  idx_line = pd.Series(idx_line_).ffill().to_numpy()\n","\n","  return idx_line\n","\n","def get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj):\n","  \n","  short_op_idx = short_obj[-1].astype(int)\n","  short_en_idx = short_obj[2].astype(int)\n","  short_en_tp1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)   # en_idx 에 sync 된 open_idx 를 사용해야함\n","  short_en_out0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","  long_op_idx = long_obj[-1].astype(int)\n","  long_en_idx = long_obj[2].astype(int)\n","  long_en_tp1 = ffill_line(res_df['long_wave_1_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","  long_en_out0 = ffill_line(res_df['long_wave_0_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","\n","  bias_info_tick = config.tr_set.bias_info_tick\n","\n","  # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","  # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","  # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","  last_idx = len_df - 1\n","  short_en_tp1_touch_idx = pd.Series(np.where(low <= short_en_tp1, np.arange(len_df), last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-bias_info_tick).to_numpy()[short_en_idx]  \n","  short_en_out0_touch_idx = pd.Series(np.where(high >= short_en_out0, np.arange(len_df), last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-bias_info_tick).to_numpy()[short_en_idx]\n","\n","  long_en_tp1_touch_idx = pd.Series(np.where(high >= long_en_tp1, np.arange(len_df), last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-bias_info_tick).to_numpy()[long_en_idx]\n","  long_en_out0_touch_idx = pd.Series(np.where(low <= long_en_out0, np.arange(len_df), last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-bias_info_tick).to_numpy()[long_en_idx]\n","\n","  short_true_bias_idx = short_en_tp1_touch_idx < short_en_out0_touch_idx  # true_bias 의 조건\n","  long_true_bias_idx = long_en_tp1_touch_idx < long_en_out0_touch_idx\n","\n","  short_false_bias_idx = short_en_tp1_touch_idx > short_en_out0_touch_idx  # false_bias 의 조건\n","  long_false_bias_idx = long_en_tp1_touch_idx > long_en_out0_touch_idx\n","\n","  # return short_true_bias_idx.ravel(), short_false_bias_idx.ravel(), long_true_bias_idx.ravel(), long_false_bias_idx.ravel()\n","  return short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1[short_en_idx], short_en_out0[short_en_idx], long_en_tp1[long_en_idx], long_en_out0[long_en_idx]\n","\n","  \n","def wave_bias(true_idx, false_idx):  # 정확하게 하려고, true & false 로 기준함\n","    true_sum = np.sum(true_idx)\n","    false_sum = np.sum(false_idx)\n","    return true_sum / (true_sum + false_sum)"],"metadata":{"id":"aFpEbTaECnGW"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v13(res_df, len_df, config, high, low, open_idx, side_arr, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5), fontsize=15, signi=False):\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        fig = plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","    \n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","      sample_len = int(len_df * sample_ratio)\n","    else:\n","      sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","    point1_arr, valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res    \n","    assert len(valid_openi_arr) != 0, \"assert len(valid_openi_arr) != 0\"    \n","    short_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.SELL)[0]  # valid_openi_arr 에 대한 idx, # side_arr,\n","    long_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.BUY)[0]\n","\n","    valid_open_idx = open_idx[valid_openi_arr].reshape(-1, 1)\n","\n","    short_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[short_valid_openi_idx]\n","    long_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[long_valid_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_point1_arr, long_point1_arr = [point1_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)    \n","    # print(\"elapsed time :\", time.time() - start_0)\n","\n","    short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1, short_en_out0, long_en_tp1, long_en_out0 = \\\n","    get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj)\n","\n","    len_short, len_long = len(short_valid_openi_idx), len(long_valid_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","      # start_0 = time.time()      \n","      if len_short == 0:\n","        short_pr = []\n","        gs_idx += 1\n","      else:\n","        short_tr = short_tr_arr.mean()\n","        short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","        short_cum_pr = np.cumprod(short_total_pr)\n","        # short_liqd = liquidation_v2(OrderSide.SELL, h, short_obj[:4], short_lvrg_arr, short_fee_arr)\n","        short_prcn, short_rc = precision(short_pr, short_true_bias_idx), wave_bias(short_true_bias_idx, short_false_bias_idx)\n","        short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","        if signi:\n","          short_idep_res_obj = (short_prcn, short_rc) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, short_tr, short_prcn, short_rc, short_trade_ticks, short_pr, short_total_pr, short_cum_pr, short_liqd, short_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in short plot_data :\", e)\n","\n","    try:\n","      # start_0 = time.time()   \n","      if len_long == 0:\n","        long_pr = []\n","        gs_idx += 1\n","      else:\n","        long_tr = long_tr_arr.mean()\n","        long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","        long_cum_pr = np.cumprod(long_total_pr)\n","        # long_liqd = liquidation_v2(OrderSide.BUY, l, long_obj[:4], long_lvrg_arr, long_fee_arr)\n","        long_prcn, long_rc = precision(long_pr, long_true_bias_idx), wave_bias(long_true_bias_idx, long_false_bias_idx)\n","        long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","        if signi:\n","          long_idep_res_obj = (long_prcn, long_rc) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, long_tr, long_prcn, long_rc, long_trade_ticks, long_pr, long_total_pr, long_cum_pr, long_liqd, long_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in long plot_data :\", e)\n","\n","    \n","    try:\n","      # start_0 = time.time()\n","      if len_short * len_long == 0:\n","        both_pr = []\n","        gs_idx += 1\n","      else:\n","        both_tr = (short_tr + long_tr) / 2\n","        both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","        both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","        both_cum_pr = np.cumprod(both_total_pr)\n","        both_liqd = min(short_liqd, long_liqd)\n","        both_true_bias_idx = np.vstack((short_true_bias_idx, long_true_bias_idx))  # vstack for 2d arr\n","        both_false_bias_idx = np.vstack((short_false_bias_idx, long_false_bias_idx))\n","        both_prcn, both_rc = precision(both_pr, both_true_bias_idx), wave_bias(both_true_bias_idx, both_false_bias_idx)\n","        both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","        if signi:\n","          both_idep_res_obj = (both_prcn, both_rc) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, both_tr, both_prcn, both_rc, both_trade_ticks, both_pr, both_total_pr, both_cum_pr, both_liqd, lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","      if len_short * len_long > 0:\n","        for obj, cum_pr in zip([short_obj, long_obj, both_obj], [short_cum_pr, long_cum_pr, both_cum_pr]):\n","          try:\n","            # start_0 = time.time()\n","            gs_idx = frq_dev_plot_v3(gs, gs_idx, len_df, sample_len, obj[-2], cum_pr[-1], fontsize)\n","            # print(\"elapsed time :\", time.time() - start_0)          \n","          except Exception as e:\n","            gs_idx += 1\n","            print(\"error in frq_dev_plot_v3 :\", e)\n","        plt.show()\n","        plt.close()\n","\n","      return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_true_bias_idx, short_false_bias_idx, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_true_bias_idx, long_false_bias_idx, long_point1_arr, long_en_tp1, long_en_out0\n","        \n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v5(res_df, open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs):  # 이미 충분히 줄여놓은 idx 임\n","    side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","    id_idx_arr = id_idx_arr.astype(int)\n","\n","    ep_out, ep_loc_point2, lvrg_set = funcs\n","\n","    point1_list, valid_openi_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(8)]\n","    len_df = len(res_df)\n","    len_open_idx = len(open_idx)\n","    i, open_i = 0, -1  # i for total_res_df indexing\n","\n","    while 1:\n","        # ------------ entry phase ------------ #\n","        open_i += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i >= len_open_idx:\n","            break\n","\n","        # ------ ep_loc ------ #\n","        op_idx = open_idx[open_i]  # open_i 는 i 와 별개로 운영\n","        if op_idx < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ dynamic data by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        id_idx = id_idx_arr[open_i]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        open_side = side_arr[open_i]\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()  # => eptpout arr_list 만들어서 꺼내 사용하면 될 것\n","        point_idxgap_arr = res_df['{}_point_idxgap_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        ep_arr = res_df['{}_ep_{}'.format(side_pos, selection_id)].to_numpy()  # Todo - while loop 내에서 to_numpy() 반복하느니, pd_indexing 이 낫지 않을까\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","        # bias_info_arr = res_df['{}_bias_info_{}'.format(side_pos, selection_id)].to_numpy()  # ex. rolling(entry ~ end)'s high\n","        # bias_thresh_arr = res_df['{}_bias_thresh_{}'.format(side_pos, selection_id)].to_numpy()  # ex. close + dc_T20 * 0.5\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ ei_k & point2 ------ #\n","        i = op_idx + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        point_idxgap = point_idxgap_arr[op_idx]\n","        if np.isnan(point_idxgap):\n","            continue\n","        else:\n","            # ------ allow point2 only next to point1 ------ #\n","            open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","            tp_j = int(op_idx - point_idxgap)\n","            if np.sum(open_arr[tp_j:op_idx]) != 0:\n","                continue\n","\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side,\n","                                                                                 [*ohlc_list, ep_arr], ep_out, ep_loc_point2)\n","        i = exec_j\n","\n","        if not entry_done:\n","            continue\n","\n","        # ------ leverage ------ #\n","        out = out_arr[out_j]  # lvrg_set use out on out_j\n","        leverage = lvrg_set(res_df, config, open_side, en_p, out, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","        if leverage is None:\n","            continue\n","\n","        exit_done, cross_on = 0, 0\n","        # ------ check tpout_onexec ------ #\n","        # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","        if config.ep_set.entry_type == \"LIMIT\":\n","            if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                tp_j = exec_j\n","            if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                out_j = exec_j\n","\n","        while 1:\n","            # ------------ exit phase ------------ #\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                           [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            # ------------ out ------------ #\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_market_out_exec_v2(config, res_df, np_timeidx, open_i, i, len_df, fee, open_side, cross_on, exit_done)\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out != \"None\":\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_out(config, open_i, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                point1_list.append(tp_j)\n","                valid_openi_list.append(open_i)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                # bias_list.append([bias_info_arr[exec_j], bias_thresh_arr[exec_j]])  # backtest 에서만 가능한 future_data 사용\n","                # bias_list.append([bias_info_arr[exec_j], tp_arr[tp_j]])  # bias_info 는 entry_idx 부터 & tp = bias_thresh\n","                tr_list.append(tr_arr[op_idx])\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(point1_list), np.array(valid_openi_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side, np_datas, ep_out, ep_loc_point2):\n","    o, h, l, c, ep_arr = np_datas\n","    ep_j = op_idx\n","    # tp_j = op_idx\n","    out_j = op_idx\n","\n","    selection_id = config.selection_id    \n","    allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ ei_k ------ # - limit 사용하면 default 로 ei_k 가 존재해야함\n","            if ep_out(res_df, config, op_idx, e_j, tp_j, [h, l], open_side):\n","              break\n","\n","            # ------ point2 ------ #\n","            if not allow_ep_in:\n","                allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","                if allow_ep_in:\n","                  if config.ep_set.point2.entry_type == \"LIMIT\":\n","                    ep_j = e_j\n","                    # print(\"e_j in point2 :\", e_j)\n","                    continue\n","\n","            # ------ check ep_exec ------ #\n","            if allow_ep_in:\n","              if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","                entry_done = 1\n","                ep = c[e_j]\n","                break\n","              else:\n","                if open_side == OrderSide.SELL:\n","                    if h[e_j] >= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                            ep = o[e_j]\n","                        break\n","                else:\n","                    if l[e_j] <= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] <= ep_arr[ep_j]:\n","                            ep = o[e_j]\n","                        break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = c[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, j, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        try:\n","            if config.tr_set.decay_gap != \"None\":\n","                decay_share = (j - open_i) // config.tp_set.decay_term\n","                decay_remain = (j - open_i) % config.tp_set.decay_term\n","                if j != open_i and decay_remain == 0:\n","                    if open_side == OrderSide.SELL:\n","                        tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","                    else:\n","                        tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        except:\n","            pass\n","\n","        if open_side == OrderSide.SELL:\n","            if l[j] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if l[j] <= tp_arr[j] <= h[j]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[j]:\n","                        tp = o[j]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[j]\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if h[j] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    if o[j] > tp_arr[j]:\n","                        tp = o[j]\n","                    else:\n","                        tp = tp_arr[j]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if o[j] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_market_out_exec_v2(config, res_df, np_timeidx, open_i, j, len_df, fee, open_side, cross_on, exit_done):    \n","    close = res_df['close'].to_numpy()\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[j] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and j != open_i:\n","            exit_done = 1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[j - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[j] < 50 - config.loc_set.point.osc_band):\n","                exit_done = 1\n","        else:\n","            if (rsi_T[j - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[j] > 50 + config.loc_set.point.osc_band):\n","                exit_done = 1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[j] < ha_c[j]):# & (ha_o[j] == ha_l[j]):   # 양봉 출현\n","    #           exit_done = 1\n","    #     else:\n","    #       if (ha_o[j] > ha_c[j]):# & (ha_o[j] == ha_h[j]):  # 음봉 출현\n","    #           exit_done = 1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[j] < bb_lower_5T[j] < close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] > bb_upper_5T[j] > close[j - 1]:\n","                exit_done = 1\n","        else:\n","            if close[j] > bb_upper_5T[j] > close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] < bb_lower_5T[j] < close[j - 1]:\n","                exit_done = 1\n","\n","    if exit_done:\n","        ex_p = close[j]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_out(config, open_i, j, out_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if h[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if l[j] <= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if c[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if c[j] <= out_arr[out_j]:  # check out only once\n","                ex_p = c[j]\n","                exit_done = 1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = c[j]\n","\n","        if open_side == OrderSide.SELL:\n","            if o[j] >= out_arr[out_j]:\n","                ex_p = o[j]\n","        else:\n","            if o[j] <= out_arr[out_j]:\n","                ex_p = o[j]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# del np_df\n","del np_plot_params"]},{"cell_type":"code","execution_count":36,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1651449418238,"user_tz":-540,"elapsed":2462,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","front_plot = 3    # 0 : whole, 1 : open, 2 : ep_tick, 3 : tp_tick, 4 : bias_tick\n","bias_plot = 1     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","pr_descend = 0    # 1 : 내림차순, 0 : 오름차순\n","position = 1      # -1 : short 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 50 #  100 20\n","# post_plotsize = 60\n","post_plotsize = config.tr_set.bias_info_tick\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_point1_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_en_tp1, short_en_out0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_point1_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_en_tp1, long_en_out0]\n","pr, obj, [point1_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, false_bias_arr, en_tp1, en_out0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","\n","# ------ pr_descend ------ #\n","true_pr_idx = pr > 1\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # pos_str 으로 이곳에서 정의함\n","\n","# ------------------ data chunknize ------------------ #\n","np_df = res_df.to_numpy()\n","\n","# left_end_idx = obj[2] - prev_plotsize  # left_margin 기준 - entry_idx\n","left_end_idx = obj[4] - prev_plotsize  # left_margin 기준 - open_idx\n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, point1_arr, lvrg_arr, fee_arr, tpout_arr, en_tp1, en_out0))[invalid_left_end:]  # all arr should have same dimension\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = false_bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":37,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":353,"status":"ok","timestamp":1651449422085,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"b58c8f0b-9d88-45c3-8b67-cfa4feb36386","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["s_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf = 'T'\n","wave_period = 5\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","step_col_list.append([['dc_base_{}{}'.format(wave_tf, wave_period)], 1, '#5b9cf6', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_tf2 = '15T'\n","dc_period2 = 1\n","\n","# step_col_list.append([['dc_upper_{}'.format(dc_tf1), 'dc_lower_{}'.format(dc_tf1)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}'.format(dc_tf2), 'dc_lower_{}'.format(dc_tf2)], 1, '#ff00ff', 4])\n","# step_col_list.append([['dc_base_{}'.format(dc_tf2)], 1, '#5b9cf6', 4])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ff00ff', 7, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_tf, wave_period)], 1, '#ff00ff', 5, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_tf, wave_period)], 1, '#00ff00', 5, 'o'])\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T1', 'dc_lower_15T1'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":38,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1TK6BU5mSRtYjHu8M8Ifn1cw6fLWbeGCw"},"executionInfo":{"status":"error","timestamp":1651449486140,"user_tz":-540,"elapsed":54851,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"ec8d8a6f-3cf7-42b1-bcae-eb2fa09111f6"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["_ = [plot_check_v5(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v5(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, lvrg, fee, tp_line, out_line, en_tp1, en_out0 = params\n","\n","    # if ep > out_line:  # for tp > ep > out plot_check\n","    #   break\n","\n","    # ------------ add_col section ------------ #\n","    a_data = data[int(iin):int(iout + 1)]\n","    # a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v5(config, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                    front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline_v3 :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v5(config, en_p, ex_p, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  point1_tick = open_tick - int(open_idx - point1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if front_plot == 1:\n","    x_max = open_tick + 20\n","  elif front_plot == 2:\n","    x_max = entry_tick + 20 \n","  elif front_plot == 3:\n","    x_max = exit_tick + 20\n","  elif front_plot == 4:\n","    x_max = bias_info_tick + 20\n","\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  plt.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ wave_line ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  plt.axhline(en_tp1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_tp1, ' wave_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  plt.axhline(en_out0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_out0, ' wave_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  point1_ymax, open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [point1_tick, open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(point1_tick, 0, point1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff7722')\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["VdukVo5-Suzj","Bw5JibDKSuzj","Pe0QpnORSuzk","E0n53hflJbnp","MlFkpO1MSuzl","t1E_eAyPSuzm","nUs4fjVHSuzl","L7l5CTJfSuzn","x_XGJqBi8Jex","MSUY4nnku3s9","epgS5Dksu-HX","Iy76iO7gztne","x2yj2SwAXDLp","EOXQbXixiQcK","c2729DJ6h720","RZJ6uIA_VcJs","xpyP5t8Ht_pE","MuD_2vY7TI_8","mScdfR9hmjVu","xivLUsSGC4VF","EJ4f-3Zf4ImT","zmYbP-Gc1ojs","5rdQZm_71ojv","tApzvz_gK9lR","OJqkmkpsLCYC"],"name":"stem5_2_vec_backi2(0430).ipynb","toc_visible":true,"provenance":[],"machine_shape":"hm","authorship_tag":"ABX9TyNahkcuMdEhfpC331gv2MKP"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}