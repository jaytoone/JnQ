{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1666420149651,"user_tz":-540,"elapsed":21840,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"e0785026-1816-4a8c-c2c5-30759cf48478"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1666420175147,"user_tz":-540,"elapsed":6787,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    df = h_candle_v4(df, df_H)\n","    df = h_candle_v4(df, df_4H)\n","\n","    # df = get_hhll(df, '15T')\n","    # df = get_hhll(df, '30T')\n","    df = get_hhll(df, 'H')\n","    df = get_hhll(df, '4H')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","    \n","    # --------------- stochastic --------------- #\n","    # df = stoch_v2(df)\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","    # --------------- ma --------------- #  \n","    # df = ma(df, 60)\n","    # print(\"ma phase done\")\n","\n","    # df = macd_hist(df, 5, 35, 15)\n","    # print(\"macd_hist phase done\")\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    # dc_period = 20\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df, dc_period=10)\n","    # df = dc_line_v4(df, df, dc_period=20)\n","    # df = dc_line_v4(df, df, dc_period=100)\n","    # df = dc_line_v4(df, df_5T, dc_period=20)\n","    # df = dc_line_v4(df, df_15T, dc_period=20)\n","    # df = dc_line_v4(df, df_H, dc_period=20)\n","    # df = dc_line_v4(df, df_4H, dc_period=20)\n","    # print(\"dc phase done\")\n","\n","    # df_5T = cci_v2(df_5T, 20)\n","\n","    # df_5T = tc_cci(df_5T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-3, -2, -1]), how='inner')\n","    \n","\n","    # --------------- lucid sar --------------- #\n","    # sar_ = talib.SAREXT(df_5T.high.to_numpy(), df_5T.low.to_numpy(),\n","    #                            startvalue=0.0, offsetonreverse=0,\n","    #                            accelerationinitlong=0.02, accelerationlong=0.02, accelerationmaxlong=0.2,\n","    #                            accelerationinitshort=0.02, accelerationshort=0.02, accelerationmaxshort=0.2)\n","\n","    # df_5T['sar_5T'] = sar_\n","    # b1_sar_ = df_5T['sar_5T'].shift(1).to_numpy()\n","    \n","    # df_5T['sar_trend_5T'] = np.where(sar_ > 0, 1, 0)\n","    # # df_5T['sar_tc_5T'] = np.where((sar_ < 0 & b1_sar_ > 0) | (sar_ > 0 & b1_sar_ < 0), 1, 0)\n","    # # df_5T['sar_tc_5T'] = np.where((sar_ < 0 and b1_sar_ > 0) | (sar_ > 0 and b1_sar_ < 0), 1, 0)\n","    # df_5T['sar_5T'] = np.where(sar_ < 0, -sar_, sar_)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-1, -2]), how='inner')\n","\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 100\n","    \n","    # df = bb_line_v3(df, df_15T, 20)\n","    # df = bb_level_v2(df, '15T', 20)\n","\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")        \n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"elapsed":2270,"status":"ok","timestamp":1666007990943,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"odqVwQHpYo1M","outputId":"fb3cd5ad-8b9d-465e-a3d0-f6bdcf260b07"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                           low_H  close_H  open_4H  high_4H   low_4H  close_4H   hh_H   ll_H  hh_4H  ll_4H\n","index                                                                                                     \n","2022-04-27 08:41:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:42:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:43:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:44:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:45:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False"],"text/html":["\n","  <div id=\"df-da39659c-5631-4cad-8978-21846b8ba3c3\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>low_H</th>\n","      <th>close_H</th>\n","      <th>open_4H</th>\n","      <th>high_4H</th>\n","      <th>low_4H</th>\n","      <th>close_4H</th>\n","      <th>hh_H</th>\n","      <th>ll_H</th>\n","      <th>hh_4H</th>\n","      <th>ll_4H</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-da39659c-5631-4cad-8978-21846b8ba3c3')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-da39659c-5631-4cad-8978-21846b8ba3c3 button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-da39659c-5631-4cad-8978-21846b8ba3c3');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":240}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gOQxwYqK0jCS"},"outputs":[],"source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmiB5VU5DN6B"},"outputs":[],"source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1644,"status":"ok","timestamp":1666007998453,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"b740e17a-7566-442b-92d0-3edb22d8d095"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":4325,"status":"ok","timestamp":1666420179470,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"7FPBG5Qqg2jB","outputId":"36451019-5e46-4eda-d272-5b99b62976e2"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 3.7509098052978516\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes\n","# res_df_.index[[0, -1]]"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","\n","# ------ check target cols ------ #\n","# print([col_ for col_ in col_list if 'cci_5T' in col_])\n","\n","# ------ drop ------ #\n","res_df_.drop([col_ for col_ in col_list if 'bb' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'll_15' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'cci_5T' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["def get_wave_time_ratio(res_df, wave_itv1, wave_period1):\n","\n","  wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","  wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","\n","  wave_cu_idx_fill_ = res_df['wave_cu_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","  wave_co_idx_fill_ = res_df['wave_co_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","\n","  wave_valid_cu_post_idx_fill_ = np.where(wave_cu_post_idx_fill_ < 0, 0, wave_cu_post_idx_fill_)\n","  wave_valid_co_post_idx_fill_ = np.where(wave_co_post_idx_fill_ < 0, 0, wave_co_post_idx_fill_)\n","\n","  wave_valid_cu_idx_fill_ = np.where(wave_cu_idx_fill_ < 0, 0, wave_cu_idx_fill_)\n","  wave_valid_co_idx_fill_ = np.where(wave_co_idx_fill_ < 0, 0, wave_co_idx_fill_)\n","\n","  res_df['short_wave_time_ratio_{}{}'.format(wave_itv1, wave_period1)] = (wave_valid_co_post_idx_fill_ - wave_valid_cu_post_idx_fill_[wave_valid_co_post_idx_fill_[wave_valid_cu_idx_fill_]]) / (wave_valid_cu_idx_fill_ - wave_valid_co_post_idx_fill_)\n","  res_df['long_wave_time_ratio_{}{}'.format(wave_itv1, wave_period1)] = (wave_valid_cu_post_idx_fill_ - wave_valid_co_post_idx_fill_[wave_valid_cu_post_idx_fill_[wave_valid_co_idx_fill_]]) / (wave_valid_co_idx_fill_ - wave_valid_cu_post_idx_fill_)\n","\n","  return res_df"],"metadata":{"id":"Fg4JnLY6i99D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def wave_range_cci_v4_1(t_df, wave_period):\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    baseline = 0\n","    band_width = 100\n","    upper_band = baseline + band_width\n","    lower_band = baseline - band_width\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    ohlc_list = [t_df[col_].to_numpy() for col_ in data_cols]\n","    open, high, low, close = ohlc_list\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    return wave_publics_v2(t_df, cu_bool, co_bool, ohlc_list, wave_period)"],"metadata":{"id":"XkrbzNFKZhl0"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def wave_publics_v2(t_df, cu_bool, co_bool, ohlc_list, wave_period):\n","    itv = pd.infer_freq(t_df.index)\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    open, high, low, close = ohlc_list\n","\n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","        cu_idx, co_idx, len_df, len_df_range)\n","    # cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #   cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v5(cu_idx, co_idx, len_df, len_df_range)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ get post_idx ------ #\n","    paired_cu_post_idx = high_post_terms[:, 1]  # Todo, 여기는 cross_idx (위에서 vstack 으로 cross_idx 입력함)\n","    paired_co_post_idx = low_post_terms[:, 1]\n","\n","    cu_post_idx = np.full(len_df, np.nan)  # --> Todo, unavailable : not cross_idx\n","    co_post_idx = np.full(len_df, np.nan)\n","\n","    cu_post_idx[paired_cu_post_idx] = paired_cu_post_idx\n","    co_post_idx[paired_co_post_idx] = paired_co_post_idx\n","\n","    cu_post_fill_idx = fill_arr(cu_post_idx)\n","    co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_cu_post_idx] = wave_highs\n","    wave_low_[paired_co_post_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_cu_post_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_post_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    # ------ term cnt ------ #\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_post_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_co_post_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    # b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    # b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    # wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    # wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","    #\n","    # high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    # low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","    t_df['wave_update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool  # temporary, for plot_check\n","    t_df['wave_update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool  # * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool  # * ~update_high_co_bool\n","    \n","    t_df['wave_cu_idx_fill_{}{}'.format(itv, wave_period)] = cu_fill_idx\n","    t_df['wave_co_idx_fill_{}{}'.format(itv, wave_period)] = co_fill_idx\n","\n","    t_df['wave_co_post_idx_{}{}'.format(itv, wave_period)] = co_post_idx  # paired_\n","    t_df['wave_cu_post_idx_{}{}'.format(itv, wave_period)] = cu_post_idx  # paired_\n","    t_df['wave_co_post_idx_fill_{}{}'.format(itv, wave_period)] = co_post_fill_idx\n","    t_df['wave_cu_post_idx_fill_{}{}'.format(itv, wave_period)] = cu_post_fill_idx\n","\n","    # Todo, idx 저장은 sync. 가 맞는 tf_df 에 대하여 적용하여야함\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력 = 뜻 : high_term's prime co_idx (high_prime_idx = wave_high 를 만들기 위한 가장 앞단의 co_idx)\n","    t_df['wave_co_prime_idx_{}{}'.format(itv,\n","                                         wave_period)] = co_prime_idx  # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_cu_prime_idx_{}{}'.format(itv,\n","                                         wave_period)] = cu_prime_idx  # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx  # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx  # cu_prime_fill_idx low_prime_idx_fill_\n","\n","    # ------ for plot_checking ------ #\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","\n","    return t_df"],"metadata":{"id":"FdDkSxbaX4AI"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","metadata":{"id":"O1uu9vQnY5dn"},"source":["##### plot_check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 336424\n","\n","plot_size = 300 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PgaNnempXRd_"},"outputs":[],"source":["wave_itv1, wave_period1 = 'T', 20\n","roll_hl_cnt = 3\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)  # to_htf 는 ohlc, 4개의 col 만 존재 (현재까지)\n","    htf_df = wave_range_cci_v4_1(htf_df, wave_period1)\n","    # htf_df = wave_range_dc_envel_v1(htf_df, wave_period1)\n","    \n","\n","    cols = list(htf_df.columns)  # 그냥 다 넣어버리기 (추후 혼란 방지)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])  # wrr 은 4개의 cols\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  t_df = wave_range_cci_v4_1(t_df, wave_period1)\n","  # t_df = wave_range_stoch_v1(t_df, wave_period1)\n","  # t_df = wave_range_dc_envel_v1(t_df, wave_period1)\n","\n","  valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","  t_df = wave_range_ratio_v4_2(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"]},{"cell_type":"code","source":["def wave_range_cci_v4_1(t_df, wave_period, band_width=100):\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    baseline = 0\n","    upper_band = baseline + band_width\n","    lower_band = baseline - band_width\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    ohlc_list = [t_df[col_].to_numpy() for col_ in data_cols]\n","    open, high, low, close = ohlc_list\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    return wave_publics_v3(t_df, cu_bool, co_bool, ohlc_list, wave_period)"],"metadata":{"id":"WM85fKSd9F7f"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"elapsed":2786,"status":"ok","timestamp":1663393141160,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"-Dr_tTk9csFm","outputId":"53ac4f58-eff0-4346-f28e-dc30e6835245"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_high_idx_fill_ = t_df['wave_high_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_idx_fill_ = t_df['wave_low_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","\n","wave_cu_prime_idx_ = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_ = t_df['wave_co_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_prime_idx_fill_ = t_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_fill_ = t_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_post_idx_ = t_df['wave_cu_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_ = t_df['wave_co_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_post_idx_fill_ = t_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_fill_ = t_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","# plt.step(len_df_range, t_df['dc_upper_{}{}'.format(wave_itv1, wave_period1)], color='#ffeb3b')\n","# plt.step(len_df_range, t_df['dc_lower_{}{}'.format(wave_itv1, wave_period1)], color='#ffeb3b')\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# ------ data check in gs[0] ------ #\n","plt.axvline(wave_cu_post_idx_fill_[230], color='r')\n","plt.axvline(wave_cu_prime_idx_fill_[230])\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","\n","# --- cci --- #\n","cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","\n","# --- stoch --- #\n","# stoch_ = t_df['stoch_{}{}33'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, stoch_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.axhline(67, color=\"#ffffff\")\n","# plt.axhline(33, color=\"#ffffff\")\n","\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]   # long 이라서 초록색임\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"code","source":["# wave_high_idx_fill_[200]\n","print(wave_low_idx_fill_[200])\n","print(wave_low_idx_fill_[210])\n","\n","y = (y1 - y0) / (x1 - x0) * x + y0 # x : x0 부터의 ticks "],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"x-ob07j19TUf","executionInfo":{"status":"ok","timestamp":1663393203342,"user_tz":-540,"elapsed":361,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2c6894ee-421c-492b-d658-042bafe57265"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["149.0\n","208.0\n"]}]},{"cell_type":"markdown","metadata":{"id":"c2yVTn1tnxMn"},"source":["###### data_window"]},{"cell_type":"code","source":["# print(valid_high_prime_idx)  # = valid_co_prime_idx\n","# print(roll_prev_high_idx_arr)   # = roll_prev_co_idx_arr\n","print(valid_low_prime_idx)  # = valid_co_prime_idx\n","print(roll_prev_low_idx_arr)   # = roll_prev_co_idx_arr"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"6bra-Br3lq1h","executionInfo":{"status":"ok","timestamp":1660483201485,"user_tz":-540,"elapsed":351,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"8c90e368-24c7-439e-9733-567d4848859a"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["[ 39  45 124 164]\n","[[ 39  45 124]\n"," [ 45 124 164]]\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":345,"status":"ok","timestamp":1660484147094,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"0DgdFydfB1f-","outputId":"1677cb32-6a71-4292-b49a-204f7da8ed20"},"outputs":[{"output_type":"stream","name":"stdout","text":["145.0\n","239.0\n"]}],"source":["idx = 239\n","# print(wave_cu_post_idx_fill_[idx])\n","# print(wave_co_prime_idx_fill_[idx - 1])\n","# print(wave_co_post_idx_fill_[idx - 1])\n","# print(wave_co_prime_idx_fill_[idx])\n","print(wave_co_post_idx_fill_[int(wave_cu_post_idx_fill_[idx])])\n","print(wave_co_idx_[idx])\n","\n","# print(len(t_df))\n","# len(wave_co_prime_idx_fill_)"]},{"cell_type":"code","source":["wave_co_idx_[~np.isnan(wave_co_idx_)]"],"metadata":{"id":"7zLNu-8gjeJ1"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zj_d5wsfDzf_"},"outputs":[],"source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Z-EokTzIqb-T"},"outputs":[],"source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"]},{"cell_type":"markdown","metadata":{"id":"Q_1wJTcRYpm8"},"source":["##### legacy"]},{"cell_type":"code","source":["def get_next_fibo_gap(x):\n","  if 0 < x < 0.214:\n","    return -0.786\n","  elif 0.214 < x < 0.382:\n","    return -0.618\n","  elif 0.382 < x < 0.5:\n","    return -0.5\n","  elif 0.5 < x < 0.618:\n","    return -0.382\n","  elif 0.618 < x < 0.764:\n","    return -0.236\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로.\n","\n","\n","def get_next_fibo_gap2(x):\n","  if 0 < x < 0.214:\n","    return -0.618\n","  elif 0.214 < x < 0.382:\n","    return -0.5\n","  elif 0.382 < x < 0.5:\n","    return -0.382\n","  elif 0.5 < x < 0.618:\n","    return -0.236\n","  elif 0.618 < x < 0.764:\n","    return 0\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로."],"metadata":{"id":"Bmp7faPhzydp"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"02DcTVB2cYuR"},"source":["##### dump"]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"fjGcs9ngkh5s"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"],"metadata":{"id":"CLYKs7ItkgIa"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Go7ARIUhfC1g"},"outputs":[],"source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pgA8QqyXZ66o"},"outputs":[],"source":["t_df[roll_cols].tail(100)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wF7fKJ3mOhaf"},"outputs":[],"source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3vHLGont-BFe"},"outputs":[],"source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Mh3w2s-j34Zs"},"outputs":[],"source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1651799326382,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eQ06-kWq4m6F","outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"outputs":[{"name":"stdout","output_type":"stream","text":["11\n","11\n"]}],"source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SUFmr9Z_kcCN"},"outputs":[],"source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_3pOQtt2ttfk"},"outputs":[],"source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1651756811396,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"kKaD1fK3WPRP","outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"outputs":[{"data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"execution_count":79,"metadata":{},"output_type":"execute_result"}],"source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","metadata":{"id":"RZJ6uIA_VcJs"},"source":["##### instant."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLWAP1Cl2Hvu"},"outputs":[],"source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"H_zPYIshbZgP"},"outputs":[],"source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"o3IUBc59VR5D"},"outputs":[],"source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u3yFd8Dcok5m"},"outputs":[],"source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JWj02LLGbnji"},"outputs":[],"source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":4,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1666420181855,"user_tz":-540,"elapsed":2388,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":19,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1666420667446,"user_tz":-540,"elapsed":514,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","# from funcs.funcs_trader import to_itvnum\n","\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","\n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","\n","    # if config.tr_set.check_hlm == 2:  # 동일한 param 으로도 p2_hlm 시도를 충분히 할 수 있음 (csdbox 와 같은)\n","    #   assert not (wave_itv1 == wave_itv2 and wave_period1 == wave_period2)\n","\n","    # ------------ get wave_features ------------ #\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","    tc_period = config.tr_set.tc_period\n","    roll_hl_cnt = 3\n","\n","    # roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    # roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    #\n","    # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #\n","    # roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    # roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    #\n","    # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    # res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = roll_highs1[-1] / wave_low_fill1_\n","    # res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / roll_lows1[-1]\n","    # res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / wave_low_fill1_\n","    # res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / wave_low_fill1_\n","\n","    itvnum = to_itvnum(wave_itv1)\n","    itvnum2 = itvnum * 2\n","    itvnum3 = itvnum * 3\n","\n","    # high_ = res_df['high_{}'.format(wave_itv1)].to_numpy()\n","    # low_ = res_df['low_{}'.format(wave_itv1)].to_numpy()\n","    b1_high_ = res_df['high_{}'.format(wave_itv1)].shift(itvnum).to_numpy()  \n","    b1_low_ = res_df['low_{}'.format(wave_itv1)].shift(itvnum).to_numpy()   \n","    b2_high_ = res_df['high_{}'.format(wave_itv1)].shift(itvnum2).to_numpy()  \n","    b2_low_ = res_df['low_{}'.format(wave_itv1)].shift(itvnum2).to_numpy()  \n","    b3_high_ = res_df['high_{}'.format(wave_itv1)].shift(itvnum3).to_numpy()  \n","    b3_low_ = res_df['low_{}'.format(wave_itv1)].shift(itvnum3).to_numpy()  \n","\n","    # max_high_ = np.maximum(b1_high_, b2_high_)\n","    # min_low_ = np.minimum(b1_low_, b2_low_)\n","    max_high_ = np.maximum(b3_high_, b2_high_)\n","    min_low_ = np.minimum(b3_low_, b2_low_)\n","    \n","    res_df['b1_high_{}'.format(wave_itv1)] = b1_high_\n","    res_df['b1_low_{}'.format(wave_itv1)] = b1_low_\n","    res_df['b2_high_{}'.format(wave_itv1)] = b2_high_\n","    res_df['b2_low_{}'.format(wave_itv1)] = b2_low_\n","    res_df['b3_high_{}'.format(wave_itv1)] = b3_high_\n","    res_df['b3_low_{}'.format(wave_itv1)] = b3_low_\n","    res_df['max_high_{}'.format(wave_itv1)] = max_high_\n","    res_df['min_low_{}'.format(wave_itv1)] = min_low_\n","    \n","    # ------------ enlist tr_unit ------------ #\n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # 2 사용하는 이유 : tp_1 을 p2_box 기준으로 설정하가 위함 --> enex_pairing_v4 function 과 호환되지 않음\n","    res_df['short_tp_1_{}'.format(selection_id)] = b1_low_     # wave_low_fill1_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = b1_high_  # roll_highs1[-1] wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_tp_1_{}'.format(selection_id)] = b1_high_     # wave_high_fill1_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = b1_low_  # roll_lows1[-1]  wave_low_fill1_   # roll_low_[:, -2]\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = b1_low_  # wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = b1_high_  # wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = b1_high_  # wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = b1_low_  # wave_low_fill1_    # roll_low_[:, -2]\n","\n","    # --> p2's ep use p1's ep\n","    # res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill1_  # wave_low_fill2_   # b2_low_5T\n","    # res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill1_ # wave_high_fill2_  # roll_high_[:, -2]\n","    # res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill1_  # wave_high_fill2_   # b2_high_5T\n","    # res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill2_    # roll_low_[:, -2]\n","\n","    # --> out use p1's low, (allow prev_low as out for p1_hhm only)\n","    # res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill1_   # wave_low_fill2_   # b2_low_5T\n","    # res_df['short_out_0_{}'.format(selection_id)] = wave_high_fill1_ # roll_highs1[-1] if not config.tr_set.check_hlm else wave_high_fill1_   # roll_highs2[-1]  # roll_high_[:, -2]\n","    # res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill1_   # wave_high_fill1_   # wave_high_fill2_   # b2_high_5T\n","    # res_df['long_out_0_{}'.format(selection_id)] = wave_low_fill1_ # roll_lows1[-1] if not config.tr_set.check_hlm else wave_low_fill1_   # roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    # below codes exist for p2_wave\n","    res_df['short_ep2_1_{}'.format(selection_id)] = b1_low_  # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = b1_high_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = b1_high_  # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = b1_low_  # roll_low_[:, -2]\n","\n","    res_df['short_out_1_{}'.format(selection_id)] = b1_low_\n","    res_df['short_out_0_{}'.format(selection_id)] = b1_high_\n","    res_df['long_out_1_{}'.format(selection_id)] = b1_high_\n","    res_df['long_out_0_{}'.format(selection_id)] = b1_low_\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(\n","        res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(\n","        res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(\n","        res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #\n","    short_open_res1 = np.ones(len_df)  # .astype(object)\n","    long_open_res1 = np.ones(len_df)  # .astype(object)\n","    short_open_res2 = np.ones(len_df)  # .astype(object)\n","    long_open_res2 = np.ones(len_df)  # .astype(object)\n","\n","    # ------------ wave_point ------------ #\n","    # notnan_short_tc = ~pd.isnull(res_df['short_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    # notnan_long_tc = ~pd.isnull(res_df['long_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","\n","    # notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    # notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    # notnan_cu2 = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy())  # isnull for object\n","    # notnan_co2 = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy())\n","\n","    # short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    # long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    # short_open_res1 *= res_df['short_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_short_tc\n","    # long_open_res1 *= res_df['long_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_long_tc\n","\n","    # short_open_res2 *= res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_cu2  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    # long_open_res2 *= res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_co2  # np.nan = bool type 으로 True 임..\n","    # short_open_res2 *= res_df['short_tc_{}{}'.format(wave_itv2, tc_period)].to_numpy()\n","    # long_open_res2 *= res_df['long_tc_{}{}'.format(wave_itv2, tc_period)].to_numpy()\n","\n","    if show_detail:\n","        sys_log.warning(\"wave_point\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","        # ------ reject wave_update_hl ------ #\n","    # notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    # notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    # notnan_update_low_cu2 = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy())\n","    # notnan_update_high_co2 = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy())\n","\n","    # short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    # long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    # short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu2\n","    # long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co2\n","\n","    if show_detail:\n","        sys_log.warning(\"reject update_hl\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_itv ------ #\n","    if wave_itv1 != 'T':\n","        wave_itv1_num = to_itvnum(wave_itv1)\n","        short_open_res1 *= np_timeidx % wave_itv1_num == 0\n","        long_open_res1 *= np_timeidx % wave_itv1_num == 0\n","        # short_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1)\n","        # long_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1)\n","\n","        if show_detail:\n","            sys_log.warning(\"wave_itv1\")\n","            sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","            sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    if wave_itv2 != 'T':\n","        wave_itv2_num = to_itvnum(wave_itv2)\n","        short_open_res2 *= np_timeidx % wave_itv2_num == 0\n","        long_open_res2 *= np_timeidx % wave_itv2_num == 0\n","        # short_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1)\n","        # long_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1)\n","\n","        if show_detail:\n","            sys_log.warning(\"wave_itv2\")\n","            sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","            sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    # res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_out_1_{}'.format(selection_id)].to_numpy() - res_df[\n","        'short_out_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_out_1_{}'.format(selection_id)].to_numpy() + res_df[\n","        'long_out_gap_{}'.format(selection_id)].to_numpy() * tpg\n","\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep1 ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","\n","        # ------ epbox as epg ------ #\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","\n","        # ------ tpbox as epg ------ #\n","        # p1_hlm 을 위해선, tp_0 를 기준할 수 없음 --> ep1 & ep2 를 기준으로 진행\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1\n","\n","        # ------ fibo_ep ------ #\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1\n","\n","        # ------ market_ep1 ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","\n","    # ------ limit_ep2 ------ #\n","    if config.ep_set.point2.entry_type == \"LIMIT\":\n","        epg2 = config.tr_set.ep_gap2\n","\n","        # # ------ epbox as epg ------ #\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ outbox as epg ------ # --> ep1 & ep2 를 기준으로 진행\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ fibo_ep by tp_box ------ #\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg2  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ fibo_ep by out_box ------ #\n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_out_gap_{}'.format(selection_id)].to_numpy() * epg2  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ market_ep2 ------ #\n","    else:\n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    if config.tr_set.check_hlm == 0:\n","        res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","        res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","\n","        # ------ temporary refix for flexible p1_hhm ------ #\n","        res_df['short_tp_0_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)]\n","        res_df['long_tp_0_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)]\n","\n","        # ------ ep1box as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    elif config.tr_set.check_hlm == 1:  # for p1_hlm\n","        # ------ irregular - next_fibo ------ #\n","        # co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","        # cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # short_next_fibo_outg = np.vectorize(get_next_fibo_gap2)(cu_wrr_32_)\n","        # long_next_fibo_outg = np.vectorize(get_next_fibo_gap2)(co_wrr_32_)\n","\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * short_next_fibo_outg  # ep 와 마찬가지로, tpg 기준 가능\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * long_next_fibo_outg\n","\n","        # ------ ep1box as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ 1_tr - ep1box as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ 1_tr - auto_calculation by ep1 ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_{}'.format(selection_id)] + (res_df['short_ep1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_{}'.format(selection_id)].to_numpy())\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_{}'.format(selection_id)].to_numpy() - (res_df['long_tp_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_{}'.format(selection_id)].to_numpy())\n","\n","        # ------ tpbox as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ fibo_out ------ #\n","        res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","        res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    else:  # p2_hlm\n","        # ------ outbox as out ------ #\n","        res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","        res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ ep2box as out ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg   # p2's ep_box 를 out 으로 사용한다?\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    # ------ p1 point_validation ------ #\n","    short_open_res1 *= (short_tp_ < short_ep1_) & (short_ep1_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < short_out_ # res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) & (long_ep1_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation\n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution\n","    long_open_res1 *= close > long_out_ # res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution\n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    # ------ p2 point_validation ------ # --> executed in en_ex_pairing() function.\n","    # short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    # short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    # long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out cannot be vectorized\n","    # long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban)\n","    # print(\"res_df['long_open1_{}'.format(selection_id)].to_numpy() :\", res_df['long_open1_{}'.format(selection_id)].to_numpy())\n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","        sys_log.warning(\"point validation\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","        # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","\n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    if config.tr_set.check_hlm == 2:\n","        res_df['short_tr_{}'.format(selection_id)] = np.nan\n","        res_df['long_tr_{}'.format(selection_id)] = np.nan\n","    else:\n","        res_df['short_tr_{}'.format(selection_id)] = abs(\n","            (short_ep1_ / short_tp_ - config.trader_set.limit_fee - 1) / (\n","                        short_ep1_ / short_out_ - config.trader_set.market_fee - 1))  # 이게 맞음, loss 의 분모 > 분자 & profit 의 분모 < 분자\n","        res_df['long_tr_{}'.format(selection_id)] = abs(\n","            (long_tp_ / long_ep1_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep1_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","metadata":{"id":"HuCb0phoPN83"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-DNPumVZi0xs"},"outputs":[],"source":["\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    \n","# ------------ csd ------------ #\n","    # ------ dc ------ #\n","    # dc_upper_ = res_df['dc_upper_T30'].to_numpy()    \n","    # dc_lower_ = res_df['dc_lower_T30'].to_numpy()    \n","\n","    # # Todo, post_cu ~ co 의 dc_lower == low (=touched) 여부 조사\n","    # short_open_idx1 = get_index_bybool(short_open_res1, len_df_range)\n","    # long_open_idx1 = get_index_bybool(long_open_res1, len_df_range)\n","    # wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()   # co_prime_idx (wave_high 정보를 지정하기 위한 front co_idx 지정)\n","\n","    # # 1. dc_lower == low 여부 조사, np.nan 덕분에 vectorize 불가하다고 봄\n","    # short_valid_idx_bool = ~(pd.isnull(wave_co_post_idx_fill_) | pd.isnull(short_open_idx1)) # get_index_bybool\n","    # dc_upper_touch = dc_upper_ <= high\n","    # dc_upper_touch_span = np.full(len_df, np.nan)\n","    # dc_upper_touch_span[short_valid_idx_bool] = [dc_upper_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_co_post_idx_fill_, short_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # long_valid_idx_bool = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1)) # get_index_bybool\n","    # dc_lower_touch = dc_lower_ >= low\n","    # dc_lower_touch_span = np.full(len_df, np.nan)\n","    # dc_lower_touch_span[long_valid_idx_bool] = [dc_lower_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # short_open_res1 *= dc_upper_touch_span == 0\n","    # long_open_res1 *= dc_lower_touch_span == 0\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"csd - dc\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","    #   # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","    #   # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))   \n","    \n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "]},{"cell_type":"markdown","metadata":{"id":"aTV4h3LjTZBp"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dc49JPmoTaPQ"},"outputs":[],"source":["\n","    \n","    csd_period = 40\n","    res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","    \n","    dc_upper_ = res_df['dc_upper_T{}'.format(csd_period)].to_numpy()    \n","    dc_lower_ = res_df['dc_lower_T{}'.format(csd_period)].to_numpy()  \n","\n","    short_open_res2 *= dc_upper_touch_span == 0\n","    long_open_res2 *= dc_lower_touch_span == 0\n","\n","    # ------ csdbox ------ # --> 결국 dc's upper & lower\n","    if show_detail:\n","      sys_log.warning(\"csdbox\")\n","      # sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","      \n","    # olds,\n","    # np.nan - np.nan = np.nan -> vectorize 가능할 것 => xx\n","    # 1. wave_high_prime_idx_ ~ long_open_idx1 의 valid(not_non) 한 idx 를 max_dc_lower 와 min_low 의 비교값으로 채워넣음\n","    # valid_idx = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1))\n","    # max_dc_lower_ = [dc_lower_[int(iin):int(iout)].max() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    # min_low = [low[int(iin):int(iout)].min() for iin, iout in zip(wave_high_prime_idx_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","        # ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":23,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1666421548673,"user_tz":-540,"elapsed":901,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment', None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set_v2(balance, config, open_side, tp_, out_, fee, limit_leverage=50):\n","\n","    if not pd.isnull(tp_) and not config.lvrg_set.static_lvrg:\n","        if open_side == OrderSide.SELL:\n","            wave_range = (out_ / tp_)\n","        else:\n","            wave_range = (tp_ / out_)\n","\n","        # if wave_range > 1.0065 or wave_range < 1.002:  # spread_rejection\n","        #     # sys_log.warning(\"spread_rejection : {}\".format(wave_range))\n","        #     return None\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_loss / (((wave_range - 1) / 2 - (fee + config.trader_set.market_fee)) * balance)\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        # sys_log.warning(\"leverage_rejection : config.lvrg_set.leverage < 1\".format(config.lvrg_set.leverage))\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        # wave_range = 1 + (1 - loss) * 2\n","        # if wave_range > 1.0065 or wave_range < 1.002:  # spread_rejection\n","        #     return None\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        # h_candle_v3(df, '5T')\n","        # df = dc_line(df, df_5T, '5T')\n","        # df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(df, '15T')\n","        # df = dc_line(df, df_15T, '15T')\n","        # df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        h_candle_v3(df, '30T')\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        h_candle_v3(df, '4H')\n","\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","\n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and\n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2)\n","\n","    try:\n","        # ------------ wave_period1 ------------ #\n","        # if to_itvnum(wave_itv1) > 1:\n","        #     offset = '1h' if wave_itv1 != 'D' else '9h'\n","        #     htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","        #     htf_df = wave_range_cci_v4_1(htf_df, wave_period1)\n","        #\n","        #     # cols = list(htf_df.columns[-15:-4])  # except idx col\n","        #     cols = list(htf_df.columns[4:])  # 15T_ohlc 를 제외한 wave_range_cci_v4 로 추가된 cols, 다 넣어버리기 (추후 혼란 방지)\n","        #\n","        #     valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1,\n","        #                                                                                                    roll_hl_cnt=roll_hl_cnt)\n","        #\n","        #     htf_df = get_roll_wave_data_v2(htf_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1),\n","        #                                    roll_hl_cnt)\n","        #     cols += list(htf_df.columns[-roll_hl_cnt:])\n","        #\n","        #     htf_df = get_roll_wave_data_v2(htf_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","        #     cols += list(htf_df.columns[-roll_hl_cnt:])\n","        #\n","        #     htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","        #     cols += list(htf_df.columns[-4:])\n","        #\n","        #     # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","        #     res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","        #     res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=1), how='inner')\n","        # else:\n","        #     res_df = wave_range_cci_v4_1(res_df, wave_period1)\n","        #     # res_df = wave_range_stoch_v1(res_df, wave_period1)\n","        #     # res_df = wave_range_dc_envel_v1(res_df, wave_period1)\n","        #\n","        #     # valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv1, wave_period1,\n","        #     #                                                                                                roll_hl_cnt=roll_hl_cnt)\n","        #     # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1),\n","        #     #                                roll_hl_cnt)\n","        #     # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","        #     #\n","        #     # res_df = wave_range_ratio_v4_2(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","        #     # res_df = get_wave_length(res_df, valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr, wave_itv1, wave_period1,\n","        #     #                          roll_hl_cnt=roll_hl_cnt)\n","\n","        # ------------ wave_period2 ------------ #\n","        if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","            assert wave_itv2 == 'T'\n","\n","            res_df = wave_range_cci_v4_1(res_df, wave_period2)\n","\n","            # valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv2, wave_period2,\n","            #                                                                                                roll_hl_cnt=roll_hl_cnt)\n","            # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2),\n","            #                                roll_hl_cnt)\n","            # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","            #\n","            # res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","        # ------ wave_loc_pct (bb) ------ #\n","        # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","        # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","        # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","        # itv_list = ['15T', '15T', '15T', '15T']\n","        # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","        # ====== intervaly ====== #\n","        # ------ 5T ------ #\n","        # res_df = dc_level(res_df, '5T', 1)\n","        # res_df = bb_level(res_df, '5T', 1)\n","\n","        # res_df = st_level(res_df, '5T', 1)\n","\n","        # ------ 15T ------ #\n","        res_df = wick_ratio(res_df, '15T')\n","        # res_df = dc_level(res_df, '15T', 1)\n","        # res_df = bb_level(res_df, '15T', 1)\n","        # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","        # res_df = st_level(res_df, '15T', 1)\n","\n","        # ------ 30T ------ #\n","        res_df = wick_ratio(res_df, '30T')\n","        # res_df = dc_level(res_df, '30T', 1)\n","        # res_df = bb_level(res_df, '30T', 1)\n","        # res_df = st_level(res_df, '30T', 1)\n","\n","        # ------ H ------ #\n","        res_df = wick_ratio(res_df, 'H')\n","        # res_df = bb_level(res_df, 'H', 1)\n","\n","        # ------ 4H ------ #\n","        res_df = wick_ratio(res_df, '4H')\n","        # res_df = bb_level(res_df, '4H', 1)\n","\n","        # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","        # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","        # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","        # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","        # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","        #     temp indi.    #\n","        # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","        # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","        # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    except Exception as e:\n","        sys_log.error(\"error in utils_public : {}\".format(e))\n","    else:\n","        return res_df\n","    # return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면,\n","                # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","                # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                 (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:\n","                # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","                # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave2, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ candle_shape ============ #\n","    wave_itv1 = config.tr_set.wave_itv1\n","    itvnum = to_itvnum(wave_itv1)\n","    itvnum2 = itvnum * 2\n","        \n","    # close_T = res_df['close'].shift(-1).to_numpy() \n","    # open_T = res_df['open'].shift(-1).to_numpy() \n","    close_T = res_df['close'].to_numpy() \n","    open_T = res_df['open'].to_numpy()\n","\n","    b1_close_ = res_df['close_{}'.format(wave_itv1)].shift(itvnum).to_numpy()  \n","    b1_open_ = res_df['open_{}'.format(wave_itv1)].shift(itvnum).to_numpy()  \n","    # high_ = res_df['high_{}'.format(wave_itv1)].to_numpy()  \n","    # low_ = res_df['low_{}'.format(wave_itv1)].to_numpy()  \n","\n","    b1_high_ = res_df['b1_high_{}'.format(wave_itv1)].to_numpy() \n","    b1_low_ = res_df['b1_low_{}'.format(wave_itv1)].to_numpy() \n","    b2_high_ = res_df['b2_high_{}'.format(wave_itv1)].to_numpy() \n","    b2_low_ = res_df['b2_low_{}'.format(wave_itv1)].to_numpy()\n","    b3_high_ = res_df['b3_high_{}'.format(wave_itv1)].to_numpy() \n","    b3_low_ = res_df['b3_low_{}'.format(wave_itv1)].to_numpy() \n","    max_high_ = res_df['max_high_{}'.format(wave_itv1)].to_numpy() \n","    min_low_ = res_df['min_low_{}'.format(wave_itv1)].to_numpy()   \n","\n","    b1_body_ratio_ = res_df['body_ratio_{}'.format(wave_itv1)].shift(itvnum).to_numpy()\n","    b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(wave_itv1)].shift(itvnum).to_numpy()\n","    b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(wave_itv1)].shift(itvnum).to_numpy()\n","    # candle_updown_ = res_df['candle_updown_{}'.format(wave_itv1)].to_numpy()\n","    # b1_candle_updown_ = res_df['candle_updown_{}'.format(wave_itv1)].shift(to_itvnum(wave_itv1)).to_numpy()\n","\n","    # ------ fakey - public ------ #\n","    # mr_res *= b1_high_ <= b2_high_\n","    # mr_res *= b1_low_ >= b2_low_\n","    mr_res *= b2_high_ <= b3_high_\n","    mr_res *= b2_low_ >= b3_low_\n","\n","    # --- marubozu_pair --- #\n","    if ep_loc_side == OrderSide.SELL:\n","        # mr_res *= b1_high_ > max_high_\n","        mr_res *= b1_high_ > b2_high_\n","\n","        mr_res *= b1_body_ratio_ >= config.loc_set.point1.short_body_ratio  # green_maru\n","        mr_res *= b1_close_ > b1_open_\n","        mr_res *= close_T < open_T\n","\n","        # mr_res *= upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","        if show_detail:\n","            sys_log.warning(\"b1_upper_wick_ratio_, b1_body_ratio_ : {:.5f}, {:.5f}  ({})\"\\\n","                            .format(b1_upper_wick_ratio_[c_i], b1_body_ratio_[c_i], mr_res[c_i]))\n","    else:\n","        # mr_res *= b1_low_ < min_low_\n","        mr_res *= b1_low_ < b2_low_\n","\n","        mr_res *= b1_body_ratio_ >= config.loc_set.point1.long_body_ratio  # red_maru\n","        mr_res *= b1_close_ < b1_open_\n","        mr_res *= close_T > open_T\n","\n","        # mr_res *= lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","        if show_detail:\n","            sys_log.warning(\"b1_lower_wick_ratio_, b1_body_ratio_ : {:.5f}, {:.5f}  ({})\"\\\n","                            .format(b1_lower_wick_ratio_[c_i], b1_body_ratio_[c_i], mr_res[c_i]))\n","            \n","    # ============ tr_thresh ============ #  # vectorize allow only for p1_hhm\n","    # if config.loc_set.point1.short_tr_thresh != \"None\":  #  and not config.tr_set.check_hlm:\n","    #     if ep_loc_side == OrderSide.SELL:\n","    #         short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","    #         mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","    #         # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","    #         if show_detail:\n","    #             sys_log.warning(\n","    #                 \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","    #     else:\n","    #         long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","    #         mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","    #         # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","    #         if show_detail:\n","    #             sys_log.warning(\n","    #                 \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ csd_ending ============ #     \n","    # ------ bb_cc ----- #\n","    # bb_lower_ = res_df['bb_lower_15T20'].to_numpy()\n","    # bb_upper_ = res_df['bb_upper_15T20'].to_numpy()\n","    # open_ = res_df['open_15T'].to_numpy()  \n","    # close_ = res_df['close_15T'].to_numpy()   \n","    \n","    # if ep_loc_side == OrderSide.SELL:\n","    #     # mr_res *= (open_ > bb_lower_) & (bb_lower_ > close_)\n","    #     mr_res *= (open_ <= bb_lower_) | (bb_lower_ <= close_)\n","    #     if show_detail:\n","    #         sys_log.warning(\"open_, bb_lower_, close_ : {:.5f} {:.5f} {:.5f} ({})\"\\\n","    #                         .format(open_[c_i], bb_lower_[c_i], close_[c_i], mr_res[c_i]))\n","    # else:\n","    #     # mr_res *= (open_ < bb_upper_) & (bb_upper_ < close_)\n","    #     mr_res *= (open_ >= bb_upper_) | (bb_upper_ >= close_)\n","    #     if show_detail:\n","    #         sys_log.warning(\"open_, bb_upper_, close_ : {:.5f} {:.5f} {:.5f} ({})\"\\\n","    #                         .format(open_[c_i], bb_upper_[c_i], close_[c_i], mr_res[c_i]))\n","\n","    # ------ sar ------ # \n","    # sar_trend_ = res_df['sar_trend_5T'].to_numpy()\n","    # b1_sar_trend_ = res_df['sar_trend_5T'].shift(15).to_numpy()\n","    \n","    # if ep_loc_side == OrderSide.SELL:\n","    #     # mr_res *= sar_trend_ == 0\n","    #     # mr_res *= b1_sar_trend_ == 1\n","    #     mr_res *= sar_trend_ == 1\n","    #     mr_res *= b1_sar_trend_ == 0\n","    #     if show_detail:\n","    #         sys_log.warning(\"sar_trend_, b1_sar_trend_ : {:.5f} {:.5f} ({})\".format(sar_trend_[c_i], b1_sar_trend_[c_i], mr_res[c_i]))\n","    # else:\n","    #     # mr_res *= sar_trend_ == 1\n","    #     # mr_res *= b1_sar_trend_ == 0\n","    #     mr_res *= sar_trend_ == 0\n","    #     mr_res *= b1_sar_trend_ == 1\n","    #     if show_detail:\n","    #         sys_log.warning(\"sar_trend_, b1_sar_trend_ : {:.5f} {:.5f} ({})\".format(sar_trend_[c_i], b1_sar_trend_[c_i], mr_res[c_i]))\n","\n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone1.use_zone:\n","\n","        # ------------ on_price ------------ #\n","          # ------ 추세선 리스트 ------ #\n","        # wave_itv1 = config.tr_set.wave_itv1\n","        # wave_period1 = config.tr_set.wave_period1\n","\n","        # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","        # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","        # long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","\n","          # ------ sar ------ #\n","        high_ = res_df['high_15T'].to_numpy()  \n","        low_ = res_df['low_15T'].to_numpy()        \n","        sar_ = res_df['sar_5T'].to_numpy()\n","\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= high_ < sar_\n","            if show_detail:\n","                sys_log.warning(\"high_ < sar_ : {:.5f} {:.5f} ({})\".format(high_[c_i], sar_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= low_ > sar_\n","            if show_detail:\n","                sys_log.warning(\"low_ > sar_ : {:.5f} {:.5f} ({})\".format(low_[c_i], sar_[c_i], mr_res[c_i]))\n","\n","        # ------ dc_base ------ #\n","        # dc_base_ = res_df['dc_base_T30'].to_numpy()\n","        # dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","        # dc_base_5T20 = res_df['dc_base_5T20'].to_numpy()\n","        # dc_base_15T20 = res_df['dc_base_15T20'].to_numpy()\n","        # dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","        # dc_base_4H20 = res_df['dc_base_4H20'].to_numpy()\n","\n","        # if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= short_tp_0_ < dc_base_H20\n","        #     if show_detail:\n","        #         sys_log.warning(\"short_tp_0_ < dc_base_H20 : {:.5f} {:.5f} ({})\".format(short_tp_0_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","        # else:\n","        #     mr_res *= long_tp_0_ > dc_base_H20\n","        #     if show_detail:\n","        #         sys_log.warning(\"long_tp_0_ > dc_base_H20 : {:.5f} {:.5f} ({})\".format(long_tp_0_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","        # ------------ outer_price ------------ #\n","          # ------ macd ------ #\n","        # # macd_ = res_df['macd_T535'].to_numpy()\n","        # macd_ = res_df['macd_hist_T53515'].to_numpy()\n","\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= macd_ < 0\n","        #   if show_detail:\n","        #     sys_log.warning(\"macd_ < 0 : {:.5f} {:.5f} ({})\".format(macd_[c_i], 0, mr_res[c_i]))\n","        # else:\n","        #   mr_res *= macd_ > 0\n","        #   if show_detail:\n","        #     sys_log.warning(\"macd_ > 0 : {:.5f} {:.5f} ({})\".format(macd_[c_i], 0, mr_res[c_i]))\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection\n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":\n","        wave_itv2 = config.tr_set.wave_itv2\n","        wave_period2 = config.tr_set.wave_period2\n","        co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","        cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  # + 0.1  # 0.1 0.05\n","            # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","            if show_detail:\n","                sys_log.warning(\n","                    \"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32,\n","                                                                                             mr_res[c_i]))\n","        else:\n","            mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  # + 0.1  # 0.1 0.05\n","            # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","            if show_detail:\n","                sys_log.warning(\n","                    \"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32,\n","                                                                                             mr_res[c_i]))\n","\n","    if config.loc_set.point2.csd_period != \"None\":\n","        wave_itv2 = config.tr_set.wave_itv2\n","        csd_period = config.loc_set.point2.csd_period\n","\n","        res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","        dc_upper_ = res_df['dc_upper_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","        dc_lower_ = res_df['dc_lower_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","        if ep_loc_side == OrderSide.SELL:\n","            csdbox = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() + res_df[\n","                'short_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","            mr_res *= dc_upper_ <= csdbox\n","            if show_detail:\n","                sys_log.warning(\"dc_upper_ <= csdbox : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], csdbox[c_i], mr_res[c_i]))\n","        else:\n","            csdbox = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() - res_df[\n","                'long_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","            mr_res *= dc_lower_ >= csdbox\n","            if show_detail:\n","                sys_log.warning(\"dc_lower_ >= csdbox : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], csdbox[c_i], mr_res[c_i]))\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","metadata":{"id":"EQ63Jwpvr7qA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"csZwxsP5r_Pz"},"outputs":[],"source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1666420182399,"user_tz":-540,"elapsed":7,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"6\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.99\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 0.0002,\n","    \"market_fee\": 0.0004,\n","    \"initial_asset\": 9000,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"BNBUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[500, 1, 1, 1, 1, 1, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0,\n","    \"short_fake\": 0,\n","    \"long_fake\": 0\n","  },\n","  \"loc_set\": {\n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": 0.3,\n","      \"long_wick_ratio\": 0.3,\n","      \"short_body_ratio\": 0.7,\n","      \"long_body_ratio\": 0.7,\n","      \"wick_itv\": \"5T\",\n","      \"wrr_10\": \"None\",\n","      \"wrr_21\": \"None\",\n","      \"wrr_32\": \"None\",\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"wrr_32\": \"None\",\n","      \"csdbox_range\": 0.3,\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"csd_period\": \"None\"\n","    },\n","    \"zone1\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    },\n","    \"zone2\": {\n","      \"use_zone\": 0\n","    }\n","  },\n","  \"tr_set\": {\n","    \"check_hlm\": 0,\n","    \"wave_itv1\": \"15T\",\n","    \"wave_period1\": 20,\n","    \"wave_length1\": \"None\",\n","    \"wave_spread1\": \"None\",\n","    \"wave_time_ratio1\": \"None\",\n","    \"wave_itv2\": \"T\",\n","    \"wave_period2\": 20,\n","    \"tc_period\": 20,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\": 0,\n","    \"p2_box_k2\": 0,\n","    \"p1p2_low\": 0.0,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.5,\n","    \"ep_gap2\": 0,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_tick\": 100\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"entry_type\": \"LIMIT\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"close_out\": 0,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0,\n","    \"cci_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"static_lvrg\": 0,\n","    \"leverage\": 1,\n","    \"limit_leverage\": 5,\n","    \"target_loss\": 50,\n","    \"target_pct\": 0.03,\n","    \"allow_float\": 0,\n","    \"lvrg_rejection\": 1\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","metadata":{"id":"MuD_2vY7TI_8"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"EKag94Y2TMCO"},"outputs":[],"source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":8,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":7,"status":"ok","timestamp":1666420182400,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"qBJfPsmJzVIr","outputId":"76c91e0e-e7cd-4db7-f211-d1a7fd4d2df6"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"6\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": 0.3,\n","  \"long_wick_ratio\": 0.3,\n","  \"short_body_ratio\": 0.7,\n","  \"long_body_ratio\": 0.7,\n","  \"wick_itv\": \"5T\",\n","  \"wrr_10\": \"None\",\n","  \"wrr_21\": \"None\",\n","  \"wrr_32\": \"None\",\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"wrr_32\": \"None\",\n","  \"csdbox_range\": 0.3,\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"csd_period\": \"None\"\n"," },\n"," \"zone1\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," },\n"," \"zone2\": {\n","  \"use_zone\": 0\n"," }\n","} {\n"," \"check_hlm\": 0,\n"," \"wave_itv1\": \"15T\",\n"," \"wave_period1\": 20,\n"," \"wave_length1\": \"None\",\n"," \"wave_spread1\": \"None\",\n"," \"wave_time_ratio1\": \"None\",\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 20,\n"," \"tc_period\": 20,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"p1p2_low\": 0.0,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.5,\n"," \"ep_gap2\": 0,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_tick\": 100\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"entry_type\": \"LIMIT\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"close_out\": 0,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0,\n"," \"cci_exit\": 0\n","} {\n"," \"static_lvrg\": 0,\n"," \"leverage\": 1,\n"," \"limit_leverage\": 5,\n"," \"target_loss\": 50,\n"," \"target_pct\": 0.03,\n"," \"allow_float\": 0,\n"," \"lvrg_rejection\": 1\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2022-01-14 16:34:59.999000\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","# ------ p1_hhm 의 경우 out_box 를 위해 wave_itv 1 & 2 를 동일하게 설정해야함 ------ #\n","config_list[0].tr_set.wave_itv1 = '15T'\n","# config_list[0].tr_set.wave_period1 = 20\n","# config_list[0].tr_set.wave_itv2 = 'T'\n","# config_list[0].tr_set.wave_period2 = 4\n","# config_list[0].tr_set.tc_period = 20"]},{"cell_type":"code","execution_count":13,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2249,"status":"ok","timestamp":1666420326264,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"26924f62-909b-4d4a-e08e-71a669d7b89e"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 1.1030986309051514\n","make data_list elapsed time : 0.0003948211669921875\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","source":["res_df.dtypes\n","# res_df.head()"],"metadata":{"id":"rRBzxUfDuXeK"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":10,"metadata":{"id":"_iYcJk8nK8Yq","executionInfo":{"status":"ok","timestamp":1666420187944,"user_tz":-540,"elapsed":12,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].tr_set.check_hlm = 2\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].pos_set.long_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_length1 = \"None\"  # \"None\" 45 15 110 100 \n","# config_list[0].tr_set.wave_spread1 = \"None\"  # \"None\" 15 110 100 \n","# config_list[0].tr_set.wave_time_ratio1 = \"None\"  # \"None\" 6\n","# config_list[0].tr_set.wave_greater1 = 0  # 0 50 \n","# config_list[0].tr_set.wave_greater2 = 0  # 10\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].ep_set.point2.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap1 = -0.5 # -0.8 -0.618 -0.23 -0.382 0.19 0.8 -0.12 -0.26\n","# config_list[0].tr_set.ep_gap2 = -0.5 # -0.618 -0.23 -0.382 0.19 -0.5\n","# config_list[0].tr_set.out_gap = 0.0  # 0 -0.35 -0.6\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.0\n","config_list[0].trader_set.limit_fee = 1e-10\n","config_list[0].trader_set.market_fee = 1e-10\n","# config_list[0].trader_set.limit_fee = 0.0002\n","# config_list[0].trader_set.market_fee = 0.0004\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":16,"metadata":{"id":"iI39YI_5GguK","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1666420537207,"user_tz":-540,"elapsed":924,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"1a69c5df-5781-479c-e052-bdcc5f849ffc"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 863086\n","WARNING:root:np.sum(long_open_res1 == 1) : 863086\n","WARNING:root:np.sum(short_open_res2 == 1) : 863086\n","WARNING:root:np.sum(long_open_res2 == 1) : 863086\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 863086\n","WARNING:root:np.sum(long_open_res1 == 1) : 863086\n","WARNING:root:np.sum(short_open_res2 == 1) : 863086\n","WARNING:root:np.sum(long_open_res2 == 1) : 863086\n","WARNING:root:wave_itv1\n","WARNING:root:np.sum(short_open_res1 == 1) : 57540\n","WARNING:root:np.sum(long_open_res1 == 1) : 57540\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 52343\n","WARNING:root:np.sum(long_open_res1 == 1) : 53255\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.5489423274993896\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfDSOGMd91rE"},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.wrr_10 = \"None\" # \"None\" 0.3\n","config_list[0].loc_set.point1.wrr_21 = \"None\" # \"None\" \n","config_list[0].loc_set.point1.wrr_32 = \"None\" # \"None\" 1 0.5 0.482 0.302\n","config_list[0].loc_set.point2.wrr_32 = \"None\" # \"None\" 1 0.5 0.382 0.302 0.25\n","config_list[0].loc_set.point2.csd_period = \"None\"  # \"None\" 100\n","config_list[0].loc_set.zone1.use_zone = 0\n","# config_list[0].loc_set.zone1.bb_trend_period = 150\n","# config_list[0].loc_set.zone1.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","# config_list[0].loc_set.zone2.use_zone = 0\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_wick_ratio = 0.5\n","config_list[0].loc_set.point1.long_wick_ratio = 0.5\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\" #  \"None\" 0.5 2 0.8 # # 0.7  5 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = \"None\"  #  \"None\" 2 0.8 ## 0.7 5 \n","# # config_list[0].loc_set.zone1.base_roll_period = 60"]},{"cell_type":"code","execution_count":24,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":9017,"status":"ok","timestamp":1666421558300,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","outputId":"da8c8507-1118-4041-b3c9-8c4b6a54b942"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:b1_upper_wick_ratio_, b1_body_ratio_ : 0.06390, 0.44218  (0.0)\n","WARNING:root:b1_lower_wick_ratio_, b1_body_ratio_ : 0.49392, 0.44218  (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0396909713745117\n","get_open_info_df elapsed time : 2.9560508728027344\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","# config_list[0].tr_set.p2_box_k1 = 0.0  # 0 default --> 0 ~ 1 사이 값 사용 tp_1 로부터 떨어지는 거리\n","# config_list[0].tr_set.p2_box_k2 = 0  # 0.5 0 default --> \"None\" 불가, 0 ~ 1 사이 값 사용 tp_0 로부터 떨어지는 거리, 본디 p2_box 는 p1_box 내부에 존재해야, 정확한 hhm 이 측정가능해짐\n","# config_list[0].tr_set.p1p2_low = 0.5  # 0.5 0.7 0  0 is equal to \"None\", 마찬가지로 tp_0 로부터 떨어지는 거리\n","# config_list[0].loc_set.point2.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","# config_list[0].loc_set.point2.long_tr_thresh = \"None\"  #  \"None\" 2 0.8 ## 0.7\n","# config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# config_list[0].ep_set.point2.wick_score_list = str([])\n","# config_list[0].tp_set.static_tp = 1\n","# config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","config_list[0].out_set.hl_out = 1\n","# config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","# config_list[0].lvrg_set.static_lvrg = 0\n","# config_list[0].lvrg_set.leverage = 5\n","# config_list[0].lvrg_set.target_pct = 0.03 # 0.1 0.03\n","# config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_bias_arr, short_net_p1_bias_tick, short_p2exec_p1_bias_tick, short_net_p1_idx_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_bias_arr, long_net_p1_bias_tick, long_p2exec_p1_bias_tick, long_net_p1_idx_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v9_1(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961_1"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":716},"id":"TvGs5mBxsuBK","executionInfo":{"status":"ok","timestamp":1666421558301,"user_tz":-540,"elapsed":10,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"b4b8ebe7-125d-4433-dd35-0ffa2057b4a4"},"execution_count":25,"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.2220299243927002\n","short_obj.shape : (479, 5)\n","long_obj.shape : (413, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.554075002670288\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8lYgsqH-rfAM"},"outputs":[],"source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ # --> 추후, outg 로 tp_gap / out_gap custom 여부를 위해, 본 cell 을 지우지 않음\n","short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","metadata":{"id":"tOFkzUX2imQu"},"source":["#### consecutive dur. value survey on bias"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CgvSrXaZEkMZ"},"outputs":[],"source":["res_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","# devided_cols.append('wave_length_fill_{}{}'.format(wave_itv1, wave_period1))\n","# devided_cols.append('wave_spread_fill_{}{}'.format(wave_itv1, wave_period1))\n","\n","wave_itv1 = '15T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","public_cols.append('upper_wick_ratio_{}'.format(wave_itv1))\n","public_cols.append('lower_wick_ratio_{}'.format(wave_itv1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"elapsed":2660,"status":"ok","timestamp":1666006926730,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"Sahvc-R0jD1A","outputId":"91d95624-5a3d-4996-dcf0-89aa4b24a551"},"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1080 with 12 Axes>"],"image/png":"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a/v888/10Ucf6dlnn1VoaKgGDBigiRMn6u23327S+gAA/ue5557Tp59+qry8POXn52vHjh167rnnPHrujBkz1LVrVx06dEirVq3SmjVrPNotbd68eVq5cqUqKir0ox/9yKt8L1y4oKSkJN1zzz06ceKEUlNTNWXKFH322WderQdoLZYfSEQQvoxvfetbZvv27ebkyZPm6NGj5n//939N7969TUpKilm1apW73aUTB1w6CHTgwIHmgw8+MMePHze7du0y999/v7ttXScouPHGG01OTo6pqKgw69evbzCn++67z+zfv99UVFSYp5566orXbiz69OljNm3aZE6dOmX27dtnpk+fbvk4EwRBEP4ZixYtMq+++qrleRCEv0TAf24AAACgDerfv79CQ0OVn5+v+Ph4bdy4UT/5yU+0YcMGq1MD/AK7tAEAALRhXbp00ZtvvqkzZ87o9ddf15IlS7RhwwbdcccdOnXqVJ3hidmzZ9f53I0bN7ZwjwDfYgsP4ANRUVHavXt3nY8NHDiw0bOxPfDAA3rllVeuWL5//37ddNNNPskRAACgPaLgAQAAAGBbwVYnIElffvlljYttAQBaX3R0tL7xjW9YnYZfYp4CAOs1dZ7yi4Jn//79io+PtzoNAGjXHA6H1Sn4LeYpALBeU+cpTloAAAAAwLYoeAAAAADYFgUPAAAAANui4AEAAABgW35x0gIrXSMptNaySkknLcgFAAAAaG21vw/b7btwuy94QiVtqrUs0YpEAAAAAAvU/j5st+/C7NIGAAAAwLYoeAAAAADYFgUPAAAAANui4AEAAABgWxQ8AAAAAGyLggcAAACAbVHwAAAAALAtCh4AAAAAtmXbC4/a/YqxAAAAABrX6BaeDh06aPv27dq5c6cKCgo0b948SVLfvn2VnZ0tp9Op9PR0hYSESJJCQ0OVnp4up9Op7OxsRUdHt2gH6nPpirGXwl38XCMp/LIIsCI7AAAAoOXU/sob/p9l7VGjBc9XX32lO++8U4MGDdKgQYN09913a9iwYVq8eLGWLl2qmJgYVVRUaOrUqZKkqVOnqqKiQjExMVq6dKkWL17c4p3wSu1KiIIHAAAANlP7K2+NDQDtjEfH8Jw5c0aSFBISopCQEBljdOedd2rdunWSpJUrV+r++++XJCUlJWnlypWSpHXr1mn06NEtkTcAAAAANMqjgicw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vf7663rooYf017/+1erU/MYNN9yguLg496+EW7Zs0R133KFt27ZZnBk8tWXLFvcW38s9++yz7guTTpo0ya+37jTUh+DgYF177bW67bbbFB8fr7Vr1+r666+3IMuGNdSHZcuWaeHChTLGaOHChVqyZImmTp1qQZYNa6gPc+bM0dixYy3IyjuN/X+YO3eu5s6dq2eeeUYzZszQvHnzWj/JRnjyf3rOnDm6cOGCVq9e3drpecSTPqBhbargcblcioqKct+PjIyUy+WSy+XSyJEjayz/4IMPWj9BP1DfGElfH4z/zjvv6Nlnn9X27dutStFy9Y3R8OHDNWLECD3++OPq3LmzQkNDdfr0ac2ePdvCbFtffeMTHBysnTt3qri4WJL01ltv6bbbbmuXBU99Y/Tggw8qOztbZ86ckSRt2rRJw4cPp+BpQ+66664GHw8KCtIPfvADvz44uKE+PPbYY+4LrDocDl28eFHh4eE6cuRIa6Xnkcbeh0tSU1P19ttvt3A2TVNfH2666Sb169dPubm5kr7+/NixY4eGDh3qd7vAevo+rF69Whs3bvTLgqexPiQnJ+t73/ueRo8e3UoZec/T96Etaej7aktoU/ujZGRkuM/ANmzYMJ04cUKHDh1SZmamxo4dq7CwMIWFhWns2LHKzMy0OFtr1DdGISEhWr9+vdLS0vTGG29YnKW16hujBx98UNHR0erXr5+efvpppaWltbtiR6p/fBwOh8LCwhQeHi5JuvPOO7V7924rU7VMfWNUUlKihIQEBQUFKTg4WAkJCdqzZ4/F2cKXxowZo8LCwja7Jfitt97SqFGjJEkxMTEKDQ31u2KnMZf/0v39739fBQUFFmbjvYKCAvXs2VP9+vVTv379VFZWpltuucXvip3G3Hjjje7bSUlJbXL33XHjxmnmzJm67777bHtMqr9yOByKiYlR3759FRISookTJ7b41irLz9RwKV577TVz4MABU1lZaUpLS80jjzxiHn30UfPoo4+62/zxj380RUVFJi8vr8bZKB5++GHjdDqN0+k0Dz30kOV98bcxmjx5sqmsrDQ5OTnuuPnmmy3vjz+N0eWRnJxs27O0NWd8xowZY3Jzc01eXp5ZsWKFCQkJsbw//jRGgYGB5s9//rPZvXu32bVrl1myZInlfSF8GytWrKjxd9DWIiQkxKxatcrk5+ebf//732bU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U1saKzvs2tWS81RxcXGbeS8b0pb+Jhtjl760+X5cNp802Bervy95sc7w4nAd+dTD98SPv1s2+TugN229XWcThYeHq1OnTk16rlcFjy+lpqYqNTW1yc93OByKj4/3YUb2xVh5jrHyDOPkOcaq7ao9T9nlvbRLPyT79MUu/ZDs0xf64X8cDof69evXpOd6tUuby+VSVFSU+35kZKRcLle9bYKCgtS1a9crfjUDAKAlME8BAGrzquBxOByKiYlR3759FRISookTJyojI6NGm4yMDCUnJ0uSxo8fr/fff9932QIA0ADmKQBAbUGS5nna2Bgjp9Op1atX64knntDf/vY3vfnmm5o/f766dOmivXv3Ki8vT5MnT9bzzz+vQYMG6ac//amOHz/eIsnv2LGjRdZrR4yV5xgrzzBOnmOsWk9Lz1N2eS/t0g/JPn2xSz8k+/SFfvifpvYlQJLxbSoAAAAA4B+8vvAoAAAAALQVFDwAAAAAbMvvCp7ly5ervLxc+fn59bZ58cUX5XQ6lZubq8GDB7uXT5kyRXv37tXevXs1ZcqU1kjXUk0dq5tvvlkff/yxCgoKlJubqwkTJrRWypZpzt+VJHXp0kWlpaV66aWXWjpVSzVnnKKiopSZmandu3dr165dtrimS0OaM1aLFy9WQUGBdu/erRdffLE10oWPpKenKycnRzk5OSouLlZOTo7VKTXZjBkztGfPHhUUFGjx4sVWp9NkKSkpKisrc78viYmJVqfULE8++aSMMerevbvVqTTJggULlJubq5ycHGVmZqp3795Wp9RkL7zwgvbs2aPc3Fy9+eab6tq1q9UpNcn48eNVUFCg6upqDRkyxOp0vDZu3DgVFhbK6XRq1qxZTV6P8acYMWKEGTx4sMnPz6/z8cTERLNx40YjyQwbNsxkZ2cbSaZbt25m3759plu3biYsLMzs27fPhIWFWd4ffxyrmJgYc+ONNxpJpnfv3ubAgQOma9eulvfHH8fqUvz+9783q1evNi+99JLlffHXccrKyjJjxowxkkynTp3MVVddZXl//HGshg8fbrZt22YCAwNNYGCg+fjjj01CQoLl/SG8j9/+9rfm17/+teV5NCVGjhxptmzZYkJDQ40k06NHD8tzamqkpKSYp556yvI8fBGRkZHm3XffNV988YXp3r275fk0Jbp06eK+/cQTT5hly5ZZnlNT46677jJBQUFGklm0aJFZtGiR5Tk1JQYMGGBiY2NNVlaWGTJkiOX5eBOBgYGmqKjI9OvXz4SEhJidO3eauLg479cjP7N161YdO3as3seTkpKUlpYmSdq+fbvCwsLUq1cvjRs3Tlu2bFFFRYWOHz+uLVu26O67726ttC3R1LFyOp0qKiqSJB08eFBffvmlevTo0So5W6WpYyVJt9xyi3r27KnNmze3Sq5Wauo4xcXFKTg4WP/4xz8kSWfOnNG5c+daJWerNHWsjDHq2LGjQkND1aFDB4WEhKi8vLy10oYPTZgwQWvWrLE6jSZ57LHHtGjRIlVWVkqSDh8+bHFGkKSlS5dq5syZMsZYnUqTnTp1yn27U6dObbovW7ZsUXV1tSQpOztbkZGRFmfUNIWFhdq7d6/VaTTJ0KFDVVRUpOLiYlVVVSk9PV1JSUler8fvCp7GREREqLS01H2/rKxMERER9S5vzzwZk/j4eIWGhmrfvn2tnZ5fqW+sAgICtGTJEj399NMWZuc/6hun2NhYHT9+XG+88YZ27NihF154QYGBbe7jxafqG6vs7GxlZWXp4MGDOnjwoDIzM1VYWGhhpmiKESNGqLy83P3jUVsTGxurESNGKDs7Wx988IFuvfVWq1NqlhkzZig3N1fLly9XWFiY1ek0yX333SeXy6W8vDyrU2m25557TiUlJZo8ebJ+85vfWJ2OTzzyyCPatGmT1Wm0O776fh/sy6TQtvTq1UurVq1ScnJym/4FpiU9/vjj2rhx4xVXakdNwcHBGjFihAYPHqySkhK9/vrreuihh/TXv/7V6tT8zg033KC4uDj3L4VbtmzRHXfcoW3btlmcGS7ZsmWLewvv5Z599ln3RUwnTZrk91t3GupHcHCwrr32Wt12222Kj4/X2rVrdf3111uQpWca6suyZcu0cOFCGWO0cOFCLVmyRFOnTrUgy8Y11I85c+Zo7NixFmTlvcb+j8ydO1dz587VM888oxkzZmjevHmtn6SHPPn/PmfOHF24cEGrV69u7fQ85kk/2rM2V/C4XC5FRUW570dGRsrlcsnlcmnkyJE1ln/wwQetn6AfqW+spK8Pwn/nnXf07LPPavv27Val6DfqG6vhw4drxIgRevzxx9W5c2eFhobq9OnTmj17toXZWqe+cQoODtbOnTtVXFwsSXrrrbd02223teuCp76xevDBB5Wdna0zZ85IkjZt2qThw4dT8PiRu+66q8HHg4KC9IMf/MDvD/5tqB+PPfaY3nzzTUmSw+HQxYsXFR4eriNHjrRWel5p7D25JDU1VW+//XYLZ9N09fXjpptuUr9+/ZSbmyvp68+LHTt2aOjQoX65y6un78fq1au1ceNGvy54GutLcnKyvve972n06NGtlFHTePqetDUNfZf1Rpvb5yQjI8N9BrZhw4bpxIkTOnTokDIzMzV27FiFhYUpLCxMY8eOVWZmpsXZWqu+sQoJCdH69euVlpamN954w+Is/UN9Y/Xggw8qOjpa/fr109NPP620tLR2W+xI9Y+Tw+FQWFiYwsPDJUl33nmndu/ebWWqlqtvrEpKSpSQkKCgoCAFBwcrISFBe/bssThbeGPMmDEqLCxs01t+33rrLY0aNUqSFBMTo9DQUL8tdhpz+a/a3//+91VQUGBhNk1TUFCgnj17ql+/furXr5/Kysp0yy23+GWx05gbb7zRfTspKalN77I7btw4zZw5U/fdd5/tj0v1Vw6HQzExMerbt69CQkI0ceLEJm+xsvwMDJfHa6+9Zg4cOGAqKytNaWmpeeSRR8yjjz5qHn30UXebP/7xj6aoqMjk5eXVONvEww8/bJxOp3E6neahhx6yvC/+OlaTJ082lZWVJicnxx0333yz5f3xx7G6PJKTk21/lrbmjNOYMWNMbm6uycvLMytWrDAhISGW98cfxyowMND8+c9/Nrt37za7du0yS5YssbwvhHexYsWKGu9zW4yQkBCzatUqk5+fb/7973+bUaNGWZ5TUyMtLc3k5eWZ3Nxcs2HDBtOrVy/Lc2puFBcXt9mztK1bt87k5+eb3Nxck5GRYfr06WN5Tk0Np9NpSkpK3N+V2uoZ5+6//35TWlpqzp8/bw4dOmTeffddy3PyJhITE81nn31mioqKzJw5c5q0joD/3AAAAAAA22lzu7QBAAAAgKcoeAAAAADYFgUPAAAAANui4AEAAABgWxQ8AAAAQDu3fPlylZeXKz8/v9nrGjlypHJyctxx7tw5JSUlefTc/v376+OPP9b58+f11FNPNTsXSeIsbQAAAEA7N2LECJ0+fVppaWn61re+5bP1duvWTUVFRYqMjLziekbFxcXq169fjWU9evRQdHS07r//flVUVGjJkiXNzoEtPAAAAEA7t3XrVh07dqzGsuuvv16bNm3Sp59+qo8++kj9+/f3er3jx4/Xpk2bPL546+HDh/Xpp5+qqqrK69eqDwUPAAAAgCv85S9/0RNPPKFbb71VTz/9tP70pz95vY6JEydqzZo1LZCd54ItfXUAAAAAfqdTp066/fbb9fe//929rEOHDpKk73//+1qwYMEVz3G5XLr77rvd93v16qVvfetbyszMdC/74x//qO985zuSpD59+ignJ0eS9Pe//13PP/98i/SFggcAAABADYGBgTp+/LgGDx58xWPr16/X+vXrG13HhAkTtH79el24cMG9bMaMGe7bxcXFda7f19ilDQAAAEANp06dUnFxscaPH+9e9u1vf9urdUyaNMny3dkuMQRBEARBEARBtN947bXXzIEDB0xlZaUpLS01jzzyiOnbt6/ZtGmT2blzp9m1a5f59a9/7fH6oqOjTVlZmQkICKi3TXFx8RXLevbsaUpLS82JEydMRUWFKS0tNV26dGlW3zgtNQAAAADbYpc2AAAAALZFwQMAAADAtih4AAAAANgWBQ/qlJKSolWrVlmdRpu3ceNGTZkypdF2xcXFGj16dCtkVNOyZcs0d+7cVn9dAGgKqz4r7aagoEAJCQmNtjPG6IYbbmiFjGrydO4EPEXBg1axYsUKLVy40Oo0Wt0999yjtLQ0q9OQJCUnJ2vr1q01lj322GN67rnnmrXeBQsWKC8vT1VVVUpJSanxWEJCgqqrq3Xq1Cl3XJrELl9WXV2ts2fPuu8/8MADzcoJAFC/m266SR9++KHVaUiq+wdWX8ydr7zyigoLC1VdXa3k5OQajyUnJ+vChQs15qGEhARFRUXVWGaM0enTp93377jjjmblBOtw4VG0uMDAtllXBwYG6uLFi1an4ZGgoCBVV1db8tpFRUWaOXOmfvrTn9b5+IEDBxQVFXXF8i5durhvFxcX6yc/+Ynee++9FssTAOwgICBAxrSNE+xaOTfl5ubq9ddf1+LFi+t8/JNPPtGIESOuWH753GSM0c0336x9+/a1WJ5oHW3zmyh8aubMmSorK9PJkydVWFioO++8U5IUGhqqlStX6uTJkyooKNCQIUPczxkwYICysrJUUVGhgoIC3Xvvve7HVqxYoT/96U965513dPr0aU2dOlWTJ0/WzJkzderUKWVkZDSYT+1N6JdvHUpISFBpaalmz56tw4cPq7i4uMbWgBUrVmjZsmXavHmzTp48qQ8++EDXXXed+/H+/ftr8+bNOnr0qAoLC/WjH/2o3rxHjRpVZ359+/ZVRUWFAgICJEl/+ctfVF5e7n48LS1NP//5zyVJWVlZmjp1qvuxn/zkJ9q9e7dOnjypXbt21Xl14QEDBujzzz/XxIkTGxyn4uJizZw5U7m5uTpz5oyCgoI0a9YsFRUVudd///33u9f55z//WcOHD9epU6dUUVFxxdheys/pdOro0aPasGGDevfu3WAOl/r77rvv6tSpU422BQBfCA0N1dKlS+VyueRyubR06VKFhoZK+r954sknn1R5ebkOHDighx56yP3ca6+9VhkZGTpx4oT+9a9/aeHChVds/a4tOjpaxhgFBQW5l13++Z6cnKxt27bppZde0vHjx7Vnzx73XHqp7fPPP6/t27frxIkTeuutt9StWzf348OGDdM///lPVVRUaOfOnTV2N8vKytJzzz2nbdu26ezZs7r++uvrzHHkyJHKy8tz39+8ebP+9a9/ue9/9NFHSkpKklRz18DAwEDNnj3bPXd8+umnioyMvGL93/nOd1RSUtLornDGGD3++OPau3evnE6nJOn3v/+9SkpKdOLECX366afuLSXjxo3TnDlz9N///d86deqUdu7cecXYBgQE6Nlnn9UXX3yh8vJyrVy5Utdcc02DOUjSn/70J73//vs6f/58o23RPlh+oSPCuoiNjTUlJSWmd+/eRvr6IlHXX3+9SUlJMefOnTOJiYkmMDDQPP/88+aTTz4xkkxwcLBxOp1m9uzZJiQkxIwaNcqcPHnSxMbGGklmxYoV5vjx4+b22283AQEBpkOHDmbFihVm4cKFHuVkjDE33HCD+/7lz01ISDBVVVVmyZIlJjQ01Hz3u981p0+frvHaJ0+eNCNGjDChoaHm97//vdm6dauRZK6++mpTUlJiHnroIRMUFGQGDRpkDh8+bOLi4urNu74c9+/fb2655RYjyRQWFpp9+/aZAQMGuB8bNGiQkWSysrLM1KlTjSQzfvx4U1ZWZm699VYjydxwww3muuuuM9LXF94aPXq0GTx4sNm/f7/5r//6r0bHqbi42OTk5JjIyEjTsWNH92v07t3bBAQEmAkTJpjTp0+bXr16GUkmOTnZPRZ1je2oUaPM4cOHzeDBg01oaKj5wx/+YD788EOP/5ZWrVplUlJSaixLSEgwX331lTl06JD5/PPPze9+9ztz9dVX19mX0aNHW/7/gSAI/45LnxXz5883n3zyienRo4cJDw83//znP82CBQuM9H/zxPz5801wcLBJTEw0Z86cMWFhYUaSWbNmjVmzZo256qqrTFxcnCkpKbnis7F2REdHG2OMCQoKci+7/PM9OTnZVFVVmV/84hcmODjYTJgwwRw/ftx069bN3basrMx885vfNFdffbVZt26dWbVqlZFk+vTpY44cOWISExNNQECAGTNmjDly5IgJDw93P3f//v1m4MCBJigoyAQHB9eZY8eOHc25c+dM9+7dTXBwsDl06JApKysznTt3Nh07djRnz5411157bY1xlGSefvppk5eX555Hv/3tb7vbXZqPx40bZ0pKSkx8fHyj75ExxmzevNl069bNPTdNnjzZXHvttSYoKMg8+eST5uDBg+45NiUlxT0WdY3t7Ich8AAAIABJREFUww8/bJxOp+nXr5/p1KmTeeONN0xaWprHfzNbt241ycnJNZYlJyeb06dPm8OHD5vPPvvMzJ07t8Z7e3lfLv8+QrTdYAtPO1ddXa0OHTpo4MCBCg4O1v79+/X5559LkrZt26ZNmzbp4sWLWrVqlW6++WZJ0m233abOnTtr0aJFqqqqUlZWlt5++21NmjTJvd4NGzbo448/ljFGX331lc/z/vWvf63Kykp99NFHeueddzRhwgT3Y++88462bt2qyspKPfvssxo+fLgiIyP1ve99T1988YVeffVVVVdXa+fOnXrjjTdqbOXxNO8PP/xQCQkJ6tmzpyRp3bp1SkhIUN++fXXNNdcoNzf3iuf85Cc/0QsvvKBPP/1UkrRv3z6VlJS4Hx8xYoQyMjI0ZcoUvfPOOx6Nwx/+8AeVlZW5f8Fat26dDh48KGOM1q5dK6fTqaFDh3q0rsmTJ+uvf/2rcnJyVFlZqdmzZ2v48OGKjo726Pl1KSws1KBBg9S7d2/deeedGjJkiH73u981eX0AIH39ebVgwQIdPnxYR44c0fz58/XjH//Y/XhVVZUWLFigCxcuaNOmTTp9+rT69++vwMBA/fCHP1RKSorOnTunPf+fvXsPi7LM+wD+5aimnJSUlXMrKKZveUBttbCoEAtxxQwPr2Qs5rbacRPTetNsPdSbWq151eQqmopEteC+WpoH0hKblZMgyIwiAgqIguFpRbzfP1xnneE052fm4fvxuq/LYe6Z+f3mgeee3zz3cz/FxUhJSTFLTLW1tVizZg1u3ryJtLQ0nDhxAk899ZTm/s2bN6OoqAhXr17F22+/jSlTpsDR0REzZszAzp07sWvXLggh8MMPP+Cf//wnxo8fr3nsxo0bcfz4cTQ3N+PmzZutvv7169ehVCrxyCOPYNiwYcjPz8dPP/2E0aNHY9SoUVCpVLh48WKLx/3hD3/AW2+9hdLSUgBAQUGBVr9nnnkGn332GaKjo6FUKvV6L5YvX476+nrN2LRlyxZcvHgRzc3NWLVqFbp06YL+/fvr9VzTp0/HqlWrUFZWhitXruDNN99EfHy81tE2Q/34448YNGgQevfujbi4OEydOhVvvPGG0c9Hto8FTyd38uRJvPLKK1i8eDFqa2uxbds2zTSm6upqTb+rV6+iW7ducHJyQt++fVFRUaE1h7i8vBy+vr6a2xUVFRaLub6+HlevXtV67b59+7b62leuXMHFixfRt29fBAYGYuTIkaivr9e06dOnw8fHx+C4s7KyMHbsWDzyyCP48ccfceDAAURERCAiIgIHDx5sdX61v79/u/OA58yZg59//tmgE0l14/3v//5v5ObmavIbNGgQvL299Xquvn37ory8XHP7ypUruHDhgtZ2NVRNTQ2Ki4shhMDp06cxf/58xMXFGf18RERAy/2V7jhw4cIFrXNHrl69ih49euDee++Fi4uL1r7TXONVVVWV1u32xqby8nK4urrC29sbgYGBeOaZZ7TGpjFjxmhNKTZmbMrKytIam9oaWzoam1555RWkpaWhqKhIrxhai/f111/H8ePH0dDQgPr6enh4eBg9NpWXl8PFxUXzhaMxysrKcPr0aQghUFhYiHfffReTJ082+vnI9rHgIWzbtg0PP/ywZo5yWyf43XHnJPQ757AAQEBAgNbOXvcDvyEnWF65cgX33HOP5vbdBQkAeHl5ad0fEBCAs2fPam7ffYJ89+7d0bNnT5w9exYVFRXIysqCl5eXprm5ueHFF180OM6srCw8/PDDGDt2LLKysnDo0CGMHj263UGloqKi3eU958yZg4CAAIOOgNwdb0BAABQKBebOnYtevXrBy8sLhYWFmu3UUW5nz57VOppzzz33oFevXi0GcVMIIex2EQsish26+yvdcaAt58+fR1NTk9Y5Kq0tqqLrypUrANDu2KT7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efjyyy/xzTffmPMlWsjJybHo80tFrnkB8s1NrnkB8s1NrnkB8s7NVNYeq+S+LeScH3OzT3LODZB3fpbIzeyLFhAREREREdkKi1x4lIiIiIiIyBaw4CEiIiIiItmy6YInKioKJSUlUKlUSE5ObnG/q6srUlNToVKpkJ2djcDAQM19CxYsgEqlQklJCZ588klrht0hY/MKDAzE1atXkZubi9zcXKxbt87aobero7wefvhhHD16FE1NTYiLi9O6b+bMmSgtLUVpaSlmzpxprZD1ZkpuN2/e1GyzjIwMa4Wsl47yevXVV1FUVIT8/Hz88MMPCAgI0Nxn79usvdxseZsBHef2wgsvoKCgALm5uTh48CDCwsI099nyvtHedbRd7pg0aRKEEBg2bJgVozNNR7klJCSgtrZW83eTmJgoQZTG0We7PfPMMygqKkJhYSG2bNli5QhN01F+q1at0my3EydOoL6+XoIojdNRbv7+/ti3bx9ycnKQn5+P6OhoCaI0Tke5BQQE4IcffkB+fj72798PX19fCaI0zvr161FTU4Njx4612eejjz6CSqVCfn4+hgwZYpbXlXzN7daao6OjUKvnvROeAAAgAElEQVTVIjg4WLi4uIi8vDwRFham1eePf/yjWLdunQAgnn32WZGamioAiLCwMJGXlydcXV1FUFCQUKvVwtHRUfKcTM0rMDBQHDt2TPIcjM0rMDBQDB48WKSkpIi4uDjNz728vMTJkyeFl5eX8PT0FCdPnhSenp6S52SO3ACIxsZGyXMwNq+xY8eKbt26CQBizpw5mt9FOWyztnKz5W2mb25ubm6a/8fExIhdu3YJwLb3jfbe9NkuAESPHj1EVlaWOHz4sBg2bJjkcZsrt4SEBItec0/K3Pr16ydycnI0+7h7771X8rjNmd/dbe7cuWL9+vWSx22u3D777DMxZ84cAdze/5WVlUket7lyS0tLEzNnzhQAxKOPPio2bdokedz6tocfflgMGTKkzc+00dHRYufOnQKAGDlypMjOzjb9PYWNGjFiBNRqNcrKytDU1ITU1FTExsZq9YmNjUVKSgoAID09HZGRkZqfp6am4saNGzh9+jTUajVGjBhh9RxaY0petkyfvMrLy3Hs2DHcunVL6+dRUVHYs2cP6uvr0dDQgD179mDcuHHWDL9dpuRmy/TJ68CBA7h27RoAIDs7G35+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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_p1_idx]\n","  long_open_data = long_data[long_p1_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  # short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  short_false_data = short_open_data[~short_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  # long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  long_false_data = long_open_data[~long_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":881},"executionInfo":{"elapsed":2820,"status":"ok","timestamp":1659074362424,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"jHh0uFkXC4VF","outputId":"cf21f56c-faf2-471d-b7e0-5c16e0ff2bdd"},"outputs":[{"output_type":"stream","name":"stdout","text":["223\n","533\n","223\n","533\n","223\n","533\n","223\n","533\n","pkx : [0.05994977 0.14818175 0.35111529 0.74815919]\n","pkx : [0.09816775 0.30374184 0.78029994]\n","\n","56\n","84\n","56\n","84\n","56\n","84\n","56\n","84\n","pkx : [-0.23140658 -0.19827966 -0.16515274 -0.14385686 -0.11072994 -0.07287061 -0.01371539]\n","pkx : [-0.32640606 -0.24710795 -0.18102619 -0.11494443 -0.03234223]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(short_max_data))\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"mScdfR9hmjVu"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"983aUwM76s6X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p_e8PtFXa7mc"},"outputs":[],"source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLZDkNNxbZPO"},"outputs":[],"source":["p1_hlm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":261,"status":"ok","timestamp":1653452376525,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WhCPOi1qbkHS","outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"outputs":[{"data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"execution_count":161,"metadata":{},"output_type":"execute_result"}],"source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wgERZ65F5RBB"},"outputs":[],"source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rAao95SEnOY0"},"outputs":[],"source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":267,"status":"ok","timestamp":1653119592395,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"OEQ9KWXVnQ2J","outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"outputs":[{"name":"stdout","output_type":"stream","text":["153\n","163\n"]},{"data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"execution_count":220,"metadata":{},"output_type":"execute_result"}],"source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hOtCGUeBQ4hn"},"outputs":[],"source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QPhjkZQhRLqr"},"outputs":[],"source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cFd7Fz0Y6ucU"},"outputs":[],"source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v4"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":94486,"status":"ok","timestamp":1662375629618,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oVifICO4-Grk","outputId":"6a893363-2ab7-4613-d92b-14407dcb5617"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.10000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.10000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.4183809757232666\n","get_open_info_df elapsed time : 1.1475732326507568\n","en_ex_pairing elapsed time : 0.002592325210571289\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.20000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.20000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.1166181564331055\n","get_open_info_df elapsed time : 1.1268563270568848\n","en_ex_pairing elapsed time : 0.05585646629333496\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.1961812973022461\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9891541004180908\n","get_open_info_df elapsed time : 1.133213996887207\n","en_ex_pairing elapsed time : 0.443495512008667\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21266508102416992\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.40000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.010218620300293\n","get_open_info_df elapsed time : 1.1166355609893799\n","en_ex_pairing elapsed time : 1.9594817161560059\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.25990796089172363\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.50000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9856662750244141\n","get_open_info_df elapsed time : 1.1325628757476807\n","en_ex_pairing elapsed time : 4.9015138149261475\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.3125646114349365\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.60000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.60000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.008387565612793\n","get_open_info_df elapsed time : 1.125178575515747\n","en_ex_pairing elapsed time : 8.5075364112854\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.35973072052001953\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.70000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.70000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.025289535522461\n","get_open_info_df elapsed time : 1.1360254287719727\n","en_ex_pairing elapsed time : 12.39824891090393\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.39333009719848633\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.80000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.80000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.034311056137085\n","get_open_info_df elapsed time : 1.1319921016693115\n","en_ex_pairing elapsed time : 16.35196018218994\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.41879725456237793\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.90000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.90000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0511291027069092\n","get_open_info_df elapsed time : 1.1418323516845703\n","en_ex_pairing elapsed time : 19.928776502609253\n","idep_plot elapsed time : 0.41760993003845215\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAABWkAAAILCAYAAACadh4AAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzde1gUZfsH8C+nReW0CAiKiIhgKopYHkrLkjyQGZbmq1agkeY5U/PUgdQ0stfMSqkfIqmpaKmJeSS1VzMyVERRFFQkQI4CuyAqp+f3B7GJgJx2mV34fq7ruS52Znbm3hmWm3nmmXv0AAgQERERERERERERkST0pQ6AiIiIiIiIiIiIqDljJy0RERERERERERGRhNhJS0RERERERERERCQhdtISERERERERERERSYidtEREREREREREREQSYictERERERERERERkYTYSUtNmr+/P7Zs2SJ1GERERFSFhIQEeHp6Sh0GERERVUMIAWdnZ7Wsy9fXFydPnlTLuoiaInbSEtVBSEgIli9fLnUYRERERERERFrL0dERQggYGBhIHQqRzmAnLVEt6evz60JEREREREREROrHXidqEhYsWIDk5GQolUpcuXIFgwcPVs2TyWTYtGkTlEolYmJi8Pjjj6vmPfbYYzh+/DhycnIQExODkSNHquaFhIRg/fr12L9/P/Lz8+Hn54fXXnsNCxYsQF5eHsLCwhr1MxIRETVlMpkMa9asQUpKClJSUrBmzRrIZDIAwKBBg5CUlIS5c+ciPT0dt27dwsSJE1Xvbd26NcLCwqBQKPDXX39h+fLlvJ2SiIhITV544QVcv34dmZmZWLVqFfT09AAAenp6eP/993Hz5k2kp6dj06ZNMDc3BwCcOHECAJCbm4u8vDz0799ftb7PP/8c2dnZuHHjBoYPH974H4hIiwk2Nl1urq6u4u+//xZt27YVAISjo6Po1KmTACD8/f3F3bt3hZeXl9DX1xcrV64UERERAoAwNDQU8fHxYvHixcLIyEg899xzQqlUCldXVwFAhISEiNzcXPHUU08JPT09YWxsLEJCQsTy5csl/8xsbGxsbGxNoSUkJAhPT08BQCxdulREREQIGxsbYW1tLU6dOiWWLVsmAIhBgwaJoqIisXTpUmFoaCi8vLzEnTt3hFwuFwDE9u3bxfbt20XL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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","val_list = np.arange(0.1, 1, 0.1)     # prcn 1\n","# val_list = np.arange(-0.5, 0.5, 0.05)  # prcn 2\n","# val_list = np.arange(-0.5, 0., 0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(1, 10, 1)   # prcn -1\n","# val_list = np.arange(100, 120, 1)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  config_list_copy[0].loc_set.point1.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point1.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val\n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  # config_list_copy[0].tr_set.ep_gap1 = set_val \n","  # config_list_copy[0].tr_set.ep_gap2 = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","  # config_list_copy[0].tr_set.wave_length1 = set_val  \n","  # config_list_copy[0].tr_set.wave_time_ratio1 = set_val\n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","  open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","  open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=2)\n","  open_info_df_list = [open_info_df1, open_info_df2]\n","\n","  try:\n","    result.append(get_res_v9(res_df, open_info_df_list, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'frq', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1658210884.pkl\"\n","trade_log_dir_path = \"./trade_log/0717_5_47_trader\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","source":["trade_log  # both pos_side's log"],"metadata":{"id":"9Kymnik4ZpA6"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1658222594162,"user_tz":-540,"elapsed":431,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"a06c3f6a-311d-4a7d-c425-00563fd8980f"},"outputs":[{"output_type":"stream","name":"stdout","text":["lacked_open_ts : []\n","added_open_ts : ['2022-01-14 17:27:59.999000']\n","\n","lacked_entry_ts : []\n","added_entry_ts : ['2022-01-14 17:28:59.999000']\n","\n","lacked_exit_ts : []\n","added_exit_ts : ['2022-01-14 19:53:59.999000']\n","\n"]}],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"SELL\" # BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","op_ts = list(map(lambda x : str(x), res_df.index[val_obj[4].astype(int).ravel()])) \n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","for order_type, ts_ in zip(['open', 'entry', 'exit'], [op_ts, en_ts, ex_ts]):\n","  trade_log_ts = [k for k, v in trade_log.items() if order_type in v if pos_side in v]\n","  lacked_ts = [ts for ts in ts_ if not ts in trade_log_ts]\n","  added_ts = [ts for ts in trade_log_ts if not ts in ts_]\n","\n","  print(\"lacked_{}_ts :\".format(order_type), lacked_ts)\n","  print(\"added_{}_ts :\".format(order_type), added_ts)\n","  print()"]},{"cell_type":"code","source":["# ex_ts\n","# [k for k, v in trade_log.items() if order_type in v if pos_side in v]\n","# list(trade_log.keys())[1]\n","res_df.iloc[-0:]"],"metadata":{"id":"ZlcPZeuO-UnB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### check added_ts"],"metadata":{"id":"bPfWgZCI73LZ"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"markdown","source":["#### price sync_check"],"metadata":{"id":"yMFIedEG77Yt"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    # print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v9_1(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if config_list[0].tr_set.check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  # paired_res = en_ex_pairing_v9_41(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  paired_res = en_ex_pairing_v9_4(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16_3(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v16_3(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","    # print(\"passed\")\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","          short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    \n","    short_ll = res_df['ll_{}'.format(config.tr_set.wave_itv1)].to_numpy()[short_net_p1_idx_arr]\n","    short_ll_odds = np.sum(short_ll) / len(short_ll)\n","    long_hh = res_df['hh_{}'.format(config.tr_set.wave_itv1)].to_numpy()[long_net_p1_idx_arr]\n","    long_hh_odds = np.sum(long_hh) / len(long_hh)\n","    both_odds = (short_ll_odds + long_hh_odds) /2\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","    # print(\"short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick :\", short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8_1(gs, gs_idx, len_df, sample_len, short_tr, short_ll_odds, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8_1(gs, gs_idx, len_df, sample_len, long_tr, long_hh_odds, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8_1(gs, gs_idx, len_df, sample_len, both_tr, both_odds, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_net_p1_bias_tick, short_p2exec_p1_bias_tick, short_net_p1_idx_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_net_p1_bias_tick, long_p2exec_p1_bias_tick, long_net_p1_idx_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"code","source":["\n","def plot_info_v8_1(gs, gs_idx, len_df, sample_len, tr, hhll, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n hhll : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhll, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"],"metadata":{"id":"ocrkzEQPunhA"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","source":["# lvrg_set_v2 adj.\n","def en_ex_pairing_v9_41(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    open, high, low, close = ohlc_list\n","\n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:  # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        if show_detail:\n","            print(\"open_i1 :\", open_i1, side_arr1[open_i1])\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1  # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","            # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm\n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        if show_detail:\n","            print(\"============ op_idx1 : {} {} ============\".format(op_idx1, open_side))\n","\n","        # if show_detail:\n","        #   print(\"check_hlm :\", check_hlm)\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.entry_type, op_idx1, tp_1_, tp_gap_, len_df,\n","                                                                          open_side,\n","                                                                          [*ohlc_list, ep1_arr], expiry_p2)\n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","                print(\"p1's expiry by expiry_p2 function in p1's loop : continue\")\n","            continue\n","            # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        # if check_hlm in [0, 1]:\n","        #   i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","            # ============ get p2_info ============ #\n","            if check_hlm in [1, 2]:\n","                open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","                if open_i2 >= len_open_idx2:  # open_i2 소진\n","                    break\n","\n","                if show_detail:\n","                    print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","                # ------ check side sync. ------ #\n","                if open_side != side_arr2[open_i2]:\n","                    continue\n","\n","                # ------ assert, op_idx2 >= exec_j ------ #\n","                op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","                if check_hlm == 1 and allow_exit:\n","                    if op_idx2 < op_idx1:\n","                        continue\n","                else:\n","                    if op_idx2 < i:  # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","                        continue\n","\n","                if check_hlm == 2:\n","                    i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","                    if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                        break\n","\n","                if show_detail:\n","                    print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","\n","            else:\n","                op_idx2 = op_idx1\n","\n","            tp_ = tp_arr[op_idx1]\n","            ep2_ = ep2_arr[op_idx2]\n","            out_ = out_arr[op_idx2]\n","\n","            out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","            out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","            out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","\n","            # ------ const. for p2_wave ------ #\n","            wave_itv1 = config.tr_set.wave_itv1\n","            wave_period1 = config.tr_set.wave_period1\n","            wave_itv2 = config.tr_set.wave_itv2\n","            wave_period2 = config.tr_set.wave_period2\n","\n","            if check_hlm in [1, 2]:\n","                # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","                # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","                # if check_hlm:  # p1_hlm, p2_hlm --> Todo, 이거를 왜 p1_hlm 에도 적용했는지 잘 모르겠음\n","                if op_idx1 < op_idx2:\n","                    expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","                    if expire:  # p1's expiry\n","                        if show_detail:\n","                            print(\"expiry_p1, touch_idx = {} : break\".format(touch_idx))\n","                        i = touch_idx  # + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                        open_i2 = prev_open_i2\n","                        break  # change op_idx1\n","\n","                if check_hlm == 2:\n","                    # ------ p2 point_validation - vectorization unavailable ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","                    if open_side == OrderSide.SELL:\n","                        # --- p2_wave validation --- #\n","                        wave_co_post_idx = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        if not (op_idx1 < wave_co_post_idx):\n","                            if show_detail:\n","                                print(\"p2_wave validation : continue\")\n","                            continue  # change op_idx2\n","\n","                        # --- p2_wave high validation --- #\n","                        # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                        # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        # if not (wave_high_fill1_ >= wave_high_fill2_):\n","                        #   if show_detail:\n","                        #     print(\"p2_wave high validation : continue\")\n","                        #   continue  # change op_idx2\n","\n","                        if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","                            break  # change op_idx1\n","                        elif not (ep2_ < out_ and close[op_idx2] < out_):\n","                            if show_detail:\n","                                print(\"point validation : continue\")\n","                            continue  # change op_idx2\n","                    else:\n","                        # --- p2_wave validation --- #\n","                        wave_cu_post_idx = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        if not (op_idx1 < wave_cu_post_idx):\n","                            if show_detail:\n","                                print(\"p2_wave validation : continue\")\n","                            continue  # change op_idx2\n","\n","                        # --- p2_wave low validation --- #\n","                        # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                        # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        # if not (wave_low_fill1_ <= wave_low_fill2_):\n","                        #   if show_detail:\n","                        #     print(\"p2_wave low validation : continue\")\n","                        #   continue  # change op_idx2\n","\n","                        if not (tp_ > ep2_):\n","                            break\n","                        elif not (ep2_ > out_ and close[op_idx2] > out_):\n","                            if show_detail:\n","                                print(\"point validation : continue\")\n","                            continue\n","\n","                    # ------ p2_box location ------ #\n","                    if open_side == OrderSide.SELL:\n","                        if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (\n","                                out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                            # if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                            if show_detail:\n","                                print(\"p2_box rejection : continue\")\n","                            continue\n","                        else:\n","                            # ------ p1p2_low ------ #\n","                            if not high[op_idx1:op_idx2 + 1].max() < tp_0_ - tp_gap_ * config.tr_set.p1p2_low:\n","                                if show_detail:\n","                                    print(\"p1p2_low rejection : continue\")\n","                                continue\n","                    else:\n","                        if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                            # if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                            if show_detail:\n","                                print(\"p2_box rejection : continue\")\n","                            continue\n","                        else:\n","                            # ------ p1p2_low ------ #\n","                            if not low[op_idx1:op_idx2 + 1].min() > tp_0_ + tp_gap_ * config.tr_set.p1p2_low:\n","                                if show_detail:\n","                                    print(\"p1p2_low rejection : continue\")\n","                                continue\n","\n","                    # ------ check p2's expiry ------ # - 현재, op_idx2 기준의 ep2_arr 을 사용 중임.\n","                    # exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, tp_1_, tp_gap_, len_df, open_side,\n","                    #                                                                         [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄                                                                                      \n","                    exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, out_1_,\n","                                                                                   out_gap_, len_df, open_side,\n","                                                                                   [*ohlc_list, ep2_arr],\n","                                                                                   expiry_p2)  # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄\n","                    i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","                    if not entry_done:  # p2's expiry\n","                        if show_detail:\n","                            print(\"expiry_p2, i = {} : continue\".format(i))\n","                        continue  # change op_idx2            \n","\n","                    # ------ devectorized tr_calc ------ # - en_p 에 대해 하는게 맞을 것으로봄\n","                    if open_side == OrderSide.SELL:\n","                        tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))\n","                    else:\n","                        tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))\n","\n","                        # ------ tr_threshold ------ #\n","                    if config.loc_set.point2.short_tr_thresh != \"None\":\n","                        if open_side == OrderSide.SELL:\n","                            if tr_ < config.loc_set.point2.short_tr_thresh:\n","                                if show_detail:\n","                                    print(\"tr_threshold : continue\")\n","                                continue\n","                        else:\n","                            if tr_ < config.loc_set.point2.long_tr_thresh:\n","                                if show_detail:\n","                                    print(\"tr_threshold : continue\")\n","                                continue\n","\n","            if not allow_exit:  # p1_hlm 의 경우, 한번 out 되면 price 가 wave_range 에 닿기전까지 retrade 를 허용하지 않는다. (expiry_p1 을 이용해 op_idx1 을 변경할 것)  \n","                if show_detail:\n","                    print(\"allow_exit = {} : continue\".format(allow_exit))\n","                continue\n","\n","            if check_hlm in [0, 1]:\n","                tr_ = tr_arr[op_idx1]\n","\n","            # ------ leverage ------ #\n","            # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","            # leverage = lvrg_set_v2(config.trader_set.initial_asset, config, open_side, tp_, out_, fee, config.lvrg_set.limit_leverage)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","            leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)\n","            if leverage is None:\n","                if show_detail:\n","                    print(\"leverage is None : continue\")\n","                if check_hlm:\n","                    continue  # change op_idx2\n","                else:\n","                    break  # change op_idx1\n","\n","            exit_done, cross_on = 0, 0\n","            # ------ check tpout_onexec ------ #\n","            # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","            if config.ep_set.entry_type == \"LIMIT\":\n","                if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                    tp_j = exec_j\n","                if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                    out_j = exec_j\n","\n","            # ============ exit loop ============ #\n","            while 1:\n","                if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                    tp_j = i\n","                if not config.out_set.static_out:\n","                    out_j = i\n","\n","                # ------------ out ------------ #  # out 우선 (보수적 검증)\n","                # ------ signal_out ------ #\n","                if not exit_done:\n","                    exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done,\n","                                                                         [*ohlc_list, np_timeidx])\n","                # ------ hl_out ------ #\n","                if config.out_set.hl_out:\n","                    if not exit_done:  # and i != len_df - 1:\n","                        exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","                # ------------ tp ------------ #\n","                if not config.tp_set.non_tp and i != exec_j:\n","                    if not exit_done:\n","                        exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                                   [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                        # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                        # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","                if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                    # ------ append dynamic vars. ------ #\n","                    p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                    p2_idx_list.append(op_idx2)\n","                    pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                    pair_price_list.append([en_p, ex_p])\n","                    lvrg_list.append(leverage)\n","                    fee_list.append(fee)\n","                    tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                    tr_list.append(tr_)  # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                    # open_i += 1  # 다음 open_idx 조사 진행\n","                    break\n","\n","                # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","                # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","                i += 1\n","                if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                    break\n","\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","            if exit_done == 1:  # tp_done 은 check_hlm 여부와 무관하게 op_idx1 을 변경함\n","                if show_detail:\n","                    print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","                break  # change op_idx1\n","            else:  # exit_done -> -1 or 0 (0 means end of df) \n","                if check_hlm in [1, 2]:\n","                    if check_hlm == 1:  # exit only once in p1_hlm mode\n","                        allow_exit = 0\n","                    if show_detail:\n","                        print(\"exit_done = {}, i = {} : continue\".format(exit_done, i))\n","                    continue  # change op_idx2\n","                else:\n","                    if show_detail:\n","                        print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","                    break  # change op_idx1    \n","\n","        # if op_idx1 >= 16355:\n","        #   break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(\n","        lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)"],"metadata":{"id":"dJB5VtXMM8D8"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def check_entry_v6(res_df, config, entry_type, op_idx, wave1, wave_gap, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave_gap, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3_1(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id  \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ cci ------ # \n","    if config.out_set.cci_exit:\n","        if open_side == OrderSide.SELL:\n","            wave_co_ = res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","            if wave_co_[i]:\n","                exit_done = -1\n","        else:\n","            wave_cu_ = res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","            if wave_cu_[i]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"qM6H6fmrKtsA"},"source":["#### legacy"]},{"cell_type":"code","source":["def get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_p2exec_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_p2exec_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정 --> olds\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","    # last_idx = np.inf  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))   # p1's 1st & 2nd pair 위해서 last_idx 마지막에 붙여준 것\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # print(\"pass min touch_idx\")\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","\n","    short_tp_1_p2exec_p1_touch_idx = short_tp_1_touch_idx[short_p2exec_p1_idx]  # p2 까지 체결된 p1's hhm (p2 executed p1_hhm)\n","    short_tp_0_p2exec_p1_touch_idx = short_tp_0_touch_idx[short_p2exec_p1_idx]\n","    long_tp_1_p2exec_p1_touch_idx = long_tp_1_touch_idx[long_p2exec_p1_idx]\n","    long_tp_0_p2exec_p1_touch_idx = long_tp_0_touch_idx[long_p2exec_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------ get wave's bias_tick ------------ #\n","    short_tp_1_net_p1_touch_idx2 = np.where(short_tp_1_net_p1_touch_idx == last_idx, np.nan, short_tp_1_net_p1_touch_idx)\n","    long_tp_1_net_p1_touch_idx2 = np.where(long_tp_1_net_p1_touch_idx == last_idx, np.nan, long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx2 = np.where(short_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, short_tp_1_p2exec_p1_touch_idx)\n","    long_tp_1_p2exec_p1_touch_idx2 = np.where(long_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, long_tp_1_p2exec_p1_touch_idx)\n","\n","    short_net_p1_bias_tick = short_tp_1_net_p1_touch_idx2 - short_net_p1_idx\n","    long_net_p1_bias_tick = long_tp_1_net_p1_touch_idx2 - long_net_p1_idx\n","\n","    short_p2exec_p1_bias_tick = short_tp_1_p2exec_p1_touch_idx2 - short_p2exec_p1_idx\n","    long_p2exec_p1_bias_tick = long_tp_1_p2exec_p1_touch_idx2 - long_p2exec_p1_idx\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_p2exec_p1_true_bias_bool = short_tp_1_p2exec_p1_touch_idx < short_tp_0_p2exec_p1_touch_idx  # true_bias 의 조건\n","    short_p2exec_p1_false_bias_bool = short_tp_1_p2exec_p1_touch_idx >= short_tp_0_p2exec_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_p2exec_p1_true_bias_bool = long_tp_1_p2exec_p1_touch_idx < long_tp_0_p2exec_p1_touch_idx\n","    long_p2exec_p1_false_bias_bool = long_tp_1_p2exec_p1_touch_idx >= long_tp_0_p2exec_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p2exec_tpbox_hhm = hhm(short_p2exec_p1_true_bias_bool, short_p2exec_p1_false_bias_bool)\n","    long_p2exec_tpbox_hhm = hhm(long_p2exec_p1_true_bias_bool, long_p2exec_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_p2exec_tpbox_hhm, long_p2exec_tpbox_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","           short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음\n"],"metadata":{"id":"Z51DvMhgXjUA"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_touch_idx_fill(tp_1_touch_idxs, net_p1_pair, net_p1_idx, len_df):\n","    tp_1_touch_idx = np.full(len_df, np.nan)\n","    # valid_net_p1_idx = [idx for (iin, iout), idx  in zip(net_p1_pair, net_p1_idx) if iin < iout]\n","    # print(\"len(valid_net_p1_idx) :\", len(valid_net_p1_idx))\n","    tp_1_touch_idx[net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair]\n","    # tp_1_touch_idx[valid_net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair if iin < iout]\n","\n","    return fill_arr(tp_1_touch_idx)"],"metadata":{"id":"I_nHtMZUZx9l"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def en_ex_pairing_v9_5(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    open, high, low, close = ohlc_list\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        if show_detail:\n","            print(\"open_i1 :\", open_i1, side_arr1[open_i1])\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm   \n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ============\".format(op_idx1, open_side))\n","     \n","        # if show_detail:\n","        #   print(\"check_hlm :\", check_hlm)\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.entry_type, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry by expiry_p2 function in p1's loop : continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        # if check_hlm in [0, 1]:\n","        #   i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          if check_hlm in [1, 2]:\n","            open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","            if open_i2 >= len_open_idx2:  # open_i2 소진\n","                break\n","\n","            if show_detail:\n","              print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","            # ------ check side sync. ------ #\n","            if open_side != side_arr2[open_i2]:\n","              continue\n","\n","            # ------ assert, op_idx2 >= exec_j ------ #\n","            op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","            if check_hlm == 1 and allow_exit:\n","              if op_idx2 < op_idx1:\n","                continue\n","            else:\n","              if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","                continue\n","            \n","            if check_hlm == 2:\n","              i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","\n","            if show_detail:\n","              print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","              \n","          else:\n","            op_idx2 = op_idx1\n","          \n","          tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]  # p2's tp_box 를 위한 재정의\n","          tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]   \n","\n","          tp_ = tp_arr[op_idx2]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]  \n","\n","          # ------ const. for p2_wave ------ #\n","          wave_itv1 = config.tr_set.wave_itv1\n","          wave_period1 = config.tr_set.wave_period1\n","          wave_itv2 = config.tr_set.wave_itv2\n","          wave_period2 = config.tr_set.wave_period2\n","\n","          if check_hlm in [1, 2]:\n","            # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","            # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","            # if check_hlm:  # p1_hlm, p2_hlm --> Todo, 이거를 왜 p1_hlm 에도 적용했는지 잘 모르겠음\n","            # if op_idx1 < op_idx2:\n","            #   expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","            #   if expire:   # p1's expiry\n","            #       if show_detail:\n","            #         print(\"expiry_p1, touch_idx = {} : break\".format(touch_idx))\n","            #       i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","            #       open_i2 = prev_open_i2\n","            #       break   # change op_idx1\n","\n","            if check_hlm == 2:\n","              # ------ p2 point_validation - vectorization unavailable ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","              if open_side == OrderSide.SELL:\n","                # --- p2_wave validation --- #\n","                wave_co_post_idx = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                if not (op_idx1 < wave_co_post_idx):\n","                  if show_detail:\n","                    print(\"p2_wave validation : continue\")\n","                  continue  # change op_idx2\n","\n","                # --- p2_wave high validation --- #\n","                # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                # if not (wave_high_fill1_ >= wave_high_fill2_):\n","                #   if show_detail:\n","                #     print(\"p2_wave high validation : continue\")\n","                #   continue  # change op_idx2\n","                  \n","                if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","                  break  # change op_idx1\n","                elif not (ep2_ < out_ and close[op_idx2] < out_):\n","                  if show_detail:\n","                    print(\"point validation : continue\")\n","                  continue  # change op_idx2\n","              else:\n","                # --- p2_wave validation --- #\n","                wave_cu_post_idx = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                if not (op_idx1 < wave_cu_post_idx):\n","                  if show_detail:\n","                    print(\"p2_wave validation : continue\")\n","                  continue  # change op_idx2\n","                \n","                # --- p2_wave low validation --- #\n","                # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                # if not (wave_low_fill1_ <= wave_low_fill2_):\n","                #   if show_detail:\n","                #     print(\"p2_wave low validation : continue\")\n","                #   continue  # change op_idx2\n","\n","                if not (tp_ > ep2_):              \n","                  break\n","                elif not (ep2_ > out_ and close[op_idx2] > out_):\n","                  if show_detail:\n","                    print(\"point validation : continue\")\n","                  continue\n","\n","              # ------ p2_box location ------ #\n","              # if open_side == OrderSide.SELL:\n","              #   if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","              #   # if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","              #     if show_detail:\n","              #         print(\"p2_box rejection : continue\")\n","              #     continue\n","              #   else:                \n","              #     # ------ p1p2_low ------ #\n","              #     if not high[op_idx1:op_idx2 + 1].max() < tp_0_ - tp_gap_ * config.tr_set.p1p2_low:\n","              #       if show_detail:\n","              #         print(\"p1p2_low rejection : continue\")\n","              #       continue\n","              # else:\n","              #   if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","              #   # if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","              #     if show_detail:\n","              #         print(\"p2_box rejection : continue\")\n","              #     continue\n","              #   else:\n","              #     # ------ p1p2_low ------ #\n","              #     if not low[op_idx1:op_idx2 + 1].min() > tp_0_ + tp_gap_ * config.tr_set.p1p2_low:\n","              #       if show_detail:\n","              #         print(\"p1p2_low rejection : continue\")\n","              #       continue\n","\n","              # ------ check p2's expiry ------ # - 현재, op_idx2 기준의 ep2_arr 을 사용 중임.\n","              # exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, tp_1_, tp_gap_, len_df, open_side,\n","              #                                                                         [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄                                                                                      \n","              exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, out_1_, out_gap_, len_df, open_side,\n","                                                                                      [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄\n","              i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","              if not entry_done:   # p2's expiry\n","                  if show_detail:\n","                      print(\"expiry_p2, i = {} : continue\".format(i))\n","                  continue  # change op_idx2            \n","              \n","              # ------ devectorized tr_calc ------ # - en_p 에 대해 하는게 맞을 것으로봄\n","              if open_side == OrderSide.SELL:\n","                tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))\n","              else:\n","                tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))              \n","\n","              # ------ tr_threshold ------ #\n","              if config.loc_set.point2.short_tr_thresh != \"None\":\n","                if open_side == OrderSide.SELL:\n","                  if tr_ < config.loc_set.point2.short_tr_thresh:\n","                    if show_detail:\n","                      print(\"tr_threshold : continue\")\n","                    continue\n","                else:\n","                  if tr_ < config.loc_set.point2.long_tr_thresh:\n","                    if show_detail:\n","                      print(\"tr_threshold : continue\")\n","                    continue\n","                \n","          if not allow_exit:  # p1_hlm 의 경우, 한번 out 되면 price 가 wave_range 에 닿기전까지 retrade 를 허용하지 않는다. (expiry_p1 을 이용해 op_idx1 을 변경할 것)  \n","            if show_detail:\n","              print(\"allow_exit = {} : continue\".format(allow_exit))\n","            continue\n","\n","          if check_hlm in [0, 1]:\n","            tr_ = tr_arr[op_idx1]\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None : continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ #\n","          while 1:\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ out ------------ #  # out 우선 (보수적 검증)\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out:\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","              if not exit_done:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                          [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                p2_idx_list.append(op_idx2)\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done 은 check_hlm 여부와 무관하게 op_idx1 을 변경함\n","            if show_detail:\n","                    print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:  # exit_done -> -1 or 0 (0 means end of df) \n","            if check_hlm in [1, 2]:\n","              if check_hlm == 1:   # exit only once in p1_hlm mode\n","                allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : continue\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        # if op_idx1 >= 16355:\n","        #   break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"AH3JXLkwL_B6","executionInfo":{"status":"ok","timestamp":1658884508950,"user_tz":-540,"elapsed":1076,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0fa49ccd-e99c-44fd-ac0a-84441dd585d4"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["False"]},"metadata":{},"execution_count":21}]},{"cell_type":"code","execution_count":null,"metadata":{"id":"uB-I09hKKvmu"},"outputs":[],"source":["def get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_p2exec_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_p2exec_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정 --> olds\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))   # p1's 1st & 2nd pair 위해서 last_idx 마지막에 붙여준 것\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx = short_tp_1_touch_idx[short_p2exec_p1_idx]  # p2 까지 체결된 p1's hhm (p2 executed p1_hhm)\n","    short_tp_0_p2exec_p1_touch_idx = short_tp_0_touch_idx[short_p2exec_p1_idx]\n","    long_tp_1_p2exec_p1_touch_idx = long_tp_1_touch_idx[long_p2exec_p1_idx]\n","    long_tp_0_p2exec_p1_touch_idx = long_tp_0_touch_idx[long_p2exec_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------ get wave's bias_tick ------------ #\n","    short_tp_1_net_p1_touch_idx2 = np.where(short_tp_1_net_p1_touch_idx == last_idx, np.nan, short_tp_1_net_p1_touch_idx)\n","    long_tp_1_net_p1_touch_idx2 = np.where(long_tp_1_net_p1_touch_idx == last_idx, np.nan, long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx2 = np.where(short_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, short_tp_1_p2exec_p1_touch_idx)\n","    long_tp_1_p2exec_p1_touch_idx2 = np.where(long_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, long_tp_1_p2exec_p1_touch_idx)\n","\n","    short_net_p1_bias_tick = short_tp_1_net_p1_touch_idx2 - short_net_p1_idx\n","    long_net_p1_bias_tick = long_tp_1_net_p1_touch_idx2 - long_net_p1_idx\n","\n","    short_p2exec_p1_bias_tick = short_tp_1_p2exec_p1_touch_idx2 - short_p2exec_p1_idx\n","    long_p2exec_p1_bias_tick = long_tp_1_p2exec_p1_touch_idx2 - long_p2exec_p1_idx\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_p2exec_p1_true_bias_bool = short_tp_1_p2exec_p1_touch_idx < short_tp_0_p2exec_p1_touch_idx  # true_bias 의 조건\n","    short_p2exec_p1_false_bias_bool = short_tp_1_p2exec_p1_touch_idx >= short_tp_0_p2exec_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_p2exec_p1_true_bias_bool = long_tp_1_p2exec_p1_touch_idx < long_tp_0_p2exec_p1_touch_idx\n","    long_p2exec_p1_false_bias_bool = long_tp_1_p2exec_p1_touch_idx >= long_tp_0_p2exec_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p2exec_tpbox_hhm = hhm(short_p2exec_p1_true_bias_bool, short_p2exec_p1_false_bias_bool)\n","    long_p2exec_tpbox_hhm = hhm(long_p2exec_p1_true_bias_bool, long_p2exec_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_p2exec_tpbox_hhm, long_p2exec_tpbox_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","           short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"code","source":["def idep_plot_v17(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"short_net_p1_frq :\", short_net_p1_frq)\n","    # print(\"long_net_p1_frq :\", long_net_p1_frq)\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ get hhm ------ #    \n","    # start_0 = time.time()\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ mean_low ------ #    \n","    # start_0 = time.time()\n","    selection_id = config.selection_id\n","\n","    short_p1_idx = short_obj[-1].astype(int)\n","    long_p1_idx = long_obj[-1].astype(int)    \n","\n","    short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx] # != short_tp_1\n","    long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","    long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","    long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","    long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","    short_mean_low = short_max_outg[short_p2_true_bias_bool].mean()\n","    long_mean_low = long_max_outg[long_p2_true_bias_bool].mean()\n","    both_mean_low = (short_mean_low + long_mean_low) / 2\n","    # print(\"short_mean_low :\", short_mean_low)\n","    # print(\"long_mean_low :\", long_mean_low)\n","    # print(\"both_mean_low :\", both_mean_low)\n","    # print(\"mean_low elapsed time :\", time.time() - start_0)\n","\n","    # ------ plot_data ------ #\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_mean_low, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_mean_low, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_mean_low, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"],"metadata":{"id":"Eos0FoAgrfW5"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":260,"status":"ok","timestamp":1653436951068,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oLDZobRcgg6E","outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"outputs":[{"data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":["res_df.low.rolling(100) #> 1000"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","source":["def get_pr_v4(open_side, h, l, obj, tpout, lvrg, fee, p_ranges, p_qty_ratio, inversion=False):  # --> 여기서 사용하는 ex_p = ex_p\n","\n","    en_p = obj[0]\n","    # ex_p = obj[1]\n","    tp, out = np.split(tpout, 2, axis=1)\n","    len_p = len(p_ranges)\n","    en_ps, tps, outs, lvrgs, fees = [np.tile(arr_, (1, len_p)) for arr_ in [en_p, tp, out, lvrg, fee]]\n","\n","    np_obj = np.array(obj).T[0]\n","    assert len(np_obj.shape) == 2\n","\n","    # iin == iout 인 경우 분리\n","    en_idx = np_obj[:, 2]\n","    ex_idx = np_obj[:, 3]\n","    equal_idx = en_idx == ex_idx    # equal_idx 는 어차피 out 임\n","    issue_idx = en_idx > ex_idx    # equal_idx 는 어차피 out 임\n","\n","    print('pass')\n","    idx_gap_ = (ex_idx - en_idx)[~equal_idx]\n","    print(\"en_idx[issue_idx] :\", en_idx[issue_idx])\n","    print(\"ex_idx[issue_idx] :\", ex_idx[issue_idx])\n","    print(\"idx_gap_[idx_gap_ <= 0] :\", idx_gap_[idx_gap_ <= 0])\n","\n","    min_low = np.full_like(en_p, np.nan)\n","    min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","    max_high = np.full_like(en_p, np.nan)\n","    max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","\n","    if open_side == \"SELL\":\n","        p_tps = en_ps - (en_ps - tps) * p_ranges\n","        # min_low = np.full_like(en_p, np.nan)\n","        # min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","        tp_idx = (np.tile(min_low, (1, len_p)) <= p_tps) * (np.tile(max_high, (1, len_p)) <= outs)  # entry_idx 포함해서 out touch 금지 (보수적 검증)\n","    else:\n","        p_tps = en_ps + (tps - en_ps) * p_ranges\n","        # max_high = np.full_like(en_p, np.nan)\n","        # max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","        tp_idx = (np.tile(max_high, (1, len_p)) >= p_tps) * (np.tile(min_low, (1, len_p)) >= outs)\n","\n","    ex_ps = outs.copy()\n","    ex_ps[tp_idx] = p_tps[tp_idx]\n","\n","    if open_side == \"SELL\":\n","        if not inversion:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","    else:\n","        if not inversion:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","\n","    return pr.reshape(-1, 1), liqd"],"metadata":{"id":"wDQWK3v5xOFa"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def idep_plot_v16(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"],"metadata":{"id":"6G92q_bExTVn"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oE5zkT75Beiy"},"outputs":[],"source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","pos_side = \"SELL\" # SELL BUY\n","\n","if pos_side == \"SELL\":\n","  open_ = res_df['short_open1_{}'.format(config.selection_id)].to_numpy()\n","  open_ts = list(map(lambda x : str(x), res_df.index[open_ == 1]))  \n","else:\n","  open_ = res_df['long_open1_{}'.format(config.selection_id)].to_numpy()\n","  open_ts = list(map(lambda x : str(x), res_df.index[open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["pos_index = open_info_df1.side == pos_side\n","for ts in res_df.index[open_info_df1.index[pos_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6YcqQQzsl6Ys"},"outputs":[],"source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"t7a5Hyyyd5Lk"},"outputs":[],"source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dsI-R8Zz7ls1"},"outputs":[],"source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":350,"status":"ok","timestamp":1652751452213,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"gMur2u8WeQ2K","outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"outputs":[{"data":{"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":872,"status":"ok","timestamp":1652756329304,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eoXMxRm3qdz2","outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"outputs":[{"data":{"image/png":"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\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dm7ZqzS9vqhm"},"outputs":[],"source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qOE2YSzntx8v"},"outputs":[],"source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v3"]},{"cell_type":"code","execution_count":29,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1666421706325,"user_tz":-540,"elapsed":737,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 0     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick\n","x_max = 200       # back_plot : 0 사용시, custom x_max 반영됨\n","\n","bias_plot = 0     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = 1   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 100 #  150 100 20 500 1000\n","post_plotsize = 200 #\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_net_p1_bias_tick, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_net_p1_bias_tick, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","  if pr_descend == -1:\n","    pr_descend = 0\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, bias_tick, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, bias_tick, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","try:   # wave_range 단독 실행의 경우 tr_arr 이 존재하지 않기 때문에 try 처리함\n","  res_df['short_tr_{}'.format(selection_id)].iloc[short_obj[-1].astype(int).ravel()] = short_tr_arr\n","  res_df['long_tr_{}'.format(selection_id)].iloc[long_obj[-1].astype(int).ravel()] = long_tr_arr\n","except:\n","  pass\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","# plot_idx = np.full(len(np_plot_params), True)\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  \n","  # trendy_idx = bias_tick[invalid_left_end:] < config.tr_set.bias_tick  # temp location\n","\n","  np_plot_params = np_plot_params[bias_idx] #  * trendy_idx]  "]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":27,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":559,"status":"ok","timestamp":1666421567849,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"2bjxKCIh1ojZ","outputId":"67c90cdf-c415-4613-d254-046f4e8262ed"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:11: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","# hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(wave_itv1), 'close_{}'.format(wave_itv1)], 1, '#ffffff', 2])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffeb3b', 1])  #ffffff\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_period1 = config.tr_set.wave_period1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = 'T'\n","dc_period1 = 20 # wave_period2  # 20\n","dc_tf2 = '5T'\n","dc_period2 = 20 # config.loc_set.point2.csd_period if config.loc_set.point2.csd_period != \"None\" else wave_period2 \n","dc_tf3 = '15T'\n","dc_period3 = 20\n","dc_tf4 = 'H'\n","dc_period4 = 20\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ff00ff', 1]),  # inner #ffeb3b\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 2]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1]) # ffee58 5b9cf6 \n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 3]) # ffee58 5b9cf6\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf3, dc_period3)], 1, '#5b9cf6', 5]) # ffee58 5b9cf6\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf4, dc_period4)], 1, '#5b9cf6', 7]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = '15T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ma / ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","ma_period = 60\n","# step_col_list.append([['ma_T{}'.format(ma_period)], 1, '#03ed30', 2])\n","# step_col_list.append([['long_ma_T{}_-1'.format(ma_period)], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","# step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","# ------ stoch ------ #\n","# step_col_list2.append([['stoch_{}{}33'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","\n","# ------ macd ------ #\n","# step_col_list2.append([['macd_T535'], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","\n","# ------ sar ------ #\n","sar_tf1 = '5T'\n","# stepmark_col_list.append([['sar_{}'.format(sar_tf1)], 1, '#ffeb3b', 7])\n","\n","# ------ wave_range ------ #\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","# data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","data_window_p1_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_p1_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","data_window_p1_col_list.append([['hh_{}'.format(wave_itv1)], 'hh_{}'.format(wave_itv1)])\n","data_window_p1_col_list.append([['ll_{}'.format(wave_itv1)], 'll_{}'.format(wave_itv1)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"post_cu_idx\": get_col_idxs(res_df, ['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"post_co_idx\": get_col_idxs(res_df, ['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"post_cu_idx\": get_col_idxs(res_df, ['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"post_co_idx\": get_col_idxs(res_df, ['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close'])  \n","}   \n","#   , 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"XfvH5ngyieS9"},"source":["#### session_plot main"]},{"cell_type":"code","execution_count":30,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1ygNbpE2tfGvgJo0gVZ8N6MxRKXl2ZfOG"},"executionInfo":{"status":"error","timestamp":1666421766481,"user_tz":-540,"elapsed":58894,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d5cfa12a-ce5e-47ac-b67d-1dc8fe195cfd"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["# p2_hlm 의 경우, tr 확인을 우해 session_plot 우선 실행 필요함\n","_ = [plot_check_v9(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","metadata":{"id":"sZAYhcdoXnm4"},"source":["### whole_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jjFziVVIhgSr"},"outputs":[],"source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"50HXDIdJij28"},"source":["#### whole_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-tbLsXN9eN2p"},"outputs":[],"source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FtILHO-4kVlO"},"outputs":[],"source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v9(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    # print(\"p1_idx :\", p1_idx)\n","    # if p1_idx != 370259:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    if back_plot == 0:\n","      iout = iin + x_max\n","      # print(\"iin, iout :\", iin, iout)\n","\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ get vp_info ------ #\n","    # kde_factor = 0.1   # 커질 수록 전체적인 bars_shape 이 곡선이됨, 커질수록 latency 좋아짐 (0.00003s 정도)\n","    # num_samples = 100  # plot 되는 volume bars (y_axis) 와 비례관계\n","    # # vp_data = data[iin - 500:iin, col_idx_dict['vp_col_idxs']].T  # Todo, vp_range should be calculated by wave_point\n","\n","    # if tp_1 < out_0:  # SELL order\n","    #   post_co_idx = res_df.iloc[int(p1_idx), col_idx_dict['post_co_idx']]\n","    #   # vp_iin = res_df.iloc[int(p1_idx) - 1, col_idx_dict['post_cu_idx']].to_numpy()  # Todo, co_idx 와 co_post_idx 의 차별을 위해서 -1 해줌 <-- 중요 point\n","    #   vp_iin = res_df.iloc[post_co_idx, col_idx_dict['post_cu_idx']].to_numpy()  # Todo, co_idx 와 co_post_idx 의 차별을 위해서 -1 해줌 <-- 중요 point\n","    # else:\n","    #   post_cu_idx = res_df.iloc[int(p1_idx), col_idx_dict['post_cu_idx']]\n","    #   # vp_iin = res_df.iloc[int(p1_idx) - 1, col_idx_dict['post_co_idx']].to_numpy()\n","    #   vp_iin = res_df.iloc[int(post_cu_idx), col_idx_dict['post_co_idx']].to_numpy()\n","    # # print(\"iin, vp_iin, p1_idx :\", iin, vp_iin, p1_idx)\n","\n","    # vp_data = res_df.iloc[int(vp_iin):int(p1_idx), col_idx_dict['vp_col_idxs']].to_numpy().T  # Todo, vp_range should be calculated by wave_point\n","    # # print(\"vp_data :\", vp_data)\n","    # vp_info = [*vp_data, kde_factor, num_samples]\n","    vp_info = []\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v9_1(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v9_1(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  if config.tr_set.check_hlm in [0, 1]:\n","    ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg1 {}'.format(en_p, config.tr_set.ep_gap1), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  else:\n","    ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg2 {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  \n","  # ------ volume profile ------ #\n","  if len(vp_info) > 0:\n","    close, volume, kde_factor, num_samples = vp_info\n","    # if iin >= vp_range:\n","    # start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    kdy_max = kdy.max()\n","    # print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    # peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)   # get peak_entries\n","    # peak_list = kdx[peaks]   # peak_list\n","    # [ax1.axhline(peak, linewidth=1, linestyle='-', alpha=1, color='orange') for peak in peak_list]\n","    \n","    kdy_ratio = p1_tick / kdy_max # 30 / 0.0001   # max_value 가 p1_tick 까지 닿을 수 있게.\n","    # print(\"kdx :\", kdx)\n","    # ax1.plot(kdy * kdy_ratio, kdx, color='white')  # Todo, bars 가능 ?\n","    # ax1.barh(kdy * kdy_ratio, kdx, color='white')  # Todo, bars 가능 ?\n","    ax1.barh(kdx, kdy * kdy_ratio, color='#00ff00', alpha=0.5)  # Todo, bars 가능 ?\n","\n","  # ------------ ax2 ------------ #\n","  # ------ cci_band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ------ stoch_band ------ #\n","  # ax2.axhline(67, color=\"#ffffff\")\n","  # ax2.axhline(33, color=\"#ffffff\")\n","  \n","  # ax2.axhline(0, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"ddL_BC24buq0"},"source":["### dump"]},{"cell_type":"markdown","metadata":{"id":"zgTrEWWqbwsT"},"source":["#### whole_plot thing"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M4zn8wxibzAR"},"outputs":[],"source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"4IhBjPMobzAS"},"outputs":[],"source":["cf.go_offline()\n","init_notebook_mode()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"n9WZkE9wbzAS"},"outputs":[],"source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","E0n53hflJbnp","MlFkpO1MSuzl","MSUY4nnku3s9","x2yj2SwAXDLp","O87s8_EUakqS","LyGnAMvLYvOZ","Q_1wJTcRYpm8","EOXQbXixiQcK","c2729DJ6h720","RZJ6uIA_VcJs","xpyP5t8Ht_pE","MuD_2vY7TI_8","983aUwM76s6X","_blyFhQJUd5X","50HXDIdJij28"],"provenance":[],"toc_visible":true,"authorship_tag":"ABX9TyNt3NFiqzJ0NccbjKpOTs/U"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}