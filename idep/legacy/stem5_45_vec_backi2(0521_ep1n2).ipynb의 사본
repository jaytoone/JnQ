{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1653644575639,"user_tz":-540,"elapsed":26438,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"9e85dc1e-9bd3-4b70-abab-a30728a66caa"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1653644610707,"user_tz":-540,"elapsed":35073,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","source":["\n","def bb_level_v2(res_df, itv, period):\n","\n","    bb_base = res_df['bb_base_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_upper2 = 'bb_upper2_{}{}'.format(itv, period)\n","    bb_lower2 = 'bb_lower2_{}{}'.format(itv, period)\n","    bb_upper3 = 'bb_upper3_{}{}'.format(itv, period)\n","    bb_lower3 = 'bb_lower3_{}{}'.format(itv, period)\n","\n","    level_gap = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy() - bb_base\n","\n","    res_df[bb_upper2] = bb_base + level_gap * 2\n","    res_df[bb_lower2] = bb_base - level_gap * 2\n","\n","    res_df[bb_upper3] = bb_base + level_gap * 3\n","    res_df[bb_lower3] = bb_base - level_gap * 3\n","\n","    return res_df"],"metadata":{"id":"kuf6ZhccgRj9"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    # df = bb_line_v3(df, df_15T, 60)\n","\n","    # df = bb_level_v2(df, 'T', 60)\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"status":"ok","timestamp":1652066331412,"user_tz":-540,"elapsed":2108,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"90cf9151-9050-4f0c-fa54-9f9a9a9e38bb"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                         bb_upper_T60  bb_lower_T60  bb_base_T60  bb_upper2_T60  bb_lower2_T60  bb_upper3_T60  bb_lower3_T60  upper_wick_ratio_5T  lower_wick_ratio_5T  candle_updown_5T\n","index                                                                                                                                                                                   \n","2022-04-27 08:41:59.999   2823.126867   2790.340133  2806.733500    2839.520235    2773.946765    2855.913602    2757.553398             0.354545             0.640260                 0\n","2022-04-27 08:42:59.999   2822.498326   2790.088008  2806.293167    2838.703485    2773.882848    2854.908644    2757.677689             0.354545             0.640260                 0\n","2022-04-27 08:43:59.999   2821.914551   2789.914116  2805.914333    2837.914768    2773.913898    2853.914986    2757.913681             0.354545             0.640260                 0\n","2022-04-27 08:44:59.999   2821.473171   2789.742162  2805.607667    2837.338676    2773.876657    2853.204181    2758.011153             0.354545             0.640260                 0\n","2022-04-27 08:45:59.999   2820.842501   2789.526499  2805.184500    2836.500502    2773.868498    2852.158503    2758.210497             0.089172             0.248408                 0"],"text/html":["\n","  <div id=\"df-882399d2-6441-4f90-a90e-e91ecbb1b52a\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>bb_upper_T60</th>\n","      <th>bb_lower_T60</th>\n","      <th>bb_base_T60</th>\n","      <th>bb_upper2_T60</th>\n","      <th>bb_lower2_T60</th>\n","      <th>bb_upper3_T60</th>\n","      <th>bb_lower3_T60</th>\n","      <th>upper_wick_ratio_5T</th>\n","      <th>lower_wick_ratio_5T</th>\n","      <th>candle_updown_5T</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2823.126867</td>\n","      <td>2790.340133</td>\n","      <td>2806.733500</td>\n","      <td>2839.520235</td>\n","      <td>2773.946765</td>\n","      <td>2855.913602</td>\n","      <td>2757.553398</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2822.498326</td>\n","      <td>2790.088008</td>\n","      <td>2806.293167</td>\n","      <td>2838.703485</td>\n","      <td>2773.882848</td>\n","      <td>2854.908644</td>\n","      <td>2757.677689</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2821.914551</td>\n","      <td>2789.914116</td>\n","      <td>2805.914333</td>\n","      <td>2837.914768</td>\n","      <td>2773.913898</td>\n","      <td>2853.914986</td>\n","      <td>2757.913681</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2821.473171</td>\n","      <td>2789.742162</td>\n","      <td>2805.607667</td>\n","      <td>2837.338676</td>\n","      <td>2773.876657</td>\n","      <td>2853.204181</td>\n","      <td>2758.011153</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2820.842501</td>\n","      <td>2789.526499</td>\n","      <td>2805.184500</td>\n","      <td>2836.500502</td>\n","      <td>2773.868498</td>\n","      <td>2852.158503</td>\n","      <td>2758.210497</td>\n","      <td>0.089172</td>\n","      <td>0.248408</td>\n","      <td>0</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-882399d2-6441-4f90-a90e-e91ecbb1b52a')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-882399d2-6441-4f90-a90e-e91ecbb1b52a button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-882399d2-6441-4f90-a90e-e91ecbb1b52a');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":94}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1071,"status":"ok","timestamp":1652066337627,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"c3a01224-f5a8-442f-8300-805b0988100d"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1653644615803,"user_tz":-540,"elapsed":5102,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d0643c40-ac9d-4c36-9aae-888d8c319358"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 3.3214223384857178\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["\n","\n","def wave_range_ratio_v4_2(res_df, wave_itv, wave_period, roll_hl_cnt=3):\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    roll_highs = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    cu_wave1_range = roll_highs[-1] - roll_lows[-2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_highs[-1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_highs[-2] - roll_lows[-1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_lows[-1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_roll_wave_data_v2(res_df, valid_prime_idx, roll_idx_arr, data_col, roll_hl_cnt):\n","\n","    data = res_df[data_col].to_numpy()\n","    len_res_df = len(res_df)\n","    roll_cols = [data_col + '_-{}'.format(cnt_ + 1) for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    roll_data = pd.DataFrame(index=res_df.index, data=np.full((len_res_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    res_df[roll_cols] = roll_data.ffill()\n","\n","    return res_df\n","\n","def roll_wave_hl_idx_v4(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array(\n","        [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    \n","    assert len(roll_high_idx_arr) > 0 and len(roll_low_idx_arr) > 0\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","    \n","def to_lower_tf_v3(ltf_df, htf_df, cols, backing_i=1, show_info=False):\n","    ltf_itv = pd.infer_freq(ltf_df.index)\n","    assert ltf_itv == 'T', \"currently only -> 'T' allowed..\"\n","    # assert type(column[0]) in [int, np.int64], \"column value should be integer\"\n","\n","    # cols = htf_df.columns[column]  # to_lower_tf_v1 의 int col 반영\n","\n","    if show_info:\n","        print(\"backing_i :\", backing_i)\n","\n","    renamed_last_index = htf_df.rename(index={htf_df.index[-1]: ltf_df.index[-1]}, inplace=False).iloc[[-1]]\n","    if htf_df.index[-1] != renamed_last_index.index[-1]:  # cannot reindex a non-unique index with a method or limit 방지\n","        htf_df = htf_df.append(renamed_last_index)\n","\n","    downsampled_df = htf_df[cols].shift(backing_i).resample(ltf_itv).ffill()\n","\n","    if len(downsampled_df) > len(ltf_df):\n","        downsampled_df = downsampled_df.iloc[-len(ltf_df):]\n","\n","    downsampled_df.index = ltf_df.index[-len(downsampled_df):]\n","    # assert len(ltf_df) <= len(downsampled_df), \"for join method, assert len(ltf_df) <= len(downsampled_df)\"\n","\n","    # ------ check last row's validity ------ #\n","    assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0, \"assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0\"\n","\n","    return downsampled_df"],"metadata":{"id":"gWOmz--hNaSR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","def wave_range_cci_v2(t_df, wave_period):\n","\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    band_width = 100\n","    upper_band = band_width\n","    lower_band = -band_width\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","        cu_idx, co_idx, len_df, len_df_range)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    # ------ term cnt ------ #\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    # b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    # b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    # wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    # wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","    #\n","    # high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    # low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","    # ------ for plot_checking ------ #\n","    t_df['wave_update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool  # temporary, for plot_check\n","    t_df['wave_update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool #* ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool #* ~update_high_co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","    \n","    # Todo, idx 저장은 sync. 가 맞는 tf_df 에 대하여 적용하여야함\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","\n","    return t_df"],"metadata":{"id":"euA18M1uyc3s"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 370940\n","# i = 185369\n","i = 186060\n","\n","plot_size = 1500 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","source":["wave_itv1, wave_period1 = '15T', config.tr_set.wave_period1\n","\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)\n","    htf_df = wave_range_cci_v2(htf_df, wave_period1)\n","    \n","    cols = list(htf_df.columns[-15:-4])  # except idx col\n","\n","    roll_hl_cnt = 3\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  t_df = wave_range_cci_v2(t_df, wave_period1)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"],"metadata":{"id":"PgaNnempXRd_"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-Dr_tTk9csFm","colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"status":"ok","timestamp":1653286351313,"user_tz":-540,"elapsed":7228,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"b2a18374-e580-4874-f9fe-70a98375e8ad"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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3XvvvTp+/Hiz5caYKFSF1lx77bU6fPhwXF7PJRYkJibqkksu0dKlS3XJJZfoxIkTys3NbbYex5/9JCcna+rUqRo6dKgGDBig7t2765prrol2WQgRx5ozPfjgg6qtrdWf//znaJeCNkhKStKDDz6ohx56KNql2IqtQ115ebkGDhzov52Zmany8vIoVoRAEhMTtWrVKv35z3/WK6+8Ikk6dOiQ0tPTJUnp6ek6fPiwJPap3Vx++eW67rrrtGfPHq1YsUL/9m//piVLlig5OVlut1tS433UcP+53W717t1b//znP6NWf7wrKytTWVmZtm3bJkl66aWXdMkll3D8OcD48eO1Z88eHTlyRLW1tXr55Zd1+eWXc+w5THuPNY5B+5k1a5amTJmi2267zT+P/Wdv5557roYOHaqdO3dqz549yszM1EcffaS0tLS433dR7wMabHK73eazzz4zQ4YM8Z+QeuGFF0a9LqbG07Jly8xvf/vbRvMeffTRRiePL1682EgykydPbnQC69atW6NeP5NvuvLKK/3n1K1cubLRYA3f+973jCRz1113NRqs4cUXX4x63fE+vfvuuyYrK8tIMgsufOAUAAAgAElEQVQWLDCPPvoox58DppycHFNYWGiSkpKM5BvwZv78+Rx7Np+antfT3mMtJSXF7N692yQnJ5vk5GSze/duk5KSEvXHFS9T0/139dVXm3/84x8mNTW10XoXXnhho4FSPvvsM+NyuXhfaqN913BqeE5dnB97US+gxWnSpEnm008/NaWlpebBBx+Mej1MjafLL7/cGGPMzp07zfbt28327dvNpEmTTJ8+fczGjRtNcXGx2bBhQ6MD53e/+50pLS01H3/8sbn00kuj/hiYfFPDUDd06FCzdetWU1JSYlauXGk6d+5sJJkuXbqYlStXmpKSErN161YzdOjQqNcd79PFF19s8vPzzc6dO80rr7xikpOTOf4cMv385z83n3zyiSkoKDDPP/+86dy5M8eejafly5ebgwcPmjNnzpgDBw6Y73znOx061r797W+bkpISU1JSYr71rW9F/XHFyxRo/5WUlJj9+/f737/Uf3AiyTz44IOmtLTUFBUVmWuuucY/n/el9th3DZc3DHVS/B57CXU/AAAAAAAcyNbn1AEAAAAAWkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4GKEOAAAAAByMUAcAAAAADkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4GKEOAAAAAByMUAcAAAAADkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4GKEOAAAAAByMUAcAAAAADkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4GKEOAAAAAByMUAcAAAAADkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4GKEOAAAAAByMUAcAAAAADkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4GKEOAAAAAByMUAcAAAAADkaoAwAAAAAHI9QBAAAAgIMR6gAAAADAwQh1AAAAAOBghDoAAAAAcDBCHQAAAAA4WFhC3dNPP61Dhw6poKDAP2/BggUqKyvT9u3btX37dk2aNMm/LDc3VyUlJSoqKtLEiRPDUQIAAAAAxKUESSbUjVxxxRWqrq7W888/rxEjRkjyhbrq6mo99thjjdbNzs7WX/7yF+Xk5GjAgAHauHGjsrKy5PV6Qy0DAAAAAOJOYjg28ve//12DBw9u07pTp07VihUrdObMGe3du1elpaXKycnRli1bWvy9w4cPa9++feEoN3pGSnK3sNwj6ZSkT60pJ5pGaqTcLTwZHnl0Sqf0aShPRmvPtyRVK7LP9/mSerSyjkfSjhDvI0mt/22Fch9WacsxYofH4ZQ6naAtx0iox6kVx6FNtPbaKknVqg7ttdUC5+t89Whlp1nyOOxwrFtxjISDXY5lOzwXVoiR58Iux7qT3pcOHjxY/fv3D7jMhGMaPHiwKSgo8N9esGCB2bNnj9m5c6d5+umnTXJyspFknnjiCXPbbbf513vqqafM9OnTW91+fn5+WOqM6lQpI6+Mauomb4Oppm75ZhvUacFUqUrjldfUqMbUqMZ45fVPNaoxlao0m7U59Oc72HNdP0X6+d7c5P4C1VEZhvuobGH73jDch1VT/TES7Dixy+NoWGegWu1SpxOm+mOkpdfGUI9TK45Dm0yVqmz2utrwdo1qQn9ttWDarM1BH4Olj8MOr0mbm9xv0zqs+F/WkTqb1hrOY9nuz0WsPN8WTA2P9WDvCa041p30vjRYJorYQClLly7Vueeeq5EjR+rzzz9v1g2zLebMmaP8/Hzl5+crNTU1AlUCAAAAgLNFLNQdPnxYXq9Xxhjl5eUpJydHklReXq6BAwf618vMzFR5eXnAbeTl5Wn06NEaPXq0jhw5EqlSAQAAAMCxIhbq0tPT/T9ff/31KiwslCStWbNGM2bMUOfOnTVkyBANGzZM27Zti1QZAAAAABDTwjJQyvLlyzVu3DilpqbqwIEDWrBggcaNG6eRI0fKGKO9e/fqzjvvlCTt2rVLK1eu1K5du1RbW6t58+Yx8iUAAAAAdFBYQt2tt97abN4zzzwTdP2FCxdq4cKF4bhrAAAAAIhrYQl1AAAAANBQ375SYgtpo9M/JdVaVk5MI9QBAAAACKsHHpBa7Zg3TvK8K9+g/AgJoQ4AAABAu6SnS9nZwZdPnnz254qK5su7dpWSJSUkiFAXBoQ6AAAAAG2WmCgVFEhtuYz0dddJr73WfP7UqdLq8JcWtwh1AAAAANosKelsoPvb34KvV1Ehvf22JSXFPUId2mXCBOmFF6Ru3YKvY4z0m99IP/+5ZWUBAGzigQek4cNbXmfPHumhh3z/LwA417Fj0r//e7SrgESoQztNmCD179/6etOnE+oAoD0uvLD1rkyFhdKXX1pTT0cMGdKGgRHqvPyytH17RMsBgLhBqEOH/OIX0q9+1Xz+hRdK27ZZXw8AONm4cdLmza2vt2+fLzjZVefOZ3++7bbA6/ziF9J55zVeFwAQGkIdOqS6Wjpxovn8kyetrwUAnG7QoLM/v/NO8+UJCdK//qs0eLB1NYXi00+l5csDL/v+932hDgAQPoQ6AABsYtky6VvfCrws1s4/e+QRacuWwMsGPSVpv6XlAICjEeoQEV//uu+8umDcr0jyWlYOAMAmjh/3fZ8wwTcFtEnyHhDXrgIQEpfLN3jfuee2vF7X/5B02pKSIoZQh7CqqTn780svBV/PJEuqing5AACbmT9fuvFG35utQEaPlq6TJC5IDCBEI0ZI99zThhW7SIZQB5xVXCz98pfSBRcEX2f8eClZ/K8GgHhUXNzyCJl33FEX6gAgRIkNks6UKYHX+cMfpEGBFzkKoQ5h97Oftbz8ww+lS6wpBQDgMLW10a4AQKz54APpjTcCL6vvEu50QTo/AAAAWM/jiXYFAOA8tNQBAOAgZWXBl/W8QDLV1tUSCYQ6AGg/Qh0AAA7w0UfSJZdIGRktrOSWPAnOvvwBoQ4A2o9QBwCAA+TkSGlpwZcvWSLdaF05EUOoA4D2I9QBAOAAHo908GDw5SdPWldLJDFQCgC0X1gGSnn66ad16NAhFRQU+OelpKRo/fr1Ki4u1vr165WcnOxftmTJEpWUlGjnzp0aNWpUOEoAAAAxgJY6AGi/sIS65557Ttdcc02jebm5udq0aZOysrK0adMm5ebmSpImTZqkYcOGadiwYZo7d66WLl0ajhIAAEAMINQBQPslKEzXgB48eLBef/11jRgxQpJUVFSkcePGqaKiQunp6Xr77bd1wQUX6Mknn9Tbb7+tFStWNFuvJceOHdOHH34YjlKjZso3p+iE+4RcdVnaK69/mUsuJXmSdF71eXp8x+PRKrFV55wjDRokffaZdOBAx7Zx6aVSz4HflKlyn/1YwdtgBZfkSfKo+rxq7Xh8R4drnfLNKTrlPlW3+cbPdb0RVSMi+nzfO/JeFfQ+24IdqI4kT5Jef+/1kO6jtEepTrlPBdy+V15193QP6T6sUn+MSAp4nNjlcTSsU2peq13qdIL6Y8Qrb9DXxlCPUyuOw1ClpUnZ2VJFhVRU1LFtXHCBlH7BN2Wq3b7/7PUPs+HrrEuqGlEV0mtrS5KSpDFjfF1Bt23r2Db69JEuunukzHu9pfqA1/R/RYQfRz07vCY1PEYC1RGOYyQcmtYpNa41nMey3Z8LK1jxfLfE7ZauuMLXXfq99zq2jdRU6evzGxzrQd4ThnKs9+zpe995/LjvOsmBjB4tdc9wzvvSHj16aPTo0c3mR+ycurS0NH9Qq6ioUFrd2d0ZGRk60CANlJWVKSMjI2ComzNnjubOnStJ6tSpU6RKdYzUVKl375bXOXNGKi+XvN6W1wMAwI6cPHInAESTCcc0ePBgU1BQ4L9dWVnZaPmXX35pJJnXXnvNXH755f75GzduNJdeemmr28/Pzw9LnVGdKmXklVFN3eRtMNXULd8c+HfdbplTp2SMaX267rrIPYZHH/Xdx49+1PFtfPihjOldabzymtqEGlObUGO88vqn2oQac6Jzpfl74ubQn+9gz3X9FOT5Dtu0ucn9BaqjMgz3UdnC9r1huA+rpvpjJNhxYpfH0bDOQLXapU4nTPXHSEuvjaEep1YchyFOM2f6Xlufe67j21i2zPfaWptQY2p09nW1Rmdv16jGbFaIr60tTFlZvsdRVNTxbYwbJ2Ou3Gy8rsCPwYrH4Z/s8Jq0ucn9Nq3Div9lHamzaa3hPJbt/lzEyvPdwtSzp+9Yr6rq+DamTvUd6x5XTcDjPBzH+qWX+urMzw++TmHh2felwWqoVGXorzlhel8aLBNFrKXu0KFDSk9P93e/PHz4sCSpvLxcAwcO9K+XmZmp8vLySJURM1wuqWtX38/33Rd4ndtvl0aNkrp1s66ujjhR12stQZK7vsW5wTkUbpfULUnKTJG019raAADR5WnYDQsA0CYRC3Vr1qzRrFmztHjxYs2aNUuvvvqqf/78+fO1YsUKjRkzRlVVVa2eT4ezzpyRfvObwMsuu8wX6uzunnuk//1K6iLJ1HUTTWiw3Bjf//NEdxSKAwBEFaEOANovLKFu+fLlGjdunFJTU3XgwAEtWLBAixYt0sqVKzV79mzt27dPN910kyRp7dq1mjx5skpLS3Xy5El9+9vfDkcJcJDt26XT8oU6r/HNa5jfOJ8CAOKXxyOJ0+gBoF3CEupuvfXWgPPHjx8fcP78+fPDcbcAANhCYmLrA1lVV0tffWVNPU7GxccBoP0i1v0SAIB40Lmz9Mknvku+tOToUenCC6XPP7emLqfiOnUA0H6EOgAAQtC//9lAd+RI4HV695aSk33XkiPUtYxQBwDtR6hDI5dcIk2cGHz52LHW1QIAdpCaKv3gB76L2AZSP//AAWnQoMDrbNok/du/Raa+WOMPdQktrgYAuvZa6dlnpaSkwMvdcTToHqEOjbz4onTeea2vV10d+VoAwA5mzpQefLD19SorW19n3DjJ620+Pzu73WXFLFrqALTV1VdL/fq1vt4770S+lmgj1KGRXr18359+Wqq7tGAzVVXS8uXW1QQA0VT/CXBVlfSf/xl8vQ0bgi+rDyoPPeSbWlsvFE2v/+m/PIzH9/OQgbL1NUAZKKX9BgyQpn4v+PLycmnNGuvqAaz2wAPSE08EXmaMdPKktfVEA6EOAT3wgPTFF9GuAgDs44knpN/9rmO/+/jjksvVclegr76S8vI6tn3J96b9dtNyr8UEtT5KZ7TRUtc+brc0LEv6wx9aXm/MGGnbNmtqAqxWXS2dOBHtKqKLUAcAMaZLF19Xk2HDWl6vpES68kqG2bfC2rW+KZJWrZKOSepRd9vfQOdpfNvup6oR6tqpbocGC3VTpvjO9ezTx7qSAFiPUAcAMeb8832fyrdmzBjfaIw7d0a+JthHgs1THaGu/WrOSPPmBV42dGjwAXwAxA5X66sAAJzowAHfp/OBpsLCaFeHqCHUAUDMoaUOAGLUl18GH5GRwSjil80zHX+bANABhLo45Gqhfdbu3XIA+C478rOfSd26BV6enGxtPXAWu7/O01IHxBdXgmTqvkvy3WiwrG+KpC+jUJjDEOriyNe+Jn34oe87AOe64w7ftdNaU1ER+VrgQIQ6ADZw/PjZnxMkJTS5HIvq5g3/utTtg/i4LEEoCHVx5KKLzga6lv5pbt0qHTliTU0A2q9TJ9/3//1f6Te/CbyOMfFxsVW0n80zHaEOiBPvvCN92k86z+sb5MPr9c1v2qHMlSClpBDqWkOoi0Pr1kmTJkW7CgCheukl3zD2QHvYvfsl59TBai6XlJjou+af233252Df9+zhUjDh4PFIn1dI59bdNib4ur16SeXllpTlWIQ6AIhjc+dKO3YEXnbypLR6NRd0jTk2D3W01CFS7rlHWrBA6ty5cVBrr8JCacSI8NeHAOqCXs+e0S3DCQh1ABCHTp/2fb/rrpbX+8//lP7rvyJfD6xj80znD3UJajReAhCy66/3deNryuPxTbW1LX/3eKRhw6TsbOtrj1dGvtcCQl3rCHUx6C9/ke67r/n83r2trwWAPf34x9LttwfvinfRRdLYsVLfvtbWhcize/dL6ewbOSASJk+W/va3s2GtrVwuWpKjpVevaFdgf4S6GPLZZ2d/vuyytq0HID69955vCubee32hDjHIAWnJGEeUCYc6cYJz4pyGlrrWEepiyEMPSStX+vqKB1NbKxUUWFcTAMBenBCWWhowAUAcqXstoKWudREPdXv27NHx48fl8XhUW1ur0aNHKyUlRS+++KKGDBmivXv36qabbtLRo0cjXUrMM4bABgBomRO6X3IyHYCGaKlrXdNLQUTEVVddpVGjRmn06NGSpNzcXG3atElZWVnatGmTcnNzrSgDAAA4INTRUgdAOvv5Di11rbMk1DU1depULVu2TJK0bNkyTZs2LRplAAAQdxyQ6WioA9DIPfdIhw83n+bMiXZl9hHx7pfGGK1fv17GGP3xj39UXl6e0tLSVFFRIUmqqKhQWlpawN+dM2eO5s6dK0lKTU2NdKkAAMQ8J3S/pKUOgOR7LfB6paQk3xTIV18Fv95qPIl4qPvmN7+pgwcPql+/ftqwYYOKioqarWOCvHrn5eUpLy9PkpSfnx/ROgEAiAuEOgAO8t7/SNP7BV9+8qRvincRD3UHDx6UJH3xxRd65ZVXlJOTo0OHDik9PV0VFRVKT0/X4cOHI12GI3TqJPXLkK6f13xZIuOUAgDCwAGZjv6XAPy8XunIkWhXYX8RjQrdunWTy+VSdXW1unXrpokTJ+rhhx/WmjVrNGvWLC1evFizZs3Sq6++GskynCFB6tZdGjZM+t3vgq926pR1JQEAYg/dLwEg9kQ01KWlpemVV17x3VFiopYvX6633npL+fn5WrlypWbPnq19+/bppptuimQZjtDwf2xLoW7DhoiXAgCIZU4IdU1uu911P3jO3r7gPEmfWlgUAERQQoI0eIj0nYc79vsRDXV79uzRyJEjm83/8ssvNX78+EjetWN9flD6/vejXQUAIFY5INOpslJKUsu19usnQh2A2JAgudy+UPezn7W86gcfBJ7PmVoAAMQRJ3S/LC6W+kvyN9DVt9DV3XbAQwCANmv4mtZaqJs6NfB8Qh0AAPGERAQAtnT4kPTLX7a8TrBQF5WLjwMAgOgg0wFA7CHUAQAQJ+oHIPEPPAIAiAmEOgAA4oyL//4AEFN4WQcAIM7QUgcAsYWBUgDAZv74R+n//t/gyzt1sq4WxCZCHQDEFkIdANjMDTdISUktr3PihLRtmzX1IPbQ/RIAYguhDgBsauBA6ciRwMtqa30T0BG01AFAbCHUAYBNnTolnT4d7SoQiwh1ABBb6IABAECcofslAMQWWuoAIMxcLumikcGX19ZK//iHZEzwdYBIoqUOAGILoQ4AwqxnL2n79pbXefxx6Qc/sKYeoClCHQDEFkIdAERIoGDXu7d0zjnSsGHW1wPUo/slAMQWQh0ARMBNN0l//Wvz+ZMnS2+8YX09QEO01MWfhx+W/uVfAi87c0Z6/nnpwAFrawIQPoQ6AADiDKHOGZKSpOSvSRUJUv0puAkJvu9tPSX3+HHf99GjfVMwgwdLc+d2tFIA0UaoA+AYnbtI9/8s+HJjpNdek3butK4mwInofukMt90mlZwvHZbkqZvnqgvkngbrebzBt3H//dKOHVJikHd8I0ZI//EfUs+eYSg4ylwuKWes9OK+wMvT0qytB7ASoQ6AYyQl+boQteT666VLL7WmHsCpaKlzht69G9yoa5rz+pvszt4uKgq+jb17pf/3/4Ivv/lmX6iLBQkuqUtXadCg4OtUV0ulpdbVBFiFUAfAcQIFuz59pPnzpV69rK8HcIy6QECocxavV/4QZ+pb5dxnb1cdjUZV9tVSqPvyS+nECetqAawStVB39dVXa8mSJXK73Xrqqae0ePHiaJUCwAZ+8hNpaU+p7vQP/5tOT5P1fvYz6Ze/bP77Q4f6Qh3dyoDWcZwgVp0+zYAviE9ReVl3uVz6/e9/r0mTJunCCy/ULbfcouzs7GiUAsAm7rqr7lyRhBYmSbt2Bf59b92n17xZBVpHSx0AxJaotNTl5OSotLRUe/bskSStWLFCU6dO1SeffBKNcoCY17Wr9MtfB19+5oz0pz/5zr2IlvoR3eq7h3nqm+gavPk8dkx6+eXAv29Mk+0gLH7wA2nSpODL//KX1s9zhP0Q6gAgtkQl1GVkZOhAg7bxsrIyjRkzptl6c+bM0dy68XVTU1Mtqw+INV26Svfd1/I6ffpI3/2uNfV0lGlhDG9a6sKr4cALF1wQfL3vf59Q50QcJwAQW2w9UEpeXp7y8vIkSfn5+VGuBlbLzJTuvzH48k2bpA8+sK4ep3vzTWnjxubzL7tMuuUWqVs362sKJ0JdeK1bJw0YEHzgmZQU6f33aRl1qmAtdeefL/37v7f8u8eOSS+95Dt3CQBgD1EJdeXl5Ro4cKD/dmZmpsrLy6NRCmxu0aLgy/btk4YMsawUx3vsMV8Qbur2232hzukIdeH3+ee+KZA+faytBeEVLNS99JL09a+3/vvdu0t//GN4awIAdFxUQl1+fr6GDRumIUOGqLy8XDNmzNCtt94ajVJgQ8ZIp05LX+yXlgcIdV27Svfe2+T6PYh7nFMHtF2wDz9SUnzfV6+WAn3W+i//Il1yCaEe8c3tllauDL78iy+k3Fzp+PHg6wDhFpVQ5/F4NH/+fL311ltyu9165plntCvYkHaIS199Je3eIz3wQPNlvXv7Qh3QEC11QNu1NlDKvHnSwYPN5//Xf/lCHRCPjPEFtn79Wr9g+9tvS3/9qyVlAZKieE7dm2++qTfffDNadw8gxhDqgNYZ+a4OwuiXQPsZI40d2/IHG/fcI33zm1KnTtbVBUg2HygFANqK7pdA2/HhB9Axu3f7pmCmTfOFOsBqhDoAMYGWOqDt7rhDuuqq5vM5VxkAnIlQByAmEOqAtrvppuDLPB7p5EnragEAu/D39jGN53XuJLk9kjzRqKptCHUAYgLdL4HWeb3Sns+kpwIMQlVv507p6FHragKAaDpxwvc9QZK7/oPhBuHN7ZK6JUkZvSXtt7i4diDUAYgJtNQBbXOgrOVrgAJAPJk3T/r7V1IXSabuvUSjz4eN73aizQeY4u0PgJhAqAMAAO31wQfS6dO+n73GNzXU9LZd8fYHQEwg1AEAgHhF90sAMcFp59Rde610552BlyUlWVsLAABwNkIdgJjglJa6+i4ekvTkk8HX83qlM2ciXw8AIP643VJ2dsv/M0+dkkpKrKsJoSHUAYgJTgl1774rPfSQNGBAy+tt2yYdP25NTQCA+LJsmXTbba2vd/fd0hNPRL4ehI5QByAmOKX7ZW2t9Mgj0a4CcD63W1q/PvjyQ4d8o9odO2ZdTYBTZGWd/XnnzubLU1OljIzG68HeCHUAYkJ9qLN7Sx0QCxYulO67r/l8t0VDfhv5hhifMKHl9VatklavtqIiwJlGj/aN/tjUvHnS735nfT3oOEIdgJjh9fpCXULC2ZAHIHzy832tzYmJUt++wdd7//3I1uHxSP/YKf0oSKh76CHpiiusC5kAEG2EOgAxo2EXTEIdEH6rV0vJyVKXLsHXMUaqrIx8LZVHpY0bAy8LNrIsAMQqQh2AmOH1+j6Zd7nODpwCILxOnPBNAAD74OwTADHDKSNgAgAAhBMtdQBiBqEOgJW6dpW2Bhg5sJ4x0n//t/TMM9bVBCA+EeoAxAynXNYAQGzo0lW66KKW15k3j1AHIPIiFuoWLFigOXPm6IsvvpAkPfjgg3rzzTclSbm5uZo9e7Y8Ho/uvvturW/pQjMA0Ea01KFDEqRu3aSn/xJ48fDh1pYDZzlzRrrssubzs7OlF1/kQyYA1ohoS91vf/tbPfbYY43mZWdna8aMGRo+fLgGDBigjRs3KisrS15GNQAQIkIdOsLlkjq5pRkzWl7v8GFr6oGznDkjFRQ0n8/lFABYyfLul1OnTtWKFSt05swZ7d27V6WlpcrJydGWLVusLgVxzuWWRo+VVuwJvs4770jf+pZlJSFElnW/5JP3mFK/Ox96SCouDrxOdbVEpxIEUlMT7QrCY8YM6eqrgy/ftEn6j/+wrh4A7RPRUDd//nzNnDlTH3zwge677z4dPXpUGRkZjQJcWVmZMjIyIlkG0FyC741/167SkCHBVxsyxHc+hJ2H707qJtV0kmqbBo04DB5WtNRde630Xi+pqsHz6657JfVE7m5hgRUrpJKSaFcBp3F6qPv4Y+n4calnTyklJfh6N97o+595+rR1tQFou5BC3YYNG5Sent5s/k9/+lMtXbpUjzzyiIwxeuSRR/TYY49p9uzZ7dr+nDlzNHfuXElSampqKKUCAR0/Lg0ZEXjZrl2+82zsrHt36ZJLpY/dUrUah4r6rj/185z+xqMtrAh1o0ZJ7yVIauHi5h6P9N57kasBgH3U1ka7gtB88onUr5+UlBR8nfJy3/9DupQC9hVSqJswYUKb1svLy9Prr78uSSovL9fAgQP9yzIzM1VeXh709/Ly8iRJ+fn5oZQadbfcIr3Ww/fG21X3otjwLELOAYqO06elffsCL3PCaZ69ep39ezJeNWqdq++KqATpqzPS++9bXZ31rOh+GehNjac+Odctq66Wqj+PXA0A7CMWPjD76ivfFEx9cCXUAfYVsSjRsAXv+uuvV2FhoSRpzZo1mjFjhjp37qwhQ4Zo2LBh2rZtW6TKsI3vfreui1Zdt7+EBN/PjSZJJ09FrUQ4mPE2D6HeBvNOn4qNNx6tsaKljjc1ABpyektdW9R/cBXN179+/aSh5zyZdCkAABt4SURBVEgJDV7fE1yNbwN2NWuW1LOX7xhqehy53eF53xKxc+oeffRRjRw5UsYY7d27V3feeackadeuXVq5cqV27dql2tpazZs3Ly5GvvS3HJjmn+pLvnnHT0pVB6yuDIgdVoS6RK7uCaCBePjAzA6hbtYsKX+QtF9nTytw1b23anjqQW0c7A84zy23SKvb8N7k+PGO30fE3p7MnDkz6LKFCxdq4cKFkbprx4qDbAtEFC11AKxGqLOG/5y/Bucz+983uc7e3rXLyqqA9vF66k4VadKwU6+srOPb5jNnADEjWufUAYhf8dD9sv4x2qGngtfIf8qKaTJglTHSKU5jgY21MMZayOiJDCBm0P0SgNVoqQNgB4Q6ADGD7pcArEaoA2AHfOYMIGbQ/RKA1eKh+yWhLn7Nnx94zIcuXayvBS0j1AGIGbTUAbAaLXXS9ddLhy+Xtrgbj0RZv76n7uevDZRCGAcCFqqsPPvz3Xe3bT1EF6EOQMzgnDpn6dJFSh8s7Xf5Th6vb2FteiJ5YqJk3I1HCAPsIh5CXWsDpVxzjbS8U+vbSU0l1DnFSy/5/pempLS83jvvWFMPWsfbEwAxg+6XzjJ+vFQ91PcmzyPJ1eBT/XruROnyb0pv10rV1dLRo2enqirf9/37pUWLpGPHovAgEPfofnmW16NGozU0ui5vBF+XEX5nzkgvvBDtKtAehDoAMYPul86SlCRV198wvqHKE6Rmb/5qayWPS+rRwzdlZjbf1qefSsuWRbZeIJB4aKnjnDrA/gh1AGIG3S+dyXglJfi+G6nZRVn/53+kxKt8gS45+ezUu7d0772+Fr+uXaNUPOIeoQ6AHfD2BEDMoKUutlVX+6ayBiflTJniC3VAtND9EoAdcJ06ADGDc+oAWC0eWupaGygFQPQR6gDEDFrqAFiNljpEAwEbTRHqAMQMzqkDYLV4aKkj1NnLzTdLl1/uGx1YCWcnd+LZee5E6YILolsnrEWoAxAz6H6JppKSpIsv9u23+qkh9idCRaiD1UaO1NlRgk2QSVLPnlEoDlHDZ85AhCQmSudlS8Vu+V9gvQ2W1wePxE7S5KnS8eNnp2PHfN+rq88GFbSO7pdo6uKLpS6tXDxX8o28efBg5OtB7KH7JaKlxesCIu4Q6oAIGTlS6p4mlUgBL7paf6Hlbt2l1auDb+fwYWnGDGnz5khUGVvofomgTOA3PPXzjlVLOmF1UYgF8dBSx0ApgP1xeAIR4mry6VmC1OgTtfoLLZ+pldas83WTCDT17y9NmECoawu6XyIYGrzj05/+JE2cGHhZba305JNSQUFo9xEPoY6WOsD+CHVAhJm6/u1N31TWX2j51Elp6tTAv/vAA9LChREuMIbQ/RKAJH35pe97nz7S3LnB10tN9Q06EQq6X8KuunWXfvSjwMu+9jVra0HkEeoAG+N8uvYh1AGQfB+Ivf++1KlT4OUXXyzNmyd17Rr6fdFSBzv71a9aXn6CbucxI6RQd+ONN+rnP/+5srOzlZOTow8//NC/LDc3V7Nnz5bH49Hdd9+t9evXS5KuvvpqLVmyRG63W0899ZQWL14c2iMAgDqcUwdA8rXUPfdc8OX/5//4Ql1LEuqGiW/ts7V4CHWcU+c8Xo90oFz61YvB1/nsM+mTT6yrCZEV0uFZWFioG264QX/84x8bzc/OztaMGTM0fPhwDRgwQBs3blRWVpYk6fe//70mTJigsrIy5efna82aNfqEvyiE2fjx0vvdpVN1nyo2HHXS5Q44bgliAOfUAQiXN9+Ubu4tVdXddte9Y/I0WY/ul7AjY6Tdu6Wf/CTalcAqIYW6oqKigPOnTp2qFStW6MyZM9q7d69KS0uVk5MjSSotLdWePXskSStWrNDUqVPbFOrOP/98bXbwSBEjRkjSFEkn5HL7mhG8DaKGy+1SUo8knTfyPD2++fGo1GilHlN6SCckt6t56nK73OqR1EMjzxupzY833+f1nxT26BF88JDhw6VhnaYoQafU9A4SGoxW0qvnCG0O8nwnJfm+v/lmg1Hz2qFnT+k+3asEFejsw2y8zyUpqUeSXt/8esBtDBrk+/7AA74RMJtyu6WZulcJCaVyuU8F3L5XXnXv0T3ofaSl+b5HezCW/v2l+mNEUsDjpKXHIdUfZ9J//7dUVRV0tZAMG9a4Tql5ra3VGQvqj8NevTr+d9OvnzRP9yohoUCSN+hr44iRI4K+LtZ9Xqgf/jDwMdKrl/TDEI9DJ+kxpYfcTT7Navg663a5NXJE4NdWOxl570i5C9wBH0P97VAeR9++vu/f+Ebwv9/LL5ekKZKpP9br/3c0/Jiwu2655XVdd13z3+/Rw/f9vPM6fowMHCjN1r1yJRTIU3e/TY+T1o6RcKi/iPVPfyrdcUfz5VlZ0nLdK5frbJ3Na3Wpe/fg/3NbM3iw9K4NnovWZGf7vv/0p9KcOZG5j3POkda18nzb4bloi4bHerD3hFa8ZrX0vtTlckvqof5pI7X5mY7VcdFFkjRFLtepus0332+SQtpnEWlIz8jI0JYtW/y3y8rKlJGRIUk6cOBAo/ljxowJup05c+Zobt0Zzp2CdYwHAkhocFHOZgOUNPj51GmLCuqghmFy6NDo1eEUVrTURXLbAOwrUDfMWk98nJNkxWsrgNAFuxa9kWQ2bNhgCgoKmk3XXXedf53NmzebSy+91H/7iSeeMLfddpv/9lNPPWWmT59upk+fbvLy8vzzb7/9dvPEE0+0eP/1U35+fpvWs+v07rsyvY2MvDKqqZu8DaYaGVXKaHP0a7ViqlSl8cpralRjalRjvPL6pxrVmEpVms3aHPB3e/eWMcY39e8feFq3ru75rg3yXNdPLTzfx4/77qN79449xpwcmSuNjKulfV6/34Nso1cvmR/9SObhh4NPQ/bIuI+1sH1vy/dx++2+x/n889H9m9i3r8ExEuw5a+FxSDKbNvkey1VXRa7OoqImdf7/9u49Jqoz/QP4V0Zu1cogqKyMwtTVXWzaCt2qG2+18YKttWzjrmRNtLVrqtZt7WUrodnW3SbWujbW2F1sSFvrVoNYkdUoVP1p222yIGUEQW7DpeWiIhS8NVYEnt8fR0YocwHmcuYw30/yxOGcl5nnzMs7nmfOOe+xlquDPAdDjBypvNfNzQN/jqVL74yRDjt97mCcpqQoeTz/vPX106c7Pw61FK1o7fW52v3n27ht87PVm+I0TtvcBldsx5NPKn83//mP7TYtLc59Jk2ZoryGyTTw9+HVV5W/3yEddvJwMEZcEampyrb86U/W13/44Z0822Hzs1EnkClXBp7DX//qHe+Fo/jsM+W9+uMf3fca77zj+P32hveiL9F9rNvaJ/TEZ5a9/dL2IbdFQlrle+PA83DFfmlX2KqJHB6pmz9/vqMmvTQ0NGDcuHGWnw0GAxoaGgDA5nKigWhsVDsD97p2Ddi2zUGjWQD0nsjG+3H2SyIi1+NEKUTezy27PocPH0ZiYiICAgIQHR2NiRMn4syZM8jLy8PEiRMRHR0Nf39/JCYm4vDhw+5IgQaxq1eBgweVgs5edHRA+e6CfAaLOiIi1+NEKUTez6nvXBISErBz506MGjUKR48eRUFBAeLj41FSUoL09HSUlJSgvb0dL7zwAjrv7G2tX78eX3zxBXQ6HT7++GOUlJS4ZEPItyxd2odGrQCGuzsT8iaeuO6D31QTka9hUec6996rfDFtMNhv9+23wIoVnsmJBgendk8yMzORmZlpdd3mzZuxefPmXsuzsrKQlZXlzMsSkcb4+QHJycpMbrZ0zUbnDB6pIyJyPVcVdUGB9v8faGoCfvLyCcycNW2aMtu0IzExwF/+MvgvMyHX4XfOROR2U6cCb7/dh4ZOni7Loo6IyPVcVdQFBgG1tbbXX7qkTNd/86btNlrXdSZJXR2wYIH1Nv/9LxAeztlGqX9Y1BGR2wUF3X185y4lVt14D06dMuuJoo6nXxKRr3HFRCkiwK1bQO1l6+vHjgUiIoBf/EK5afZgV1oK2LjdM27f9mwuNDhw94SIPOb0aSA11U6Drc49vyeuqeOROiLyNa44UtfZAeTkAFFzra+vrAQmTBj48xP5Ojd+n01Eg8nw4d5f0PD0SyIi1+NEKUTej0fqiMih06eBRx9VHt+8Cdy4YTuuX++9LDraM3myqCMicj0WdUTej0UdETk0e/bdx8HBSowa1f/n6bouw114SwMiItdjUUdkm58f8M03wCOP2G7jiX0H7p4QUZ/pdEBgoHIqZn8jKAj417/cmx+P1BERuZ4rJkohGqxGjQJ++1vH7aQTTs/ybQ+HJxH1mYhy+uXNm8r9hLwNizoi8jaxscCaNbbXV1QAp055Lp+B4JE6Iseam5UZXG3paIZTM3w7wqKOiAYNd59+admhceM3bUQ0OHS/iXZKiv22BgPQ0ODefJzBoo7Isfb2u2NFDSzqiGjQcPZIncEAfPwxMHKk9fW8ESwR9VVZGfDKK8DEibbbLFumfN6EhmqjqJs0CXjqqd7rPTUZlq/Ztg24eLH38tmzgWzPp0NejkUdEQ0azhZ18fHA/PmO23V0gjeE6QOdTjn1zNZ1OL/6FeCFZ/ESucz27fbXz5ypFHUhIcCIEb3XBwe7J6/+6jrq+MQTSliz2XPpDHpXryo3YV++XO1MSEtY1BHRoOFsUdf1e99+Czz/vO12N/4PQMjAXsOXbN8O/PnP9ts86pFMiLzbN9/YXveox7Kw7dAhYNo022cxAMDFaYAMYFZk6u0PfwAWLLDfpnw1ILxZO3XDos4FdDrg5EngwQdtt7H2DRwRuZarrqnLzwdMJufz8XVG493H//uf9TZXY4DOewHw1FbyQQcOAOPG2f/MagsCZChUHSNNTcBzzzlodBoAizqXKCpSwq7FAFjUUTcs6lxg/Pi7N2a2RzrBHRciN/LE7JfUf4sXA0eP2lh5GsBMT2ZD5D3eflsJuzhGiKgPWNS50JUrwH332V5/rRo8ZYvIjVjUERERkTsEBSkHcn5u9GjP52INizoXamkBWlvVzoLId7n7lgZERETkm0aPBr7/Uu0sbGNR1wevvQa8+qrt9bZmdiMiz+KROiIiInIlEeW2Hrd/Ahq/t91uzx7P5WQNy5E+GD7c/h3iu+TluT8XIncZP165YN8arRRJXUXd8uXAI48AgYG9IyDA9vJhw9TNn4g8a8kSwGy2vi6El0sQ0R3XbwAFucDcaLUzsY1FXR9s2wakpDhu19jo/lyI3GXOHKC2Vu0snNN1+vOcOUoMRFsb8NVXrsuJiLxPRYUy1gMCgF/+0na7Tk5wRkQa4VRRt3TpUmzatAkxMTGYOnUq8vPzAQBRUVEoLS1FeXk5ACAnJwdr164FAMTFxWH37t0IDg7GsWPH8NJLLzm5Ce5344YSRIPRV18pU/iPcjAVdXb23WvWvNU//gHU1Sm3Gbl1q3e0tVlf3n3dTz8B7e1qbwkRuVN5uXIGjr37rgHA9W/BCc6ISBOcKuqKi4vx9NNP48MPP+y1rqqqCrGxsb2Wp6SkYPXq1cjNzcWxY8cQHx+P7OxsZ9IgIifU1QG/+Y3aWbhGa2vfjqoTEbW2cnIzIho8nLpSpqysDBUVFX1uHxERgREjRiA3NxcAsGfPHiQkJDiTAhERERERkU9z2/QHRqMRJpMJX375JWbOVO6aGRkZifr6ekub+vp6REZG2nyO1atXIy8vD3l5eQgPD3dXqkRERERERJrl8PTLEydOIMLK1I9vvPEGDh8+bPV3Ll68iPHjx6OlpQVxcXHIzMzE/fff3+/kUlNTkZqaCgDI49SSpJKpU21fU9naClRWejYfIiIiIqLuHBZ18+fP7/eTtrW1oaWlBQBgMplQVVWFSZMmoaGhAQaDwdLOYDCgoaGh389P5Ald0+OfOmW/3aJFyiQiRERERERqcMstDcLDw9HS0oLOzk4YjUZMnDgR1dXVaG1txbVr1zBt2jTk5uZixYoV2LlzpztSIHLaO+8Av/ud7fXR0cDo0cB993ksJSIiIiKiXpwq6hISErBz506MGjUKR48eRUFBAeLj4zF79mz8/e9/x+3bt9HZ2Yk1a9ag9c4UU+vWrbPc0iArKwtZWVku2RAiV9uyRQlbPvgAeOEFz+VDRERERGSNU0VdZmYmMjMzey3PyMhARkaG1d/Jz8/HAw884MzLEnmVf/4TmDu39/KwMOBvnk+HiIiIiHyMW06/JPIFjY13Hy9dar3N3wDAy2/YTTQYzJtnfdKiyZOBc55Ph4iIyKNY1BEN0NatQH4+EBxsu835TUDnrz2WEpHHhYUBP/5ofV1QkPtfv6ND+XfpUttfrjzq/jSIiIhUxaKOaIBu3QKOHXPQaL1HUiHyuCtXgIICYMoU4J57bLf74QegqMh9eXz0ERAVZb+AbI0DOkPclwMRuc7u3UBVVe/lU6YAX3s8m4Hbu9f6dfme+LKLfBOLOiIi6rfOTiAuzvEOSlvb3aNp7nD2LPDkkw4anQYw0305EJHzmpuBCROAWbOUsEkADPFUVv139iywfLnyeNw42+1MJs/kQ76DRR0REQ2ICHDzptpZENFg8PvfK5OODbFTsJ1/DRAvv6ThvfeAf/8bCAiw3aa9Hbh0yXM5kW9gUUdEREREqqqrA/bscdDoGU9k4rzLl9XOgHyRn9oJEBERERER0cCxqCMiIiIiItIwFnVEREREREQaxqKOiIiIiIhIw1jUERERERERaRiLOiIiIiIiIg0bAuU2jl7v2rVrKC8vVzsNGoDw8HA0NzernQYNEPtPu9h32sb+0zb2n3ax77RtsPdfVFQURo8ebXWdaCHy8vJUz4HBvvPFYP9pN9h32g72n7aD/afdYN9pO3y1/3j6JRERERERkYaxqCMiIiIiItIwHYBNaifRVyaTSe0UaIDYd9rG/tMu9p22sf+0jf2nXew7bfPF/tPMRClERERERETUG0+/JCIiIiIi0jAWdURERERERBrm9UXdwoULUVZWBrPZjI0bN6qdDv2MwWDAqVOncP78eRQXF+PFF18EAISGhuL48eOoqKjA8ePHodfrLb+zY8cOmM1mFBYWIjY2Vq3UqRs/Pz+YTCYcOXIEABAdHY2cnByYzWakpaXB398fABAQEIC0tDSYzWbk5OQgKipKzbQJQEhICA4cOIDS0lKUlJRg+vTpHH8asWHDBhQXF6OoqAj79u1DYGAgx54X++ijj9DY2IiioiLLsoGMtRUrVqCiogIVFRVYsWKFR7fBl1nrv61bt6K0tBSFhYXIyMhASEiIZV1SUhLMZjPKysqwYMECy3Lul3qetb7r8sorr0BEEBYWZlnmy2NP9fsq2Ao/Pz+prKwUo9Eo/v7+UlBQIDExMarnxbgbEREREhsbKwBk+PDhUl5eLjExMfLuu+/Kxo0bBYBs3LhRtmzZIgBk0aJFcuzYMQEg06ZNk5ycHNW3gQF5+eWXZe/evXLkyBEBIPv375dly5YJAElJSZE1a9YIAFm7dq2kpKQIAFm2bJmkpaWpnruvx+7du+W5554TAOLv7y8hISEcfxqIsWPHSnV1tQQFBQmgjLmVK1dy7HlxzJo1S2JjY6WoqMiyrL9jLTQ0VKqqqiQ0NFT0er1UVVWJXq9Xfdt8Iaz13/z580Wn0wkA2bJli6X/YmJipKCgQAICAiQ6OloqKyvFz8+P+6Ve1HcAxGAwSHZ2tnz33XcSFhYmgM+PPdUTsBnTp0+X7Oxsy89JSUmSlJSkel4M25GZmSnz5s2TsrIyiYiIEEAp/MrKygSA7Nq1SxITEy3tu7djqBORkZFy8uRJmTt3rqWoa2pqsvxH130cZmdny/Tp0wWA6HQ6aWpqUj1/X44RI0ZIdXV1r+Ucf94fY8eOldraWgkNDRWdTidHjhyRBQsWcOx5eURFRfXYsezvWEtMTJRdu3ZZlv+8HcOz/dc9EhIS5LPPPhOg9/5m1/jjfql39d2BAwfkwQcflJqaGktR58tjz6tPv4yMjERdXZ3l5/r6ekRGRqqYEdkTFRWF2NhY5ObmYsyYMbh06RIA4NKlSxgzZgwA9qk3ev/99/H666+js7MTABAWFoYrV66go6MDQM8+6t5/HR0duHr1ao9THsizjEYjmpqa8Mknn8BkMiE1NRX33HMPx58GXLhwAdu2bUNtbS0uXryIq1evIj8/n2NPY/o71jgGvdeqVauQlZUFgP2nBUuWLEFDQwPOnTvXY7kv951XF3WkHcOGDcPBgwexYcMGXL9+vdd6EVEhK3LkiSeewOXLl33yfi6DwdChQxEXF4eUlBTExcXhxx9/RFJSUq92HH/eR6/X46mnnoLRaMTYsWMxbNgwxMfHq50WOYljTZuSk5PR3t6OvXv3qp0K9UFwcDCSk5Px5ptvqp2KV/Hqoq6hoQHjxo2z/GwwGNDQ0KBiRmTN0KFDcfDgQezduxeHDh0CADQ2NiIiIgIAEBERgcuXLwNgn3qbGTNmYMmSJaipqUFaWhoee+wx7NixA3q9HjqdDkDPPurefzqdDiEhIfjhhx9Uy9/X1dfXo76+HmfOnAEAfP7554iLi+P404B58+ahpqYGzc3NaG9vR0ZGBmbMmMGxpzH9HWscg95n5cqVWLx4MZYvX25Zxv7zbhMmTIDRaERhYSFqampgMBhgMpkwZswYn+871c8BtRU6nU6qqqokOjrackHq5MmTVc+L0TM+/fRT2b59e49lW7du7XHx+LvvvisA5PHHH+9xAWtubq7q+TOUmDNnjuWauvT09B6TNaxdu1YAyLp163pM1rB//37V8/b1+Prrr2XSpEkCQN566y3ZunUrx58GYurUqVJcXCzBwcECKBPerF+/nmPPy+Pn1/X0d6yFhoZKdXW16PV60ev1Ul1dLaGhoapvl6/Ez/tv4cKFcv78eQkPD+/RbvLkyT0mSqmqqhI/Pz/ul3pR33WP7tfU+fjYUz0Bu7Fo0SIpLy+XyspKSU5OVj0fRs+YMWOGiIgUFhbK2bNn5ezZs7Jo0SIZOXKknDx5UioqKuTEiRM9Bs4HH3wglZWVcu7cOXn44YdV3waGEt2LOqPRKLm5uWI2myU9PV0CAgIEgAQGBkp6erqYzWbJzc0Vo9Goet6+Hg899JDk5eVJYWGhHDp0SPR6PcefRmLTpk1SWloqRUVFsmfPHgkICODY8+LYt2+fXLhwQdra2qSurk5WrVo1oLH27LPPitlsFrPZLM8884zq2+UrYa3/zGaz1NbWWvZfur44ASDJyclSWVkpZWVlEh8fb1nO/VLv6Lvu67sXdYDvjr0hdx4QERERERGRBnn1NXVERERERERkH4s6IiIiIiIiDWNRR0REREREpGEs6oiIiIiIiDSMRR0REREREZGGsagjIiIiIiLSMBZ1REREREREGvb/HY/BnOIRI1EAAAAASUVORK5CYII=\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"markdown","source":["###### data_window"],"metadata":{"id":"c2yVTn1tnxMn"}},{"cell_type":"code","source":["idx_ = 990\n","\n","# t_df[roll_cols].iloc[idx_]\n","t_df.iloc[:, -4:].iloc[idx_]\n","\n","# roll_cnt = 3\n","# valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_v4(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_cnt)\n","# roll_high = get_roll_wave_data(valid_high_prime_idx, roll_prev_high_idx_arr, len_df, wave_high_fill_, roll_cnt)\n","# roll_low = get_roll_wave_data(valid_low_prime_idx, roll_prev_low_idx_arr, len_df, wave_low_fill_, roll_cnt)\n","\n","# print(roll_high[idx_])\n","# print(roll_low[idx_])\n","# roll_prev_high_idx_arr\n","# valid_high_prime_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"I_ZNM9n7hFOf","executionInfo":{"status":"ok","timestamp":1652690281646,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"aee10236-b76e-45db-f25d-4a3c6d352d69"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["cu_wrr_21_15T5    2.096046\n","cu_wrr_32_15T5    0.838580\n","co_wrr_21_15T5    0.780256\n","co_wrr_32_15T5    1.000000\n","Name: 2021-05-20 14:10:59.999000, dtype: float64"]},"metadata":{},"execution_count":64}]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"],"metadata":{"id":"zj_d5wsfDzf_"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_co_bool_idx_[~np.isnan(wave_co_bool_idx_)]\n","# wave_cu_bool_idx_[~np.isnan(wave_cu_bool_idx_)]"],"metadata":{"id":"BvF0CoLn7bF3"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"],"metadata":{"id":"TqMmmSAGuChM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"50ucQUF-Jixd"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"code","source":["\n","def get_roll_wave_data(valid_prime_idx, roll_idx_arr, len_df, data, roll_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_idx_v4(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array(\n","        [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","    \n","def wave_range_ratio_v4_1(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    cu_wave1_range = roll_high_[:, -1] - roll_low_[:, -2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_high_[:, -1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_high_[:, -2] - roll_low_[:, -1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_low_[:, -1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def wave_range_ratio_v4(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])\n","    valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #         cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_dcbase_v11_3(res_df, config, itv='T', over_period=2):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    # b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    over_base = close > dc_base_\n","    prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","    prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = prev_over_base & ~over_base\n","    co_bool = prev_under_base & over_base\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","def wave_range_v11_2(res_df, config, itv='T'):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n"],"metadata":{"id":"RVFfP9VcDG2_"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","\n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","\n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_, _, _ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","    for col_, itv_ in zip(future_cols, itv_list):\n","        back_col_ = 'b1_' + col_\n","        res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","    return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1) \n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)   \n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","    \n","    # ============ modules ============ #  \n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","    wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    \n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    wave_high_[paired_cu_idx] = wave_highs\n","    wave_low_[paired_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","    \n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    cu_prime_idx = wave_high_prime_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","    co_prime_idx = wave_low_prime_idx\n","    co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","    # ============ enlist to df_cols ============ #       \n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ # \n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","    # ------ for first_high ------ # \n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","      \n","    if itv != 'T':\n","      assert ltf_df is not None, \"assert ltf_df is not None\"\n","      join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","      ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","      try:\n","        ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","      except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","    else:\n","      ltf_df = t_df    \n","\n","    return ltf_df\n"],"metadata":{"id":"841i4oo2abh-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"code","source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"],"metadata":{"id":"Go7ARIUhfC1g"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df[roll_cols].tail(100)"],"metadata":{"id":"pgA8QqyXZ66o"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"],"metadata":{"id":"wF7fKJ3mOhaf"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"],"metadata":{"id":"3vHLGont-BFe"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"],"metadata":{"id":"Mh3w2s-j34Zs"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"eQ06-kWq4m6F","executionInfo":{"status":"ok","timestamp":1651799326382,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["11\n","11\n"]}]},{"cell_type":"code","source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"],"metadata":{"id":"SUFmr9Z_kcCN"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"],"metadata":{"id":"_3pOQtt2ttfk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"kKaD1fK3WPRP","executionInfo":{"status":"ok","timestamp":1651756811396,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"metadata":{},"execution_count":79}]},{"cell_type":"code","source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"],"metadata":{"id":"YoZpr7lDn7z-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"code","source":[""],"metadata":{"id":"1eZov-szzNuB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"],"metadata":{"id":"nLWAP1Cl2Hvu"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":4,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1653644619966,"user_tz":-540,"elapsed":4167,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1653644621122,"user_tz":-540,"elapsed":1173,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","      \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","\n","    roll_hl_cnt = 3\n","\n","    roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    \n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    res_df['short_tp_1_{}'.format(selection_id)] = wave_low_fill1_      # wave_low_fill_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = roll_highs1[-1]   # roll_high_[:, -2] wave_high_fill_\n","    res_df['long_tp_1_{}'.format(selection_id)] = wave_high_fill1_      # wave_high_fill_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = roll_lows1[-1]     # roll_low_[:, -2]  wave_low_fill_\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = wave_low_fill1_    # roll_low_[:, -2]\n","\n","    res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill2_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill2_    # roll_low_[:, -2]\n","\n","    res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_out_0_{}'.format(selection_id)] = roll_highs2[-1]  # roll_high_[:, -2]\n","    res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_out_0_{}'.format(selection_id)] = roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #     \n","    short_open_res1 = np.ones(len_df) #.astype(object)\n","    long_open_res1 = np.ones(len_df)  #.astype(object)\n","    short_open_res2 = np.ones(len_df) #.astype(object)\n","    long_open_res2 = np.ones(len_df)  #.astype(object)\n","    \n","    # ------------ wave_point ------------ #\n","    notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    short_open_res2 *= res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_cu\n","    long_open_res2 *= res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_co\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_point\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","    \n","    # ------ reject update_hl ------ #\n","    notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co\n","\n","    # short_open_res1 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # long_open_res1 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # short_open_res2 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # long_open_res2 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    if show_detail:\n","      sys_log.warning(\"reject update_hl\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","\n","    # ------ tf_entry ------ #    \n","    tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    if wave_itv1 != 'T':      \n","      short_open_res1 *= np_timeidx % tf_entry == (tf_entry - 1)\n","      long_open_res1 *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"tf_entry\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","    \n","    if wave_itv2 != 'T':      \n","      short_open_res2 *= np_timeidx % tf_entry == (tf_entry - 1)\n","      long_open_res2 *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"tf_entry\")\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    # ------ wave_mm ------ #\n","    wave_high_terms_cnt_fill1_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_terms_cnt_fill1_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    short_open_res1 *= (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","    long_open_res1 *= (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","\n","    wave_high_terms_cnt_fill2_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_terms_cnt_fill2_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    short_open_res2 *= (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","    long_open_res2 *= (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_mm\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # ------ base_15T < wave_base ------ #\n","    # dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","    # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    # short_open_res1 *= (dc_base_ > wave_base_) & (dc_base_ > close)\n","    # long_open_res1 *= (dc_base_ < wave_base_) & (dc_base_ < close)\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))     \n","        \n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","        epg2 = config.tr_set.ep_gap2\n","\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1        \n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        \n","        # res_df['short_ep_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * epg\n","        \n","        # wave_cu_marker_ = res_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","        # wave_co_marker_ = res_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","        # res_df['short_ep_{}'.format(selection_id)] = wave_cu_marker_ + short_epout_gap * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = wave_co_marker_ - long_epout_gap * epg\n","\n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","    res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * outg      # for p1_hhm, p2_hlm\n","    res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * outg \n","    # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg    # for p1 hlm\n","    # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg \n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res1 *= (short_tp_ < short_ep1_) # (short_ep_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) # (long_ep_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation     \n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution    \n","    long_open_res1 *= close > res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution   \n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out can be vectorized\n","    long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban) \n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","    \n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    \n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    # res_df['short_tr_{}'.format(selection_id)] = abs(\n","    #     (short_ep_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep_ / short_out_ - config.trader_set.market_fee - 1))\n","    # res_df['long_tr_{}'.format(selection_id)] = abs(\n","    #     (long_tp_ / long_ep_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"aTV4h3LjTZBp"}},{"cell_type":"code","source":["\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","# ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"],"metadata":{"id":"dc49JPmoTaPQ"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":24,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1653644808974,"user_tz":-540,"elapsed":3200,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","# from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","  \n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and \n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2) \n","    \n","    # ------------ wave_period1 ------------ #\n","    if to_itvnum(wave_itv1) > 1: \n","      offset = '1h' if wave_itv1 != 'D' else '9h'\n","      htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","      htf_df = wave_range_cci_v2(htf_df, wave_period1)\n","      \n","      cols = list(htf_df.columns[-15:-4])  # except idx col\n","\n","      valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      cols += list(htf_df.columns[-4:])\n","\n","      # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","      res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","      res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=0), how='inner') \n","    else:\n","      res_df = wave_range_cci_v2(res_df, wave_period1)\n","\n","      valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    # ------------ wave_period2 ------------ #\n","    if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","      res_df = wave_range_cci_v2(res_df, wave_period2)\n","\n","      valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    # itv_list = ['15T', '15T', '15T', '15T']\n","    # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면, \n","            # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","            # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                  (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                  idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:                                  \n","            # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","            # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave2, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #\n","    if config.loc_set.point1.short_tr_thresh != \"None\":\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point1\n","    if config.loc_set.point1.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point1.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point1.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point1.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point1.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point1.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point1.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point1.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point1.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point1.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point1.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point1.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point1.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point1.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point1.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point1.wrr_32 != \"None\":            \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point1.wrr_32  # + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point1.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point1.wrr_32  # + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point1.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point1.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point1.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point1.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point1.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point1.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point1.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point1.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point1.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point1.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point1.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point1.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point1.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point1.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point1.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point1.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point1.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point1.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point1.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point1.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point1.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point1.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point1.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point1.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point1.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point1.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point1.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point1.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point1.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point1.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    # if config.loc_set.zone.use_zone:\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":            \n","      wave_itv2 = config.tr_set.wave_itv2\n","      wave_period2 = config.tr_set.wave_period2\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1653644624184,"user_tz":-540,"elapsed":8,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_45\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 1e-10,\n","    \"market_fee\": 1e-10,\n","    \"initial_asset\": 24500,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 50, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"cu_wrr_21\": \"None\",\n","      \"co_wrr_21\": \"None\",\n","      \"wrr_32\": 0.3,\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"wrr_32\": 0.3,\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"wave_itv1\" : 'T',\n","    \"wave_period1\": 20,\n","    \"wave_itv2\" : 'T',    \n","    \"wave_period2\": 20,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\" : 0,\n","    \"p2_box_k2\" : 0,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.12,\n","    \"ep_gap2\": -0.12,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 30000\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":8,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1653644624185,"user_tz":-540,"elapsed":9,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"4ed084a8-7230-43ee-9706-49b0af65e9de"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_45\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"cu_wrr_21\": \"None\",\n","  \"co_wrr_21\": \"None\",\n","  \"wrr_32\": 0.3,\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"wrr_32\": 0.3\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"wave_itv1\": \"T\",\n"," \"wave_period1\": 20,\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 20,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.12,\n"," \"ep_gap2\": -0.12,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 30000\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":33,"metadata":{"id":"afUV2b1jaggN","executionInfo":{"status":"ok","timestamp":1653645733466,"user_tz":-540,"elapsed":384,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","config_list[0].tr_set.wave_itv1 = 'T'\n","config_list[0].tr_set.wave_period1 = 20\n","config_list[0].tr_set.wave_itv2 = 'T'\n","config_list[0].tr_set.wave_period2 = 20"]},{"cell_type":"code","execution_count":25,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":4343,"status":"ok","timestamp":1653644819403,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"1e4168b7-d3ea-4626-b67a-8e94d68aa952"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 2.9470741748809814\n","make data_list elapsed time : 0.0001685619354248047\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_iYcJk8nK8Yq"},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_greater1 = 0\n","# config_list[0].tr_set.wave_greater2 = 0\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap = -0.12 # -0.618 -0.23 -0.382 0.19 \n","# config_list[0].tr_set.out_gap = 0\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 30000\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004\n","\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":34,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":452,"status":"ok","timestamp":1653645735687,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"ddd8da10-70eb-498f-8467-7c5579b92820"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 42048\n","np.sum(long_open_res1 == 1) : 42240\n","np.sum(short_open_res2 == 1) : 42048\n","np.sum(long_open_res2 == 1) : 42240\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 40427\n","np.sum(long_open_res1 == 1) : 40130\n","np.sum(short_open_res2 == 1) : 40427\n","np.sum(long_open_res2 == 1) : 40130\n","wave_mm\n","np.sum(short_open_res1 == 1) : 40425\n","np.sum(long_open_res1 == 1) : 40128\n","np.sum(short_open_res2 == 1) : 40425\n","np.sum(long_open_res2 == 1) : 40128\n","point validation\n","np.sum(short_open_res1 == 1) : 40401\n","np.sum(long_open_res1 == 1) : 40115\n","np.sum(short_open_res2 == 1) : 24865\n","np.sum(long_open_res2 == 1) : 24969\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.5026400089263916\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":27,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1653644826469,"user_tz":-540,"elapsed":424,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.wrr_32 = 0.4 # \"None\" 1 0.5 0.382 0.302\n","config_list[0].loc_set.point2.wrr_32 = 0.5 # \"None\" 1 0.5 0.382 0.302 0.25\n","# config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\"  #  \"None\" 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = 1  #  \"None\" 2 0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":35,"metadata":{"executionInfo":{"elapsed":2377,"status":"ok","timestamp":1653645744706,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"f252a14a-93b6-4b20-a933-dc6d5d40803e"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.40000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0997183322906494\n"]},{"output_type":"stream","name":"stderr","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9876203536987305\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":31,"metadata":{"id":"KqVkg236t_f2","executionInfo":{"status":"ok","timestamp":1653645272394,"user_tz":-540,"elapsed":436,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","# config_list[0].loc_set.tr_set.p2_box_k1 = 0\n","config_list[0].tr_set.p2_box_k2 = 0.0\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","# config_list[0].lvrg_set.leverage = 1\n","# config_list[0].lvrg_set.static_lvrg = 0\n","# config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":36,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":663},"executionInfo":{"elapsed":4820,"status":"ok","timestamp":1653645749524,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"7dabc0c8-b75c-4ad2-e572-4ebd4763334e"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 2.2941181659698486\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAABWAAAAJkCAYAAACfwYhFAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdd1RU19oG8GdAUEFUir3gjSbBksSILZqIigWwIBYEEyWJGDWWa2KNicGaqGg0sUSjwk2z12tBVESxxRgsWEAREcVGV2Dovt8ffpzLcQBBRdrzW+tZMnv22bP3jPJ6zsycowEgICIiIiIiIiIiIqKXTq+4J0BERERERERERERUVvEALBEREREREREREVER4QFYIiIiIiIiIiIioiLCA7BERERERERERERERYQHYImIiIiIiIiIiIiKCA/AEhERERERERERERURHoClcm/QoEFwc3N7ZY/n7u6Oa9euISUlBf/88w+6du1aoO0qV66M+fPnIyIiAikpKQgLC8PkyZOV+2vVqoWdO3cq99+9exebN29GkyZNVOOMHj0aZ86cQVxcHJKTkxEUFITRo0e/1DUSEREBpaPGenh4QER00rNnT6VPQWts9hyuXr2K1NRUXLlyBR9++OFLXSMRERFQdmosADRp0gRbt27F/fv38fDhQ5w4cUKnD/DsfWKikqxCcU+AqLg5OzvDwsICv/76a5E/louLC1atWoWZM2fi+PHj+OSTT7Bnzx60adMGly9fznM7PT097Nu3D7Vr18bXX3+N27dvo3HjxjA3N1f6GBkZIT4+HjNmzEBERARq166N6dOn4/Dhw3jrrbfw8OFDAICpqSl27NiBoKAgaLVa2NraYvny5TAyMsLixYuL/DkgIqLyozTUWABISEiAnZ2dqi04OFj5uaA11sXFBatXr8bChQtx+PBh2Nvb47fffkNSUhJ27dr18hdNRETlVlmpsVWqVMHBgwcRHx+P0aNHIykpCZ999hl2796Njh074syZMwAKtk9MVNIJw5TnbNmyRfz9/Z/Zr0KFCqKnp/dCjxUSEiLr1q1Tbms0GgkKCpLff/893+1GjhwpcXFxUqNGjUI9XpMmTURExMnJKd9+f/zxh1y4cKHYXwuGYRimbKU01FgPDw+Jjo4u9OPlVmNDQkLkt99+U/XbunWrXLx4sdhf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dwBAu3bt8P777+P8+fOoWrUqXF1d0bNnT7z//vs6j9GuXTv861//whdffJHrHFatWoXx48dj+/btWLBgAV577TXMnDkTP/zwg+q8QURERCVBSaix+/btQ0REBHbu3InZs2cjOjoavXr1wuDBg/H5558DAGJjY3XeyGzUqBEA4NixY/nuUBIREb1qJaG+ZnvWPmw2FxcXnD9/nt/cpBKDn4AlesU0Gg0qVKgAjUaTb78TJ05g4MCB6NatG3x9fdG3b18MGTIEBw8e1BlLT+9//5QzMjIwePBg7Ny5E//5z39gZGSEjh074uLFizqP4eLigoSEhDwvAJKQkABbW1vo6+tj9+7dmDVrFpYsWQIPD4/nXD0REVHRKQk1NikpCba2trh06RIWL16MnTt3omvXrhg5ciR+/vnnl79oIiKiIlYS6mu2Z+3DAoC5uTlsbW2xcePG51gtUdHQAJDingQRERERERERERFRWcRPwBIREREREREREREVER6AJSIiIiIiIiIiIioiPABLREREREREREREVER4AJaIiIiIiIiIiIioiPAALBEREREREREREVER4QFYKnHCw8Ph6elZ3NPIk5ubG0QExsbGr+wxnZ2dsW3bNty9exciAjc3tzz7jhjxf+zdd1hTZ/sH8G8IAUERlSFqARUHIm4RrQMUF+rrREWtxVnrq9Zqq7VVf2hta+uotFpHHVj3ArVFcSMiRaW4QHEShgOZYa/A/fuDl1MjAYKAiXB/rut7lTznOU+eE2jvnuTkOTMRGhqKrKwsxMbG4tChQyX2/eyzz0BEOHr0qErz0NPTw48//oioqChkZWXh6dOnWLRokUKfZcuW4fz580hJSQERwdLSstg4UqkURKQ0ZmZmKs2FMcZY+XGNLU6VGuvg4KC0Zq1evbpY3xkzZuDRo0fIysrCP//8g379+qk0jw8//BDXrl1DVlYWIiIiMG/ePIXtRa+NsmzdulXoxzWWMcbUg2tscZVZY/38/JT209XVLXMeM2bMwMOHD5GdnY379+9j0qRJCtsbNmyIEydOCOe5L168wJEjR9CiRYtiY82ZMwdhYWHIyMhAZGQkfv31VxgaGpbzlWE1kba6J8DY++bUqVPo3r07MjMz39lzuri4oGnTpvDx8cHMmTNL7Ldq1SrMnTsX3333HYKDg9GwYUM4ODgo7WtiYoIVK1YgLi5O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xucwoOLnZGNuma6votdyRsb9K/saraJxZdyvil6rlH2Or6gH00w2PbdMX28YX/OZHgujsq+xgMrPocpe75oyfd1Zdprp829Fr9WM/ZiOT9PjU7Zn0z5MlzF93jberuzYV3RumPZX2T6W5VjmtuljYzq+K3r+Kzu2y44X03PKuK3KxnbZrDN9rgDKZ67p9IpeI5nmeWWv94zzTV+DmY4509cuxrFa0fNDKRB1lBlbG6YZe9btLALdAitfuOx5ZXwdWfYcqAnTcVfZcxpQ8XNGdc/j9aWiLDJOr2qfy74+LZu/NX1tUPZ1QUXZXNNjUVFmG1W0L2WvMRiVfR6v6f5U14+R6X5XdAzK5rmxv5qOwapeq1TUT0X24uZz1I1qljPtX4PyOVrb86bsa4WKzo2qHsuKxg5g/rqp7Outssvf7nln+roDlfRbF2Vf15bNmsp6N97PdFzVZiyVPf6o4v5lx7bpspW91je+7qns9Zfp65aKHrOy02t63Cs5DlFHKs/XevsIgppYtmwZAgMDERgYiNzc3MbcNBERUZNmmrHXr1+3dDtERERNhmnGEhER1UWjXoAlIiIiIiIiIiIiak54AZaIiIiIiIiIiIiogdTbBdh169bh4MGD6NmzJ/R6PSZOnFhfqyYiImrWmLFERET1j/lKRESNpd6+hOvpp5+ur1URERGRCWYsERFR/WO+EhFRY+FHEBARERERERERERE1EF6AJSIiIiIiIiIiImogvABLRERERERERERE1EB4AZaIiIiIiIiIiIiogfACLBEREREREREREVED4QVYIiIiIiIiIiIiogbCC7BEREREREREREREDYQXYImIiIiIiIiIiIgaCC/AEhERERERERERETUQXoAlIiIiIiIiIiIiaiC8AEtERERERERERETUQHgBloiIiIiIiIiIiKiB8AIsERERERERERERUQPhBVgiIiIiIiIiIiKiYqEAeQAADV9JREFUBsILsEREREREREREREQNhBdgiYiIiIiIiIiIiBoIL8ASERERERERERERNRBegCUiIiIiIiIiIiJqILwAS0RERERERERERNRAeAGWiIiIiIiIiIiIqIHwAiwRERERERERERFRA+EFWCIiIiIiIiIiIqIGwguwRERERERERERERA2EF2CJiIiIiIiIiIiIGki9XoAdNmwYTpw4gaSkJEyfPr0+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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.6426818370819092\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v8(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, check_hlm=2, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["~# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":38,"metadata":{"id":"HHjIdn2MC4VE","executionInfo":{"status":"ok","timestamp":1653645779043,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ #\n","short_max_outg = get_max_outg_v4(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)\n","long_max_outg = get_max_outg_v4(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":40,"metadata":{"id":"gnSvYKIzC4VF","colab":{"base_uri":"https://localhost:8080/","height":502},"executionInfo":{"status":"error","timestamp":1653645804082,"user_tz":-540,"elapsed":394,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"42094947-0ec1-4da1-9e6b-efb38d1d836a"},"outputs":[{"output_type":"error","ename":"KeyError","evalue":"ignored","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/core/indexes/base.py\u001b[0m in \u001b[0;36mget_loc\u001b[0;34m(self, key, method, tolerance)\u001b[0m\n\u001b[1;32m   3360\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 3361\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_engine\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_loc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcasted_key\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   3362\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mKeyError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0merr\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/_libs/index.pyx\u001b[0m in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[0;34m()\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/_libs/index.pyx\u001b[0m in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[0;34m()\u001b[0m\n","\u001b[0;32mpandas/_libs/hashtable_class_helper.pxi\u001b[0m in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[0;34m()\u001b[0m\n","\u001b[0;32mpandas/_libs/hashtable_class_helper.pxi\u001b[0m in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[0;34m()\u001b[0m\n","\u001b[0;31mKeyError\u001b[0m: 'short_tr_5_45'","\nThe above exception was the direct cause of the following exception:\n","\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)","\u001b[0;32m<ipython-input-40-d5aec4c9a5f3>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     31\u001b[0m \u001b[0;31m#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     32\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 33\u001b[0;31m \u001b[0mshort_datas\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'short_'\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mdevided_cols\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mpublic_cols\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     34\u001b[0m \u001b[0mlong_datas\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'long_'\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mdevided_cols\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mpublic_cols\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     35\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<ipython-input-40-d5aec4c9a5f3>\u001b[0m in \u001b[0;36m<listcomp>\u001b[0;34m(.0)\u001b[0m\n\u001b[1;32m     31\u001b[0m \u001b[0;31m#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     32\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 33\u001b[0;31m \u001b[0mshort_datas\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'short_'\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mdevided_cols\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mpublic_cols\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     34\u001b[0m \u001b[0mlong_datas\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'long_'\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mdevided_cols\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mres_df\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcol\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcol\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mpublic_cols\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     35\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/core/frame.py\u001b[0m in \u001b[0;36m__getitem__\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   3456\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcolumns\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnlevels\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3457\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_getitem_multilevel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 3458\u001b[0;31m             \u001b[0mindexer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcolumns\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_loc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   3459\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mis_integer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindexer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3460\u001b[0m                 \u001b[0mindexer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mindexer\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/core/indexes/base.py\u001b[0m in \u001b[0;36mget_loc\u001b[0;34m(self, key, method, tolerance)\u001b[0m\n\u001b[1;32m   3361\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_engine\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_loc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcasted_key\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3362\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mKeyError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0merr\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 3363\u001b[0;31m                 \u001b[0;32mraise\u001b[0m \u001b[0mKeyError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0merr\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   3364\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3365\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mis_scalar\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0misna\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhasnans\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mKeyError\u001b[0m: 'short_tr_5_45'"]}],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_itv1 = 'T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF","colab":{"base_uri":"https://localhost:8080/","height":741},"executionInfo":{"status":"ok","timestamp":1652336000146,"user_tz":-540,"elapsed":2191,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0f96fffd-6b9a-4f7e-88ff-692d53ae921e"},"outputs":[{"output_type":"stream","name":"stdout","text":["661\n","661\n","661\n","661\n","pkx : [0.16567421 0.37261006 0.43912516 0.62388931]\n","pkx : [0.13770337 0.25029868 0.60309732]\n","\n","293\n","293\n","293\n","293\n","pkx : [-0.52628423 -0.45473521 -0.33365224 -0.2070655  -0.1300127  -0.02544105]\n","pkx : [-0.46075458 -0.25025689 -0.14500805 -0.04852994]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"983aUwM76s6X"}},{"cell_type":"code","source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"],"metadata":{"id":"p_e8PtFXa7mc"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["p1_hlm_p1_idx = long_obj[-1]"],"metadata":{"id":"nLZDkNNxbZPO"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"WhCPOi1qbkHS","executionInfo":{"status":"ok","timestamp":1653452376525,"user_tz":-540,"elapsed":261,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"metadata":{},"execution_count":161}]},{"cell_type":"code","source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"],"metadata":{"id":"wgERZ65F5RBB"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"],"metadata":{"id":"rAao95SEnOY0"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"OEQ9KWXVnQ2J","executionInfo":{"status":"ok","timestamp":1653119592395,"user_tz":-540,"elapsed":267,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["153\n","163\n"]},{"output_type":"execute_result","data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"metadata":{},"execution_count":220}]},{"cell_type":"code","source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"],"metadata":{"id":"hOtCGUeBQ4hn"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"],"metadata":{"id":"QPhjkZQhRLqr"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"],"metadata":{"id":"cFd7Fz0Y6ucU"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v3"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oVifICO4-Grk","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1652442940773,"user_tz":-540,"elapsed":52000,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5c9539c8-4fa9-4dd9-dbf0-a070618cccdf"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 -0.00000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 -0.00000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.6678133010864258\n","en_ex_pairing elapsed time : 0.00150299072265625\n","short_obj.shape : (0, 5)\n","long_obj.shape : (5, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.05000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.05000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.938042402267456\n","en_ex_pairing elapsed time : 0.006476640701293945\n","short_obj.shape : (8, 5)\n","long_obj.shape : (38, 5)\n","idep_plot elapsed time : 0.15370750427246094\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.10000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.10000 (1.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9340569972991943\n","en_ex_pairing elapsed time : 0.03796505928039551\n","short_obj.shape : (72, 5)\n","long_obj.shape : (230, 5)\n","idep_plot elapsed time : 0.16156935691833496\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.15000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.15000 (1.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9375967979431152\n","en_ex_pairing elapsed time : 0.1277174949645996\n","short_obj.shape : (319, 5)\n","long_obj.shape : (655, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.17165017127990723\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.20000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.20000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9565761089324951\n","en_ex_pairing elapsed time : 0.26297640800476074\n","short_obj.shape : (840, 5)\n","long_obj.shape : (1244, 5)\n","idep_plot elapsed time : 0.18038082122802734\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9551839828491211\n","en_ex_pairing elapsed time : 0.4788327217102051\n","short_obj.shape : (1505, 5)\n","long_obj.shape : (2026, 5)\n","idep_plot elapsed time : 0.19758844375610352\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9695498943328857\n","en_ex_pairing elapsed time : 0.6392936706542969\n","short_obj.shape : (2265, 5)\n","long_obj.shape : (2762, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21212220191955566\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.35000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.35000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9572036266326904\n","en_ex_pairing elapsed time : 0.8163747787475586\n","short_obj.shape : (3033, 5)\n","long_obj.shape : (3326, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.233687162399292\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9504046440124512\n","en_ex_pairing elapsed time : 0.9629926681518555\n","short_obj.shape : (3628, 5)\n","long_obj.shape : (3810, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.23377537727355957\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.45000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.45000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9773266315460205\n","en_ex_pairing elapsed time : 1.1199846267700195\n","short_obj.shape : (3987, 5)\n","long_obj.shape : (4096, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2484416961669922\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.50000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9605038166046143\n","en_ex_pairing elapsed time : 1.1008503437042236\n","short_obj.shape : (4218, 5)\n","long_obj.shape : (4177, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.24922657012939453\n"]},{"output_type":"stream","name":"stderr","text":["wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.55000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.55000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9583590030670166\n","en_ex_pairing elapsed time : 1.1536345481872559\n","short_obj.shape : (4339, 5)\n","long_obj.shape : (4220, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.24882173538208008\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.60000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.60000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9655780792236328\n","en_ex_pairing elapsed time : 1.1792562007904053\n","short_obj.shape : (4433, 5)\n","long_obj.shape : (4239, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.25986385345458984\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.65000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.65000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9574406147003174\n","en_ex_pairing elapsed time : 1.2422080039978027\n","short_obj.shape : (4452, 5)\n","long_obj.shape : (4098, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2535998821258545\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.70000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.70000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9548816680908203\n","en_ex_pairing elapsed time : 1.1278448104858398\n","short_obj.shape : (4382, 5)\n","long_obj.shape : (3992, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.25209593772888184\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.75000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.75000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9675965309143066\n","en_ex_pairing elapsed time : 1.1214463710784912\n","short_obj.shape : (4253, 5)\n","long_obj.shape : (3882, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n","wave_mm\n","np.sum(short_open_res == 1) : 79369\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2552158832550049\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.80000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.80000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.2942922115325928\n","en_ex_pairing elapsed time : 1.1557459831237793\n","short_obj.shape : (4074, 5)\n","long_obj.shape : (3755, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.24727678298950195\n"]},{"output_type":"stream","name":"stderr","text":["wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.85000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.85000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9597580432891846\n","en_ex_pairing elapsed time : 1.0517606735229492\n","short_obj.shape : (3823, 5)\n","long_obj.shape : (3569, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.26427507400512695\n"]},{"output_type":"stream","name":"stderr","text":["wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.90000 (1.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.90000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0179243087768555\n","en_ex_pairing elapsed time : 1.0500407218933105\n","short_obj.shape : (3840, 5)\n","long_obj.shape : (3553, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 79370\n","np.sum(long_open_res == 1) : 79066\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.25498342514038086\n"]},{"output_type":"stream","name":"stderr","text":["wave_mm\n","np.sum(short_open_res == 1) : 79369\n","np.sum(long_open_res == 1) : 79062\n","point validation\n","np.sum(short_open_res == 1) : 78627\n","np.sum(long_open_res == 1) : 78425\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.95000 (1.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.18178 0.95000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0456984043121338\n","en_ex_pairing elapsed time : 1.3167588710784912\n","short_obj.shape : (3666, 5)\n","long_obj.shape : (3300, 5)\n","idep_plot elapsed time : 0.2509620189666748\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAABXYAAAILCAYAAABM08RlAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdd1QUVxsG8IcuiAqCohRBFBBEAY0lNmKJLRo1GmOLGI2Jxp5iiQWVaDTRzxRLjLFgxR4xmtijxmBEUQRBKSICAqIiRTrc7w/jRhSkLTs78PzOec9hd2dn3tll5t25M3OvBgABIiIiIiIiIiIiIpINTakTICIiIiIiIiIiIqKyYcMuERERERERERERkcywYZeIiIiIiIiIiIhIZtiwS0RERERERERERCQzbNglIiIiIiIiIiIikhk27BIRERERERERERHJDBt2iV7g6emJbdu2SZ0GERERFSEqKgrdu3eXOg0iIiIqhhACTZo0Ucq8PDw8cP78eaXMi6gqYsMuUSXbvHkzvLy8pE6DiIiIiIiISG1ZW1tDCAEtLS2pUyGSDTbsElUiTU1uYkREREREREREpHxsdaJqa+bMmYiNjUVqaipu3ryJbt26KV7T1dWFt7c3UlNTERwcjNatWytea9asGc6cOYPk5GQEBwejf//+itc2b96MtWvX4siRI0hPT8e4ceMwcuRIzJw5E2lpafD19VXpOhIREVVlurq6WLVqFeLi4hAXF4dVq1ZBV1cXAODu7o6YmBh8+umnSExMxL179zBmzBjFe+vWrQtfX1+kpKTg0qVL8PLy4q2eREREStK3b19ERkYiKSkJ33zzDTQ0NAAAGhoamDt3Lu7cuYPExER4e3ujdu3aAIBz584BAB4/foy0tDS0b99eMb9vv/0Wjx49wu3bt9G7d2/VrxCRGhMMRnULe3t7cffuXdGwYUMBQFhbWwtbW1sBQHh6eorMzEzRp08foampKZYuXSr8/PwEAKGtrS3Cw8PFnDlzhI6OjujatatITU0V9vb2AoDYvHmzePz4sejQoYPQ0NAQenp6YvPmzcLLy0vydWYwGAwGoypEVFSU6N69uwAgFi1aJPz8/ES9evWEqampuHDhgli8eLEAINzd3UVubq5YtGiR0NbWFn369BFPnjwRRkZGAoDYtWuX2LVrl9DX1xeOjo7i7t274vz585KvH4PBYDAYcg8hhDh9+rQwNjYWVlZW4tatW2LcuHECgPjggw9EeHi4aNy4sahZs6bYv3+/2Lp1qwCeHpcLIYSWlpZiXh4eHiInJ0d8+OGHQlNTU0yYMEHExcVJvo4MhhqF5AkwGCqPJk2aiMTERNG9e3ehra1d6DVPT09x4sQJxWNHR0eRkZEhAIhOnTqJ+Ph4oaGhoXh9586dwtPTUwBPG3a9vb0LzY8NuwwGg8FgKC+eb9iNiIgQffr0UbzWs2dPERUVJYCnDbsZGRmFDg4TExNFu3bthKampsjJyVGcmAUgvLy82LDLYDAYDIYSQgghevXqpXg8ceJEcfLkSQFAnDx5UkycOFHxmr29vcjJyRFaWlrFNuyGh4crHuvr6wshhDAzM5N8PRkMdQh2xUDVUmRkJKZPn46FCxfi/v372LVrFxo2bKh4PSEhQfF3RkYG9PX1oaWlBXNzc8TExEAIoXg9OjoaFhYWiscxMTGqWQkiIqJqztzcHNHR0YrH0dHRMDc3Vzx++PAh8vPzFY8zMjJgaGiIevXqQUdHp1DNZv0mIiJSnufr6vP1uajaraOjAzMzs2Ln9fzxeWZmJgDA0NBQ2SkTyRIbdqna2rVrFzp37qwYeXP58uUlvufevXuwsrJS9A8EAI0aNUJcXJzi8fONvkU9JiIiIuW4d+8erK2tFY8bNWqEe/fulfi+pKQk5ObmwtLSUvGclZVVpeRIRERUHT1fV5+vz0XV7tzcXCQmJvLYmagc2LBL1ZK9vT26du0KXV1dZGVlITMzEwUFBSW+759//kFGRgZmzpwJbW1tuLu7o3///vDx8Sn2PYmJibC1tVVm+kRERISnJ2nnzZsHU1NTmJiYYMGCBdi+fXuJ7ysoKMCBAwewcOFC6Ovrw8HBAaNHj1ZBxkRERNXDF198ASMjI1haWmLatGnYvXs3gKe1e8aMGbCxsUHNmjWxdOlS7N69G/n5+UhKSkJ+fj6Pn4nKgA27VC3p6elh2bJlePDgARISElC/fn3MmTOnxPfl5uaif//+6NOnDx48eIC1a9di9OjRuHXrVrHv2bhxI5ycnJCcnIyDBw8qczWIiIiqta+++gqXL1/G9evXERQUhICAAHz11Veleu/kyZNRp04dJCQkYNu2bdi1axeys7MrOWMiIqLq4dChQ7hy5QquXbuGI0eOYOPGjQCATZs2Ydu2bTh37hyioqKQlZWFKVOmAHjazcKSJUtw4cIFJCcno127dlKuApEsaOBpZ7tERERERNXWsmXL0KBBA4wZM0bqVIiIiIiISoVX7BIRERFRtePg4IAWLVoAANq0aYNx48bxzhoiIiIikhVtqRMgIiIiIlK1WrVqYdeuXTA3N0diYiJWrlyJQ4cOSZ0WEREREVGpsSsGIiIiIiIiIiIiIplhVwxEREREREREREREMsOGXSIiIiIiIiIiIiKZYcMuERERERERERERkcywYZeIiIiIiIiIiIhIZtiwS0RERERERERERCQzbNglIiIiIiIiIiIikhk27BIRERERERERERHJDBt2iYiIiIiIiIiIiGSGDbtEREREREREREREMsOGXSIiIiIiIiIiIiKZYcMuERERERERERERkcywYZeIiIiIiIiIiIhIZtiwS0RERERERERERCQzbNglIiIiIiIiIiIikhk27BIRERERERERERHJDBt2iYiIiIiIiIiIiGSGDbtEREREREREREREMsOGXSIiIiIiIiIiIiKZYcMuERERERERERERkcywYZeIiIiIiIiIiIhIZtiwS0RERERERERERCQzbNglIiIiIiIiIiIikhk27BIRERERERERERHJDBt2iYiIiIiIiIiIiGSGDbtEREREREREREREMsOGXSIiIiIiIiIiIiKZYcMuERERERERERERkcywYZeIiIiIiIiIiIhIZtiwS0TFioqKQvfu3aVOg5Rk8+bN8PLyKnG6GjVqwNfXF48fP8aePXtUkBkRUfXC+lr1sMYSEakH1tiqhfW1ZGzYldjw4cNx584dpKen4+DBgzA2Ni522n79+iEoKAhpaWm4cOECHB0dFa95eHggLy8PaWlpinB3d1fFKqgVIQSaNGkidRqkYsbGxjhw4ADS09Nx584dDB8+/JXTu7m54ezZs0hLS0NCQgKmTp2qeC0qKgoZGRmK7ejYsWOVnb7aGTJkCMzMzGBiYoKhQ4e+ctqy7MNcXFxw+fJlPHnyBJcvX4aLi4viNU9PT+Tk5BTahzVu3Fhp60TVD+ur8rHGVj/KrK/W1tY4ffo0njx5gtDQ0Gp70M0aS1UBa6zyscZWP6yxylWd6ysbdktJS0tL6fN0cnLC+vXr8f7778PMzAwZGRlYu3ZtkdM2bdoUO3bswIQJE2Bk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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","val_list = np.arange(-0.0, -0.5, -0.03)  # prcn 2\n","val_list = np.arange(-0.0, 1, 0.05)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  config_list_copy[0].loc_set.point.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  # config_list_copy[0].tr_set.ep_gap = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    # enlist_rtc(res_df, config_, np_timeidx)\n","    enlist_tr(res_df, config_, np_timeidx)\n","  open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","\n","  try:\n","    result.append(get_res_v5(res_df, open_info_df, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":21,"metadata":{"id":"eiQ36_SLLE3w","executionInfo":{"status":"ok","timestamp":1653629640520,"user_tz":-540,"elapsed":355,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def get_res_v8(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, check_hlm=0, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v8(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, check_hlm, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":22,"metadata":{"id":"xafHpMLwESKf","executionInfo":{"status":"ok","timestamp":1653629642539,"user_tz":-540,"elapsed":329,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def idep_plot_v16(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    # print(\"short_obj.shape :\", short_obj.shape)\n","    # print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_p2_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"code","source":["def plot_info_v8(gs, gs_idx, len_df, sample_len, tr, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize) #, color='yellow')\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"],"metadata":{"id":"I9GysZ5_vv5J"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v8(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, check_hlm=0, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    close = ohlc_list[3]\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ======\".format(op_idx1, open_side))\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry on p1_loop continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        if check_hlm in [0, 1]:\n","          i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","          if open_i2 >= len_open_idx2:  # open_i2 소진\n","              break\n","\n","          if show_detail:\n","            print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","          # ------ check side sync. ------ #\n","          if open_side != side_arr2[open_i2]:\n","            continue\n","\n","          op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","          if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","            continue\n","          \n","          if show_detail:\n","            print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","          \n","          i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          tp_ = tp_arr[op_idx1]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          \n","          # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","          # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","          # if not check_net_hhm:\n","          if check_hlm:  # p1_hlm, p2_hlm\n","            if op_idx1 < op_idx2:\n","              expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","              if expire:   # p1's expiry\n","                  if show_detail:\n","                    print(\"expiry_p1 break {}\".format(touch_idx))\n","                  i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                  open_i2 = prev_open_i2\n","                  break   # change op_idx1\n","          \n","          # ------ point validation ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","          if open_side == OrderSide.SELL:\n","            if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","              break  # change op_idx1\n","            elif not (ep2_ < out_ and close[op_idx2] < out_):\n","              continue  # change op_idx2\n","          else:\n","            if not (tp_ > ep2_):              \n","              break\n","            elif not (ep2_ > out_ and close[op_idx2] > out_):\n","              continue\n","\n","          # ------ tr_threshold ------ #\n","          if check_hlm:          \n","            if open_side == OrderSide.SELL:\n","              tr_ = abs((ep2_ / tp_ - config.trader_set.limit_fee - 1) / (ep2_ / out_ - config.trader_set.market_fee - 1))\n","              if tr_ < config.loc_set.point1.short_tr_thresh:\n","                continue\n","            else:\n","              tr_ = abs((tp_ / ep2_ - config.trader_set.limit_fee - 1) / (out_ / ep2_ - config.trader_set.market_fee - 1))\n","              if tr_ < config.loc_set.point1.long_tr_thresh:\n","                continue\n","\n","          if check_hlm == 2:\n","            # ------ p2_box location ------ #\n","            if open_side == OrderSide.SELL:\n","              if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                if show_detail:\n","                    print(\"p2_box continue\")\n","                continue\n","            else:\n","              if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                if show_detail:\n","                    print(\"p2_box continue\")\n","                continue\n","                  \n","            # ------ check p2's expiry ------ #\n","            exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx2, out_1_, out_gap_, len_df, open_side,\n","                                                                                    [*ohlc_list, ep2_arr], expiry_p2)   # tp_j 는 op_idx1 사용\n","            i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","            if not entry_done:   # p2's expiry\n","                if show_detail:\n","                    print(\"expiry_p2 continue {}\".format(i))\n","                continue  # change op_idx2\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ # --> p1_hlm 의 경우, 1번만 실행\n","          if not allow_exit:\n","            continue\n","\n","          while 1:\n","              if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                  tp_j = i\n","              if not config.out_set.static_out:\n","                  out_j = i\n","\n","              # ------------ out ------------ #  # out 우선 (보수적 검증)\n","              # ------ signal_out ------ #\n","              if not exit_done:\n","                  exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","              # ------ hl_out ------ #\n","              if config.out_set.hl_out != \"None\":\n","                  if not exit_done:  # and i != len_df - 1:\n","                      exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","              # ------------ tp ------------ #\n","              if not config.tp_set.non_tp and i != exec_j:\n","                if not exit_done:\n","                  exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                            [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                  # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                  # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","              if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                  # ------ append dynamic vars. ------ #\n","                  p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                  p2_idx_list.append(op_idx2)\n","                  pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                  pair_price_list.append([en_p, ex_p])\n","                  lvrg_list.append(leverage)\n","                  fee_list.append(fee)\n","                  tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                  tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                  # open_i += 1  # 다음 open_idx 조사 진행\n","                  break\n","\n","              # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","              # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","              i += 1\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done\n","            if show_detail:\n","                    print(\"exit_done = {} break {}\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:\n","            if check_hlm:\n","              if check_hlm == 1:   # exit only once in p1_hlm mode\n","                allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {} continue {}\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {} break {}\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_entry_v5(res_df, config, op_idx, wave1, wave0, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave0, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[i] < ha_c[i]):# & (ha_o[i] == ha_l[i]):   # 양봉 출현\n","    #           exit_done = -1\n","    #     else:\n","    #       if (ha_o[i] > ha_c[i]):# & (ha_o[i] == ha_h[i]):  # 음봉 출현\n","    #           exit_done = -1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[i] < bb_lower_5T[i] < close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] > bb_upper_5T[i] > close[i - 1]:\n","                exit_done = -1\n","        else:\n","            if close[i] > bb_upper_5T[i] > close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] < bb_lower_5T[i] < close[i - 1]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"qM6H6fmrKtsA"}},{"cell_type":"code","source":["res_df.low.rolling(100) #> 1000"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"oLDZobRcgg6E","executionInfo":{"status":"ok","timestamp":1653436951068,"user_tz":-540,"elapsed":260,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"metadata":{},"execution_count":92}]},{"cell_type":"code","source":["def get_touch_idx_fill(tp_1_touch_idxs, net_p1_pair, net_p1_idx, len_df):\n","\n","    tp_1_touch_idx = np.full(len_df, np.nan)\n","    tp_1_touch_idx[net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair]\n","    \n","    return fill_arr(tp_1_touch_idx)\n","    \n","def get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_tpbox_p2exec_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_tpbox_p2exec_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"],"metadata":{"id":"uB-I09hKKvmu","executionInfo":{"status":"ok","timestamp":1653629956497,"user_tz":-540,"elapsed":828,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":24,"outputs":[]},{"cell_type":"code","source":["def get_wave_bias_v4(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)  # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ------------------ touch idx ------------------ #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    short_tp_1_touch_idx = pd.Series(np.where(low <= short_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_tp_0_touch_idx = pd.Series(np.where(high >= short_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_1_touch_idx = pd.Series(np.where(high >= long_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_0_touch_idx = pd.Series(np.where(low <= long_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_out_1_touch_idx = pd.Series(np.where(low <= short_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_out_0_touch_idx = pd.Series(np.where(high >= short_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_1_touch_idx = pd.Series(np.where(high >= long_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_0_touch_idx = pd.Series(np.where(low <= long_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    # print(np.sum(np.isnan(short_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(short_tp_0_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_0_unq_p1_touch_idx)))\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","    \n","    # print(\"np.sum(short_net_p1_true_bias_bool) :\", np.sum(short_net_p1_true_bias_bool))\n","    # print(\"np.sum(long_net_p1_true_bias_bool) :\", np.sum(long_net_p1_true_bias_bool))\n","\n","    # print(\"np.sum(short_unq_p1_true_bias_bool) :\", np.sum(short_unq_p1_true_bias_bool))\n","    # print(\"np.sum(short_unq_p1_false_bias_bool) :\", np.sum(short_unq_p1_false_bias_bool))\n","    # print(\"np.sum(long_unq_p1_true_bias_bool) :\", np.sum(long_unq_p1_true_bias_bool))\n","    # print(\"np.sum(long_unq_p1_false_bias_bool) :\", np.sum(long_unq_p1_false_bias_bool))\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"],"metadata":{"id":"FuIwazc3P5d1"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"],"metadata":{"id":"6YcqQQzsl6Ys","executionInfo":{"status":"ok","timestamp":1653630323394,"user_tz":-540,"elapsed":506,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":28,"outputs":[]},{"cell_type":"code","source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "],"metadata":{"id":"t7a5Hyyyd5Lk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"],"metadata":{"id":"dsI-R8Zz7ls1"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"],"metadata":{"id":"gMur2u8WeQ2K","colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"status":"ok","timestamp":1652751452213,"user_tz":-540,"elapsed":350,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"execution_count":null,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1152x144 with 2 Axes>"],"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n"},"metadata":{}}]},{"cell_type":"code","source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"id":"eoXMxRm3qdz2","executionInfo":{"status":"ok","timestamp":1652756329304,"user_tz":-540,"elapsed":872,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"execution_count":null,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1152x144 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}]},{"cell_type":"code","source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"],"metadata":{"id":"dm7ZqzS9vqhm"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"],"metadata":{"id":"qOE2YSzntx8v"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_plot_params"]},{"cell_type":"code","execution_count":38,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1653632441605,"user_tz":-540,"elapsed":324,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 4     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick, 5 : bias_tick (사용 금지)\n","\n","bias_plot = 0     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = 0   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 100 #  150 100 20 500\n","post_plotsize = 160 # config.tr_set.bias_info_tick -> excessive bit 는 감당 못함\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","    if pr_descend == -1:\n","      pr_descend = 0\n","    pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":31,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":380,"status":"ok","timestamp":1653630566818,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"e7a2e86a-4425-45f4-d3f0-314f37eef292","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period1 = config.tr_set.wave_period1\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 1\n","dc_tf2 = '15T'\n","dc_period2 = 1\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 60\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","# data_window_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","# data_window_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  # \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":39,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1NZKWPcWegPj9Um5WBIn3VunbwtOB2R6o"},"executionInfo":{"status":"error","timestamp":1653632555938,"user_tz":-540,"elapsed":112893,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"c7fda866-642e-47e6-abf0-04b0d60fb0d4"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["_ = [plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v8(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v8(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","  elif back_plot == 5:\n","    x_max = bias_info_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------------ ax2 ------------ #\n","  # ------ band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  if back_plot == 5:\n","    ax1.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","x2yj2SwAXDLp","14chOHeXh6JD","xpyP5t8Ht_pE","MuD_2vY7TI_8","983aUwM76s6X"],"name":"stem5_45_vec_backi2(0521_ep1n2).ipynb","toc_visible":true,"provenance":[],"authorship_tag":"ABX9TyOLwc/5vbm+9kKxfP88L8M7"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}