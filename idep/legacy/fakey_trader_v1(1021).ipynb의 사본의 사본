{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1666402967171,"user_tz":-540,"elapsed":20463,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"3cac49e6-c919-4246-ff2b-9a7103e5ebe6"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1666402982555,"user_tz":-540,"elapsed":15388,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    df = h_candle_v4(df, df_H)\n","    df = h_candle_v4(df, df_4H)\n","\n","    # df = get_hhll(df, '15T')\n","    # df = get_hhll(df, '30T')\n","    df = get_hhll(df, 'H')\n","    df = get_hhll(df, '4H')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","    \n","    # --------------- stochastic --------------- #\n","    # df = stoch_v2(df)\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","    # --------------- ma --------------- #  \n","    # df = ma(df, 60)\n","    # print(\"ma phase done\")\n","\n","    # df = macd_hist(df, 5, 35, 15)\n","    # print(\"macd_hist phase done\")\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    # dc_period = 20\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df, dc_period=10)\n","    # df = dc_line_v4(df, df, dc_period=20)\n","    # df = dc_line_v4(df, df, dc_period=100)\n","    # df = dc_line_v4(df, df_5T, dc_period=20)\n","    # df = dc_line_v4(df, df_15T, dc_period=20)\n","    # df = dc_line_v4(df, df_H, dc_period=20)\n","    # df = dc_line_v4(df, df_4H, dc_period=20)\n","    # print(\"dc phase done\")\n","\n","    # df_5T = cci_v2(df_5T, 20)\n","\n","    # df_5T = tc_cci(df_5T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-3, -2, -1]), how='inner')\n","    \n","\n","    # --------------- lucid sar --------------- #\n","    # sar_ = talib.SAREXT(df_5T.high.to_numpy(), df_5T.low.to_numpy(),\n","    #                            startvalue=0.0, offsetonreverse=0,\n","    #                            accelerationinitlong=0.02, accelerationlong=0.02, accelerationmaxlong=0.2,\n","    #                            accelerationinitshort=0.02, accelerationshort=0.02, accelerationmaxshort=0.2)\n","\n","    # df_5T['sar_5T'] = sar_\n","    # b1_sar_ = df_5T['sar_5T'].shift(1).to_numpy()\n","    \n","    # df_5T['sar_trend_5T'] = np.where(sar_ > 0, 1, 0)\n","    # # df_5T['sar_tc_5T'] = np.where((sar_ < 0 & b1_sar_ > 0) | (sar_ > 0 & b1_sar_ < 0), 1, 0)\n","    # # df_5T['sar_tc_5T'] = np.where((sar_ < 0 and b1_sar_ > 0) | (sar_ > 0 and b1_sar_ < 0), 1, 0)\n","    # df_5T['sar_5T'] = np.where(sar_ < 0, -sar_, sar_)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-1, -2]), how='inner')\n","\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 100\n","    \n","    # df = bb_line_v3(df, df_15T, 20)\n","    # df = bb_level_v2(df, '15T', 20)\n","\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")        \n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"elapsed":2270,"status":"ok","timestamp":1666007990943,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"odqVwQHpYo1M","outputId":"fb3cd5ad-8b9d-465e-a3d0-f6bdcf260b07"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                           low_H  close_H  open_4H  high_4H   low_4H  close_4H   hh_H   ll_H  hh_4H  ll_4H\n","index                                                                                                     \n","2022-04-27 08:41:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:42:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:43:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:44:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False\n","2022-04-27 08:45:59.999  2761.27  2800.43  2837.34   2855.0  2761.27   2800.43  False  False  False  False"],"text/html":["\n","  <div id=\"df-da39659c-5631-4cad-8978-21846b8ba3c3\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>low_H</th>\n","      <th>close_H</th>\n","      <th>open_4H</th>\n","      <th>high_4H</th>\n","      <th>low_4H</th>\n","      <th>close_4H</th>\n","      <th>hh_H</th>\n","      <th>ll_H</th>\n","      <th>hh_4H</th>\n","      <th>ll_4H</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>2837.34</td>\n","      <td>2855.0</td>\n","      <td>2761.27</td>\n","      <td>2800.43</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","      <td>False</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-da39659c-5631-4cad-8978-21846b8ba3c3')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-da39659c-5631-4cad-8978-21846b8ba3c3 button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-da39659c-5631-4cad-8978-21846b8ba3c3');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":240}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gOQxwYqK0jCS"},"outputs":[],"source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmiB5VU5DN6B"},"outputs":[],"source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1644,"status":"ok","timestamp":1666007998453,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"b740e17a-7566-442b-92d0-3edb22d8d095"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":5676,"status":"ok","timestamp":1666402988226,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"7FPBG5Qqg2jB","outputId":"10fc6f28-007f-4d33-8bae-697dd3d92e28"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 5.108432054519653\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes\n","# res_df_.index[[0, -1]]"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","\n","# ------ check target cols ------ #\n","# print([col_ for col_ in col_list if 'cci_5T' in col_])\n","\n","# ------ drop ------ #\n","res_df_.drop([col_ for col_ in col_list if 'bb' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'll_15' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'cci_5T' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["def get_wave_time_ratio(res_df, wave_itv1, wave_period1):\n","\n","  wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","  wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","\n","  wave_cu_idx_fill_ = res_df['wave_cu_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","  wave_co_idx_fill_ = res_df['wave_co_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(int)\n","\n","  wave_valid_cu_post_idx_fill_ = np.where(wave_cu_post_idx_fill_ < 0, 0, wave_cu_post_idx_fill_)\n","  wave_valid_co_post_idx_fill_ = np.where(wave_co_post_idx_fill_ < 0, 0, wave_co_post_idx_fill_)\n","\n","  wave_valid_cu_idx_fill_ = np.where(wave_cu_idx_fill_ < 0, 0, wave_cu_idx_fill_)\n","  wave_valid_co_idx_fill_ = np.where(wave_co_idx_fill_ < 0, 0, wave_co_idx_fill_)\n","\n","  res_df['short_wave_time_ratio_{}{}'.format(wave_itv1, wave_period1)] = (wave_valid_co_post_idx_fill_ - wave_valid_cu_post_idx_fill_[wave_valid_co_post_idx_fill_[wave_valid_cu_idx_fill_]]) / (wave_valid_cu_idx_fill_ - wave_valid_co_post_idx_fill_)\n","  res_df['long_wave_time_ratio_{}{}'.format(wave_itv1, wave_period1)] = (wave_valid_cu_post_idx_fill_ - wave_valid_co_post_idx_fill_[wave_valid_cu_post_idx_fill_[wave_valid_co_idx_fill_]]) / (wave_valid_co_idx_fill_ - wave_valid_cu_post_idx_fill_)\n","\n","  return res_df"],"metadata":{"id":"Fg4JnLY6i99D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def wave_range_cci_v4_1(t_df, wave_period):\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    baseline = 0\n","    band_width = 100\n","    upper_band = baseline + band_width\n","    lower_band = baseline - band_width\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    ohlc_list = [t_df[col_].to_numpy() for col_ in data_cols]\n","    open, high, low, close = ohlc_list\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    return wave_publics_v2(t_df, cu_bool, co_bool, ohlc_list, wave_period)"],"metadata":{"id":"XkrbzNFKZhl0"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def wave_publics_v2(t_df, cu_bool, co_bool, ohlc_list, wave_period):\n","    itv = pd.infer_freq(t_df.index)\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    open, high, low, close = ohlc_list\n","\n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","        cu_idx, co_idx, len_df, len_df_range)\n","    # cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #   cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v5(cu_idx, co_idx, len_df, len_df_range)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ get post_idx ------ #\n","    paired_cu_post_idx = high_post_terms[:, 1]  # Todo, 여기는 cross_idx (위에서 vstack 으로 cross_idx 입력함)\n","    paired_co_post_idx = low_post_terms[:, 1]\n","\n","    cu_post_idx = np.full(len_df, np.nan)  # --> Todo, unavailable : not cross_idx\n","    co_post_idx = np.full(len_df, np.nan)\n","\n","    cu_post_idx[paired_cu_post_idx] = paired_cu_post_idx\n","    co_post_idx[paired_co_post_idx] = paired_co_post_idx\n","\n","    cu_post_fill_idx = fill_arr(cu_post_idx)\n","    co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_cu_post_idx] = wave_highs\n","    wave_low_[paired_co_post_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_cu_post_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_post_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    # ------ term cnt ------ #\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_post_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_co_post_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    # b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    # b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    # wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    # wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","    #\n","    # high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    # low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","    t_df['wave_update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool  # temporary, for plot_check\n","    t_df['wave_update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool  # * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool  # * ~update_high_co_bool\n","    \n","    t_df['wave_cu_idx_fill_{}{}'.format(itv, wave_period)] = cu_fill_idx\n","    t_df['wave_co_idx_fill_{}{}'.format(itv, wave_period)] = co_fill_idx\n","\n","    t_df['wave_co_post_idx_{}{}'.format(itv, wave_period)] = co_post_idx  # paired_\n","    t_df['wave_cu_post_idx_{}{}'.format(itv, wave_period)] = cu_post_idx  # paired_\n","    t_df['wave_co_post_idx_fill_{}{}'.format(itv, wave_period)] = co_post_fill_idx\n","    t_df['wave_cu_post_idx_fill_{}{}'.format(itv, wave_period)] = cu_post_fill_idx\n","\n","    # Todo, idx 저장은 sync. 가 맞는 tf_df 에 대하여 적용하여야함\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력 = 뜻 : high_term's prime co_idx (high_prime_idx = wave_high 를 만들기 위한 가장 앞단의 co_idx)\n","    t_df['wave_co_prime_idx_{}{}'.format(itv,\n","                                         wave_period)] = co_prime_idx  # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_cu_prime_idx_{}{}'.format(itv,\n","                                         wave_period)] = cu_prime_idx  # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx  # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx  # cu_prime_fill_idx low_prime_idx_fill_\n","\n","    # ------ for plot_checking ------ #\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","\n","    return t_df"],"metadata":{"id":"FdDkSxbaX4AI"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","metadata":{"id":"O1uu9vQnY5dn"},"source":["##### plot_check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 336424\n","\n","plot_size = 300 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PgaNnempXRd_"},"outputs":[],"source":["wave_itv1, wave_period1 = 'T', 20\n","roll_hl_cnt = 3\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)  # to_htf 는 ohlc, 4개의 col 만 존재 (현재까지)\n","    htf_df = wave_range_cci_v4_1(htf_df, wave_period1)\n","    # htf_df = wave_range_dc_envel_v1(htf_df, wave_period1)\n","    \n","\n","    cols = list(htf_df.columns)  # 그냥 다 넣어버리기 (추후 혼란 방지)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])  # wrr 은 4개의 cols\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  t_df = wave_range_cci_v4_1(t_df, wave_period1)\n","  # t_df = wave_range_stoch_v1(t_df, wave_period1)\n","  # t_df = wave_range_dc_envel_v1(t_df, wave_period1)\n","\n","  valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","  t_df = wave_range_ratio_v4_2(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"]},{"cell_type":"code","source":["def wave_range_cci_v4_1(t_df, wave_period, band_width=100):\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    baseline = 0\n","    upper_band = baseline + band_width\n","    lower_band = baseline - band_width\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    ohlc_list = [t_df[col_].to_numpy() for col_ in data_cols]\n","    open, high, low, close = ohlc_list\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    return wave_publics_v3(t_df, cu_bool, co_bool, ohlc_list, wave_period)"],"metadata":{"id":"WM85fKSd9F7f"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"elapsed":2786,"status":"ok","timestamp":1663393141160,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"-Dr_tTk9csFm","outputId":"53ac4f58-eff0-4346-f28e-dc30e6835245"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_high_idx_fill_ = t_df['wave_high_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_idx_fill_ = t_df['wave_low_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","\n","wave_cu_prime_idx_ = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_ = t_df['wave_co_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_prime_idx_fill_ = t_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_fill_ = t_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_post_idx_ = t_df['wave_cu_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_ = t_df['wave_co_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_post_idx_fill_ = t_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_fill_ = t_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","# plt.step(len_df_range, t_df['dc_upper_{}{}'.format(wave_itv1, wave_period1)], color='#ffeb3b')\n","# plt.step(len_df_range, t_df['dc_lower_{}{}'.format(wave_itv1, wave_period1)], color='#ffeb3b')\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# ------ data check in gs[0] ------ #\n","plt.axvline(wave_cu_post_idx_fill_[230], color='r')\n","plt.axvline(wave_cu_prime_idx_fill_[230])\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","\n","# --- cci --- #\n","cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","\n","# --- stoch --- #\n","# stoch_ = t_df['stoch_{}{}33'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, stoch_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.axhline(67, color=\"#ffffff\")\n","# plt.axhline(33, color=\"#ffffff\")\n","\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]   # long 이라서 초록색임\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"code","source":["# wave_high_idx_fill_[200]\n","print(wave_low_idx_fill_[200])\n","print(wave_low_idx_fill_[210])\n","\n","y = (y1 - y0) / (x1 - x0) * x + y0 # x : x0 부터의 ticks "],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"x-ob07j19TUf","executionInfo":{"status":"ok","timestamp":1663393203342,"user_tz":-540,"elapsed":361,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2c6894ee-421c-492b-d658-042bafe57265"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["149.0\n","208.0\n"]}]},{"cell_type":"markdown","metadata":{"id":"c2yVTn1tnxMn"},"source":["###### data_window"]},{"cell_type":"code","source":["# print(valid_high_prime_idx)  # = valid_co_prime_idx\n","# print(roll_prev_high_idx_arr)   # = roll_prev_co_idx_arr\n","print(valid_low_prime_idx)  # = valid_co_prime_idx\n","print(roll_prev_low_idx_arr)   # = roll_prev_co_idx_arr"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"6bra-Br3lq1h","executionInfo":{"status":"ok","timestamp":1660483201485,"user_tz":-540,"elapsed":351,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"8c90e368-24c7-439e-9733-567d4848859a"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["[ 39  45 124 164]\n","[[ 39  45 124]\n"," [ 45 124 164]]\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":345,"status":"ok","timestamp":1660484147094,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"0DgdFydfB1f-","outputId":"1677cb32-6a71-4292-b49a-204f7da8ed20"},"outputs":[{"output_type":"stream","name":"stdout","text":["145.0\n","239.0\n"]}],"source":["idx = 239\n","# print(wave_cu_post_idx_fill_[idx])\n","# print(wave_co_prime_idx_fill_[idx - 1])\n","# print(wave_co_post_idx_fill_[idx - 1])\n","# print(wave_co_prime_idx_fill_[idx])\n","print(wave_co_post_idx_fill_[int(wave_cu_post_idx_fill_[idx])])\n","print(wave_co_idx_[idx])\n","\n","# print(len(t_df))\n","# len(wave_co_prime_idx_fill_)"]},{"cell_type":"code","source":["wave_co_idx_[~np.isnan(wave_co_idx_)]"],"metadata":{"id":"7zLNu-8gjeJ1"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zj_d5wsfDzf_"},"outputs":[],"source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Z-EokTzIqb-T"},"outputs":[],"source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"]},{"cell_type":"markdown","metadata":{"id":"Q_1wJTcRYpm8"},"source":["##### legacy"]},{"cell_type":"code","source":["def get_next_fibo_gap(x):\n","  if 0 < x < 0.214:\n","    return -0.786\n","  elif 0.214 < x < 0.382:\n","    return -0.618\n","  elif 0.382 < x < 0.5:\n","    return -0.5\n","  elif 0.5 < x < 0.618:\n","    return -0.382\n","  elif 0.618 < x < 0.764:\n","    return -0.236\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로.\n","\n","\n","def get_next_fibo_gap2(x):\n","  if 0 < x < 0.214:\n","    return -0.618\n","  elif 0.214 < x < 0.382:\n","    return -0.5\n","  elif 0.382 < x < 0.5:\n","    return -0.382\n","  elif 0.5 < x < 0.618:\n","    return -0.236\n","  elif 0.618 < x < 0.764:\n","    return 0\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로."],"metadata":{"id":"Bmp7faPhzydp"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"02DcTVB2cYuR"},"source":["##### dump"]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"fjGcs9ngkh5s"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"],"metadata":{"id":"CLYKs7ItkgIa"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Go7ARIUhfC1g"},"outputs":[],"source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pgA8QqyXZ66o"},"outputs":[],"source":["t_df[roll_cols].tail(100)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wF7fKJ3mOhaf"},"outputs":[],"source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3vHLGont-BFe"},"outputs":[],"source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Mh3w2s-j34Zs"},"outputs":[],"source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1651799326382,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eQ06-kWq4m6F","outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"outputs":[{"name":"stdout","output_type":"stream","text":["11\n","11\n"]}],"source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SUFmr9Z_kcCN"},"outputs":[],"source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_3pOQtt2ttfk"},"outputs":[],"source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1651756811396,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"kKaD1fK3WPRP","outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"outputs":[{"data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"execution_count":79,"metadata":{},"output_type":"execute_result"}],"source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","metadata":{"id":"RZJ6uIA_VcJs"},"source":["##### instant."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLWAP1Cl2Hvu"},"outputs":[],"source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"H_zPYIshbZgP"},"outputs":[],"source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"o3IUBc59VR5D"},"outputs":[],"source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u3yFd8Dcok5m"},"outputs":[],"source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JWj02LLGbnji"},"outputs":[],"source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":4,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1666402991179,"user_tz":-540,"elapsed":2957,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1666402991180,"user_tz":-540,"elapsed":7,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","# from funcs.funcs_trader import to_itvnum\n","\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","\n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","\n","    # if config.tr_set.check_hlm == 2:  # 동일한 param 으로도 p2_hlm 시도를 충분히 할 수 있음 (csdbox 와 같은)\n","    #   assert not (wave_itv1 == wave_itv2 and wave_period1 == wave_period2)\n","\n","    # ------------ get wave_features ------------ #\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","    tc_period = config.tr_set.tc_period\n","    roll_hl_cnt = 3\n","\n","    # roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    # roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    #\n","    # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #\n","    # roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    # roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    #\n","    # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    # res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = roll_highs1[-1] / wave_low_fill1_\n","    # res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / roll_lows1[-1]\n","    # res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / wave_low_fill1_\n","    # res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / wave_low_fill1_\n","\n","    itvnum = to_itvnum(wave_itv1)\n","    itvnum2 = itvnum * 2\n","\n","    high_ = res_df['high_{}'.format(wave_itv1)].to_numpy()\n","    low_ = res_df['low_{}'.format(wave_itv1)].to_numpy()\n","    b1_high_ = res_df['high_{}'.format(wave_itv1)].shift(itvnum).to_numpy()  \n","    b1_low_ = res_df['low_{}'.format(wave_itv1)].shift(itvnum).to_numpy()   \n","    b2_high_ = res_df['high_{}'.format(wave_itv1)].shift(itvnum2).to_numpy()  \n","    b2_low_ = res_df['low_{}'.format(wave_itv1)].shift(itvnum2).to_numpy()   \n","\n","    max_high_ = np.maximum(b1_high_, b2_high_)\n","    min_low_ = np.minimum(b1_low_, b2_low_)\n","    \n","    res_df['b1_high_{}'.format(wave_itv1)] = b1_high_\n","    res_df['b2_high_{}'.format(wave_itv1)] = b2_high_\n","    res_df['b1_low_{}'.format(wave_itv1)] = b1_low_\n","    res_df['b2_low_{}'.format(wave_itv1)] = b2_low_\n","    res_df['max_high_{}'.format(wave_itv1)] = max_high_\n","    res_df['min_low_{}'.format(wave_itv1)] = min_low_\n","    \n","    # ------------ enlist tr_unit ------------ #\n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # 2 사용하는 이유 : tp_1 을 p2_box 기준으로 설정하가 위함 --> enex_pairing_v4 function 과 호환되지 않음\n","    res_df['short_tp_1_{}'.format(selection_id)] = low_     # wave_low_fill1_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = high_  # roll_highs1[-1] wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_tp_1_{}'.format(selection_id)] = high_     # wave_high_fill1_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = low_  # roll_lows1[-1]  wave_low_fill1_   # roll_low_[:, -2]\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = low_  # wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = high_  # wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = high_  # wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = low_  # wave_low_fill1_    # roll_low_[:, -2]\n","\n","    # --> p2's ep use p1's ep\n","    # res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill1_  # wave_low_fill2_   # b2_low_5T\n","    # res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill1_ # wave_high_fill2_  # roll_high_[:, -2]\n","    # res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill1_  # wave_high_fill2_   # b2_high_5T\n","    # res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill2_    # roll_low_[:, -2]\n","\n","    # --> out use p1's low, (allow prev_low as out for p1_hhm only)\n","    # res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill1_   # wave_low_fill2_   # b2_low_5T\n","    # res_df['short_out_0_{}'.format(selection_id)] = wave_high_fill1_ # roll_highs1[-1] if not config.tr_set.check_hlm else wave_high_fill1_   # roll_highs2[-1]  # roll_high_[:, -2]\n","    # res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill1_   # wave_high_fill1_   # wave_high_fill2_   # b2_high_5T\n","    # res_df['long_out_0_{}'.format(selection_id)] = wave_low_fill1_ # roll_lows1[-1] if not config.tr_set.check_hlm else wave_low_fill1_   # roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    # below codes exist for p2_wave\n","    res_df['short_ep2_1_{}'.format(selection_id)] = low_  # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = high_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = high_  # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = low_  # roll_low_[:, -2]\n","\n","    res_df['short_out_1_{}'.format(selection_id)] = low_\n","    res_df['short_out_0_{}'.format(selection_id)] = high_\n","    res_df['long_out_1_{}'.format(selection_id)] = high_\n","    res_df['long_out_0_{}'.format(selection_id)] = low_\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(\n","        res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(\n","        res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(\n","        res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #\n","    short_open_res1 = np.ones(len_df)  # .astype(object)\n","    long_open_res1 = np.ones(len_df)  # .astype(object)\n","    short_open_res2 = np.ones(len_df)  # .astype(object)\n","    long_open_res2 = np.ones(len_df)  # .astype(object)\n","\n","    # ------------ wave_point ------------ #\n","    # notnan_short_tc = ~pd.isnull(res_df['short_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    # notnan_long_tc = ~pd.isnull(res_df['long_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","\n","    # notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    # notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    # notnan_cu2 = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy())  # isnull for object\n","    # notnan_co2 = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy())\n","\n","    # short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    # long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    # short_open_res1 *= res_df['short_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_short_tc\n","    # long_open_res1 *= res_df['long_tc_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_long_tc\n","\n","    # short_open_res2 *= res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_cu2  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    # long_open_res2 *= res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_co2  # np.nan = bool type 으로 True 임..\n","    # short_open_res2 *= res_df['short_tc_{}{}'.format(wave_itv2, tc_period)].to_numpy()\n","    # long_open_res2 *= res_df['long_tc_{}{}'.format(wave_itv2, tc_period)].to_numpy()\n","\n","    if show_detail:\n","        sys_log.warning(\"wave_point\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","        # ------ reject wave_update_hl ------ #\n","    # notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    # notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    # notnan_update_low_cu2 = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy())\n","    # notnan_update_high_co2 = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy())\n","\n","    # short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    # long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    # short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu2\n","    # long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co2\n","\n","    if show_detail:\n","        sys_log.warning(\"reject update_hl\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_itv ------ #\n","    if wave_itv1 != 'T':\n","        wave_itv1_num = to_itvnum(wave_itv1)\n","        short_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1)\n","        long_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1)\n","\n","        if show_detail:\n","            sys_log.warning(\"wave_itv1\")\n","            sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","            sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    if wave_itv2 != 'T':\n","        wave_itv2_num = to_itvnum(wave_itv2)\n","        short_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1)\n","        long_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1)\n","\n","        if show_detail:\n","            sys_log.warning(\"wave_itv2\")\n","            sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","            sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    # res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_out_1_{}'.format(selection_id)].to_numpy() - res_df[\n","        'short_out_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_out_1_{}'.format(selection_id)].to_numpy() + res_df[\n","        'long_out_gap_{}'.format(selection_id)].to_numpy() * tpg\n","\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep1 ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","\n","        # ------ epbox as epg ------ #\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","\n","        # ------ tpbox as epg ------ #\n","        # p1_hlm 을 위해선, tp_0 를 기준할 수 없음 --> ep1 & ep2 를 기준으로 진행\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1\n","\n","        # ------ fibo_ep ------ #\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1\n","\n","        # ------ market_ep1 ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","\n","    # ------ limit_ep2 ------ #\n","    if config.ep_set.point2.entry_type == \"LIMIT\":\n","        epg2 = config.tr_set.ep_gap2\n","\n","        # # ------ epbox as epg ------ #\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ outbox as epg ------ # --> ep1 & ep2 를 기준으로 진행\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ fibo_ep by tp_box ------ #\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg2  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ fibo_ep by out_box ------ #\n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_out_gap_{}'.format(selection_id)].to_numpy() * epg2  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","\n","        # ------ market_ep2 ------ #\n","    else:\n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    if config.tr_set.check_hlm == 0:\n","        res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","        res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","\n","        # ------ temporary refix for flexible p1_hhm ------ #\n","        res_df['short_tp_0_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)]\n","        res_df['long_tp_0_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)]\n","\n","        # ------ ep1box as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    elif config.tr_set.check_hlm == 1:  # for p1_hlm\n","        # ------ irregular - next_fibo ------ #\n","        # co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","        # cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # short_next_fibo_outg = np.vectorize(get_next_fibo_gap2)(cu_wrr_32_)\n","        # long_next_fibo_outg = np.vectorize(get_next_fibo_gap2)(co_wrr_32_)\n","\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * short_next_fibo_outg  # ep 와 마찬가지로, tpg 기준 가능\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * long_next_fibo_outg\n","\n","        # ------ ep1box as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ 1_tr - ep1box as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ 1_tr - auto_calculation by ep1 ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_{}'.format(selection_id)] + (res_df['short_ep1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_{}'.format(selection_id)].to_numpy())\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_{}'.format(selection_id)].to_numpy() - (res_df['long_tp_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_{}'.format(selection_id)].to_numpy())\n","\n","        # ------ tpbox as outg ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ fibo_out ------ #\n","        res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","        res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    else:  # p2_hlm\n","        # ------ outbox as out ------ #\n","        res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df[\n","            'short_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","        res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df[\n","            'long_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","        # ------ ep2box as out ------ #\n","        # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg   # p2's ep_box 를 out 으로 사용한다?\n","        # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    # ------ p1 point_validation ------ #\n","    short_open_res1 *= (short_tp_ < short_ep1_) & (short_ep1_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < short_out_ # res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) & (long_ep1_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation\n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution\n","    long_open_res1 *= close > long_out_ # res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution\n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    # ------ p2 point_validation ------ # --> executed in en_ex_pairing() function.\n","    # short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    # short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    # long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out cannot be vectorized\n","    # long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban)\n","    # print(\"res_df['long_open1_{}'.format(selection_id)].to_numpy() :\", res_df['long_open1_{}'.format(selection_id)].to_numpy())\n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","        sys_log.warning(\"point validation\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","        # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","\n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    if config.tr_set.check_hlm == 2:\n","        res_df['short_tr_{}'.format(selection_id)] = np.nan\n","        res_df['long_tr_{}'.format(selection_id)] = np.nan\n","    else:\n","        res_df['short_tr_{}'.format(selection_id)] = abs(\n","            (short_ep1_ / short_tp_ - config.trader_set.limit_fee - 1) / (\n","                        short_ep1_ / short_out_ - config.trader_set.market_fee - 1))  # 이게 맞음, loss 의 분모 > 분자 & profit 의 분모 < 분자\n","        res_df['long_tr_{}'.format(selection_id)] = abs(\n","            (long_tp_ / long_ep1_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep1_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","metadata":{"id":"HuCb0phoPN83"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-DNPumVZi0xs"},"outputs":[],"source":["\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    \n","# ------------ csd ------------ #\n","    # ------ dc ------ #\n","    # dc_upper_ = res_df['dc_upper_T30'].to_numpy()    \n","    # dc_lower_ = res_df['dc_lower_T30'].to_numpy()    \n","\n","    # # Todo, post_cu ~ co 의 dc_lower == low (=touched) 여부 조사\n","    # short_open_idx1 = get_index_bybool(short_open_res1, len_df_range)\n","    # long_open_idx1 = get_index_bybool(long_open_res1, len_df_range)\n","    # wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()   # co_prime_idx (wave_high 정보를 지정하기 위한 front co_idx 지정)\n","\n","    # # 1. dc_lower == low 여부 조사, np.nan 덕분에 vectorize 불가하다고 봄\n","    # short_valid_idx_bool = ~(pd.isnull(wave_co_post_idx_fill_) | pd.isnull(short_open_idx1)) # get_index_bybool\n","    # dc_upper_touch = dc_upper_ <= high\n","    # dc_upper_touch_span = np.full(len_df, np.nan)\n","    # dc_upper_touch_span[short_valid_idx_bool] = [dc_upper_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_co_post_idx_fill_, short_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # long_valid_idx_bool = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1)) # get_index_bybool\n","    # dc_lower_touch = dc_lower_ >= low\n","    # dc_lower_touch_span = np.full(len_df, np.nan)\n","    # dc_lower_touch_span[long_valid_idx_bool] = [dc_lower_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # short_open_res1 *= dc_upper_touch_span == 0\n","    # long_open_res1 *= dc_lower_touch_span == 0\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"csd - dc\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","    #   # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","    #   # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))   \n","    \n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "]},{"cell_type":"markdown","metadata":{"id":"aTV4h3LjTZBp"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dc49JPmoTaPQ"},"outputs":[],"source":["\n","    \n","    csd_period = 40\n","    res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","    \n","    dc_upper_ = res_df['dc_upper_T{}'.format(csd_period)].to_numpy()    \n","    dc_lower_ = res_df['dc_lower_T{}'.format(csd_period)].to_numpy()  \n","\n","    short_open_res2 *= dc_upper_touch_span == 0\n","    long_open_res2 *= dc_lower_touch_span == 0\n","\n","    # ------ csdbox ------ # --> 결국 dc's upper & lower\n","    if show_detail:\n","      sys_log.warning(\"csdbox\")\n","      # sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","      \n","    # olds,\n","    # np.nan - np.nan = np.nan -> vectorize 가능할 것 => xx\n","    # 1. wave_high_prime_idx_ ~ long_open_idx1 의 valid(not_non) 한 idx 를 max_dc_lower 와 min_low 의 비교값으로 채워넣음\n","    # valid_idx = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1))\n","    # max_dc_lower_ = [dc_lower_[int(iin):int(iout)].max() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    # min_low = [low[int(iin):int(iout)].min() for iin, iout in zip(wave_high_prime_idx_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","        # ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":38,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1666406921789,"user_tz":-540,"elapsed":410,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment', None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set_v2(balance, config, open_side, tp_, out_, fee, limit_leverage=50):\n","\n","    if not pd.isnull(tp_) and not config.lvrg_set.static_lvrg:\n","        if open_side == OrderSide.SELL:\n","            wave_range = (out_ / tp_)\n","        else:\n","            wave_range = (tp_ / out_)\n","\n","        # if wave_range > 1.0065 or wave_range < 1.002:  # spread_rejection\n","        #     # sys_log.warning(\"spread_rejection : {}\".format(wave_range))\n","        #     return None\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_loss / (((wave_range - 1) / 2 - (fee + config.trader_set.market_fee)) * balance)\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        # sys_log.warning(\"leverage_rejection : config.lvrg_set.leverage < 1\".format(config.lvrg_set.leverage))\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        # wave_range = 1 + (1 - loss) * 2\n","        # if wave_range > 1.0065 or wave_range < 1.002:  # spread_rejection\n","        #     return None\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        # h_candle_v3(df, '5T')\n","        # df = dc_line(df, df_5T, '5T')\n","        # df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(df, '15T')\n","        # df = dc_line(df, df_15T, '15T')\n","        # df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        h_candle_v3(df, '30T')\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        h_candle_v3(df, '4H')\n","\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","\n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and\n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2)\n","\n","    try:\n","        # ------------ wave_period1 ------------ #\n","        # if to_itvnum(wave_itv1) > 1:\n","        #     offset = '1h' if wave_itv1 != 'D' else '9h'\n","        #     htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","        #     htf_df = wave_range_cci_v4_1(htf_df, wave_period1)\n","        #\n","        #     # cols = list(htf_df.columns[-15:-4])  # except idx col\n","        #     cols = list(htf_df.columns[4:])  # 15T_ohlc 를 제외한 wave_range_cci_v4 로 추가된 cols, 다 넣어버리기 (추후 혼란 방지)\n","        #\n","        #     valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1,\n","        #                                                                                                    roll_hl_cnt=roll_hl_cnt)\n","        #\n","        #     htf_df = get_roll_wave_data_v2(htf_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1),\n","        #                                    roll_hl_cnt)\n","        #     cols += list(htf_df.columns[-roll_hl_cnt:])\n","        #\n","        #     htf_df = get_roll_wave_data_v2(htf_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","        #     cols += list(htf_df.columns[-roll_hl_cnt:])\n","        #\n","        #     htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","        #     cols += list(htf_df.columns[-4:])\n","        #\n","        #     # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","        #     res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","        #     res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=1), how='inner')\n","        # else:\n","        #     res_df = wave_range_cci_v4_1(res_df, wave_period1)\n","        #     # res_df = wave_range_stoch_v1(res_df, wave_period1)\n","        #     # res_df = wave_range_dc_envel_v1(res_df, wave_period1)\n","        #\n","        #     # valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv1, wave_period1,\n","        #     #                                                                                                roll_hl_cnt=roll_hl_cnt)\n","        #     # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1),\n","        #     #                                roll_hl_cnt)\n","        #     # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","        #     #\n","        #     # res_df = wave_range_ratio_v4_2(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","        #     # res_df = get_wave_length(res_df, valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr, wave_itv1, wave_period1,\n","        #     #                          roll_hl_cnt=roll_hl_cnt)\n","\n","        # ------------ wave_period2 ------------ #\n","        if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","            assert wave_itv2 == 'T'\n","\n","            res_df = wave_range_cci_v4_1(res_df, wave_period2)\n","\n","            # valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv2, wave_period2,\n","            #                                                                                                roll_hl_cnt=roll_hl_cnt)\n","            # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2),\n","            #                                roll_hl_cnt)\n","            # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","            #\n","            # res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","        # ------ wave_loc_pct (bb) ------ #\n","        # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","        # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","        # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","        # itv_list = ['15T', '15T', '15T', '15T']\n","        # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","        # ====== intervaly ====== #\n","        # ------ 5T ------ #\n","        # res_df = dc_level(res_df, '5T', 1)\n","        # res_df = bb_level(res_df, '5T', 1)\n","\n","        # res_df = st_level(res_df, '5T', 1)\n","\n","        # ------ 15T ------ #\n","        res_df = wick_ratio(res_df, '15T')\n","        # res_df = dc_level(res_df, '15T', 1)\n","        # res_df = bb_level(res_df, '15T', 1)\n","        # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","        # res_df = st_level(res_df, '15T', 1)\n","\n","        # ------ 30T ------ #\n","        res_df = wick_ratio(res_df, '30T')\n","        # res_df = dc_level(res_df, '30T', 1)\n","        # res_df = bb_level(res_df, '30T', 1)\n","        # res_df = st_level(res_df, '30T', 1)\n","\n","        # ------ H ------ #\n","        res_df = wick_ratio(res_df, 'H')\n","        # res_df = bb_level(res_df, 'H', 1)\n","\n","        # ------ 4H ------ #\n","        res_df = wick_ratio(res_df, '4H')\n","        # res_df = bb_level(res_df, '4H', 1)\n","\n","        # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","        # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","        # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","        # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","        # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","        #     temp indi.    #\n","        # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","        # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","        # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    except Exception as e:\n","        sys_log.error(\"error in utils_public : {}\".format(e))\n","    else:\n","        return res_df\n","    # return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면,\n","                # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","                # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                 (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:\n","                # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","                # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave2, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ candle_shape ============ #\n","    wave_itv1 = config.tr_set.wave_itv1\n","    itvnum = to_itvnum(wave_itv1)\n","    itvnum2 = itvnum * 2\n","        \n","    close_T = res_df['close'].shift(-1).to_numpy() \n","    open_T = res_df['open'].shift(-1).to_numpy() \n","\n","    close_ = res_df['close_{}'.format(wave_itv1)].to_numpy()  \n","    open_ = res_df['open_{}'.format(wave_itv1)].to_numpy()  \n","    high_ = res_df['high_{}'.format(wave_itv1)].to_numpy()  \n","    low_ = res_df['low_{}'.format(wave_itv1)].to_numpy()  \n","\n","    b1_high_ = res_df['b1_high_{}'.format(wave_itv1)].to_numpy() \n","    b2_high_ = res_df['b2_high_{}'.format(wave_itv1)].to_numpy() \n","    b1_low_ = res_df['b1_low_{}'.format(wave_itv1)].to_numpy() \n","    b2_low_ = res_df['b2_low_{}'.format(wave_itv1)].to_numpy() \n","    max_high_ = res_df['max_high_{}'.format(wave_itv1)].to_numpy() \n","    min_low_ = res_df['min_low_{}'.format(wave_itv1)].to_numpy()   \n","\n","    body_ratio_ = res_df['body_ratio_{}'.format(wave_itv1)].to_numpy()\n","    upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(wave_itv1)].to_numpy()\n","    lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(wave_itv1)].to_numpy()\n","    # candle_updown_ = res_df['candle_updown_{}'.format(wave_itv1)].to_numpy()\n","    # b1_candle_updown_ = res_df['candle_updown_{}'.format(wave_itv1)].shift(to_itvnum(wave_itv1)).to_numpy()\n","\n","    # ------ fakey - public ------ #\n","    mr_res *= b1_high_ <= b2_high_\n","    mr_res *= b1_low_ >= b2_low_\n","\n","    # --- marubozu_pair --- #\n","    if ep_loc_side == OrderSide.SELL:\n","        mr_res *= high_ > max_high_\n","        # mr_res *= high_ > b1_high_\n","\n","        mr_res *= body_ratio_ >= config.loc_set.point1.short_body_ratio  # green_maru\n","        mr_res *= close_ > open_\n","        mr_res *= close_T < open_T\n","\n","        # mr_res *= upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","        if show_detail:\n","            sys_log.warning(\"upper_wick_ratio_, body_ratio_ : {:.5f}, {:.5f}  ({})\"\\\n","                            .format(upper_wick_ratio_[c_i], body_ratio_[c_i], mr_res[c_i]))\n","    else:\n","        mr_res *= low_ < min_low_\n","        # mr_res *= low_ < b1_low_\n","\n","        mr_res *= body_ratio_ >= config.loc_set.point1.long_body_ratio  # red_maru\n","        mr_res *= close_ < open_\n","        mr_res *= close_T > open_T\n","\n","        # mr_res *= lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","        if show_detail:\n","            sys_log.warning(\"lower_wick_ratio_, body_ratio_ : {:.5f}, {:.5f}  ({})\"\\\n","                            .format(lower_wick_ratio_[c_i], body_ratio_[c_i], mr_res[c_i]))\n","            \n","    # ============ tr_thresh ============ #  # vectorize allow only for p1_hhm\n","    # if config.loc_set.point1.short_tr_thresh != \"None\":  #  and not config.tr_set.check_hlm:\n","    #     if ep_loc_side == OrderSide.SELL:\n","    #         short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","    #         mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","    #         # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","    #         if show_detail:\n","    #             sys_log.warning(\n","    #                 \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","    #     else:\n","    #         long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","    #         mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","    #         # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","    #         if show_detail:\n","    #             sys_log.warning(\n","    #                 \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ csd_ending ============ #     \n","    # ------ bb_cc ----- #\n","    # bb_lower_ = res_df['bb_lower_15T20'].to_numpy()\n","    # bb_upper_ = res_df['bb_upper_15T20'].to_numpy()\n","    # open_ = res_df['open_15T'].to_numpy()  \n","    # close_ = res_df['close_15T'].to_numpy()   \n","    \n","    # if ep_loc_side == OrderSide.SELL:\n","    #     # mr_res *= (open_ > bb_lower_) & (bb_lower_ > close_)\n","    #     mr_res *= (open_ <= bb_lower_) | (bb_lower_ <= close_)\n","    #     if show_detail:\n","    #         sys_log.warning(\"open_, bb_lower_, close_ : {:.5f} {:.5f} {:.5f} ({})\"\\\n","    #                         .format(open_[c_i], bb_lower_[c_i], close_[c_i], mr_res[c_i]))\n","    # else:\n","    #     # mr_res *= (open_ < bb_upper_) & (bb_upper_ < close_)\n","    #     mr_res *= (open_ >= bb_upper_) | (bb_upper_ >= close_)\n","    #     if show_detail:\n","    #         sys_log.warning(\"open_, bb_upper_, close_ : {:.5f} {:.5f} {:.5f} ({})\"\\\n","    #                         .format(open_[c_i], bb_upper_[c_i], close_[c_i], mr_res[c_i]))\n","\n","    # ------ sar ------ # \n","    # sar_trend_ = res_df['sar_trend_5T'].to_numpy()\n","    # b1_sar_trend_ = res_df['sar_trend_5T'].shift(15).to_numpy()\n","    \n","    # if ep_loc_side == OrderSide.SELL:\n","    #     # mr_res *= sar_trend_ == 0\n","    #     # mr_res *= b1_sar_trend_ == 1\n","    #     mr_res *= sar_trend_ == 1\n","    #     mr_res *= b1_sar_trend_ == 0\n","    #     if show_detail:\n","    #         sys_log.warning(\"sar_trend_, b1_sar_trend_ : {:.5f} {:.5f} ({})\".format(sar_trend_[c_i], b1_sar_trend_[c_i], mr_res[c_i]))\n","    # else:\n","    #     # mr_res *= sar_trend_ == 1\n","    #     # mr_res *= b1_sar_trend_ == 0\n","    #     mr_res *= sar_trend_ == 0\n","    #     mr_res *= b1_sar_trend_ == 1\n","    #     if show_detail:\n","    #         sys_log.warning(\"sar_trend_, b1_sar_trend_ : {:.5f} {:.5f} ({})\".format(sar_trend_[c_i], b1_sar_trend_[c_i], mr_res[c_i]))\n","\n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone1.use_zone:\n","\n","        # ------------ on_price ------------ #\n","          # ------ 추세선 리스트 ------ #\n","        # wave_itv1 = config.tr_set.wave_itv1\n","        # wave_period1 = config.tr_set.wave_period1\n","\n","        # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","        # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","        # long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","\n","          # ------ sar ------ #\n","        high_ = res_df['high_15T'].to_numpy()  \n","        low_ = res_df['low_15T'].to_numpy()        \n","        sar_ = res_df['sar_5T'].to_numpy()\n","\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= high_ < sar_\n","            if show_detail:\n","                sys_log.warning(\"high_ < sar_ : {:.5f} {:.5f} ({})\".format(high_[c_i], sar_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= low_ > sar_\n","            if show_detail:\n","                sys_log.warning(\"low_ > sar_ : {:.5f} {:.5f} ({})\".format(low_[c_i], sar_[c_i], mr_res[c_i]))\n","\n","        # ------ dc_base ------ #\n","        # dc_base_ = res_df['dc_base_T30'].to_numpy()\n","        # dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","        # dc_base_5T20 = res_df['dc_base_5T20'].to_numpy()\n","        # dc_base_15T20 = res_df['dc_base_15T20'].to_numpy()\n","        # dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","        # dc_base_4H20 = res_df['dc_base_4H20'].to_numpy()\n","\n","        # if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= short_tp_0_ < dc_base_H20\n","        #     if show_detail:\n","        #         sys_log.warning(\"short_tp_0_ < dc_base_H20 : {:.5f} {:.5f} ({})\".format(short_tp_0_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","        # else:\n","        #     mr_res *= long_tp_0_ > dc_base_H20\n","        #     if show_detail:\n","        #         sys_log.warning(\"long_tp_0_ > dc_base_H20 : {:.5f} {:.5f} ({})\".format(long_tp_0_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","        # ------------ outer_price ------------ #\n","          # ------ macd ------ #\n","        # # macd_ = res_df['macd_T535'].to_numpy()\n","        # macd_ = res_df['macd_hist_T53515'].to_numpy()\n","\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= macd_ < 0\n","        #   if show_detail:\n","        #     sys_log.warning(\"macd_ < 0 : {:.5f} {:.5f} ({})\".format(macd_[c_i], 0, mr_res[c_i]))\n","        # else:\n","        #   mr_res *= macd_ > 0\n","        #   if show_detail:\n","        #     sys_log.warning(\"macd_ > 0 : {:.5f} {:.5f} ({})\".format(macd_[c_i], 0, mr_res[c_i]))\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection\n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":\n","        wave_itv2 = config.tr_set.wave_itv2\n","        wave_period2 = config.tr_set.wave_period2\n","        co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","        cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  # + 0.1  # 0.1 0.05\n","            # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","            if show_detail:\n","                sys_log.warning(\n","                    \"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32,\n","                                                                                             mr_res[c_i]))\n","        else:\n","            mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  # + 0.1  # 0.1 0.05\n","            # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","            if show_detail:\n","                sys_log.warning(\n","                    \"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32,\n","                                                                                             mr_res[c_i]))\n","\n","    if config.loc_set.point2.csd_period != \"None\":\n","        wave_itv2 = config.tr_set.wave_itv2\n","        csd_period = config.loc_set.point2.csd_period\n","\n","        res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","        dc_upper_ = res_df['dc_upper_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","        dc_lower_ = res_df['dc_lower_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","        if ep_loc_side == OrderSide.SELL:\n","            csdbox = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() + res_df[\n","                'short_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","            mr_res *= dc_upper_ <= csdbox\n","            if show_detail:\n","                sys_log.warning(\"dc_upper_ <= csdbox : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], csdbox[c_i], mr_res[c_i]))\n","        else:\n","            csdbox = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() - res_df[\n","                'long_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","            mr_res *= dc_lower_ >= csdbox\n","            if show_detail:\n","                sys_log.warning(\"dc_lower_ >= csdbox : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], csdbox[c_i], mr_res[c_i]))\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","metadata":{"id":"EQ63Jwpvr7qA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"csZwxsP5r_Pz"},"outputs":[],"source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":20,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1666404359247,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"6\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.99\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 0.0002,\n","    \"market_fee\": 0.0004,\n","    \"initial_asset\": 9000,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"BNBUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[500, 1, 1, 1, 1, 1, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0,\n","    \"short_fake\": 0,\n","    \"long_fake\": 0\n","  },\n","  \"loc_set\": {\n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": 0.3,\n","      \"long_wick_ratio\": 0.3,\n","      \"short_body_ratio\": 0.7,\n","      \"long_body_ratio\": 0.7,\n","      \"wick_itv\": \"5T\",\n","      \"wrr_10\": \"None\",\n","      \"wrr_21\": \"None\",\n","      \"wrr_32\": \"None\",\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"wrr_32\": \"None\",\n","      \"csdbox_range\": 0.3,\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"csd_period\": \"None\"\n","    },\n","    \"zone1\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    },\n","    \"zone2\": {\n","      \"use_zone\": 0\n","    }\n","  },\n","  \"tr_set\": {\n","    \"check_hlm\": 0,\n","    \"wave_itv1\": \"15T\",\n","    \"wave_period1\": 20,\n","    \"wave_length1\": \"None\",\n","    \"wave_spread1\": \"None\",\n","    \"wave_time_ratio1\": \"None\",\n","    \"wave_itv2\": \"T\",\n","    \"wave_period2\": 20,\n","    \"tc_period\": 20,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\": 0,\n","    \"p2_box_k2\": 0,\n","    \"p1p2_low\": 0.0,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.5,\n","    \"ep_gap2\": 0,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_tick\": 100\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"entry_type\": \"LIMIT\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"close_out\": 0,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0,\n","    \"cci_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"static_lvrg\": 0,\n","    \"leverage\": 1,\n","    \"limit_leverage\": 5,\n","    \"target_loss\": 50,\n","    \"target_pct\": 0.03,\n","    \"allow_float\": 0,\n","    \"lvrg_rejection\": 1\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","metadata":{"id":"MuD_2vY7TI_8"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"EKag94Y2TMCO"},"outputs":[],"source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":21,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1666404362307,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"qBJfPsmJzVIr","outputId":"adb9777c-005f-4485-f1f5-a42ea3b53555"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"6\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": 0.3,\n","  \"long_wick_ratio\": 0.3,\n","  \"short_body_ratio\": 0.7,\n","  \"long_body_ratio\": 0.7,\n","  \"wick_itv\": \"5T\",\n","  \"wrr_10\": \"None\",\n","  \"wrr_21\": \"None\",\n","  \"wrr_32\": \"None\",\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"wrr_32\": \"None\",\n","  \"csdbox_range\": 0.3,\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"csd_period\": \"None\"\n"," },\n"," \"zone1\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," },\n"," \"zone2\": {\n","  \"use_zone\": 0\n"," }\n","} {\n"," \"check_hlm\": 0,\n"," \"wave_itv1\": \"15T\",\n"," \"wave_period1\": 20,\n"," \"wave_length1\": \"None\",\n"," \"wave_spread1\": \"None\",\n"," \"wave_time_ratio1\": \"None\",\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 20,\n"," \"tc_period\": 20,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"p1p2_low\": 0.0,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.5,\n"," \"ep_gap2\": 0,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_tick\": 100\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"entry_type\": \"LIMIT\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"close_out\": 0,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0,\n"," \"cci_exit\": 0\n","} {\n"," \"static_lvrg\": 0,\n"," \"leverage\": 1,\n"," \"limit_leverage\": 5,\n"," \"target_loss\": 50,\n"," \"target_pct\": 0.03,\n"," \"allow_float\": 0,\n"," \"lvrg_rejection\": 1\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2022-01-14 16:34:59.999000\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","# ------ p1_hhm 의 경우 out_box 를 위해 wave_itv 1 & 2 를 동일하게 설정해야함 ------ #\n","config_list[0].tr_set.wave_itv1 = '15T'\n","# config_list[0].tr_set.wave_period1 = 20\n","# config_list[0].tr_set.wave_itv2 = 'T'\n","# config_list[0].tr_set.wave_period2 = 4\n","# config_list[0].tr_set.tc_period = 20"]},{"cell_type":"code","execution_count":9,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1681,"status":"ok","timestamp":1666402993741,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"1232da45-49cd-47ca-a336-1e80c78e5d4f"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 1.121082067489624\n","make data_list elapsed time : 0.00042748451232910156\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","source":["res_df.dtypes\n","# res_df.head()"],"metadata":{"id":"rRBzxUfDuXeK"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":22,"metadata":{"id":"_iYcJk8nK8Yq","executionInfo":{"status":"ok","timestamp":1666404365494,"user_tz":-540,"elapsed":5,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].tr_set.check_hlm = 2\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].pos_set.long_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_length1 = \"None\"  # \"None\" 45 15 110 100 \n","# config_list[0].tr_set.wave_spread1 = \"None\"  # \"None\" 15 110 100 \n","# config_list[0].tr_set.wave_time_ratio1 = \"None\"  # \"None\" 6\n","# config_list[0].tr_set.wave_greater1 = 0  # 0 50 \n","# config_list[0].tr_set.wave_greater2 = 0  # 10\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].ep_set.point2.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap1 = -0.5 # -0.8 -0.618 -0.23 -0.382 0.19 0.8 -0.12 -0.26\n","# config_list[0].tr_set.ep_gap2 = -0.5 # -0.618 -0.23 -0.382 0.19 -0.5\n","# config_list[0].tr_set.out_gap = 0.0  # 0 -0.35 -0.6\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.0\n","config_list[0].trader_set.limit_fee = 1e-10\n","config_list[0].trader_set.market_fee = 1e-10\n","# config_list[0].trader_set.limit_fee = 0.0002\n","# config_list[0].trader_set.market_fee = 0.0004\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":32,"metadata":{"id":"iI39YI_5GguK","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1666405916019,"user_tz":-540,"elapsed":508,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"b3aa6705-f48c-4784-e914-7cfeb8a2b58c"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 863086\n","WARNING:root:np.sum(long_open_res1 == 1) : 863086\n","WARNING:root:np.sum(short_open_res2 == 1) : 863086\n","WARNING:root:np.sum(long_open_res2 == 1) : 863086\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 863086\n","WARNING:root:np.sum(long_open_res1 == 1) : 863086\n","WARNING:root:np.sum(short_open_res2 == 1) : 863086\n","WARNING:root:np.sum(long_open_res2 == 1) : 863086\n","WARNING:root:wave_itv1\n","WARNING:root:np.sum(short_open_res1 == 1) : 57539\n","WARNING:root:np.sum(long_open_res1 == 1) : 57539\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 57174\n","WARNING:root:np.sum(long_open_res1 == 1) : 57231\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.41182875633239746\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfDSOGMd91rE"},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.wrr_10 = \"None\" # \"None\" 0.3\n","config_list[0].loc_set.point1.wrr_21 = \"None\" # \"None\" \n","config_list[0].loc_set.point1.wrr_32 = \"None\" # \"None\" 1 0.5 0.482 0.302\n","config_list[0].loc_set.point2.wrr_32 = \"None\" # \"None\" 1 0.5 0.382 0.302 0.25\n","config_list[0].loc_set.point2.csd_period = \"None\"  # \"None\" 100\n","config_list[0].loc_set.zone1.use_zone = 0\n","# config_list[0].loc_set.zone1.bb_trend_period = 150\n","# config_list[0].loc_set.zone1.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","# config_list[0].loc_set.zone2.use_zone = 0\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_wick_ratio = 0.5\n","config_list[0].loc_set.point1.long_wick_ratio = 0.5\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\" #  \"None\" 0.5 2 0.8 # # 0.7  5 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = \"None\"  #  \"None\" 2 0.8 ## 0.7 5 \n","# # config_list[0].loc_set.zone1.base_roll_period = 60"]},{"cell_type":"code","execution_count":39,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":4354,"status":"ok","timestamp":1666406932133,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","outputId":"ba83cec0-8b98-42db-94eb-a8854eb5f597"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:upper_wick_ratio_, body_ratio_ : 0.12892, 0.76320  (0.0)\n","WARNING:root:lower_wick_ratio_, body_ratio_ : 0.10788, 0.76320  (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.018721103668213\n","get_open_info_df elapsed time : 2.8122284412384033\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","# config_list[0].tr_set.p2_box_k1 = 0.0  # 0 default --> 0 ~ 1 사이 값 사용 tp_1 로부터 떨어지는 거리\n","# config_list[0].tr_set.p2_box_k2 = 0  # 0.5 0 default --> \"None\" 불가, 0 ~ 1 사이 값 사용 tp_0 로부터 떨어지는 거리, 본디 p2_box 는 p1_box 내부에 존재해야, 정확한 hhm 이 측정가능해짐\n","# config_list[0].tr_set.p1p2_low = 0.5  # 0.5 0.7 0  0 is equal to \"None\", 마찬가지로 tp_0 로부터 떨어지는 거리\n","# config_list[0].loc_set.point2.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","# config_list[0].loc_set.point2.long_tr_thresh = \"None\"  #  \"None\" 2 0.8 ## 0.7\n","# config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# config_list[0].ep_set.point2.wick_score_list = str([])\n","# config_list[0].tp_set.static_tp = 1\n","# config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","config_list[0].out_set.hl_out = 1\n","# config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","# config_list[0].lvrg_set.static_lvrg = 0\n","# config_list[0].lvrg_set.leverage = 5\n","# config_list[0].lvrg_set.target_pct = 0.03 # 0.1 0.03\n","# config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_bias_arr, short_net_p1_bias_tick, short_p2exec_p1_bias_tick, short_net_p1_idx_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_bias_arr, long_net_p1_bias_tick, long_p2exec_p1_bias_tick, long_net_p1_idx_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v9_1(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961_1"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":716},"id":"TvGs5mBxsuBK","executionInfo":{"status":"ok","timestamp":1666406934387,"user_tz":-540,"elapsed":2257,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2e025739-a587-4518-b7f5-e384aa41ed44"},"execution_count":40,"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.28827524185180664\n","short_obj.shape : (379, 5)\n","long_obj.shape : (341, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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6+vZsyf27NmjalYbNmyAjY0NXFxcSjw/TzlARERlpbr3WCIiorLCHmvszp07sLS0fGQNgEfWEZUlHoylas3Lywuurq4YPXo0pkyZgrfeeguff/65Ud3q1atx5swZeHh44ODBg/jqq6/Qrl27El9/QedofZCzszMiIiJUY9euXYNOp4Ozs3OJ10BERFQW2GPva9myJVJTU5GZmYnffvsNHTt2zLcuMDAQOTk5uHHjBpYsWQJra+tSuX4iIqp62GP/x8zMDHZ2dhg6dCi6d++OgIAAoxqNRgMLCws899xzmD9/Po4fP47jx4+X2hqIiounKaBqzWAwoF+/fsq5Ylq2bInBgwfD19dXVbd+/XrMnTsXAHDw4EH06dMH/fv3V53s/HHk5OTg3r17hdbY29sjJSXFaDw5ORn29vYlun4iIqKywh4LnDp1CseOHcPFixfxxBNPYOLEidi3bx/++c9/KvuXlZWFFStWYO/evbh79y46deqEKVOmoHnz5ujXr1+J10BERFUPe+x97du3xx9//AHg/m0ybtw47Nixw6ju119/hZubGwDgzz//RK9evfgOUTIpHoylai00NFR10u6LFy+ifv36MDc3R05OjjK+d+9e5eucnBxERkaiSZMmJb5+CwuLEs9BRERUEbHHAl9++aXq8q+//ooLFy5g+vTp8PDwAADcunUL48ePV2oOHTqE27dv4+uvv0br1q1x9uzZcl0zERFVfOyx9507dw6vvPIK6tSpg969e2PFihW4e/cuNmzYoKobP3486tati2effRYzZsxAcHAwOnTogKysLBOtnKo7nqaAqrWHn6nLzs6GVquFlZXVI+vK6+2DycnJ+Z7/x97eHsnJyeWyBiIiouJijzWWkZGBX3/9FS+//HKhdVu2bAEAtG3bttTXQERElR977H16vR4nT55ESEgIPvroI6xbtw4LFiwwqrty5QqOHz+On376CT169MBLL72EoUOHlsoaiB4HD8YSVXARERFG59Rp0qQJbG1tjc7BQ0REREVnih4rIo98a2Te9/kWSiIiqqxM0WP/+usvODo6wszMrMCa2NhYJCUl4emnny6TNRAVBQ/GElVwwcHB6NGjB2rWrKmMDRo0CHq9HocOHTLhyoiIiCq38u6x1tbW6N27N06ePFlo3YABAwDgkXVEREQVlSkex3bo0AHXrl1TncLhYc89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qNLEAODixYuoX78+zM3NkZOTU+B2ISEhytcigujoaOj1etXbH65cuYI33nij0Os/fPgwLCwsSrAHREREFRN7LBERUeljfyWq/HiaAqrWHn6WLDs7G1qt9pHnyclvu/zGrK2tS2ehjyk5OTnf8wfZ29sjOTlZqalZsya0Wq1RjU6ng8FgKPJcREREedhj2WOJiKj0sb+yv1Llx4OxRFVYRESE0blwmjRpAltbW+XcORERETA3N8czzzyjqnv4/DpFmYuIiKi6YI8lIiIqfeyvVB3wYCxRFRYcHIwePXqgZs2aytigQYOg1+tx6NAhAMDRo0eRmpqKgQMHKjU1atRAnz59EBwcXKy5iIiIqgv2WCIiotLH/krVAQ/GEplQx44dYTAY0LFjx0LrHB0d4enpCU9PT1haWqJly5bw9PSEm5ubqsZgMGDYsGHKWEBAALKysrBt2za4lZ9ciwAAIABJREFUurpi1KhR8Pf3xxdffKGcGygrKwvz58/H9OnT8f7776NLly7YvHkztFotli9fXqy5iIiIKgr2WCIiotLH/kpUcvwALyIT0mg0MDc3h0ajKbSuc+fOWLt2rXLZy8sLXl5euHr1Kp566inVXA+eNyclJQWurq5YsWIFfvnlF6SkpGDp0qXw9/dXzT9//nxotVpMmzYN9erVw59//olu3bohPj6+2HMRERFVBOyxREREpY/9lajkNADE1IsgIiIiIiIiIiIiqup4mgIiIiIiIiIiIiKicsCDsURERERERERERETlgAdjiYiIiIiIiIiIiMoBD8YSERERERERERERlQMejKVKJzo6GosWLTL1Mgrk7e0NEYGtrW25XaeXlxe2bt2KGzduQETg7e1tVOPq6ooNGzbg6tWr0Ol0OHfuHHx9fVWfXJkfCwsLbNy4EVFRUdDr9YiPj8evv/6Kl19+2ah20KBBOHnyJNLS0hAXF4fvv/8eDRs2VNU8+eSTWLNmDeLi4pCWloa//voLQ4cOLdkNQEREpYI91lhZ9lgAGDt2LHbu3InExESICFxcXIxqBgwYgB07dii9888//8TgwYPznc/R0RFBQUG4c+cOdDodTp8+jR49ehR/x4mIqNSwvxory/765JNPYuHChTh9+jTS0tIQGxuLtWvXGj02zTNq1CicO3cOGRkZuHXrFjZs2FDg3B988AFEBJs3by7eDhM9gAdj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NMdqOnMq+/ulosfjfo9HlLcWquv9193bC/77X105+ys7zt25Upk1WlP/P1HefSrZy93Xqcw4ld1fAMAdwEFUz2sTqL7/7yvuuXh9l/U7qeT9qszjdLfK/I67e//dty/v/v63n+jU8vPVal/gtXjxYgQFBSEoKAh5eXnWaoOIiKjWYcYSERHVDGYsERE9KKsdjCUiIiIiIiIiIiKqS3gwloiIiIiIiIiIiMgCauRg7OrVq3H48GG0bt0aGRkZGDlyZE1MQ0REVOcwY4mIiKof85WIiCylRr7A67XXXquJYYmIiOo8ZiwREVH1Y74SEZGl8DQFRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWwIOxRERERERERERERBbAg7FEREREREREREREFsCDsUREREREREREREQWUGMHY/v27Yvk5GTo9XpMnjy5pqYhIiKqU5ivRERENYMZS0REllAjB2Pt7e0xf/58hIWF4dFHH8WQIUPQtm3bmpiKiIiozmC+EhER1QxmLBERWUqNHIzt0qULUlNTkZ6ejps3b2Lt2rUYOHBgTUxFRERUZzBfiYiIagYzloiILEmqu15++WVZvHixcnno0KEyd+5cs+uMGjVKoqOjJTo6WtLT06u9BxaLxWLVnoqOjrZ6D7ZQlclXgBnLYrFYrMoXM/ZOMWNZLBaLVZ1VUb5a7Qu8Fi9ejKCgIAQFBSEvL89abRAREdU6zFgiIqKawYwlIqIH5VgTg2ZmZqJp06bK5SZNmiAzM7Pc67du3RrR0dE10UqNatCggeoCWI09A+zbktTYM8C+LckaPfv5+Vl0PltV1XwF1JmxanxdAOzbktTYM8C+LUmNPQPMWGtixto2Nfatxp4B9m1JauwZYN+Vda98rfaP4jo4OEhaWpr4+/uLk5OTxMXFyaOPPnpfH9215VJj32rsmX2zZ/ZtW6XGnmtLVTVf1fp8qbFn9s2e2bdtlRp7VnPftaGYsbZdauxbjT2zb/bMvi1TNfLJ2KKiIvz973/Hzp074eDggB9++AEnT56siamIiIjqDOYrERFRzWDGEhGRpdTIwVgA2L59O7Zv315TwxMREdVJzFciIqKawYwlIiJLcAAww9pNAEBMTIy1W7gvauxbjT0D7NuS1NgzwL4tSY0912VqfL7U2DPAvi1JjT0D7NuS1NgzoN6+6yo1Pl9q7BlQZ99q7Blg35akxp4B9v2g7HDnfAVEREREREREREREVIPsrd0AERERERERERERUV3Ag7FEREREREREREREFmD1g7F9+/ZFcnIy9Ho9Jk+ebJE5lyxZgtzcXCQmJirbdDoddu3ahZSUFOzatQtarVbZN2fOHOj1esTHx6NTp07K9uHDhyMlJQUpKSkYPny4sj0wMBAJCQnQ6/WYM2dOpea4lyZNmmDv3r04ceIEkpKSMG7cOFX07ezsjKioKMTFxSEpKQkzZswAAPj7++PIkSPQ6/VYu3YtnJycAAAajQZr166FXq/HkSNH4Ofnp4w1ZcoU6PV6JCcnIzQ0VNle3hoqb47Ksre3R0xMDLZu3aqantPT05GQkIDY2FhER0cDsP01AgCenp5Yv349Tp06hZMnTyIkJMTm+27VqhViY2OVMhqNGD9+vM33PWHCBCQlJSExMRGrV6+Gs7OzKtY2VZ018hVgxjJjK4cZy4wtj1rzFWDG1iV8D1t5asxYNecrwIy11PpWW74C6s3Y2pqvYq2yt7eX1NRUCQgIECcnJ4mLi5O2bdvW+Lw9evSQTp06SWJiorJt5syZMnnyZAEgkydPli+++EIASFhYmERGRgoACQ4OliNHjggA0el0kpaWJjqdTrRaraSlpYlWqxUAEhUVJcHBwQJAIiMjpV+/fhXOUZlq1KiRdOrUSQCIu7u7nD59Wtq2bWvzfQMQNzc3ASCOjo5y5MgRCQ4Olp9++kkGDx4sAGTBggXyzjvvCAAZPXq0LFiwQADI4MGDZe3atQJA2rZtK3FxcaLRaMTf319SU1PF3t6+wjVU3hyVrYkTJ8qPP/4oW7durXA8W+o5PT1dvL29zbapYY0sW7ZM3njjDQEgTk5O4unpqYq+i8ve3l6ys7OlWbNmNt23j4+PnDlzRlxcXJT1FhERoYq1zar6mrRGvgLMWGZs5YoZy4ytTKklXwFmbF0qvoet2mtZrRmr1nwFmLGWWiNqzldAPRlbi/O1ZkOjogoJCZEdO3Yol6dMmSJTpkyxyNx+fn5mQZacnCyNGjUS4E5gJCcnCwBZuHChhIeHl7peeHi4LFy4UNlefL1GjRrJqVOnlO0lr1feHPdTP//8szzzzDOq6tvV1VWOHz8uXbp0EYPBIA4ODqXWwY4dOyQkJEQAiIODgxgMhjLXRvH1KlpD5c1RmfL19ZU9e/ZIr169lBCz9Z6BskPM1teIh4eHnDlzptR2W++7ZPXp00cOHjxo8337+PjI+fPnRafTiYODg2zdulVCQ0NVsbZZVStr5ivAjLVG38xYZmxZpfaMVUu+AszYulR8D3v/+QqoL2PVlK8AM9ZSa0Tt+QqoJ2Nra75a9TQFvr6+yMjIUC5fuHABvr6+VumlYcOGyMnJAQDk5OSgYcOGFfZY0fYLFy6U2l7RHFXl5+eHTp06ISoqShV929vbIzY2FhcvXsTu3buRlpaGy5cvo6ioqNRcJfsrKiqC0WiEt7d3le+Pt7d3uXNUxjfffINJkybh9u3bAFDheLbSMwCICHbt2oVjx45h1KhRAGx/bQcEBMBgMGDp0qWIiYnB4sWLUa9ePZvvu6Tw8HCsWbOmwjFtoe+srCzMnj0b58+fR3Z2NoxGI44fP66KtU1VY0v5Ctj26+JuzFhmbHmYsZZ/TaolXwFmbF1iSxlr66+Lu6kpY9WYrwAz1lJrRO35CqgnY2trvlr9nLG2SkRscg43Nzds3LgREyZMgMlkqpYxq6qqc9y+fRudOnVCkyZN0KVLF7Rp06aGOqsezz77LC5evIiYmBhrt1Jl3bt3R+fOnREWFoaxY8eiR48epa5ja2vE0dERgYGBWLBgAQIDA3H16lVMmTLlgca8X/czh5OTEwYMGID169dX25hVVdk5tFotBg4ciICAAPj4+MDNzQ39+vWr4e6ISrOl10VJzNiax4x9cHUlY9WUrwAzlmyDrb0uSlJbxqotXwFmbHWo7BxqzldAXRlbW/PVqgdjMzMz0bRpU+VykyZNkJmZaZVecnNz0ahRIwBAo0aNcPHixQp7rGh7kyZNSm2vaI7KcnR0xMaNG/Hjjz9i8+bNqum7mNFoxL59+/DEE09Aq9XCwcGh1Fwl+3NwcICnpyfy8/OrfH/y8/PLneNeunXrhgEDBiA9PR1r167F008/jTlz5th0z8WysrIAAAaDAZs3b0aXLl1sfo1cuHABFy5cwNGjRwEAGzZsQGBgoM33XSwsLAwxMTHKbW2572eeeQbp6enIy8vDrVu3sGnTJnTr1k0Va5uqxpbyFbDt10UxZiwz9l6YsZZd22rKV4AZW5fYUsba+uuimJozVi35CjBjLblG1JyvgLoytrbmq1UPxkZHR6Nly5bw9/eHk5MTwsPDsWXLFqv0smXLFkRERAAAIiIi8Msvvyjbi78ZLjg4GEajETk5Odi5cydCQ0Oh1Wqh1WoRGhqKnTt3IicnB4WFhQgODgZw5xvmSo5V1hyVtWTJEpw6dQpff/21avpu0KABPD09AQAuLi7o06cPTp06hX379mHQoEFl9l0816BBg7B3715le3h4ODQaDfz9/dGyZUscPXq0wjVU3hz3Mm3aNDRt2hQBAQEIDw/H3r17MXToUJvuGQDq1asHd3d35efQ0FAkJSXZ/BrJzc1FRkYGWrVqBQDo3bs3Tp48afN9FxsyZIjy5x0VjWkLfZ8/fx4hISFwdXU1e6xtfW1T1dlSvgK2/booxoxlxlaEGWv516Sa8hVgxtYltpSxtv66KKa2jFVjvgLMWEuuETXnK6CujK3N+VptJ6C9nwoLC5PTp09LamqqTJs2zSJzrl69WrKysuTGjRuSkZEhI0eOFC8vL9mzZ4+kpKTI7t27RafTKdefN2+epKamSkJCgnTu3FnZPmLECNHr9aLX6+X1119Xtnfu3FkSExMlNTVV5s6dq2yvaI57Vbdu3UREJD4+XmJjYyU2NlbCwsJsvu/HHntMYmJiJD4+XhITE2X69OkCQAICAiQqKkr0er2sW7dONBqNABBnZ2dZt26d6PV6iYqKkoCAAGWsadOmSWpqqiQnJyvfyFfRGipvjqpUz549lROf23rPAQEBEhcXJ3FxcZKUlKSMa+trBIB06NBBoqOjJT4+XjZv3ixarVYVfderV0/y8vLEw8OjUmPaQt8zZsyQU6dOSWJioqxYsUI0Go3Nr23W/ZU18hVgxjJjK1/MWGZseaXGfAWYsXWp+B628n2rMWPVnq8AM9YS61uN+QqoM2NrY77a/fcHIiIiIiIiIiIiIqpB/AIvIiIiIiIiIiIiIgvgwVgiIiIiIiIiIiIiC+DBWCIiIiIiIiIiIiIL4MFYIiIiIiIiIiIiIgvgwVgiIiIiIiIiIiIiC+DBWCIiIiIiIiIiIiIL4MFYIiIiIiIiIiIiIgv4f7SKQ0M+jT9GAAAAAElFTkSuQmCC\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.513641595840454\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8lYgsqH-rfAM"},"outputs":[],"source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ # --> 추후, outg 로 tp_gap / out_gap custom 여부를 위해, 본 cell 을 지우지 않음\n","short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","metadata":{"id":"tOFkzUX2imQu"},"source":["#### consecutive dur. value survey on bias"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CgvSrXaZEkMZ"},"outputs":[],"source":["res_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","# devided_cols.append('wave_length_fill_{}{}'.format(wave_itv1, wave_period1))\n","# devided_cols.append('wave_spread_fill_{}{}'.format(wave_itv1, wave_period1))\n","\n","wave_itv1 = '15T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","public_cols.append('upper_wick_ratio_{}'.format(wave_itv1))\n","public_cols.append('lower_wick_ratio_{}'.format(wave_itv1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"elapsed":2660,"status":"ok","timestamp":1666006926730,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"Sahvc-R0jD1A","outputId":"91d95624-5a3d-4996-dcf0-89aa4b24a551"},"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1080 with 12 Axes>"],"image/png":"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a/v888/10Ucf6dlnn1VoaKgGDBigiRMn6u23327S+gAA/ue5557Tp59+qry8POXn52vHjh167rnnPHrujBkz1LVrVx06dEirVq3SmjVrPNotbd68eVq5cqUqKir0ox/9yKt8L1y4oKSkJN1zzz06ceKEUlNTNWXKFH322WderQdoLZYfSEQQvoxvfetbZvv27ebkyZPm6NGj5n//939N7969TUpKilm1apW73aUTB1w6CHTgwIHmgw8+MMePHze7du0y999/v7ttXScouPHGG01OTo6pqKgw69evbzCn++67z+zfv99UVFSYp5566orXbiz69OljNm3aZE6dOmX27dtnpk+fbvk4EwRBEP4ZixYtMq+++qrleRCEv0TAf24AAACgDerfv79CQ0OVn5+v+Ph4bdy4UT/5yU+0YcMGq1MD/AK7tAEAALRhXbp00ZtvvqkzZ87o9ddf15IlS7RhwwbdcccdOnXqVJ3hidmzZ9f53I0bN7ZwjwDfYgsP4ANRUVHavXt3nY8NHDiw0bOxPfDAA3rllVeuWL5//37ddNNNPskRAACgPaLgAQAAAGBbwVYnIElffvlljYttAQBaX3R0tL7xjW9YnYZfYp4CAOs1dZ7yi4Jn//79io+PtzoNAGjXHA6H1Sn4LeYpALBeU+cpTloAAAAAwLYoeAAAAADYFgUPAAAAANui4AEAAABgW35x0gIrXSMptNaySkknLcgFAAAAaG21vw/b7btwuy94QiVtqrUs0YpEAAAAAAvU/j5st+/C7NIGAAAAwLYoeAAAAADYFgUPAAAAANui4AEAAABgWxQ8AAAAAGyLggcAAACAbVHwAAAAALAtCh4AAAAAtmXbC4/a/YqxAAAAABrX6BaeDh06aPv27dq5c6cKCgo0b948SVLfvn2VnZ0tp9Op9PR0hYSESJJCQ0OVnp4up9Op7OxsRUdHt2gH6nPpirGXwl38XCMp/LIIsCI7AAAAoOXU/sob/p9l7VGjBc9XX32lO++8U4MGDdKgQYN09913a9iwYVq8eLGWLl2qmJgYVVRUaOrUqZKkqVOnqqKiQjExMVq6dKkWL17c4p3wSu1KiIIHAAAANlP7K2+NDQDtjEfH8Jw5c0aSFBISopCQEBljdOedd2rdunWSpJUrV+r++++XJCUlJWnlypWSpHXr1mn06NEtkTcAAAAANMqjgicw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vf7663rooYf017/+1erU/MYNN9yguLg496+EW7Zs0R133KFt27ZZnBk8tWXLFvcW38s9++yz7guTTpo0ya+37jTUh+DgYF177bW67bbbFB8fr7Vr1+r666+3IMuGNdSHZcuWaeHChTLGaOHChVqyZImmTp1qQZYNa6gPc+bM0dixYy3IyjuN/X+YO3eu5s6dq2eeeUYzZszQvHnzWj/JRnjyf3rOnDm6cOGCVq9e3drpecSTPqBhbargcblcioqKct+PjIyUy+WSy+XSyJEjayz/4IMPWj9BP1DfGElfH4z/zjvv6Nlnn9X27dutStFy9Y3R8OHDNWLECD3++OPq3LmzQkNDdfr0ac2ePdvCbFtffeMTHBysnTt3qri4WJL01ltv6bbbbmuXBU99Y/Tggw8qOztbZ86ckSRt2rRJw4cPp+BpQ+66664GHw8KCtIPfvADvz44uKE+PPbYY+4LrDocDl28eFHh4eE6cuRIa6Xnkcbeh0tSU1P19ttvt3A2TVNfH2666Sb169dPubm5kr7+/NixY4eGDh3qd7vAevo+rF69Whs3bvTLgqexPiQnJ+t73/ueRo8e3UoZec/T96Etaej7aktoU/ujZGRkuM/ANmzYMJ04cUKHDh1SZmamxo4dq7CwMIWFhWns2LHKzMy0OFtr1DdGISEhWr9+vdLS0vTGG29YnKW16hujBx98UNHR0erXr5+efvpppaWltbtiR6p/fBwOh8LCwhQeHi5JuvPOO7V7924rU7VMfWNUUlKihIQEBQUFKTg4WAkJCdqzZ4/F2cKXxowZo8LCwja7Jfitt97SqFGjJEkxMTEKDQ31u2KnMZf/0v39739fBQUFFmbjvYKCAvXs2VP9+vVTv379VFZWpltuucXvip3G3Hjjje7bSUlJbXL33XHjxmnmzJm67777bHtMqr9yOByKiYlR3759FRISookTJ7b41irLz9RwKV577TVz4MABU1lZaUpLS80jjzxiHn30UfPoo4+62/zxj380RUVFJi8vr8bZKB5++GHjdDqN0+k0Dz30kOV98bcxmjx5sqmsrDQ5OTnuuPnmmy3vjz+N0eWRnJxs27O0NWd8xowZY3Jzc01eXp5ZsWKFCQkJsbw//jRGgYGB5s9//rPZvXu32bVrl1myZInlfSF8GytWrKjxd9DWIiQkxKxatcrk5+ebf//732bU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U1saKzvs2tWS81RxcXGbeS8b0pb+Jhtjl760+X5cNp802Bervy95sc7w4nAd+dTD98SPv1s2+TugN229XWcThYeHq1OnTk16rlcFjy+lpqYqNTW1yc93OByKj4/3YUb2xVh5jrHyDOPkOcaq7ao9T9nlvbRLPyT79MUu/ZDs0xf64X8cDof69evXpOd6tUuby+VSVFSU+35kZKRcLle9bYKCgtS1a9crfjUDAKAlME8BAGrzquBxOByKiYlR3759FRISookTJyojI6NGm4yMDCUnJ0uSxo8fr/fff9932QIA0ADmKQBAbUGS5nna2Bgjp9Op1atX64knntDf/vY3vfnmm5o/f766dOmivXv3Ki8vT5MnT9bzzz+vQYMG6ac//amOHz/eIsnv2LGjRdZrR4yV5xgrzzBOnmOsWk9Lz1N2eS/t0g/JPn2xSz8k+/SFfvifpvYlQJLxbSoAAAAA4B+8vvAoAAAAALQVFDwAAAAAbMvvCp7ly5ervLxc+fn59bZ58cUX5XQ6lZubq8GDB7uXT5kyRXv37tXevXs1ZcqU1kjXUk0dq5tvvlkff/yxCgoKlJubqwkTJrRWypZpzt+VJHXp0kWlpaV66aWXWjpVSzVnnKKiopSZmandu3dr165dtrimS0OaM1aLFy9WQUGBdu/erRdffLE10oWPpKenKycnRzk5OSouLlZOTo7VKTXZjBkztGfPHhUUFGjx4sVWp9NkKSkpKisrc78viYmJVqfULE8++aSMMerevbvVqTTJggULlJubq5ycHGVmZqp3795Wp9RkL7zwgvbs2aPc3Fy9+eab6tq1q9UpNcn48eNVUFCg6upqDRkyxOp0vDZu3DgVFhbK6XRq1qxZTV6P8acYMWKEGTx4sMnPz6/z8cTERLNx40YjyQwbNsxkZ2cbSaZbt25m3759plu3biYsLMzs27fPhIWFWd4ffxyrmJgYc+ONNxpJpnfv3ubAgQOma9eulvfHH8fqUvz+9783q1evNi+99JLlffHXccrKyjJjxowxkkynTp3MVVddZXl//HGshg8fbrZt22YCAwNNYGCg+fjjj01CQoLl/SG8j9/+9rfm17/+teV5NCVGjhxptmzZYkJDQ40k06NHD8tzamqkpKSYp556yvI8fBGRkZHm3XffNV988YXp3r275fk0Jbp06eK+/cQTT5hly5ZZnlNT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v16bNm3Sp59+qo8++kj9+/f3er3jx4/Xpk2bPL546+HDh/Xpp5+qqqrK69eqDwUPAAAAgCv85S9/0RNPPKFbb71VTz/9tP70pz95vY6JEydqzZo1LZCd54ItfXUAAAAAfqdTp066/fbb9fe//929rEOHDpKk73//+1qwYMEVz3G5XLr77rvd93v16qVvfetbyszMdC/74x//qO985zuSpD59+ignJ0eS9Pe//13PP/98i/SFggcAAABADYGBgTp+/LgGDx58xWPr16/X+vXrG13HhAkTtH79el24cMG9bMaMGe7bxcXFda7f19ilDQAAAEANp06dUnFxscaPH+9e9u1vf9urdUyaNMny3dkuMQRBEARBEARBtN947bXXzIEDB0xlZaUpLS01jzzyiOnbt6/ZtGmT2blzp9m1a5f59a9/7fH6oqOjTVlZmQkICKi3TXFx8RXLevbsaUpLS82JEydMRUWFKS0tNV26dGlW3zgtNQAAAADbYpc2AAAAALZFwQMAAADAtih4AAAAANgWBQ/qlJKSolWrVlmdRpu3ceNGTZkypdF2xcXFGj16dCtkVNOyZcs0d+7cVn9dAGgKqz4r7aagoEAJCQmNtjPG6IYbbmiFjGrydO4EPEXBg1axYsUKLVy40Oo0Wt0999yjtLQ0q9OQJCUnJ2vr1q01lj322GN67rnnmrXeBQsWKC8vT1VVVUpJSanxWEJCgqqrq3Xq1Cl3XJrELl9WXV2ts2fPuu8/8MADzcoJAFC/m266SR9++KHVaUiq+wdWX8ydr7zyigoLC1VdXa3k5OQajyUnJ+vChQs15qGEhARFRUXVWGaM0enTp93377jjjmblBOtw4VG0uMDAtllXBwYG6uLFi1an4ZGgoCBVV1db8tpFRUWaOXOmfvrTn9b5+IEDBxQVFXXF8i5durhvFxcX6yc/+Ynee++9FssTAOwgICBAxrSNE+xaOTfl5ubq9ddf1+LFi+t8/JNPPtGIESOuWH753GSM0c0336x9+/a1WJ5oHW3zmyh8aubMmSorK9PJkydVWFioO++8U5IUGhqqlStX6uTJkyooKNCQIUPczxkwYICysrJUUVGhgoIC3Xvvve7HVqxYoT/96U965513dPr0aU2dOlWTJ0/WzJkzderUKWVkZDSYT+1N6JdvHUpISFBpaalmz56tw4cPq7i4uMbWgBUrVmjZsmXavHmzTp48qQ8++EDXXXed+/H+/ftr8+bNOnr0qAoLC/WjH/2o3rxHjRpVZ359+/ZVRUWFAgICJEl/+ctfVF5e7n48LS1NP//5zyVJWVlZmjp1qvuxn/zkJ9q9e7dOnjypXbt21Xl14QEDBujzzz/XxIkTGxyn4uJizZw5U7m5uTpz5oyCgoI0a9YsFRUVudd///33u9f55z//WcOHD9epU6dUUVFxxdheys/pdOro0aPasGGDevfu3WAOl/r77rvv6tSpU422BQBfCA0N1dKlS+VyueRyubR06VKFhoZK+r954sknn1R5ebkOHDighx56yP3ca6+9VhkZGTpx4oT+9a9/aeHChVds/a4tOjpaxhgFBQW5l13++Z6cnKxt27bppZde0vHjx7Vnzx73XHqp7fPPP6/t27frxIkTeuutt9StWzf348OGDdM///lPVVRUaOfOnTV2N8vKytJzzz2nbdu26ezZs7r++uvrzHHkyJHKy8tz39+8ebP+9a9/ue9/9NFHSkpKklRz18DAwEDNnj3bPXd8+umnioyMvGL93/nOd1RSUtLornDGGD3++OPau3evnE6nJOn3v/+9SkpKdOLECX366afuLSXjxo3TnDlz9N///d86deqUdu7cecXYBgQE6Nlnn9UXX3yh8vJyrVy5Utdcc02DOUjSn/70J73//vs6f/58o23RPlh+oSPCuoiNjTUlJSWmd+/eRvr6IlHXX3+9SUlJMefOnTOJiYkmMDDQPP/88+aTTz4xkkxwcLBxOp1m9uzZJiQkxIwaNcqcPHnSxMbGGklmxYoV5vjx4+b22283AQEBpkOHDmbFihVm4cKFHuVkjDE33HCD+/7lz01ISDBVVVVmyZIlJjQ01Hz3u981p0+frvHaJ0+eNCNGjDChoaHm97//vdm6dauRZK6++mpTUlJiHnroIRMUFGQGDRpkDh8+bOLi4urNu74c9+/fb2655RYjyRQWFpp9+/aZAQMGuB8bNGiQkWSysrLM1KlTjSQzfvx4U1ZWZm699VYjydxwww3muuuuM9LXF94aPXq0GTx4sNm/f7/5r//6r0bHqbi42OTk5JjIyEjTsWNH92v07t3bBAQEmAkTJpjTp0+bXr16GUkmOTnZPRZ1je2oUaPM4cOHzeDBg01oaKj5wx/+YD788EOP/5ZWrVplUlJSaixLSEgwX331lTl06JD5/PPPze9+9ztz9dVX19mX0aNHW/7/gSAI/45LnxXz5883n3zyienRo4cJDw83//znP82CBQuM9H/zxPz5801wcLBJTEw0Z86cMWFhYUaSWbNmjVmzZo256qqrTFxcnCkpKbnis7F2REdHG2OMCQoKci+7/PM9OTnZVFVVmV/84hcmODjYTJgwwRw/ftx069bN3basrMx885vfNFdffbVZt26dWbVqlZFk+vTpY44cOWISExNNQECAGTNmjDly5IgJDw93P3f//v1m4MCBJigoyAQHB9eZY8eOHc25c+dM9+7dTXBwsDl06JApKysznTt3Nh07djRnz5411157bY1xlGSefvppk5eX555Hv/3tb7vbXZqPx40bZ0pKSkx8fHyj75ExxmzevNl069bNPTdNnjzZXHvttSYoKMg8+eST5uDBg+45NiUlxT0WdY3t7Ich8AAAIABJREFUww8/bJxOp+nXr5/p1KmTeeONN0xaWprHfzNbt241ycnJNZYlJyeb06dPm8OHD5vPPvvMzJ07t8Z7e3lfLv8+QrTdYAtPO1ddXa0OHTpo4MCBCg4O1v79+/X5559LkrZt26ZNmzbp4sWLWrVqlW6++WZJ0m233abOnTtr0aJFqqqqUlZWlt5++21NmjTJvd4NGzbo448/ljFGX331lc/z/vWvf63Kykp99NFHeueddzRhwgT3Y++88462bt2qyspKPfvssxo+fLgiIyP1ve99T1988YVeffVVVVdXa+fOnXrjjTdqbOXxNO8PP/xQCQkJ6tmzpyRp3bp1SkhIUN++fXXNNdcoNzf3iuf85Cc/0QsvvKBPP/1UkrRv3z6VlJS4Hx8xYoQyMjI0ZcoUvfPOOx6Nwx/+8AeVlZW5f8Fat26dDh48KGOM1q5dK6fTqaFDh3q0rsmTJ+uvf/2rcnJyVFlZqdmzZ2v48OGKjo726Pl1KSws1KBBg9S7d2/deeedGjJkiH73u981eX0AIH39ebVgwQIdPnxYR44c0fz58/XjH//Y/XhVVZUWLFigCxcuaNOmTTp9+rT69++vwMBA/fCHP1RKSorOnTunPf+fvXsPi7LM+wD+5aimnJSUlXMrKKZveUBttbCoEAtxxQwPr2Qs5rbacRPTetNsPdSbWq151eQqmopEteC+WpoH0hKblZMgyIwiAgqIguFpRbzfP1xnneE052fm4fvxuq/LYe6Z+f3mgeee3zz3cz/FxUhJSTFLTLW1tVizZg1u3ryJtLQ0nDhxAk899ZTm/s2bN6OoqAhXr17F22+/jSlTpsDR0REzZszAzp07sWvXLggh8MMPP+Cf//wnxo8fr3nsxo0bcfz4cTQ3N+PmzZutvv7169ehVCrxyCOPYNiwYcjPz8dPP/2E0aNHY9SoUVCpVLh48WKLx/3hD3/AW2+9hdLSUgBAQUGBVr9nnnkGn332GaKjo6FUKvV6L5YvX476+nrN2LRlyxZcvHgRzc3NWLVqFbp06YL+/fvr9VzTp0/HqlWrUFZWhitXruDNN99EfHy81tE2Q/34448YNGgQevfujbi4OEydOhVvvPGG0c9Hto8FTyd38uRJvPLKK1i8eDFqa2uxbds2zTSm6upqTb+rV6+iW7ducHJyQt++fVFRUaE1h7i8vBy+vr6a2xUVFRaLub6+HlevXtV67b59+7b62leuXMHFixfRt29fBAYGYuTIkaivr9e06dOnw8fHx+C4s7KyMHbsWDzyyCP48ccfceDAAURERCAiIgIHDx5sdX61v79/u/OA58yZg59//tmgE0l14/3v//5v5ObmavIbNGgQvL299Xquvn37ory8XHP7ypUruHDhgtZ2NVRNTQ2Ki4shhMDp06cxf/58xMXFGf18RERAy/2V7jhw4cIFrXNHrl69ih49euDee++Fi4uL1r7TXONVVVWV1u32xqby8nK4urrC29sbgYGBeOaZZ7TGpjFjxmhNKTZmbMrKytIam9oaWzoam1555RWkpaWhqKhIrxhai/f111/H8ePH0dDQgPr6enh4eBg9NpWXl8PFxUXzhaMxysrKcPr0aQghUFhYiHfffReTJ082+vnI9rHgIWzbtg0PP/ywZo5yWyf43XHnJPQ757AAQEBAgNbOXvcDvyEnWF65cgX33HOP5vbdBQkAeHl5ad0fEBCAs2fPam7ffYJ89+7d0bNnT5w9exYVFRXIysqCl5eXprm5ueHFF180OM6srCw8/PDDGDt2LLKysnDo0CGMHj263UGloqKi3eU958yZg4CAAIOOgNwdb0BAABQKBebOnYtevXrBy8sLhYWFmu3UUW5nz57VOppzzz33oFevXi0GcVMIIex2EQsish26+yvdcaAt58+fR1NTk9Y5Kq0tqqLrypUrANDu2KT7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efjyyy/xzTffmPMlWsjJybHo80tFrnkB8s1NrnkB8s1NrnkB8s7NVNYeq+S+LeScH3OzT3LODZB3fpbIzeyLFhAREREREdkKi1x4lIiIiIiIyBaw4CEiIiIiItmy6YInKioKJSUlUKlUSE5ObnG/q6srUlNToVKpkJ2djcDAQM19CxYsgEqlQklJCZ588klrht0hY/MKDAzE1atXkZubi9zcXKxbt87aobero7wefvhhHD16FE1NTYiLi9O6b+bMmSgtLUVpaSlmzpxprZD1ZkpuN2/e1GyzjIwMa4Wsl47yevXVV1FUVIT8/Hz88MMPCAgI0Nxn79usvdxseZsBHef2wgsvoKCgALm5uTh48CDCwsI099nyvtHedbRd7pg0aRKEEBg2bJgVozNNR7klJCSgtrZW83eTmJgoQZTG0We7PfPMMygqKkJhYSG2bNli5QhN01F+q1at0my3EydOoL6+XoIojdNRbv7+/ti3bx9ycnKQn5+P6OhoCaI0Tke5BQQE4IcffkB+fj72798PX19fCaI0zvr161FTU4Njx4612eejjz6CSqVCfn4+hgwZYpbXlXzN7daao6OjUKvnvROeAAAgAElEQVTVIjg4WLi4uIi8vDwRFham1eePf/yjWLdunQAgnn32WZGamioAiLCwMJGXlydcXV1FUFCQUKvVwtHRUfKcTM0rMDBQHDt2TPIcjM0rMDBQDB48WKSkpIi4uDjNz728vMTJkyeFl5eX8PT0FCdPnhSenp6S52SO3ACIxsZGyXMwNq+xY8eKbt26CQBizpw5mt9FOWyztnKz5W2mb25ubm6a/8fExIhdu3YJwLb3jfbe9NkuAESPHj1EVlaWOHz4sBg2bJjkcZsrt4SEBItec0/K3Pr16ydycnI0+7h7771X8rjNmd/dbe7cuWL9+vWSx22u3D777DMxZ84cAdze/5WVlUket7lyS0tLEzNnzhQAxKOPPio2bdokedz6tocfflgMGTKkzc+00dHRYufOnQKAGDlypMjOzjb9PYWNGjFiBNRqNcrKytDU1ITU1FTExsZq9YmNjUVKSgoAID09HZGRkZqfp6am4saNGzh9+jTUajVGjBhh9RxaY0petkyfvMrLy3Hs2DHcunVL6+dRUVHYs2cP6uvr0dDQgD179mDcuHHWDL9dpuRmy/TJ68CBA7h27RoAIDs7G35+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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_p1_idx]\n","  long_open_data = long_data[long_p1_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  # short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  short_false_data = short_open_data[~short_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  # long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  long_false_data = long_open_data[~long_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":881},"executionInfo":{"elapsed":2820,"status":"ok","timestamp":1659074362424,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"jHh0uFkXC4VF","outputId":"cf21f56c-faf2-471d-b7e0-5c16e0ff2bdd"},"outputs":[{"output_type":"stream","name":"stdout","text":["223\n","533\n","223\n","533\n","223\n","533\n","223\n","533\n","pkx : [0.05994977 0.14818175 0.35111529 0.74815919]\n","pkx : [0.09816775 0.30374184 0.78029994]\n","\n","56\n","84\n","56\n","84\n","56\n","84\n","56\n","84\n","pkx : [-0.23140658 -0.19827966 -0.16515274 -0.14385686 -0.11072994 -0.07287061 -0.01371539]\n","pkx : [-0.32640606 -0.24710795 -0.18102619 -0.11494443 -0.03234223]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(short_max_data))\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"mScdfR9hmjVu"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"983aUwM76s6X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p_e8PtFXa7mc"},"outputs":[],"source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLZDkNNxbZPO"},"outputs":[],"source":["p1_hlm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":261,"status":"ok","timestamp":1653452376525,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WhCPOi1qbkHS","outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"outputs":[{"data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"execution_count":161,"metadata":{},"output_type":"execute_result"}],"source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wgERZ65F5RBB"},"outputs":[],"source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rAao95SEnOY0"},"outputs":[],"source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":267,"status":"ok","timestamp":1653119592395,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"OEQ9KWXVnQ2J","outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"outputs":[{"name":"stdout","output_type":"stream","text":["153\n","163\n"]},{"data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"execution_count":220,"metadata":{},"output_type":"execute_result"}],"source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hOtCGUeBQ4hn"},"outputs":[],"source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QPhjkZQhRLqr"},"outputs":[],"source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cFd7Fz0Y6ucU"},"outputs":[],"source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v4"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":94486,"status":"ok","timestamp":1662375629618,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oVifICO4-Grk","outputId":"6a893363-2ab7-4613-d92b-14407dcb5617"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.10000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.10000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.4183809757232666\n","get_open_info_df elapsed time : 1.1475732326507568\n","en_ex_pairing elapsed time : 0.002592325210571289\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.20000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.20000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.1166181564331055\n","get_open_info_df elapsed time : 1.1268563270568848\n","en_ex_pairing elapsed time : 0.05585646629333496\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.1961812973022461\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9891541004180908\n","get_open_info_df elapsed time : 1.133213996887207\n","en_ex_pairing elapsed time : 0.443495512008667\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21266508102416992\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.40000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.010218620300293\n","get_open_info_df elapsed time : 1.1166355609893799\n","en_ex_pairing elapsed time : 1.9594817161560059\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.25990796089172363\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.50000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9856662750244141\n","get_open_info_df elapsed time : 1.1325628757476807\n","en_ex_pairing elapsed time : 4.9015138149261475\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.3125646114349365\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.60000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.60000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.008387565612793\n","get_open_info_df elapsed time : 1.125178575515747\n","en_ex_pairing elapsed time : 8.5075364112854\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.35973072052001953\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.70000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.70000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.025289535522461\n","get_open_info_df elapsed time : 1.1360254287719727\n","en_ex_pairing elapsed time : 12.39824891090393\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.39333009719848633\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.80000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.80000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.034311056137085\n","get_open_info_df elapsed time : 1.1319921016693115\n","en_ex_pairing elapsed time : 16.35196018218994\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.41879725456237793\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 28319\n","WARNING:root:np.sum(long_open_res1 == 1) : 28683\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.90000 (1.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.90000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0511291027069092\n","get_open_info_df elapsed time : 1.1418323516845703\n","en_ex_pairing elapsed time : 19.928776502609253\n","idep_plot elapsed time : 0.41760993003845215\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAABWkAAAILCAYAAACadh4AAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzde1gUZfsH8C+nReW0CAiKiIhgKopYHkrLkjyQGZbmq1agkeY5U/PUgdQ0stfMSqkfIqmpaKmJeSS1VzMyVERRFFQkQI4CuyAqp+f3B7GJgJx2mV34fq7ruS52Znbm3hmWm3nmmXv0AAgQERERERERERERkST0pQ6AiIiIiIiIiIiIqDljJy0RERERERERERGRhNhJS0RERERERERERCQhdtISERERERERERERSYidtEREREREREREREQSYictERERERERERERkYTYSUtNmr+/P7Zs2SJ1GERERFSFhIQEeHp6Sh0GERERVUMIAWdnZ7Wsy9fXFydPnlTLuoiaInbSEtVBSEgIli9fLnUYRERERERERFrL0dERQggYGBhIHQqRzmAnLVEt6evz60JEREREREREROrHXidqEhYsWIDk5GQolUpcuXIFgwcPVs2TyWTYtGkTlEolYmJi8Pjjj6vmPfbYYzh+/DhycnIQExODkSNHquaFhIRg/fr12L9/P/Lz8+Hn54fXXnsNCxYsQF5eHsLCwhr1MxIRETVlMpkMa9asQUpKClJSUrBmzRrIZDIAwKBBg5CUlIS5c+ciPT0dt27dwsSJE1Xvbd26NcLCwqBQKPDXX39h+fLlvJ2SiIhITV544QVcv34dmZmZWLVqFfT09AAAenp6eP/993Hz5k2kp6dj06ZNMDc3BwCcOHECAJCbm4u8vDz0799ftb7PP/8c2dnZuHHjBoYPH974H4hIiwk2Nl1urq6u4u+//xZt27YVAISjo6Po1KmTACD8/f3F3bt3hZeXl9DX1xcrV64UERERAoAwNDQU8fHxYvHixcLIyEg899xzQqlUCldXVwFAhISEiNzcXPHUU08JPT09YWxsLEJCQsTy5csl/8xsbGxsbGxNoSUkJAhPT08BQCxdulREREQIGxsbYW1tLU6dOiWWLVsmAIhBgwaJoqIisXTpUmFoaCi8vLzEnTt3hFwuFwDE9u3bxfbt20XL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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","val_list = np.arange(0.1, 1, 0.1)     # prcn 1\n","# val_list = np.arange(-0.5, 0.5, 0.05)  # prcn 2\n","# val_list = np.arange(-0.5, 0., 0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(1, 10, 1)   # prcn -1\n","# val_list = np.arange(100, 120, 1)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  config_list_copy[0].loc_set.point1.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point1.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val\n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  # config_list_copy[0].tr_set.ep_gap1 = set_val \n","  # config_list_copy[0].tr_set.ep_gap2 = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","  # config_list_copy[0].tr_set.wave_length1 = set_val  \n","  # config_list_copy[0].tr_set.wave_time_ratio1 = set_val\n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","  open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","  open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=2)\n","  open_info_df_list = [open_info_df1, open_info_df2]\n","\n","  try:\n","    result.append(get_res_v9(res_df, open_info_df_list, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'frq', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1658210884.pkl\"\n","trade_log_dir_path = \"./trade_log/0717_5_47_trader\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","source":["trade_log  # both pos_side's log"],"metadata":{"id":"9Kymnik4ZpA6"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1658222594162,"user_tz":-540,"elapsed":431,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"a06c3f6a-311d-4a7d-c425-00563fd8980f"},"outputs":[{"output_type":"stream","name":"stdout","text":["lacked_open_ts : []\n","added_open_ts : ['2022-01-14 17:27:59.999000']\n","\n","lacked_entry_ts : []\n","added_entry_ts : ['2022-01-14 17:28:59.999000']\n","\n","lacked_exit_ts : []\n","added_exit_ts : ['2022-01-14 19:53:59.999000']\n","\n"]}],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"SELL\" # BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","op_ts = list(map(lambda x : str(x), res_df.index[val_obj[4].astype(int).ravel()])) \n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","for order_type, ts_ in zip(['open', 'entry', 'exit'], [op_ts, en_ts, ex_ts]):\n","  trade_log_ts = [k for k, v in trade_log.items() if order_type in v if pos_side in v]\n","  lacked_ts = [ts for ts in ts_ if not ts in trade_log_ts]\n","  added_ts = [ts for ts in trade_log_ts if not ts in ts_]\n","\n","  print(\"lacked_{}_ts :\".format(order_type), lacked_ts)\n","  print(\"added_{}_ts :\".format(order_type), added_ts)\n","  print()"]},{"cell_type":"code","source":["# ex_ts\n","# [k for k, v in trade_log.items() if order_type in v if pos_side in v]\n","# list(trade_log.keys())[1]\n","res_df.iloc[-0:]"],"metadata":{"id":"ZlcPZeuO-UnB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### check added_ts"],"metadata":{"id":"bPfWgZCI73LZ"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"markdown","source":["#### price sync_check"],"metadata":{"id":"yMFIedEG77Yt"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    # print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v9_1(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if config_list[0].tr_set.check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  # paired_res = en_ex_pairing_v9_41(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  paired_res = en_ex_pairing_v9_4(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16_3(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v16_3(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","    # print(\"passed\")\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","          short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    \n","    short_ll = res_df['ll_{}'.format(config.tr_set.wave_itv1)].to_numpy()[short_net_p1_idx_arr]\n","    short_ll_odds = np.sum(short_ll) / len(short_ll)\n","    long_hh = res_df['hh_{}'.format(config.tr_set.wave_itv1)].to_numpy()[long_net_p1_idx_arr]\n","    long_hh_odds = np.sum(long_hh) / len(long_hh)\n","    both_odds = (short_ll_odds + long_hh_odds) /2\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","    # print(\"short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick :\", short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8_1(gs, gs_idx, len_df, sample_len, short_tr, short_ll_odds, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8_1(gs, gs_idx, len_df, sample_len, long_tr, long_hh_odds, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8_1(gs, gs_idx, len_df, sample_len, both_tr, both_odds, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_net_p1_bias_tick, short_p2exec_p1_bias_tick, short_net_p1_idx_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_net_p1_bias_tick, long_p2exec_p1_bias_tick, long_net_p1_idx_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"code","source":["\n","def plot_info_v8_1(gs, gs_idx, len_df, sample_len, tr, hhll, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n hhll : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhll, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"],"metadata":{"id":"ocrkzEQPunhA"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","source":["# lvrg_set_v2 adj.\n","def en_ex_pairing_v9_41(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    open, high, low, close = ohlc_list\n","\n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:  # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        if show_detail:\n","            print(\"open_i1 :\", open_i1, side_arr1[open_i1])\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1  # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","            # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm\n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        if show_detail:\n","            print(\"============ op_idx1 : {} {} ============\".format(op_idx1, open_side))\n","\n","        # if show_detail:\n","        #   print(\"check_hlm :\", check_hlm)\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.entry_type, op_idx1, tp_1_, tp_gap_, len_df,\n","                                                                          open_side,\n","                                                                          [*ohlc_list, ep1_arr], expiry_p2)\n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","                print(\"p1's expiry by expiry_p2 function in p1's loop : continue\")\n","            continue\n","            # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        # if check_hlm in [0, 1]:\n","        #   i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","            # ============ get p2_info ============ #\n","            if check_hlm in [1, 2]:\n","                open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","                if open_i2 >= len_open_idx2:  # open_i2 소진\n","                    break\n","\n","                if show_detail:\n","                    print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","                # ------ check side sync. ------ #\n","                if open_side != side_arr2[open_i2]:\n","                    continue\n","\n","                # ------ assert, op_idx2 >= exec_j ------ #\n","                op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","                if check_hlm == 1 and allow_exit:\n","                    if op_idx2 < op_idx1:\n","                        continue\n","                else:\n","                    if op_idx2 < i:  # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","                        continue\n","\n","                if check_hlm == 2:\n","                    i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","                    if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                        break\n","\n","                if show_detail:\n","                    print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","\n","            else:\n","                op_idx2 = op_idx1\n","\n","            tp_ = tp_arr[op_idx1]\n","            ep2_ = ep2_arr[op_idx2]\n","            out_ = out_arr[op_idx2]\n","\n","            out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","            out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","            out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","\n","            # ------ const. for p2_wave ------ #\n","            wave_itv1 = config.tr_set.wave_itv1\n","            wave_period1 = config.tr_set.wave_period1\n","            wave_itv2 = config.tr_set.wave_itv2\n","            wave_period2 = config.tr_set.wave_period2\n","\n","            if check_hlm in [1, 2]:\n","                # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","                # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","                # if check_hlm:  # p1_hlm, p2_hlm --> Todo, 이거를 왜 p1_hlm 에도 적용했는지 잘 모르겠음\n","                if op_idx1 < op_idx2:\n","                    expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","                    if expire:  # p1's expiry\n","                        if show_detail:\n","                            print(\"expiry_p1, touch_idx = {} : break\".format(touch_idx))\n","                        i = touch_idx  # + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                        open_i2 = prev_open_i2\n","                        break  # change op_idx1\n","\n","                if check_hlm == 2:\n","                    # ------ p2 point_validation - vectorization unavailable ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","                    if open_side == OrderSide.SELL:\n","                        # --- p2_wave validation --- #\n","                        wave_co_post_idx = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        if not (op_idx1 < wave_co_post_idx):\n","                            if show_detail:\n","                                print(\"p2_wave validation : continue\")\n","                            continue  # change op_idx2\n","\n","                        # --- p2_wave high validation --- #\n","                        # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                        # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        # if not (wave_high_fill1_ >= wave_high_fill2_):\n","                        #   if show_detail:\n","                        #     print(\"p2_wave high validation : continue\")\n","                        #   continue  # change op_idx2\n","\n","                        if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","                            break  # change op_idx1\n","                        elif not (ep2_ < out_ and close[op_idx2] < out_):\n","                            if show_detail:\n","                                print(\"point validation : continue\")\n","                            continue  # change op_idx2\n","                    else:\n","                        # --- p2_wave validation --- #\n","                        wave_cu_post_idx = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        if not (op_idx1 < wave_cu_post_idx):\n","                            if show_detail:\n","                                print(\"p2_wave validation : continue\")\n","                            continue  # change op_idx2\n","\n","                        # --- p2_wave low validation --- #\n","                        # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                        # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                        # if not (wave_low_fill1_ <= wave_low_fill2_):\n","                        #   if show_detail:\n","                        #     print(\"p2_wave low validation : continue\")\n","                        #   continue  # change op_idx2\n","\n","                        if not (tp_ > ep2_):\n","                            break\n","                        elif not (ep2_ > out_ and close[op_idx2] > out_):\n","                            if show_detail:\n","                                print(\"point validation : continue\")\n","                            continue\n","\n","                    # ------ p2_box location ------ #\n","                    if open_side == OrderSide.SELL:\n","                        if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (\n","                                out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                            # if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                            if show_detail:\n","                                print(\"p2_box rejection : continue\")\n","                            continue\n","                        else:\n","                            # ------ p1p2_low ------ #\n","                            if not high[op_idx1:op_idx2 + 1].max() < tp_0_ - tp_gap_ * config.tr_set.p1p2_low:\n","                                if show_detail:\n","                                    print(\"p1p2_low rejection : continue\")\n","                                continue\n","                    else:\n","                        if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                            # if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                            if show_detail:\n","                                print(\"p2_box rejection : continue\")\n","                            continue\n","                        else:\n","                            # ------ p1p2_low ------ #\n","                            if not low[op_idx1:op_idx2 + 1].min() > tp_0_ + tp_gap_ * config.tr_set.p1p2_low:\n","                                if show_detail:\n","                                    print(\"p1p2_low rejection : continue\")\n","                                continue\n","\n","                    # ------ check p2's expiry ------ # - 현재, op_idx2 기준의 ep2_arr 을 사용 중임.\n","                    # exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, tp_1_, tp_gap_, len_df, open_side,\n","                    #                                                                         [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄                                                                                      \n","                    exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, out_1_,\n","                                                                                   out_gap_, len_df, open_side,\n","                                                                                   [*ohlc_list, ep2_arr],\n","                                                                                   expiry_p2)  # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄\n","                    i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","                    if not entry_done:  # p2's expiry\n","                        if show_detail:\n","                            print(\"expiry_p2, i = {} : continue\".format(i))\n","                        continue  # change op_idx2            \n","\n","                    # ------ devectorized tr_calc ------ # - en_p 에 대해 하는게 맞을 것으로봄\n","                    if open_side == OrderSide.SELL:\n","                        tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))\n","                    else:\n","                        tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))\n","\n","                        # ------ tr_threshold ------ #\n","                    if config.loc_set.point2.short_tr_thresh != \"None\":\n","                        if open_side == OrderSide.SELL:\n","                            if tr_ < config.loc_set.point2.short_tr_thresh:\n","                                if show_detail:\n","                                    print(\"tr_threshold : continue\")\n","                                continue\n","                        else:\n","                            if tr_ < config.loc_set.point2.long_tr_thresh:\n","                                if show_detail:\n","                                    print(\"tr_threshold : continue\")\n","                                continue\n","\n","            if not allow_exit:  # p1_hlm 의 경우, 한번 out 되면 price 가 wave_range 에 닿기전까지 retrade 를 허용하지 않는다. (expiry_p1 을 이용해 op_idx1 을 변경할 것)  \n","                if show_detail:\n","                    print(\"allow_exit = {} : continue\".format(allow_exit))\n","                continue\n","\n","            if check_hlm in [0, 1]:\n","                tr_ = tr_arr[op_idx1]\n","\n","            # ------ leverage ------ #\n","            # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","            # leverage = lvrg_set_v2(config.trader_set.initial_asset, config, open_side, tp_, out_, fee, config.lvrg_set.limit_leverage)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","            leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)\n","            if leverage is None:\n","                if show_detail:\n","                    print(\"leverage is None : continue\")\n","                if check_hlm:\n","                    continue  # change op_idx2\n","                else:\n","                    break  # change op_idx1\n","\n","            exit_done, cross_on = 0, 0\n","            # ------ check tpout_onexec ------ #\n","            # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","            if config.ep_set.entry_type == \"LIMIT\":\n","                if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                    tp_j = exec_j\n","                if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                    out_j = exec_j\n","\n","            # ============ exit loop ============ #\n","            while 1:\n","                if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                    tp_j = i\n","                if not config.out_set.static_out:\n","                    out_j = i\n","\n","                # ------------ out ------------ #  # out 우선 (보수적 검증)\n","                # ------ signal_out ------ #\n","                if not exit_done:\n","                    exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done,\n","                                                                         [*ohlc_list, np_timeidx])\n","                # ------ hl_out ------ #\n","                if config.out_set.hl_out:\n","                    if not exit_done:  # and i != len_df - 1:\n","                        exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","                # ------------ tp ------------ #\n","                if not config.tp_set.non_tp and i != exec_j:\n","                    if not exit_done:\n","                        exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                                   [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                        # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                        # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","                if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                    # ------ append dynamic vars. ------ #\n","                    p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                    p2_idx_list.append(op_idx2)\n","                    pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                    pair_price_list.append([en_p, ex_p])\n","                    lvrg_list.append(leverage)\n","                    fee_list.append(fee)\n","                    tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                    tr_list.append(tr_)  # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                    # open_i += 1  # 다음 open_idx 조사 진행\n","                    break\n","\n","                # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","                # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","                i += 1\n","                if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                    break\n","\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","            if exit_done == 1:  # tp_done 은 check_hlm 여부와 무관하게 op_idx1 을 변경함\n","                if show_detail:\n","                    print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","                break  # change op_idx1\n","            else:  # exit_done -> -1 or 0 (0 means end of df) \n","                if check_hlm in [1, 2]:\n","                    if check_hlm == 1:  # exit only once in p1_hlm mode\n","                        allow_exit = 0\n","                    if show_detail:\n","                        print(\"exit_done = {}, i = {} : continue\".format(exit_done, i))\n","                    continue  # change op_idx2\n","                else:\n","                    if show_detail:\n","                        print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","                    break  # change op_idx1    \n","\n","        # if op_idx1 >= 16355:\n","        #   break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(\n","        lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)"],"metadata":{"id":"dJB5VtXMM8D8"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def check_entry_v6(res_df, config, entry_type, op_idx, wave1, wave_gap, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave_gap, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3_1(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id  \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ cci ------ # \n","    if config.out_set.cci_exit:\n","        if open_side == OrderSide.SELL:\n","            wave_co_ = res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","            if wave_co_[i]:\n","                exit_done = -1\n","        else:\n","            wave_cu_ = res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","            if wave_cu_[i]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"qM6H6fmrKtsA"},"source":["#### legacy"]},{"cell_type":"code","source":["def get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_p2exec_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_p2exec_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정 --> olds\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","    # last_idx = np.inf  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))   # p1's 1st & 2nd pair 위해서 last_idx 마지막에 붙여준 것\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # print(\"pass min touch_idx\")\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","\n","    short_tp_1_p2exec_p1_touch_idx = short_tp_1_touch_idx[short_p2exec_p1_idx]  # p2 까지 체결된 p1's hhm (p2 executed p1_hhm)\n","    short_tp_0_p2exec_p1_touch_idx = short_tp_0_touch_idx[short_p2exec_p1_idx]\n","    long_tp_1_p2exec_p1_touch_idx = long_tp_1_touch_idx[long_p2exec_p1_idx]\n","    long_tp_0_p2exec_p1_touch_idx = long_tp_0_touch_idx[long_p2exec_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------ get wave's bias_tick ------------ #\n","    short_tp_1_net_p1_touch_idx2 = np.where(short_tp_1_net_p1_touch_idx == last_idx, np.nan, short_tp_1_net_p1_touch_idx)\n","    long_tp_1_net_p1_touch_idx2 = np.where(long_tp_1_net_p1_touch_idx == last_idx, np.nan, long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx2 = np.where(short_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, short_tp_1_p2exec_p1_touch_idx)\n","    long_tp_1_p2exec_p1_touch_idx2 = np.where(long_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, long_tp_1_p2exec_p1_touch_idx)\n","\n","    short_net_p1_bias_tick = short_tp_1_net_p1_touch_idx2 - short_net_p1_idx\n","    long_net_p1_bias_tick = long_tp_1_net_p1_touch_idx2 - long_net_p1_idx\n","\n","    short_p2exec_p1_bias_tick = short_tp_1_p2exec_p1_touch_idx2 - short_p2exec_p1_idx\n","    long_p2exec_p1_bias_tick = long_tp_1_p2exec_p1_touch_idx2 - long_p2exec_p1_idx\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_p2exec_p1_true_bias_bool = short_tp_1_p2exec_p1_touch_idx < short_tp_0_p2exec_p1_touch_idx  # true_bias 의 조건\n","    short_p2exec_p1_false_bias_bool = short_tp_1_p2exec_p1_touch_idx >= short_tp_0_p2exec_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_p2exec_p1_true_bias_bool = long_tp_1_p2exec_p1_touch_idx < long_tp_0_p2exec_p1_touch_idx\n","    long_p2exec_p1_false_bias_bool = long_tp_1_p2exec_p1_touch_idx >= long_tp_0_p2exec_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p2exec_tpbox_hhm = hhm(short_p2exec_p1_true_bias_bool, short_p2exec_p1_false_bias_bool)\n","    long_p2exec_tpbox_hhm = hhm(long_p2exec_p1_true_bias_bool, long_p2exec_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_p2exec_tpbox_hhm, long_p2exec_tpbox_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","           short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음\n"],"metadata":{"id":"Z51DvMhgXjUA"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_touch_idx_fill(tp_1_touch_idxs, net_p1_pair, net_p1_idx, len_df):\n","    tp_1_touch_idx = np.full(len_df, np.nan)\n","    # valid_net_p1_idx = [idx for (iin, iout), idx  in zip(net_p1_pair, net_p1_idx) if iin < iout]\n","    # print(\"len(valid_net_p1_idx) :\", len(valid_net_p1_idx))\n","    tp_1_touch_idx[net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair]\n","    # tp_1_touch_idx[valid_net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair if iin < iout]\n","\n","    return fill_arr(tp_1_touch_idx)"],"metadata":{"id":"I_nHtMZUZx9l"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def en_ex_pairing_v9_5(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    open, high, low, close = ohlc_list\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        if show_detail:\n","            print(\"open_i1 :\", open_i1, side_arr1[open_i1])\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm   \n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ============\".format(op_idx1, open_side))\n","     \n","        # if show_detail:\n","        #   print(\"check_hlm :\", check_hlm)\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.entry_type, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry by expiry_p2 function in p1's loop : continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        # if check_hlm in [0, 1]:\n","        #   i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          if check_hlm in [1, 2]:\n","            open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","            if open_i2 >= len_open_idx2:  # open_i2 소진\n","                break\n","\n","            if show_detail:\n","              print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","            # ------ check side sync. ------ #\n","            if open_side != side_arr2[open_i2]:\n","              continue\n","\n","            # ------ assert, op_idx2 >= exec_j ------ #\n","            op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","            if check_hlm == 1 and allow_exit:\n","              if op_idx2 < op_idx1:\n","                continue\n","            else:\n","              if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","                continue\n","            \n","            if check_hlm == 2:\n","              i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","\n","            if show_detail:\n","              print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","              \n","          else:\n","            op_idx2 = op_idx1\n","          \n","          tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]  # p2's tp_box 를 위한 재정의\n","          tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]   \n","\n","          tp_ = tp_arr[op_idx2]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]  \n","\n","          # ------ const. for p2_wave ------ #\n","          wave_itv1 = config.tr_set.wave_itv1\n","          wave_period1 = config.tr_set.wave_period1\n","          wave_itv2 = config.tr_set.wave_itv2\n","          wave_period2 = config.tr_set.wave_period2\n","\n","          if check_hlm in [1, 2]:\n","            # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","            # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","            # if check_hlm:  # p1_hlm, p2_hlm --> Todo, 이거를 왜 p1_hlm 에도 적용했는지 잘 모르겠음\n","            # if op_idx1 < op_idx2:\n","            #   expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","            #   if expire:   # p1's expiry\n","            #       if show_detail:\n","            #         print(\"expiry_p1, touch_idx = {} : break\".format(touch_idx))\n","            #       i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","            #       open_i2 = prev_open_i2\n","            #       break   # change op_idx1\n","\n","            if check_hlm == 2:\n","              # ------ p2 point_validation - vectorization unavailable ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","              if open_side == OrderSide.SELL:\n","                # --- p2_wave validation --- #\n","                wave_co_post_idx = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                if not (op_idx1 < wave_co_post_idx):\n","                  if show_detail:\n","                    print(\"p2_wave validation : continue\")\n","                  continue  # change op_idx2\n","\n","                # --- p2_wave high validation --- #\n","                # wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                # if not (wave_high_fill1_ >= wave_high_fill2_):\n","                #   if show_detail:\n","                #     print(\"p2_wave high validation : continue\")\n","                #   continue  # change op_idx2\n","                  \n","                if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","                  break  # change op_idx1\n","                elif not (ep2_ < out_ and close[op_idx2] < out_):\n","                  if show_detail:\n","                    print(\"point validation : continue\")\n","                  continue  # change op_idx2\n","              else:\n","                # --- p2_wave validation --- #\n","                wave_cu_post_idx = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                if not (op_idx1 < wave_cu_post_idx):\n","                  if show_detail:\n","                    print(\"p2_wave validation : continue\")\n","                  continue  # change op_idx2\n","                \n","                # --- p2_wave low validation --- #\n","                # wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()[op_idx1]\n","                # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()[op_idx2]\n","                # if not (wave_low_fill1_ <= wave_low_fill2_):\n","                #   if show_detail:\n","                #     print(\"p2_wave low validation : continue\")\n","                #   continue  # change op_idx2\n","\n","                if not (tp_ > ep2_):              \n","                  break\n","                elif not (ep2_ > out_ and close[op_idx2] > out_):\n","                  if show_detail:\n","                    print(\"point validation : continue\")\n","                  continue\n","\n","              # ------ p2_box location ------ #\n","              # if open_side == OrderSide.SELL:\n","              #   if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","              #   # if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","              #     if show_detail:\n","              #         print(\"p2_box rejection : continue\")\n","              #     continue\n","              #   else:                \n","              #     # ------ p1p2_low ------ #\n","              #     if not high[op_idx1:op_idx2 + 1].max() < tp_0_ - tp_gap_ * config.tr_set.p1p2_low:\n","              #       if show_detail:\n","              #         print(\"p1p2_low rejection : continue\")\n","              #       continue\n","              # else:\n","              #   if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","              #   # if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","              #     if show_detail:\n","              #         print(\"p2_box rejection : continue\")\n","              #     continue\n","              #   else:\n","              #     # ------ p1p2_low ------ #\n","              #     if not low[op_idx1:op_idx2 + 1].min() > tp_0_ + tp_gap_ * config.tr_set.p1p2_low:\n","              #       if show_detail:\n","              #         print(\"p1p2_low rejection : continue\")\n","              #       continue\n","\n","              # ------ check p2's expiry ------ # - 현재, op_idx2 기준의 ep2_arr 을 사용 중임.\n","              # exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, tp_1_, tp_gap_, len_df, open_side,\n","              #                                                                         [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄                                                                                      \n","              exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, out_1_, out_gap_, len_df, open_side,\n","                                                                                      [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄\n","              i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","              if not entry_done:   # p2's expiry\n","                  if show_detail:\n","                      print(\"expiry_p2, i = {} : continue\".format(i))\n","                  continue  # change op_idx2            \n","              \n","              # ------ devectorized tr_calc ------ # - en_p 에 대해 하는게 맞을 것으로봄\n","              if open_side == OrderSide.SELL:\n","                tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))\n","              else:\n","                tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))              \n","\n","              # ------ tr_threshold ------ #\n","              if config.loc_set.point2.short_tr_thresh != \"None\":\n","                if open_side == OrderSide.SELL:\n","                  if tr_ < config.loc_set.point2.short_tr_thresh:\n","                    if show_detail:\n","                      print(\"tr_threshold : continue\")\n","                    continue\n","                else:\n","                  if tr_ < config.loc_set.point2.long_tr_thresh:\n","                    if show_detail:\n","                      print(\"tr_threshold : continue\")\n","                    continue\n","                \n","          if not allow_exit:  # p1_hlm 의 경우, 한번 out 되면 price 가 wave_range 에 닿기전까지 retrade 를 허용하지 않는다. (expiry_p1 을 이용해 op_idx1 을 변경할 것)  \n","            if show_detail:\n","              print(\"allow_exit = {} : continue\".format(allow_exit))\n","            continue\n","\n","          if check_hlm in [0, 1]:\n","            tr_ = tr_arr[op_idx1]\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None : continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ #\n","          while 1:\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ out ------------ #  # out 우선 (보수적 검증)\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out:\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","              if not exit_done:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                          [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                p2_idx_list.append(op_idx2)\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done 은 check_hlm 여부와 무관하게 op_idx1 을 변경함\n","            if show_detail:\n","                    print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:  # exit_done -> -1 or 0 (0 means end of df) \n","            if check_hlm in [1, 2]:\n","              if check_hlm == 1:   # exit only once in p1_hlm mode\n","                allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : continue\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        # if op_idx1 >= 16355:\n","        #   break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"AH3JXLkwL_B6","executionInfo":{"status":"ok","timestamp":1658884508950,"user_tz":-540,"elapsed":1076,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0fa49ccd-e99c-44fd-ac0a-84441dd585d4"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["False"]},"metadata":{},"execution_count":21}]},{"cell_type":"code","execution_count":null,"metadata":{"id":"uB-I09hKKvmu"},"outputs":[],"source":["def get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_p2exec_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_p2exec_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정 --> olds\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))   # p1's 1st & 2nd pair 위해서 last_idx 마지막에 붙여준 것\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx = short_tp_1_touch_idx[short_p2exec_p1_idx]  # p2 까지 체결된 p1's hhm (p2 executed p1_hhm)\n","    short_tp_0_p2exec_p1_touch_idx = short_tp_0_touch_idx[short_p2exec_p1_idx]\n","    long_tp_1_p2exec_p1_touch_idx = long_tp_1_touch_idx[long_p2exec_p1_idx]\n","    long_tp_0_p2exec_p1_touch_idx = long_tp_0_touch_idx[long_p2exec_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------ get wave's bias_tick ------------ #\n","    short_tp_1_net_p1_touch_idx2 = np.where(short_tp_1_net_p1_touch_idx == last_idx, np.nan, short_tp_1_net_p1_touch_idx)\n","    long_tp_1_net_p1_touch_idx2 = np.where(long_tp_1_net_p1_touch_idx == last_idx, np.nan, long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx2 = np.where(short_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, short_tp_1_p2exec_p1_touch_idx)\n","    long_tp_1_p2exec_p1_touch_idx2 = np.where(long_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, long_tp_1_p2exec_p1_touch_idx)\n","\n","    short_net_p1_bias_tick = short_tp_1_net_p1_touch_idx2 - short_net_p1_idx\n","    long_net_p1_bias_tick = long_tp_1_net_p1_touch_idx2 - long_net_p1_idx\n","\n","    short_p2exec_p1_bias_tick = short_tp_1_p2exec_p1_touch_idx2 - short_p2exec_p1_idx\n","    long_p2exec_p1_bias_tick = long_tp_1_p2exec_p1_touch_idx2 - long_p2exec_p1_idx\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_p2exec_p1_true_bias_bool = short_tp_1_p2exec_p1_touch_idx < short_tp_0_p2exec_p1_touch_idx  # true_bias 의 조건\n","    short_p2exec_p1_false_bias_bool = short_tp_1_p2exec_p1_touch_idx >= short_tp_0_p2exec_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_p2exec_p1_true_bias_bool = long_tp_1_p2exec_p1_touch_idx < long_tp_0_p2exec_p1_touch_idx\n","    long_p2exec_p1_false_bias_bool = long_tp_1_p2exec_p1_touch_idx >= long_tp_0_p2exec_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p2exec_tpbox_hhm = hhm(short_p2exec_p1_true_bias_bool, short_p2exec_p1_false_bias_bool)\n","    long_p2exec_tpbox_hhm = hhm(long_p2exec_p1_true_bias_bool, long_p2exec_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_p2exec_tpbox_hhm, long_p2exec_tpbox_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","           short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"code","source":["def idep_plot_v17(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"short_net_p1_frq :\", short_net_p1_frq)\n","    # print(\"long_net_p1_frq :\", long_net_p1_frq)\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ get hhm ------ #    \n","    # start_0 = time.time()\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ mean_low ------ #    \n","    # start_0 = time.time()\n","    selection_id = config.selection_id\n","\n","    short_p1_idx = short_obj[-1].astype(int)\n","    long_p1_idx = long_obj[-1].astype(int)    \n","\n","    short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx] # != short_tp_1\n","    long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","    long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","    long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","    long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","    short_mean_low = short_max_outg[short_p2_true_bias_bool].mean()\n","    long_mean_low = long_max_outg[long_p2_true_bias_bool].mean()\n","    both_mean_low = (short_mean_low + long_mean_low) / 2\n","    # print(\"short_mean_low :\", short_mean_low)\n","    # print(\"long_mean_low :\", long_mean_low)\n","    # print(\"both_mean_low :\", both_mean_low)\n","    # print(\"mean_low elapsed time :\", time.time() - start_0)\n","\n","    # ------ plot_data ------ #\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_mean_low, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_mean_low, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_mean_low, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"],"metadata":{"id":"Eos0FoAgrfW5"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":260,"status":"ok","timestamp":1653436951068,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oLDZobRcgg6E","outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"outputs":[{"data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":["res_df.low.rolling(100) #> 1000"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","source":["def get_pr_v4(open_side, h, l, obj, tpout, lvrg, fee, p_ranges, p_qty_ratio, inversion=False):  # --> 여기서 사용하는 ex_p = ex_p\n","\n","    en_p = obj[0]\n","    # ex_p = obj[1]\n","    tp, out = np.split(tpout, 2, axis=1)\n","    len_p = len(p_ranges)\n","    en_ps, tps, outs, lvrgs, fees = [np.tile(arr_, (1, len_p)) for arr_ in [en_p, tp, out, lvrg, fee]]\n","\n","    np_obj = np.array(obj).T[0]\n","    assert len(np_obj.shape) == 2\n","\n","    # iin == iout 인 경우 분리\n","    en_idx = np_obj[:, 2]\n","    ex_idx = np_obj[:, 3]\n","    equal_idx = en_idx == ex_idx    # equal_idx 는 어차피 out 임\n","    issue_idx = en_idx > ex_idx    # equal_idx 는 어차피 out 임\n","\n","    print('pass')\n","    idx_gap_ = (ex_idx - en_idx)[~equal_idx]\n","    print(\"en_idx[issue_idx] :\", en_idx[issue_idx])\n","    print(\"ex_idx[issue_idx] :\", ex_idx[issue_idx])\n","    print(\"idx_gap_[idx_gap_ <= 0] :\", idx_gap_[idx_gap_ <= 0])\n","\n","    min_low = np.full_like(en_p, np.nan)\n","    min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","    max_high = np.full_like(en_p, np.nan)\n","    max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","\n","    if open_side == \"SELL\":\n","        p_tps = en_ps - (en_ps - tps) * p_ranges\n","        # min_low = np.full_like(en_p, np.nan)\n","        # min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","        tp_idx = (np.tile(min_low, (1, len_p)) <= p_tps) * (np.tile(max_high, (1, len_p)) <= outs)  # entry_idx 포함해서 out touch 금지 (보수적 검증)\n","    else:\n","        p_tps = en_ps + (tps - en_ps) * p_ranges\n","        # max_high = np.full_like(en_p, np.nan)\n","        # max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","        tp_idx = (np.tile(max_high, (1, len_p)) >= p_tps) * (np.tile(min_low, (1, len_p)) >= outs)\n","\n","    ex_ps = outs.copy()\n","    ex_ps[tp_idx] = p_tps[tp_idx]\n","\n","    if open_side == \"SELL\":\n","        if not inversion:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","    else:\n","        if not inversion:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","\n","    return pr.reshape(-1, 1), liqd"],"metadata":{"id":"wDQWK3v5xOFa"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def idep_plot_v16(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"],"metadata":{"id":"6G92q_bExTVn"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oE5zkT75Beiy"},"outputs":[],"source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","pos_side = \"SELL\" # SELL BUY\n","\n","if pos_side == \"SELL\":\n","  open_ = res_df['short_open1_{}'.format(config.selection_id)].to_numpy()\n","  open_ts = list(map(lambda x : str(x), res_df.index[open_ == 1]))  \n","else:\n","  open_ = res_df['long_open1_{}'.format(config.selection_id)].to_numpy()\n","  open_ts = list(map(lambda x : str(x), res_df.index[open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["pos_index = open_info_df1.side == pos_side\n","for ts in res_df.index[open_info_df1.index[pos_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6YcqQQzsl6Ys"},"outputs":[],"source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"t7a5Hyyyd5Lk"},"outputs":[],"source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dsI-R8Zz7ls1"},"outputs":[],"source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":350,"status":"ok","timestamp":1652751452213,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"gMur2u8WeQ2K","outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"outputs":[{"data":{"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":872,"status":"ok","timestamp":1652756329304,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eoXMxRm3qdz2","outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"outputs":[{"data":{"image/png":"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\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dm7ZqzS9vqhm"},"outputs":[],"source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qOE2YSzntx8v"},"outputs":[],"source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v3"]},{"cell_type":"code","execution_count":35,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1666405993964,"user_tz":-540,"elapsed":515,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 0     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick\n","x_max = 200       # back_plot : 0 사용시, custom x_max 반영됨\n","\n","bias_plot = 0     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = -1   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 100 #  150 100 20 500 1000\n","post_plotsize = 200 #\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_net_p1_bias_tick, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_net_p1_bias_tick, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","  if pr_descend == -1:\n","    pr_descend = 0\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, bias_tick, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, bias_tick, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","try:   # wave_range 단독 실행의 경우 tr_arr 이 존재하지 않기 때문에 try 처리함\n","  res_df['short_tr_{}'.format(selection_id)].iloc[short_obj[-1].astype(int).ravel()] = short_tr_arr\n","  res_df['long_tr_{}'.format(selection_id)].iloc[long_obj[-1].astype(int).ravel()] = long_tr_arr\n","except:\n","  pass\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","# plot_idx = np.full(len(np_plot_params), True)\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  \n","  # trendy_idx = bias_tick[invalid_left_end:] < config.tr_set.bias_tick  # temp location\n","\n","  np_plot_params = np_plot_params[bias_idx] #  * trendy_idx]  "]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":15,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":528,"status":"ok","timestamp":1666403016787,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"2bjxKCIh1ojZ","outputId":"ef406475-3057-44fb-edde-f971e1e759af"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:11: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","# hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(wave_itv1), 'close_{}'.format(wave_itv1)], 1, '#ffffff', 2])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffeb3b', 1])  #ffffff\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_period1 = config.tr_set.wave_period1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = 'T'\n","dc_period1 = 20 # wave_period2  # 20\n","dc_tf2 = '5T'\n","dc_period2 = 20 # config.loc_set.point2.csd_period if config.loc_set.point2.csd_period != \"None\" else wave_period2 \n","dc_tf3 = '15T'\n","dc_period3 = 20\n","dc_tf4 = 'H'\n","dc_period4 = 20\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ff00ff', 1]),  # inner #ffeb3b\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 2]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1]) # ffee58 5b9cf6 \n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 3]) # ffee58 5b9cf6\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf3, dc_period3)], 1, '#5b9cf6', 5]) # ffee58 5b9cf6\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf4, dc_period4)], 1, '#5b9cf6', 7]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = '15T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ma / ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","ma_period = 60\n","# step_col_list.append([['ma_T{}'.format(ma_period)], 1, '#03ed30', 2])\n","# step_col_list.append([['long_ma_T{}_-1'.format(ma_period)], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","# step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","# ------ stoch ------ #\n","# step_col_list2.append([['stoch_{}{}33'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","\n","# ------ macd ------ #\n","# step_col_list2.append([['macd_T535'], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","\n","# ------ sar ------ #\n","sar_tf1 = '5T'\n","# stepmark_col_list.append([['sar_{}'.format(sar_tf1)], 1, '#ffeb3b', 7])\n","\n","# ------ wave_range ------ #\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","# data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","data_window_p1_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_p1_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","data_window_p1_col_list.append([['hh_{}'.format(wave_itv1)], 'hh_{}'.format(wave_itv1)])\n","data_window_p1_col_list.append([['ll_{}'.format(wave_itv1)], 'll_{}'.format(wave_itv1)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"post_cu_idx\": get_col_idxs(res_df, ['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"post_co_idx\": get_col_idxs(res_df, ['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"post_cu_idx\": get_col_idxs(res_df, ['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"post_co_idx\": get_col_idxs(res_df, ['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)]),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close'])  \n","}   \n","#   , 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"XfvH5ngyieS9"},"source":["#### session_plot main"]},{"cell_type":"code","execution_count":37,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1hw95PHy3-rHFaLM0_jcRYcmc_wOxap_q"},"executionInfo":{"status":"error","timestamp":1666406193630,"user_tz":-540,"elapsed":97322,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"a27e78d0-e68d-4a1f-aca2-edb08f9717e0"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["# p2_hlm 의 경우, tr 확인을 우해 session_plot 우선 실행 필요함\n","_ = [plot_check_v9(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","metadata":{"id":"sZAYhcdoXnm4"},"source":["### whole_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jjFziVVIhgSr"},"outputs":[],"source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"50HXDIdJij28"},"source":["#### whole_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-tbLsXN9eN2p"},"outputs":[],"source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FtILHO-4kVlO"},"outputs":[],"source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v9(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    # print(\"p1_idx :\", p1_idx)\n","    # if p1_idx != 370259:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    if back_plot == 0:\n","      iout = iin + x_max\n","      # print(\"iin, iout :\", iin, iout)\n","\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ get vp_info ------ #\n","    # kde_factor = 0.1   # 커질 수록 전체적인 bars_shape 이 곡선이됨, 커질수록 latency 좋아짐 (0.00003s 정도)\n","    # num_samples = 100  # plot 되는 volume bars (y_axis) 와 비례관계\n","    # # vp_data = data[iin - 500:iin, col_idx_dict['vp_col_idxs']].T  # Todo, vp_range should be calculated by wave_point\n","\n","    # if tp_1 < out_0:  # SELL order\n","    #   post_co_idx = res_df.iloc[int(p1_idx), col_idx_dict['post_co_idx']]\n","    #   # vp_iin = res_df.iloc[int(p1_idx) - 1, col_idx_dict['post_cu_idx']].to_numpy()  # Todo, co_idx 와 co_post_idx 의 차별을 위해서 -1 해줌 <-- 중요 point\n","    #   vp_iin = res_df.iloc[post_co_idx, col_idx_dict['post_cu_idx']].to_numpy()  # Todo, co_idx 와 co_post_idx 의 차별을 위해서 -1 해줌 <-- 중요 point\n","    # else:\n","    #   post_cu_idx = res_df.iloc[int(p1_idx), col_idx_dict['post_cu_idx']]\n","    #   # vp_iin = res_df.iloc[int(p1_idx) - 1, col_idx_dict['post_co_idx']].to_numpy()\n","    #   vp_iin = res_df.iloc[int(post_cu_idx), col_idx_dict['post_co_idx']].to_numpy()\n","    # # print(\"iin, vp_iin, p1_idx :\", iin, vp_iin, p1_idx)\n","\n","    # vp_data = res_df.iloc[int(vp_iin):int(p1_idx), col_idx_dict['vp_col_idxs']].to_numpy().T  # Todo, vp_range should be calculated by wave_point\n","    # # print(\"vp_data :\", vp_data)\n","    # vp_info = [*vp_data, kde_factor, num_samples]\n","    vp_info = []\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v9_1(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v9_1(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  if config.tr_set.check_hlm in [0, 1]:\n","    ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg1 {}'.format(en_p, config.tr_set.ep_gap1), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  else:\n","    ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg2 {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  \n","  # ------ volume profile ------ #\n","  if len(vp_info) > 0:\n","    close, volume, kde_factor, num_samples = vp_info\n","    # if iin >= vp_range:\n","    # start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    kdy_max = kdy.max()\n","    # print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    # peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)   # get peak_entries\n","    # peak_list = kdx[peaks]   # peak_list\n","    # [ax1.axhline(peak, linewidth=1, linestyle='-', alpha=1, color='orange') for peak in peak_list]\n","    \n","    kdy_ratio = p1_tick / kdy_max # 30 / 0.0001   # max_value 가 p1_tick 까지 닿을 수 있게.\n","    # print(\"kdx :\", kdx)\n","    # ax1.plot(kdy * kdy_ratio, kdx, color='white')  # Todo, bars 가능 ?\n","    # ax1.barh(kdy * kdy_ratio, kdx, color='white')  # Todo, bars 가능 ?\n","    ax1.barh(kdx, kdy * kdy_ratio, color='#00ff00', alpha=0.5)  # Todo, bars 가능 ?\n","\n","  # ------------ ax2 ------------ #\n","  # ------ cci_band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ------ stoch_band ------ #\n","  # ax2.axhline(67, color=\"#ffffff\")\n","  # ax2.axhline(33, color=\"#ffffff\")\n","  \n","  # ax2.axhline(0, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"ddL_BC24buq0"},"source":["### dump"]},{"cell_type":"markdown","metadata":{"id":"zgTrEWWqbwsT"},"source":["#### whole_plot thing"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M4zn8wxibzAR"},"outputs":[],"source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"4IhBjPMobzAS"},"outputs":[],"source":["cf.go_offline()\n","init_notebook_mode()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"n9WZkE9wbzAS"},"outputs":[],"source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","E0n53hflJbnp","MlFkpO1MSuzl","MSUY4nnku3s9","x2yj2SwAXDLp","O87s8_EUakqS","LyGnAMvLYvOZ","Q_1wJTcRYpm8","EOXQbXixiQcK","c2729DJ6h720","RZJ6uIA_VcJs","xpyP5t8Ht_pE","MuD_2vY7TI_8","983aUwM76s6X","_blyFhQJUd5X","50HXDIdJij28"],"provenance":[],"toc_visible":true,"authorship_tag":"ABX9TyMio6mMQFRoQeZkHb12uhXb"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}