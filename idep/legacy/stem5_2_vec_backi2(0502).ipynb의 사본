{"cells":[{"cell_type":"code","execution_count":null,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651448545669,"user_tz":-540,"elapsed":21855,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d61455fe-3892-4429-9640-9669ca5574c4"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"9qGt60DKTZmf"},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","import IPython\n","import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    # upper = talib.MAX(res_df_.high, timeperiod=20)\n","    # lower = talib.MAX(res_df_.low, timeperiod=20)\n","    \n","    # # bb_width_v2(df, period=bb_period, multiple=1)\n","    # # # df = bb_line(df, df_5T, '5T')\n","    # # # df = bb_line(df, df_15T, '15T')\n","    # # print(\"bb phase done\")\n","\n","    c_itv = '15T'\n","\n","    df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"status":"ok","timestamp":1651454974674,"user_tz":-540,"elapsed":1352,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"53eee5ed-32ac-49bc-f22d-c0d2f2e19197"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                         close_5T  open_15T  high_15T  low_15T  close_15T  cu_es_15T1  co_es_15T1  upper_wick_ratio_15T  lower_wick_ratio_15T  candle_updown_15T\n","index                                                                                                                                                           \n","2022-04-27 08:41:59.999   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014              0.128921              0.107881                  1\n","2022-04-27 08:42:59.999   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014              0.128921              0.107881                  1\n","2022-04-27 08:43:59.999   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014              0.128921              0.107881                  1\n","2022-04-27 08:44:59.999   2803.56   2783.61   2806.93  2780.79    2803.56    0.863144   -0.019014              0.128921              0.107881                  1\n","2022-04-27 08:45:59.999   2800.43   2803.55   2803.97  2799.26    2800.43    1.413160    0.226473              0.089172              0.248408                  0"],"text/html":["\n","  <div id=\"df-e6e469de-c8d6-4df6-a1c3-daf03fa1ffdf\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>close_5T</th>\n","      <th>open_15T</th>\n","      <th>high_15T</th>\n","      <th>low_15T</th>\n","      <th>close_15T</th>\n","      <th>cu_es_15T1</th>\n","      <th>co_es_15T1</th>\n","      <th>upper_wick_ratio_15T</th>\n","      <th>lower_wick_ratio_15T</th>\n","      <th>candle_updown_15T</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2803.56</td>\n","      <td>2783.61</td>\n","      <td>2806.93</td>\n","      <td>2780.79</td>\n","      <td>2803.56</td>\n","      <td>0.863144</td>\n","      <td>-0.019014</td>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2800.43</td>\n","      <td>2803.55</td>\n","      <td>2803.97</td>\n","      <td>2799.26</td>\n","      <td>2800.43</td>\n","      <td>1.413160</td>\n","      <td>0.226473</td>\n","      <td>0.089172</td>\n","      <td>0.248408</td>\n","      <td>0</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-e6e469de-c8d6-4df6-a1c3-daf03fa1ffdf')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-e6e469de-c8d6-4df6-a1c3-daf03fa1ffdf button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-e6e469de-c8d6-4df6-a1c3-daf03fa1ffdf');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":158}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":709,"status":"ok","timestamp":1651454981046,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"826a5cd0-bf92-49a4-f53c-5a4dea54826f"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651448577947,"user_tz":-540,"elapsed":2015,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0c46e03f-2ea6-406a-c68e-33cc156b6204"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 1.4465866088867188\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651449055641,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"844e33b3-c8cf-44bc-b219-300c186304d3"},"outputs":[{"output_type":"execute_result","data":{"text/plain":["open             float64\n","high             float64\n","low              float64\n","close            float64\n","volume           float64\n","dc_upper_3T20    float64\n","dc_lower_3T20    float64\n","dc_base_3T20     float64\n","dc_upper_H20     float64\n","dc_lower_H20     float64\n","dc_base_H20      float64\n","dc_upper_15T1    float64\n","dc_lower_15T1    float64\n","dc_base_15T1     float64\n","open_5T          float64\n","high_5T          float64\n","low_5T           float64\n","close_5T         float64\n","open_15T         float64\n","high_15T         float64\n","low_15T          float64\n","close_15T        float64\n","dtype: object"]},"metadata":{},"execution_count":20}],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PV-dlAVZfehP"},"outputs":[],"source":["def to_value_index(prev_wave_point_idx2, len_df_range):\n","  valid_idx = ~np.isnan(prev_wave_point_idx2)\n","  # np.sum(~np.isnan(prev_wave_point_idx2))\n","  prevwp_valid_value = prev_wave_point_idx2[valid_idx].astype(int)   # inner box value\n","  prev_wave_point_ = np.full(len(valid_idx), False)\n","  prev_wave_point_[prevwp_valid_value] = True\n","\n","  return np.where(prev_wave_point_, len_df_range, np.nan)\n","\n","def get_index_bybool(bool_arr, len_df_range):\n","  return np.where(bool_arr, len_df_range, np.nan)\n","\n","\n","def using_clump(a):\n","    return [a[s].astype(int) for s in np.ma.clump_unmasked(np.ma.masked_invalid(a))]\n","\n","def fill_arr(arr_, mode='ffill'):\n","  if mode == 'ffill':\n","    return pd.Series(arr_).ffill().to_numpy()\n","  else:\n","    return pd.Series(arr_).bfill().to_numpy()\n","\n","def roll_wave_hl(t_df, len_df, itv, period1, roll_hl_cnt=4):\n","        \n","  wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(itv, period1)].to_numpy()\n","  wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(itv, period1)].to_numpy()\n","  cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)].to_numpy()\n","  co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(itv, period1)].to_numpy()\n","  \n","  valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","  valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","  cu_roll_hl_idx_arr = np.array([valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","  co_roll_hl_idx_arr = np.array([valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","  cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","  cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","  co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","  co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","  cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","  cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","  co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","  co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","  return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()\n","\n","def wave_range_v11(t_df, period1, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = cu_idx > cu_prime_idx_fill_\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","\n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  valid_idx = co_idx > co_prime_idx_fill_\n","\n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # point_missing 으로 인한 low 갱신 회피\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","\n","plot_size = 100\n","t_df = res_df.iloc[i - plot_size:i]\n","# t_df = res_df.iloc[i - plot_size:i - 22]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-Dr_tTk9csFm"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","itv, period1, period2 = 'T', 5, 5\n","t_df = wave_range_v11(t_df, period1, ltf_df=None)\n","# prev_point_period = 100\n","# t_df = get_prev_wave_hl(t_df, itv, period1, period2, prev_point_period)\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)].to_numpy()\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(itv, period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(itv, period1)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(itv, period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(itv, period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# plt.step(len_df_range, wave_high_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_fill_, alpha=1.0, color='yellow', linewidth=2)\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","plt.xlim(0, len_df)\n","\n","plt.show()"]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["roll_wave_hl(t_df, itv, period1)[0][150]"],"metadata":{"id":"G5jpriueRpxH"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["itv, period1, period2 = 'T', 5, 5\n","t_df = donchian_channel_v4(t_df, period1) \n","\n","# dc_lower_ = t_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","# dc_upper_ = t_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","# short_open_res = np.ones(len_df)\n","# long_open_res = np.ones(len_df)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","b1_close = t_df.close.shift(1).to_numpy()\n","\n","\n","# ------ define co, cu ------ #\n","co_bool = (b1_close < dc_base_) & (dc_base_ < close)\n","cu_bool = (b1_close > dc_base_) & (dc_base_ > close)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","# ------ get co, cu terms ------ #\n","high_bool = cu_fill_idx < co_fill_idx\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","# ------ get valid_idx range (inner len_df) ------ #\n","paired_cu_idx = high_terms[:, 1]\n","paired_co_idx = low_terms[:, 1]\n","\n","valid_cu_bool = paired_cu_idx < len_df\n","valid_co_bool = paired_co_idx < len_df\n","\n","paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","# ------ get wave_hl & terms ------ #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ check update high & low (occurs by point missing) ------ # \n","cu_prime_idx = np.full(len_df, np.nan)\n","cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","valid_idx = cu_idx > cu_prime_idx_fill_\n","\n","update_low = np.full(len_df, np.nan)\n","update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","\n","co_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","valid_idx = co_idx > co_prime_idx_fill_\n","\n","update_high = np.full(len_df, np.nan)\n","update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]"],"metadata":{"id":"TqMmmSAGuChM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int) # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","roll_hl_cnt = 4\n","cu_roll_hl_idx_arr = np.array([valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","co_roll_hl_idx_arr = np.array([valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","cu_roll_high_fill_ = cu_roll_high_.ffill().to_numpy()\n","cu_roll_low_fill_ = cu_roll_low_.ffill().to_numpy()\n","co_roll_high_fill_ = co_roll_high_.ffill().to_numpy()\n","co_roll_low_fill_ = co_roll_low_.ffill().to_numpy()"],"metadata":{"id":"nZRVW90lbAy1"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SeJan_0t95yL"},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CB2yZdQ95Cdg"},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","sys_log = logging.getLogger()\n","\n","def get_line(touch_idx, rtc_):\n","    touch_idx_copy = touch_idx.copy()\n","\n","    nan_idx = np.isnan(touch_idx_copy)\n","    touch_idx_copy[nan_idx] = 0  # for indexing array\n","    touch_line = rtc_[touch_idx_copy.astype(int)].copy()\n","    touch_line[nan_idx] = np.nan  # for true comp.\n","\n","    return touch_line\n","\n","\n","def enlist_rtc(res_df, config, np_timeidx):\n","    selection_id = config.selection_id\n","    # ------------ rtc_gap ------------ #\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","    \n","    res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(p1_itv1, p1_period1)]\n","    res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(p1_itv1, p1_period1)]\n","    res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(p1_itv1, p1_period1)]\n","    res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(p1_itv1, p1_period1)]\n","\n","    # res_df[short_tp_1_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","    # res_df[short_tp_0_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","    # res_df[long_tp_1_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","    # res_df[long_tp_0_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","\n","    if config.tr_set.p2_itv1 != \"None\":\n","        p2_period1 = config.tr_set.p2_period1\n","        p2_period2 = config.tr_set.p2_period2\n","        res_df[short_epout_1_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[short_epout_0_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","        res_df[long_epout_1_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[long_epout_0_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","    else:\n","        res_df[short_epout_1_] = res_df['low_{}'.format(config.loc_set.point.tf_entry)]\n","        res_df[short_epout_0_] = res_df['high_{}'.format(config.loc_set.point.tf_entry)]\n","        res_df[long_epout_1_] = res_df['high_{}'.format(config.loc_set.point.tf_entry)]\n","        res_df[long_epout_0_] = res_df['low_{}'.format(config.loc_set.point.tf_entry)]\n","\n","        # res_df[short_epout_1_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","        # res_df[short_epout_0_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","        # res_df[long_epout_1_] = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)]\n","        # res_df[long_epout_0_] = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)]\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df[short_tp_1_] - res_df[short_tp_0_])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df[long_tp_1_] - res_df[long_tp_0_])\n","    res_df['short_epout_gap_{}'.format(selection_id)] = abs(res_df[short_epout_1_] - res_df[short_epout_0_])\n","    res_df['long_epout_gap_{}'.format(selection_id)] = abs(res_df[long_epout_1_] - res_df[long_epout_0_])\n","\n","    # ------------ dtk_gap ------------ #\n","    # res_df['short_dtk_1_{}'.format(selection_id)] = res_df['bb_lower_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['short_dtk_0_{}'.format(selection_id)] = res_df['dc_upper_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['long_dtk_1_{}'.format(selection_id)] = res_df['bb_upper_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['long_dtk_0_{}'.format(selection_id)] = res_df['dc_lower_%s' % config.loc_set.zone.dtk_itv]\n","\n","    # res_df['short_dtk_gap_{}'.format(selection_id)] = abs(\n","    #     res_df['short_dtk_0_{}'.format(selection_id)] - res_df['short_dtk_1_{}'.format(selection_id)])\n","    # res_df['long_dtk_gap_{}'.format(selection_id)] = abs(\n","    #     res_df['long_dtk_1_{}'.format(selection_id)] - res_df['long_dtk_0_{}'.format(selection_id)])\n","\n","    return res_df\n","\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","    selection_id = config.selection_id\n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","    short_open_res = np.ones(len_df)\n","    long_open_res = np.ones(len_df)\n","\n","    short_tp_1_col, short_tp_0_col, short_tp_gap_col = 'short_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(\n","        selection_id), 'short_tp_gap_{}'.format(selection_id)\n","    long_tp_1_col, long_tp_0_col, long_tp_gap_col = 'long_tp_1_{}'.format(selection_id), 'long_tp_0_{}'.format(\n","        selection_id), 'long_tp_gap_{}'.format(selection_id)\n","    short_epout_1_col, short_epout_0_col, short_epout_gap_col = 'short_epout_1_{}'.format(selection_id), 'short_epout_0_{}'.format(\n","        selection_id), 'short_epout_gap_{}'.format(selection_id)\n","    long_epout_1_col, long_epout_0_col, long_epout_gap_col = 'long_epout_1_{}'.format(selection_id), 'long_epout_0_{}'.format(\n","        selection_id), 'long_epout_gap_{}'.format(selection_id)\n","\n","    tp_cols = [short_tp_1_col, short_tp_0_col, short_tp_gap_col, long_tp_1_col, long_tp_0_col, long_tp_gap_col]  # Todo - public_indi 이전에 해야할지도 모름\n","    epout_cols = [short_epout_1_col, short_epout_0_col, short_epout_gap_col, long_epout_1_col, long_epout_0_col,\n","                  long_epout_gap_col]  # Todo - public_indi 이전에 해야할지도 모름\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","\n","    short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_ = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_ = [res_df[col_].to_numpy() for col_ in epout_cols]\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ---------------- point - support_confirmer---------------- #\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","\n","    if p2_itv1 != \"None\":\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","    else:  \n","        # ------ p1 only ------ #\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = 0  # default\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = 0 \n","        \n","        # ====== wave_point ====== #\n","        # short_open_res *= res_df['wave_co_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # long_open_res *= res_df['wave_cu_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # ------ wave_mm ------ #\n","        # wave_high_terms_cnt_fill_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # wave_low_terms_cnt_fill_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # short_open_res *= (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater) & (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater)\n","        # long_open_res *= (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater) & (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher high (long) ------ #\n","        # cu_roll_high_, cu_roll_low_, co_roll_high_, co_roll_low_ = roll_wave_hl(res_df, len_df, p1_itv1, p1_period1, roll_hl_cnt=4)\n","\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))        \n","\n","        # ------ tf_entry ------ #\n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ base_cc ------ #\n","\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res\n","\n","    # ------------------ tr_set ------------------ #\n","    # ------------ tpep ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = short_tp_1_ - short_tp_gap_ * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = long_tp_1_ + long_tp_gap_ * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg = config.tr_set.ep_gap\n","        # res_df['short_ep_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * epg\n","\n","        res_df['short_ep_{}'.format(selection_id)] = close\n","        res_df['long_ep_{}'.format(selection_id)] = close\n","\n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep_{}'.format(selection_id)] = close\n","        res_df['long_ep_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    res_df['short_out_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * outg\n","    res_df['long_out_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * outg\n","\n","    # ------------ point validation ------------ #\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","    short_open_res *= (short_tp_ < short_ep_) & (short_ep_ < short_out_)\n","    # short_open_res *= close < short_ep_   # reject open_execution\n","    short_open_res *= close < short_out_    # reject open_execution\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res * (not config.pos_set.short_ban)\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","    long_open_res *= (long_tp_ > long_ep_) & (long_ep_ > long_out_)\n","    # long_open_res *= close > long_ep_   # reject open_execution\n","    long_open_res *= close > long_out_    # reject open_execution\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res * (not config.pos_set.long_ban)\n","\n","    if show_detail:\n","      sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","      sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","    \n","    # ------------ wave_bias ------------ #\n","    wb_tpg = config.tr_set.wb_tp_gap\n","    wb_outg = config.tr_set.wb_out_gap\n","    res_df['short_wave_1_{}'.format(selection_id)] = short_tp_1_ - short_tp_gap_ * wb_tpg\n","    res_df['long_wave_1_{}'.format(selection_id)] = long_tp_1_ + long_tp_gap_ * wb_tpg\n","    res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * wb_outg\n","    res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * wb_outg\n","\n","    # ------ tr ------ #\n","    res_df['short_tr_{}'.format(selection_id)] = abs(\n","        (short_ep_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep_ / short_out_ - config.trader_set.market_fee - 1))\n","    res_df['long_tr_{}'.format(selection_id)] = abs(\n","        (long_tp_ / long_ep_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    if config.tr_set.c_ep_gap != \"None\":\n","        # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","        # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","        res_df['short_ep2_{}'.format(selection_id)] = short_epout_1_ + short_epout_gap_ * config.tr_set.c_ep_gap\n","        res_df['long_ep2_{}'.format(selection_id)] = long_epout_1_ - long_epout_gap_ * config.tr_set.c_ep_gap\n","\n","    # ------ zoned_out ------ #\n","    if config.tr_set.t_out_gap != \"None\":\n","        # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","        # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","        res_df['short_out2_{}'.format(selection_id)] = res_df['short_epout_0_{}'.format(selection_id)] + res_df[\n","            'short_epout_gap_{}'.format(selection_id)] * config.tr_set.t_out_gap\n","        res_df['long_out2_{}'.format(selection_id)] = res_df['long_epout_0_{}'.format(selection_id)] - res_df[\n","            'long_epout_gap_{}'.format(selection_id)] * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nzOYWA2kqZ0d"},"outputs":[],"source":["from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","    wave_period = config.tr_set.wave_period\n","\n","    t_df = wave_range_v11(res_df, wave_period)  # Todo, currently only T itv allowed\n","\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def ep_out_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_out(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_out_v2(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k or h[e_j] >= short_tp_0_[tp_j] - short_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()\n","            long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k or l[e_j] <= long_tp_0_[tp_j] + long_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","    allow_ep_in = 1\n","    if config.selection_id in ['v5_2']:\n","        if side == OrderSide.SELL:\n","            dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","            dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","            allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","                           (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","        else:\n","            dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","            dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","            allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","                           (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","    if config.selection_id in ['v3_4']:\n","        wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","        wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","        close = res_df['close'].to_numpy()\n","        if side == OrderSide.SELL:\n","            sup_T = res_df['sup_T'].to_numpy()\n","            allow_ep_in *= close[i] < sup_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","        else:\n","            resi_T = res_df['resi_T'].to_numpy()\n","            allow_ep_in *= close[i] > resi_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","    if allow_ep_in:\n","        out_j = i\n","    return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # -------------- tr_thresh -------------- #\n","    if config.loc_set.point.short_tr_thresh != \"None\":\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point.long_tr_thresh, mr_res[c_i]))\n","\n","    # -------------- spread - independent to tr_set -------------- #  --> Todo, 사용 안하고 싶은 wave_point\n","    if config.loc_set.point.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point.long_spread, mr_res[c_i]))                  \n","\n","    # ------------ ratios ------------ #\n","    # ------ enough_space ------ #\n","    if config.loc_set.point.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1\n","      cu_es_ = res_df['cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      co_es_ = res_df['co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_es_ >= config.loc_set.point.co_es\n","        mr_res *= co_es_ <= config.loc_set.point.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","        mr_res *= cu_es_ <= config.loc_set.point.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    if config.loc_set.point.short_wick_ratio != \"None\":\n","      itv_num = to_itvnum(config.loc_set.point.wick_itv)\n","      upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","      lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.short_wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.short_wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.long_wick_ratio + 0.1\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    if config.loc_set.point.crr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","      mr_res *= b1_crr_ >= config.loc_set.point.crr\n","      if show_detail:\n","          sys_log.warning(\"b1_crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n"," \n","    # ------------ rtc_zone  ------------ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ------------ zone ------------ #\n","    # config 로 통제할 수 없는 zone 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일)\n","    if config.loc_set.zone.use_zone:\n","\n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q_4E-zH02WJy"},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_2\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-04-08\\\\2022-04-08 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 0.0002,\n","    \"market_fee\": 0.0004,\n","    \"initial_asset\": 10,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"api_retry_term\": 3,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"wick_ratio\": \"None\",\n","      \"wick_itv\": \"15T\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"wave_period\": 5,\n","    \"wave_lesser\": 1,\n","    \"wave_greater\": 15,\n","    \"p1_itv1\": \"15T\",\n","    \"p1_itv0\": \"T\",\n","    \"p1_period1\": 1,\n","    \"p1_period2\": 5,\n","    \"p2_itv1\": \"None\",\n","    \"p2_itv0\": \"T\",\n","    \"p2_period1\": 20,\n","    \"p2_period2\": 40,\n","    \"ei_k\": 0.0,\n","    \"ep_out_tick\": 5,\n","    \"tp_gap\": 0.0,\n","    \"decay_gap\": \"None\",\n","    \"ep_gap\": 0.0,\n","    \"out_gap\": 0,\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 500\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651466797547,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bb3b8deb-507a-41e3-af8e-dc375b9d8afd"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_2\" {\n"," \"point\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"wick_ratio\": \"None\",\n","  \"wick_itv\": \"15T\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"wave_period\": 5,\n"," \"wave_lesser\": 1,\n"," \"wave_greater\": 15,\n"," \"p1_itv1\": \"15T\",\n"," \"p1_itv0\": \"T\",\n"," \"p1_period1\": 1,\n"," \"p1_period2\": 5,\n"," \"p2_itv1\": \"None\",\n"," \"p2_itv0\": \"T\",\n"," \"p2_period1\": 20,\n"," \"p2_period2\": 40,\n"," \"ei_k\": 0.0,\n"," \"ep_out_tick\": 5,\n"," \"tp_gap\": 0.0,\n"," \"decay_gap\": \"None\",\n"," \"ep_gap\": 0.0,\n"," \"out_gap\": 0,\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 500\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [ep_out_v2, ep_loc_point2_v2, lvrg_set]  # ep_out for p1 & p2\n","funcs = [ep_out, ep_loc_point2_v2, lvrg_set]     # ep_out for p1-only\n","# funcs = [ep_out_v0, ep_loc_point2_v2, lvrg_set]  # ep_out for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","# ['selection_id', 'pos_set', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\""]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3947,"status":"ok","timestamp":1651454991128,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"0127f97f-3c11-433d-bdf7-3a63257b576c"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 2.5165836811065674\n","make data_list elapsed time : 0.00028705596923828125\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_iYcJk8nK8Yq"},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_greater = 5\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap = -1.\n","# config_list[0].tr_set.out_gap = -0.5\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 500"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":371,"status":"ok","timestamp":1651466258666,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"2d28ca9b-a31f-498a-a626-03a2fdda0a62"},"outputs":[{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 57539\n","np.sum(long_open_res == 1) : 57539\n","np.sum(short_open_res == 1) : 14026\n","np.sum(long_open_res == 1) : 14069\n","np.sum(short_open_res == 1) : 8259\n","np.sum(long_open_res == 1) : 8346\n"]},{"output_type":"stream","name":"stdout","text":["enlist_rtc elapsed time : 0.03887581825256348\n","enlist_tr elapsed time : 0.13582086563110352\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  start_0 = time.time()\n","  res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfDSOGMd91rE"},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point.co_es = \"None\" # \"None\" # -3\n","config_list[0].loc_set.point.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point.crr = 2\n","config_list[0].loc_set.point.short_wick_ratio = \"None\" # 0.6\n","config_list[0].loc_set.point.long_wick_ratio = 0 #\"None\"\n","# config_list[0].loc_set.point.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point.short_tr_thresh = \"None\" #  0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point.long_tr_thresh = 0.8 #  0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":null,"metadata":{"executionInfo":{"elapsed":1371,"status":"ok","timestamp":1651466271195,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"0e6a074e-6925-40a8-f0a8-675d4d579681"},"outputs":[{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0639314651489258\n"]}],"source":["open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.ei_k = -0.5\n","# config_list[0].tr_set.ep_out_tick = 5\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# # config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# # config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# # config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# # config_list[0].tp_set.p_qty_ratio = \"[0.1, 0.9]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","# config_list[0].lvrg_set.leverage = 1\n","# config_list[0].lvrg_set.static_lvrg = 0\n","# config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0\n","# config_list[0].trader_set.limit_fee = 0.0000001\n","# config_list[0].trader_set.market_fee = 0.0000001"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":644},"executionInfo":{"elapsed":4571,"status":"ok","timestamp":1651468441516,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"65e10054-1e23-451f-b59e-63dfd94c5810"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 1.968965768814087\n","short_obj.shape : (5595, 5)\n","long_obj.shape : (5445, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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QkKCfPnll2JmZqb1v0Wmfsfg//5BRERERERERERERLVMfbVnIiIiIiIiIiIiIqoVDbQ9AaL6ztDQUO0XhB9XUlLyFGdDRESkO1hjiYiIah/rK1H9w2/AElXg0KFDKC4uLjNERERUPayxREREtY/1laj+4RqwRBXo0qULmjRpUub2qKiopzgbIiIi3cEaS0REVPtYX4nqH16AJSIiIiIiIiIiIqojXIKAiIiIiIiIiIiIqI7wAiw9ExQKBVatWqXtaZTJ29sbIgJzc/OndswJEyZg165duHv3LkQE3t7ean0sLS2xbt06nD17FgUFBS7efCcAACAASURBVFAoFJUev3379ggKCsKDBw+QmZmJ7du3o1WrVmr9fHx8cOXKFeTn5yMmJgaTJ09W2V763GiKn59f1U+ciIhqFWususrU2CFDhmDHjh24ceMGcnJyEB0djVmzZsHQsHL/99rBwQF79+5FZmYmHjx4gLNnz6JPnz7K7REREWXWT0dHR41jrlmzBiJSr19PIiJ9wfqqri7rq7GxMX755RfEx8cjNzcXKSkpCAsLU6mtAODu7o6TJ08iNTUVeXl5iIuLw6JFi2BsbKzS791330VISAhSU1MhInBycqr5E0B6jRdgiWpBaGgoHB0dkZub+9SOOX78eHTo0AEhISFl9rGysoKnpyeSkpLwxx9/VHpsIyMj7Nu3D926dcPUqVPh4+ODF198EeHh4SqFz8vLC99++y2Cg4MxevRo7Nu3D1u2bMHYsWOVfUqfm8fzwQcfAADCw8OrceZERKRP6muN/cc//gFzc3MsXrwYo0aNwo4dO7B69WqsXLmywvF79eqFU6dOITMzE56envDw8MDevXthZmam7DNz5ky1+rl//37cu3cPkZGRamN269YN06dPx/3796t30kREpFd0rb4aGRlBRLBixQq4urri7bffRqNGjXD48GF07NhR2a9ly5Y4fPgwfHx84OLigu+//x6LFi3CmjVrVMZ788030aJFC/z22281O2mixwjD1PcoFApZtWpVnYzdsGFDrZ9fdWJgYCAAxNzcXEREvL29y+wDQFatWiUKhaJSY3t5eUlxcbE8//zzyraePXuKiIi7u7uyLS4uTrZs2aKyb1BQkERHR5c7/oYNGyQjI0NMTEy0/jwyDMPoe1hj1VOZGtuyZUu1ts8//1xyc3MrrG+nT5+W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+/dHSEgIlixZgkuXLuHEiRNITEys8/NJSUk4d+4ciouL8fnnn6NNmzZ15kRGRmL9+vUoLy9HVlYWZsyY4XZ8zSVE8/6t3H333QCAVatWOY7l5eVh586diI+PdxyLj4/HqlWrINkbNANYtmwZoqKi0K9fvyatRb7h3292x7/f7K50GD4hIiICOTk1p7qcOXMGERERTnN69uyJnj17YufOndi1axdGjx5d73ozZ86E0WiE0WhEeHi4R2O1t/jRG9iCwBcxvzK/NrQW+Q7mWPd5Msd6K786LsKlqsti+x/mWObYhtYi3yBXflVhAVYLnZZXkvQ11157LVauXInt27dj7NixeOihh7Bu3Tq0b9++yWuFhITgk08+wXvvvYcpU6agW7duWLp0Kb7++mvs3LkTEyZMQG5uLlasWIHg4OAmrf3555/j66+/xv333w+NRoOVK1di8eLFyMvLw8SJE7Fnzx588cUXTv/Be/rpp/H3v/8dn3zyCSZOnIiKigq8/fbbddZes2YN+vXrhxkzZuD555/HM888g6FDhzYakz2xytlvplevXjhz5gzKysqcjmdkZKBXr14AbH8O3bp1Q2ZmZp059jXcXYvIX+n1esTGxuKOO+7AlClTkJKSgrZt27qcm5KSgkGDBmHQoEEoLCz0aBySxfYfXb2O+dXXML8yvzK/Ernmbo71Vn51FGD52abPYo5ljmWOpaZQ3edtAhq069T0X3ikrP79+6OkpAQvvfSS41haWlqz1goJCcHTTz+NH374AQDQtWtXfPTRR/j73/+Od999F4DtU/AjR44gLi4OGzdudHvtd955B1988QUAQKPRYMOGDdixYwfmzJkDAPjll18wceJEjB07FosWM5koXAAAIABJREFULYJWq8Xs2bPx8ccf47XXXgMAbN68GZs3b0ZkZKRj3fj4eNxyyy34wx/+gF9++QUAsG/fPpw4cQLHjh1rMCar1QqLxdLsTwKbIywsDJcuXapzvKioCGFhYQCAdu3aAUCdeUVFRY413F2LSI1yc3MRFRXluB0ZGYnc3FynOWfOnMGePXtgsViQnZ2No0ePIjY2Fnv37pU1Vql6C6w+QHWf26oe8yvza0NrEamVL+RYi8X2lQVY38Ucyxzb0FpEV1LfOymNHhpIiLn5RqUjoSY4ePAg2rZti88++wyjRo1CSEhIs9eqqqrCjz/+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xAkCzCfUL7zwgjitqwZYDg4ODg7XDHesrzfeeCOlpaVZjXvnnXfonXfeIYlEQocPH6YpU6YQgDYNsGPHjiUiEqcDoKeeeop27txJAGjRokV0+vRpSkhIIIlEQjNnzqSSkhIKDw93+mvN4V4xILsgYMweioqKEBMTIw57eXkhKCioW/2F2LuD7LS0NIwZM0Yc9vLyQnx8fIddAygUCuzatQsFBQVYvHhxj9e3cuVKzJ49GzNmzGjTGb6/vz9+/PFHJCUlYfXq1T1eNmOMMffjTjV27NixSEpKwr333iv+fA4AqqqqUFT0/9u79yApyrtf4N/untlZYIFdQEUWXZCDBDAiyE3RMgFeBEkiQesViaUxKTR60GAlJcSKt5My4i2RoLWmCAY9ikAkmhdLhSAYfRU3+4osF3dhLxzkstxkWZa9zvT8zh890zv3vUzP9vTM91P1K5iZvjz99NP9636m95ljYesaN26cuZ4ZM2bgwQcfRG1tLWpra3HJJZdgw4YNUWPdERERBWVKft23bx8uu+wy5OXlme8Fc2S/fv0wceJErF+/HrW1teZvmRw5cgTXXXcd9u/fj9bW1rDtCf3/VVddhffeew+VlZUQEWzevBm1tbW49tprU7HZRHGxA5Yo4K233sLdd99tjuf2+9//HiUlJTh06FCH8544cQJDhw6N+YuMVnjnnXdwxRVXYP78+fB4PHjsscewe/du7N+/P2pal8uFt99+G83NzbjrrrtiJlaPxwOPxxP1fwBYtmwZFi5ciJkzZ0aN7dq3b19s3rwZn332GX7zm99YvJVERJSpsiXHjh07Fh9++CEeeOABvPfee1Hzv/766/jtb3+L/Px8jBo1CosWLcKaNWsAGB2wV1xxBa666ipcddVVOHbsGO699168/PLLKdluIiJyvkzJr5WVldi1axcef/xxeDwezJs3D1deeSU2btyI+vp6DBkyxMyPN910EwDg6quvRklJCZqbm7F+/Xo8/PDDyMvLQ2FhIe655x4zD5eWlmLu3LkYPnw4AOPHoS6//HLs3bs3JdtNFA87YIkCPvroIzz66KPYuHEjamtrMWLECCxYsKBT827btg379u3D8ePHcerUqW6tf+/evVi4cGHMz06fPo1bbrkFTz31FOrq6jBlypSwshUXF6O4uBgAcO211+KHP/whZs2ahbNnz6KhoQENDQ247rrrzOlbWlrQ2NgIANi/fz9aWlrMz55++mlceumlqKqqMucNdrb++Mc/xuTJk3H33XebnzU0NIT9+iAREVGkbMmxv/rVr3DBBRdg9erV5mehN3iPP/44qqurcejQIfzrX//Cc889h82bNwMAzpw5gxMnTpih6zrq6urMfE1ERBQpU/IrACxYsAATJ05EXV0dli9fjltvvRWnT58GgLD8GCzriRMn4PV6AQCLFy/G+fPncezYMezYsQNr167Fq6++CsD48nPdunX4+OOPce7cOfzpT3/CvffeG7MjmCiVFBhjERARERERERERERGRxfgELBEREREREREREVGKsAOWiIiIiIiIiIiIKEXYAUtERERERERERESUIuyAJSIiIiIiIiIiIkoRdsASERERERERERERpQg7YInSzPTp01FeXo7GxkZs27YNl156adxpi4qKsG3bNjQ2NqK8vBwzZswI+3zJkiWora1FfX09Vq9ejZycHEvmJSIiciLmWCIiIusxvxJ1jjAYDOtD07QuzzNw4EA5e/as3HrrreLxeOTZZ5+VHTt2xJ3+888/lxdeeEFyc3Nl/vz5UldXJ4MGDRIAMmvWLDl+/LiMGTNG8vPzZfv27fL0009bMi+DwWAwGHYGcyyDwWAwGNYH8yuDkdKwvQAMRo/GSy+9JM8//3zYe//4xz9kyZIlAkAuvvhiefvtt+XkyZNSU1MjDzzwgDndpEmT5PPPP5e6ujo5duyYrFy5Utxut/m5iMj9998vBw4ckJqami6XbdGiRfLZZ5+Zr3v37i1NTU0yatSoqGlHjhwpLS0tkpeXZ773ySefyL333isA5M0335SnnnrK/Gz69OlSW1ub9LwMBoPBYMQL5ljmWAaDwWBYH8yvzK8M5weHIKCs89prr+H222+HoigAgIEDB2LmzJlYu3YtFEXBpk2bUFZWhsLCQsyYMQNLlizBrFmzAAC6ruOhhx7CoEGDcM0112DGjBm4//77w5Y/b948TJkyBWPGjIm5/rKyMtx+++0xPxs7dizKysrM101NTaiursbYsWNjTltTU4Pz58+HLTs4beSyysrKMHjwYAwYMCCpeYmIiOJhjmWOJSIi6zG/Mr+S87EDlrJOaWkp6uvrzfFiFixYgI8//hgnT57EpEmTcMEFF+B3v/sdvF4vDh48iFWrVmHBggUAgJ07d6KkpAS6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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.7432875633239746\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_point1_arr, long_en_tp1, long_en_out0 = \\\n","get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=False)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_open_i = short_obj[-1].astype(int)\n","long_open_i = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_0 = res_df['short_epout_0_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_epout_0 = res_df['long_epout_0_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_gap = res_df['short_epout_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_epout_gap = res_df['long_epout_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","# ------ pairing 된 en, ex_idx 기준으로 survey 진행 ------ #\n","# 0. high, low (exit_done 까지의) -> partial (tpg) 과 outg survey 목표\n","#   a. short -> tpg - low, outg - high\n","#   b. long -> tpg - high, outg - low\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","\n","# ------ 0. tp 까지 도달하는 최소 idx 도출, en_idx 부터 ------ #\n","#   a. bias_info_tick 의 limit 을 정해주지 않으면 굉장히 길어질 수 있다고 봄\n","# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","\n","current_tpg= config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","public_cols = ['co_es_15T1', 'cu_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","# 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = -20\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","  \n","  short_true_valid_idx *= short_true_data > xmin\n","  short_false_valid_idx *= short_false_data > xmin\n","  long_true_valid_idx *= long_true_data > xmin\n","  long_false_valid_idx *= long_false_data > xmin\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  valid_idx = total_ns > 1\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  valid_idx = total_ns > 1\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1651464323085,"user_tz":-540,"elapsed":3800,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"acaf3874-8aa5-4b15-b33c-6939694612eb"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1800 with 20 Axes>"],"image/png":"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VZWRnJxsREVFGTt37jRGjBhheq6m7cYbbzRGjRpl7N692/Qs4d6sdAztaAv1Y29nm1WO3R1tVjjmd7aFap/RmWaV/qajrSv7KUudwbnYjBkztHr1arNjNPPggw8qJydHZ8+elSQdPnzY5ETWlpeXp7lz58owDLOjtOjEiRPeny+55JKQzblp0ybV19dLkkpKSpSYmGhyouYqKyu1d+9es2M0M2bMGFVVVcntduvcuXMqLCxUWlqa2bGaeeedd/T555+bHQNhItSPvZ1llWN3R1nhmN9ZodpndIZV+puO6sp+ypIFzo033qiDBw+qqqrK7CjNDBs2TDfeeKNKSkq0detWXXfddWZHalF2drbKysq0fPlyxcXFmR2nRVOnTpXH49GuXbvMjtKmJ598Uvv379fdd9+tX//612bHadf999+vjRs3mh3DMmw2m6qrq72Pa2pqZLPZTEyEUGCFY2hHWeXY21lWO3Z3FMd866C/CZyeZgdoatOmTRo4cGCz5x999FHvTdhmzZpl6tmbtjL27NlTl156qcaNGyeHw6E1a9boiiuuCKmMy5Yt0+LFi2UYhhYvXqynn35aGRkZXZ5RajvnggULdNttt5mQqrH2/iYfe+wxPfbYY5o/f76ys7P1+OOPd31I+fbZWbBggc6fP69Vq1Z1dTxJvmUEQoFVjqEdZYVjb2dZ5djdUVY45ncWfQY6w/Qxef60yMhIo7a21rDZbKZnaalt3LjRGD9+vPdxVVWVkZCQYHqu1lpSUlJIjtm/+uqrjYMHDxput9twu93GuXPnjH379hkDBgwwPVtrzW63h+S+bGjp6enG3//+d+Mb3/iG6VnaaqE2nnrcuHHGm2++6X08f/58Y/78+abnaqmF6uc5nFu47XMrHns720L92N3RZpVjfmdbqPUZnWlW6m862rrqmGm5IWq33nqrKisr5fF4zI7Sor/85S+6+eabJUkpKSmKjo5WXV2dyakau/jbkP/8z/9UeXm5iWlaVl5ergEDBig5OVnJycmqqanRd77zHR08eNDsaI0MHTrU+3NaWpoqKytNTNO6SZMmae7cuZo6daq++uors+NYitPpVEpKioYMGaKoqCjNnDmTbw67OSscQzvKKsfezrLKsbujOOZbE/1NYJlezfnTXnjhBeOBBx4wPUdrLSoqyli5cqWxe/du48MPPzRuvvlm0zM1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dru90XOGYejkyZPexzfccIPGjx+vzZs369ixY3K73SZtHayKAgdh7YUXXtDixYvNjhEQTzzxhHbt2qVz585p4cKFjV676aabVF9f36jDuPfeeyWp0XP19fU6deqU9/Fdd92lq666Sm+++aYOHz4swzDM2DQAgEWVlZXppz/9qXbs2NHi6++//7769u3rbdu2bVN1dXWj5yTpmmuu8T5+99139eWXX+qPf/yjfvnLX3bl5iBMUOAgbEVEhNefd1VVlebOnas33nijxdcPHDjQqMNYsWKFJDV6bv/+/ZoyZYr38csvv6xz585pzZo1ysjI6MrNAQDLiY6OVl5enjwejzwej/Ly8hQdHS3pwhdN1dXVmjNnjg4ePKgDBw7oRz/6kfd3L730UhUVFen48eP64IMPtHjxYr3zzjvtvufIkSNVXFysI0eOqLa2Vv/zP/8jqfkXeA3v355BgwZp7dq1OnTokD799FPNnj3b+5rD4ZDT6dTx48dVW1urp59+ut31Pfvss9q8ebNOnz7d7rL+cDqdeumll/Tpp58GdL3oHsLrX4CwlLlz56qmpkZffPGFKisrdcstt0i60IEUFBToiy++UHl5uUaPHu39nSuvvFJbtmzR0aNHVV5erilTpnhfe+GFF/Tss8/qjTfe0MmTJ5WRkaG7775bc+fO1YkTJ1RUVNRmnsTERL3yyis6dOiQ6urq9Pvf/15S82FzSUlJMgxDkZGRba4vJiZGzz//vA4cOKCamhotXrzYW3R961vf0tatW3Xs2DEdPnxYhYWF7e6vFStW6M0339SJEyfaXdYfe/fu1R//+Eft2bMnoOsFgHDz6KOPaty4cbr22mt1zTXXaMyYMXrssce8rw8cOFCxsbGy2WzKyMjQ0qVLFRcXJ0launSpvvzySw0cOFDp6enNhnO1pE+fPvrrX/+qN998U4MHD9bQoUP19ttvdzh/jx499Nprr6msrEw2m00TJkzQww8/rNtuu02StGTJEi1ZskSxsbH61re+pTVr1nT4vRqMGjVKhw8f1scff6zHHnus3b4TCAQKHJhi2LBhys7OlsPhUExMjCZNmqTPPvtMkjR16lQVFhYqLi5ORUVF+sMf/iBJ6tmzp1577TUVFxerf//+mj17tlatWqVhw4Z513vXXXfpf//3f71nMFatWqWnnnpKffv21dSpU1vNExERoddff1379u3TkCFDZLPZfCo62vLiiy/q/PnzGjp0qEaNGqXbbrtNP/7xjyVJixcvVnFxsfr166fExERvMdUZ/fv3V21trT799FM988wz+uY3v9npdQIA/u3uu+/WE088ocOHD6uurk6LFi3Sf//3f3tfP3funJ544gmdP39eGzdu1MmTJzV8+HBFRETozjvv1MKFC/XVV1+poqJCBQUF7b7f97//fdXW1uqZZ57RmTNndPLkSX3wwQcdzu9wOHTZZZdp8eLFOnfunNxut/Lz8zVz5kxv/qFDhyo+Pl5ffvmltm/f3uH3kqS//e1vuvrqq9W/f3/deeedmjVrFkPO0CUocGCK+vp69erVSyNHjlTPnj21b98+72nod999Vxs3btTXX3+tlStX6pprrpEkjRs3Tn369FFOTo7OnTunLVu26PXXX9esWbO8612/fr3+/ve/yzAMnTlzxuc8Y8aM0eDBg/XLX/5Sp06d0pkzZ/Tee+91ePv69++vyZMn6+GHH9apU6d0+PBh5eXlNepEkpKSNHjw4E6/lyRVVlbq2muv1aBBg3TLLbdo9OjReuaZZzq1TgBAY4MHD9a+ffu8j/ft26fBgwd7Hx85ckT19fXex6dOnVKfPn102WWXKSoqqtEQMl+Gk9ntdn3yyScBSi9vv3P06FFvW7BggQYMGCBJysjI0LBhw1RZWakPPvhAd9xxR6fez+1267PPPpNhGCovL9cTTzyh6dOnB2JTgDZR4MAUn3zyiR5++GE9/vjjOnTokFavXq1BgwZJkmpra73LnTp1St/4xjcUGRmpwYMHq7q6utGF8Pv27ZPNZvM+9qXDaIndbte+ffsadUydkZSUpKioKP3zn//0diLPPfec+vfvL+nC8LwePXrogw8+UHl5ue67775Ovd/BgwdVUVEhwzD02Wefae7cubrzzjsDsSkAgH85cOCAkpKSvI8vv/xyHThwoN3fO3z4sM6dO6fExETvc3a7vd3fq66u1hVXXNHia19++WWjM/UDBw70aX1ut1v9+vXztpiYGG8hU1VVpbvuukv9+/dXbm6u1q5dG9DRAIZhqEePHgFbH9AaChyYZvXq1brxxhu917Tk5ua2ufyBAwdkt9sbHRwvv/xyeTwe7+Oms4D5OitYdXW1Lr/88hbHBne0Ezlz5owSEhK8nUhsbKyuvvpqSRcKkqysLNlsNj3wwAN69tln9a1vfcunrL4wDCPsJlkAALOtXr1ajz32mBISEhQfH69f//rXeumll9r9va+//lrr1q3T448/rm984xsaPny4d6bLtrz++usaNGiQHnroIUVHR6tPnz4aM2aMJGnnzp2aPHmy+vXrpwEDBujhhx9ud30ffPCBTpw4oblz56p3796KiIjQVVddpeuuu07ShSF4CQkJMgxDx44d82ZvS1RUlHr16qUePXo0+lmSbr/9du8Xe8OHD9evfvUrrV+/vt2c0oXrhXr16qWoqKhGPwO+4F9AMMWwYcN08803Kzo6WqdPn9ZXX33V7kF0+/btOnXqlObOnauePXvqpptu0pQpU9q8VubgwYOtfvt1sQ8++ED//Oc/lZOTo29+85vq1auX/uM//kPShU7ke9/7nux2u2JiYrwz2LSltrZWxcXFevrpp9W3b1/16NFDV1xxhb73ve9JkqZPn+4983T06FEZhtHu9vfs2VO9evVSREREo58lafz48br88sslXZgsIScnx+dORJJ69erlnQno4p8BAP/25JNP6h//+Id27dql3bt3a8eOHXryySd9+t3s7GzFxsaqtrZWK1eu1OrVq9sdSn3y5ElNnDhRU6ZMUW1trVwul26++WZJ0sqVK1VWVqbPPvtMxcXF+tOf/tRuhq+//lrf//73de2118rtdquurk7PP/+8YmNjJV0oSPbs2aMTJ05oyZIlmjlzZruzoxUXF+v06dO6/vrrlZ+fr9OnT3v7ugkTJmjXrl06efKkNmzYoHXr1uk3v/mNL7tL3/ve93T69Glt3LhRSUlJOn36tIqLi336XUCSDBqtq9u3v/1tY/v27cYXX3xhHDlyxHjttdeMQYMGGQsXLjRWrlzpXS4pKckwDMOIjIw0JBkjR440tm7dahw7dszYs2ePMW3aNO+yL7zwgrF48eJG7zN06FCjtLTUOHr0qPHqq6+2mclutxuvvvqqUVdXZxw+fNhYsmSJ97U//OEPxtGjRw2Xy2X8+Mc/bpSptRYTE2M8++yzRnV1tXHs2DFjx44dxg9/+ENDkpGbm2vU1NQYJ06cMKqqqozMzMx299kLL7xgNJWenm5IMn7xi18YNTU1xpdffmns37/fWLJkidGnT59m63C73caECRMaPdewjy/mdrtN/xuh0Wi0cG45OTnGiy++aHoOGi0cW49//QAAAIAg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vsnKyjLR0dGmfv369nW0bt3aBAUFmcGDB5tz586ZVq1aGUkmNTXVPhZVje0DDzxgjh07Zrp162bCw8PN22+/bdavX+/w79LChQvN5MmTK7yXmJhovv/+e1NcXGwOHjxoZs6caW666aYqt6V3796W/3+g0Wje3a7uK6ZOnWo2b95sbrnlFhMZGWm+/PJLM23aNCP9O09MnTrVhIaGmuTkZHP+/HkTERFhJJnFixebxYsXmwYNGphOnTqZI0eOXLdvrNxiY2ONMcaEhITY37t2/56ammrKysrM888/b0JDQ83gwYPNqVOnTLNmzex9CwsLzY9//GNz0003maVLl5qFCxcaSebWW281paWlJjk52QQFBZmHHnrIlJaWmsjISPv3Hj582HTu3NmEhISY0NDQKmOsX7+++e6770zz5s1NaGioKS4uNoWFhaZRo0amfv365sKFC+bmm2+uMI6SzG9/+1uzY8cOex79j//4D3u/q/k4KSnJHDlyxMTHx9f6MzLGmFWrVplmzZrZc9PQoUPNzTffbEJCQswLL7xg/vWvf9lz7OTJk+1jUdXYjhgxwuTm5pp27dqZhg0bmo8++sgsWLDA4d+ZjRs3mtTU1ArvpaammnPnzpljx46Zffv2mUmTJlX42V67Ldf+PULzncYZnABXXl6uevXqqXPnzgoNDdXhw4d18OBBSdKmTZv02Wef6YcfftDChQt15513SpJ69uypRo0aafr06SorK9PatWv1j3/8Q48//rh9ucuWLdNXX30lY4y+//57l8f9yiuv6NKlS9qwYYM+/fRTDR482P7Zp59+qo0bN+rSpUt6+eWXdffddys6Olo/+9nPdOjQIc2bN0/l5eXavn27PvroowpncRyNe/369UpMTFTLli0lSUuXLlViYqLatm2rJk2aKDs7+7rvefrpp/XGG2/o66+/liQdOHBAR44csX9+3333KTMzU8OHD9enn37q0Di8/fbbKiwstB+hWrp0qf71r3/JGKMlS5YoNzdXPXr0cGhZQ4cO1bvvvqusrCxdunRJL730ku6++27FxsY69P1VycnJUdeuXdW6dWs9+OCD6t69u2bOnHnDywMA6cr+atq0aTp27JhKS0s1depU/eIXv7B/XlZWpmnTpuny5cv67LPPdO7cOXXo0EHBwcEaOHCgJk+erO+++0579+7V/PnzXRLTt99+qz/+8Y+6fPmylixZon379umnP/2p/fOFCxdq9+7dunDhgl555RUNHjxYwcHBGjZsmJYvX67PPvtMxhh9/vnn+vrrr9WvXz/7986bN0979uxReXm5Ll++XOX6L168KJvNpvvvv1/du3dXdna2vvzyS91zzz3q2bOncnNzdeLEieu+7+mnn9akSZO0f/9+SdKOHTsq9Hv00Uf1zjvvKDk5WTabzaGx+MMf/qCTJ0/ac9OiRYt04sQJlZeXa+bMmapXr546dOjg0LKGDh2qmTNnKj8/X+fPn9dLL72kIUOGVDib5qwNGzaoS5cuatGihQYOHKjHH39cL7744g0vD96HAifAHThwQM8//7ymTJmib7/9VosXL7ZfllRcXGzvd+HCBTVo0EAhISG69dZbVVBQUOEa4MOHDysqKsr+uqCgwG0xnzx5UhcuXKiw7ltvvbXKdZ8/f14nTpzQrbfeqtjYWCUkJOjkyZP2NnToULVq1crpuNevX69evXrp/vvv14YNG7Ru3TolJiYqMTFRGzdurPL66JiYmBqv4x09erS++uorp278rBzvL37xC2VlZdm3r0uXLoqMjHRoWbfeeqsOHz5sf33+/HkdP368ws/VWSUlJdq7d6+MMTp06JDGjRungQMH3vDyAEC6fn9VOQ8cP368wr0fFy5cUKNGjXTLLbcoLCyswr7TVfmqqKiowuuactPhw4cVHh6uyMhIxcbG6tFHH62Qm+69994KlwjfSG5av359hdxUXW6pLTc9//zzWrJkiXbv3u1QDFXF+5vf/EZ79uzRqVOndPLkSTVt2vSGc9Phw4cVFhZmP8B4I/Lz83Xo0CEZY7Rr1y5NmzZNgwYNuuHlwftQ4ECLFy/WfffdZ7/GuLob8q66etP41XtQJKlNmzYVdu6V/8B35obI8+fP66abbrK/vrYAkaRmzZpV+LxNmzY6evSo/fW1N7Q3bNhQN998s44ePaqCggKtX79ezZo1s7fGjRvr2WefdTrO9evX67777lOvXr20fv16bdq0Sffcc0+NSaSgoKDG6TZHjx6tNm3aOHWG49p427Rpo/T0dI0ZM0bNmzdXs2bNtGvXLvvPqbZtO3r0aIWzNTfddJOaN29+XdKuC2OMz046AcB7VN5fVc4D1Tl27JjKysoq3GNS1SQolZ0/f16SasxNlQ8G1ZSb2rRpo0uXLqm0tFQFBQVauHBhhdzUqFGjCrnYmdx0bYFz9WqDuuSmRx99VAMGDNCvfvUrh2KoHO+9996rcePGafDgwfbtO3369A3npjZt2qisrKzCva91ZYyp8DcNfB9/aQS49u3b64EHHlB4eLguXryo7777rtaZw7Zu3aoLFy5o3LhxCg0NVWJiovr376+MjIxqv6ekpKTaGyMr2759u5544gkFBwcrKSmpyhsap06dqrCwMN1777362c9+pg8//ND+Wb9+/XTPPfcoLCxMr776qrZs2aLCwkL94x//UPv27TVs2DCFhoYqNDRUd911lzp27OhQXNfKy8vTd999p2HDhmn9+vU6e/asSkpKNHDgwGqTyF//+lf99re/1U9+8hNJ0m233VZhAoSzZ8+qb9++uv/++/WHP/zB6ZgaNmwoY4yOHTsmSXryySfVpUsX++clJSWKjo5WWFhYld+/ePFijRgxQnfeeafCw8PtN8Ree+SsKqGhoapXr56Cg4MrfC1duen16jZGR0dr+vTpWrZsmdPbBgDXWrx4sSZNmqTIyEg1b95cv/vd7/S3v/2t1u/74Ycf9PHHH2vKlClq0KCBOnTo4NDzVkpLS1VYWKhhw4YpODhYI0aMuK4oaNGihX71q18pNDRUgwYNUqdOnbR8+XL758OGDVOnTp3UoEEDTZs2TUuXLtUPP/ygv/3tb+rfv78efvhhBQcHq169ekpMTLyhs+dfffWVOnTooB49euif//yn9uzZY796YcOGDVV+z1//+le9+uqruv322yVJd9xxh26++Wb750ePHlXv3r313HPPVTtbZk0aN26sy5cv69ixYwoNDdUrr7xSYZKAkpIStW3bttoCY/Hixfr1r3+ttm3bqmHDhnr99df1wQcf1Do7W1hYmOrVq6egoKAKX0tS37591aJFC0lXJh965ZVXyE1+hgInwNWrV0/Tp09XaWmpiouL1aJFC7300ks1fk9ZWZn69++v5ORklZaW6i9/+YuGDx+uffv2Vfs9c+fOVefOnXXy5En9/e9/r3H5zz33nPr3769Tp05p6NCh+uSTTyp8XlxcrJMnT+ro0aNatGiRRo8eXWHd77//viZPnqwTJ06oe/fuGjZsmCTp3LlzevjhhzVkyBAdPXpUxcXFmjFjhurVq1fbMFVp/fr1On78uAoLC+2vg4KCtG3btir7L126VL///e/1/vvv6+zZs/rkk08qJBFJOn36tPr06aPk5GRNmzbNqXj27t2rN998U5s3b1ZJSYnuuOMOffnll/bP16xZo927d6u4uNheBF3riy++0CuvvKKPPvpI//rXv3TbbbfVOpObJKWnp+vixYt64oknNGnSJF28eNF+LXy3bt301Vdf6fz58/rqq6+0c+dOp44CAkBVXnvtNX399dfasWOHdu7cqW3btjn8TK8xY8aoadOmKi4u1sKFC7V48WKH7hVNS0vTiy++qOPHj+vHP/6xvvrqqwqfb926VXFxcSotLdXvf/97DRo0qMK9LAsXLtS8efNUXFys+vXr2/eFhYWFSklJ0cSJE3Xs2DEVFBToxRdfvKGz3RcuXNC2bdu0e/dulZWVSboyHfLhw4er3O9L0syZM7VkyRL77KNz585VgwYNKvQpKChQ7969NWHChAozgzpi5cqVWrFihfbv36/Dhw/r4sWLFS5hu3qA8vjx4/rmm2+u+/53331XCxcu1IYNG5Sfn6+LFy9q7Nixta531apVunjxou655x57nrr//vslSb1799aOHTt07tw5LV++XB9//LFef/11p7YL3s/ymQ5oNEdbYmKiKSgoqPZzZ2Zro9FoNBpt+vTpZt68eXVaRlWzVF7brp0VjEajub9xBgcAAASMDh066I477pAkxcfHa+TIkbVeWQDAt1DgwONiYmJ09uzZKpsjN3t6yq5du6qM8doHi7qTt4zTvffeW20cAOBrGjdurI8//ljnz5/XBx98oDfffFPLli3zmX1ddTFefXimu3nLOD3xxBNVxrBr1y6PxgHvFKQrp3KqVa9ePW3YsEH16tVTaGioli5dqilTpqht27bKyMhQ8+bN9c033+gXv/iFysrKFB4ergULFqh79+46fvy4HnvssVpvUgYAAAAAV6j1DM7333+vBx98UF27dlXXrl3Vt29fJSQkaMaMGZo1a5bi4uJ08uRJ+01nI0eO1MmTJxUXF6dZs2bVOuUwAAAAALhKrWdwrtWgQQNt2rRJzzzzjD799FO1atVK5eXl6tmzp6ZMmaK+fftqxYoVmjJlirZs2aKQkBAVFxfrlltuqXG53377LWd5AMBisbGx9qlTURF5CgCs52ieCnVkYcHBwfrmm290++23a/bs2Tpw4IBOnTpln4O8sLDQPl97VFSUffq/8vJynT59Ws2bN9fx48er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9dRTT6mqqkqHDx/W9u3bdcstt0g6k0Dmzp2rw4cPa/Pmzbruuuvcf2bAgAFavny5Dh48qM2bN2vkyJHuz2bPnq3XXntNf/vb3/T1118rLy9PDzzwgJ566ikdOXJEpaWlXsd2viS2YsUK3XXXXZKkG264QcYYjRgxQpJ0yy23qKyszL2dhx56SFu3blVdXZ0+/PBD9enTx/3Z2WSwc+dOlZeXNxvLpEmT9Oqrr0qS2rVrp6+//lovvfSSJKljx446duyYunfv3ugk3b17d73xxhtyuVyqq6tzJ7eGHnvsMW3ZskXx8fHNxnA2QT311FP66quvNHv2bMXExOiDDz7Qvn37VFdXpw8++MC9jeeff1433XST/vCHP+jIkSPuBHbuXPLzJerm7Nu3TzNnzpTD4ThvPwDwh2effVaDBw/WoEGD9L3vfU8ZGRn61a9+5f48Li5O3bp1U3x8vPLy8jRjxgzFxMRIkmbMmKFvvvlGcXFxys3NVW5uruX9//73v1e3bt10+eWXa8iQIRo3bpweeughSdLKlSs1dOhQSWfO2V9++aV++MMful+vXLlS0plz/p133qkhQ4aod+/eOnjwoGbMmOGxnyFDhig1NVVZWVnNxtLS/latWtVoulZkZKT++te/avfu3erbt6/i4+NVXFzs0SciIkJ/+tOf9F//9V+6/fbbdfjw4fOOSWZmpv71r3+pV69e+u1vf6uIiAi9+OKL6t27t1JTU5WYmKhJkyZJksaNG6c9e/Zo5MiR6tKli373u9812l5xcbGqqqrUu3dv3XPPPXrhhRd08803nzcGb7z44ovav3+/Vq9erSFDhrR6ewhOhta2W0pKitmzZ4+57LLLjCSTlJRkLr/8cjNx4kRz7Ngxk52dbSIjI80LL7xg1qxZYySZdu3amfLycvP000+b6Ohoc/PNN5vDhw+blJQUI8nMnj3bHDp0yNxwww0mIiLCdOjQwcyePds899xzXsVUUVFhhg0bZiSZyZMnmzVr1phLLrnExMbGms8++8z85je/cX/26quvGknm6aefNk6n00yZMsX92f/+7/8aSeaOO+4w5eXlZsCAASYqKso8++yz5rPPPnPvzxhjlixZYrp37246duzYbFw333yz+eKLL4wk8/3vf984nU6zdu1a92cbNmxwj6ExxkRFRRlJ5q9//aspLi42MTExpl27duaHP/yhkWSGDBliKisrjSTz61//2vzzn/80sbGx5x2bIUOGmJMnT5opU6aY9u3bm44dO5oePXqYu+66y3Tq1Ml07tzZlJSUmPfff9/9Z5YvX27y8vI8tmOMMVdccYWRZObOnWv+8pe/mM6dO5ukpCSzY8cO8/DDD3v1dxUVFWWMMSYpKcnj/dmzZ5sDBw6YAwcOmM8//9zcddddTR7L2eOn0Wg0b9rZ/OB0Ok12drb7/dtvv91UVFQY6cy55ejRo+5zsCSzd+9ek5mZaSIjI82JEyfc+UqSee6558yqVata3PfZ82ZkZKQ5fvy4SU1NdX9WUFBgli9fbiSZhx9+2CxcuNBIMlu3bjV5eXnmrbfeMpLMrl27TFpamvuzW265xb2NuLg4c+LECRMVFeXOI/369Wsxrssvv9zU1dWZiIgIM3PmTFNQUOA+t86ZM8c8/vjj7nE5+/7gwYPNvn37PMbobMvNzTVr1641xcXF5p133jHR0dEtxpCbm2t279593j45OTlm/fr1jf4uz74+N3cmJCSYU6dOmc6dO7s/f+GFF8zs2bO9+jm54oorjDlT1Xm0jIwM07lzZ9O+fXszbtw4c/jwYXP55Zc3OhZvfh5oQd1sD4Bmc7viiivM3r17zbBhw0y7du3c70+cONF8/PHH7tepqanm6NGjRpK58cYbzVdffWUiIiLcny9YsMBMnDjRSGd+uZ07d67Hfi60wDlfErvlllvMxo0bjSSzePFik5eX5y7CVqxYYX70ox8ZSWbRokUev7BHRESYb775xvTp08dIZ5LWzTff3GJcHTt2NMeOHTM9evQw48ePN08//bSprKw0F198sZk0aZKZPn26kTxP0nFxceb06dMmJiam0faGDBliqqqqzMsvv2xWrVplunbt2mIMQ4YMMcePHzcdOnRots/3vvc9U1dX5359vgKnpUTdUmuuwElLSzM9evQwUVFRJjs72xw+fNjccMMNjY6FAodGo1lpZ/PD0aNHzcCBA93vX3nlleb48eNGavrccvbP9erVyxhjTKdOndyfFRQUWCpwLr30UmOMMRdddJH7s6ysLLNz504jncmrdXV1Ji4uzuzYscN06dLF7NmzxyQlJZmDBw+6c+c333xj6uvrzcGDB93t2LFjpnfv3u48cm5ePl+rrKw0aWlpZvPmzaZ3795m3bp1JiUlxVRUVJhrr7220bjce++9xuFwNLmt3NxcU1tba44dO2auueYar/afm5trVq9e7fHepZdeat566y1TVVVl6uvrzZEjR8yePXsa/Z2cfX1u7szIyDD79u3z2N4jjzxilixZ4lU8zRU4DdvixYtNYWFho2OhwAntxhQ16Msvv9QvfvELTZo0Sfv27dNbb72lyy67TJJUU1Pj7nf06FF16tRJUVFR6t27tyorKz0uee/evdtjapWvVgfr3bu3du/e7bGf3r17S5LWrFmjlJQUXXrppRo0aJDmzZunxMRE9ezZUxkZGfr0008lnZnLPH36dB08eFAHDx5UXV2dIiIiLMf77bff6vPPP9eQIUP0wx/+UCtXrtTf//53/eAHP/CYdnCuxMRE1dXV6dChQ01uMyYmRgUFBXrxxRdbvPx/1v79+3X8+HH3606dOumPf/yjdu3apfr6en366afq3r27V/c+xcbGqn379o3G+HzT5LxRVlamuro6nT59WosXL9abb77pnk4IAK1VXV3tsbhJnz59VF1d3eKf279/v06ePKmEhAT3e4mJiZb2XVtbqxMnTjTav8vlknQmrx49elSPPfaYPv30Ux05ckQ1NTUqKCjQ6tWr3bmzsrJS2dnZ6t69u7t16tTJ4ziaWgmsKStXrtQ999yj9u3bq7q6WitXrlRubq66d++uDRs2NOpfWVmpPn36NHsf57Zt2/TQQw9p8eLFSklJ8SqGhrG+8MILMsbommuuUbdu3TR27FiP6c/nO7bq6mr16NFDnTt3dr937hj7ijGmxSnZCD0UOJAkvfXWW7rpppvc945MnTr1vP2rq6uVmJjocVJoeOJpeOLy9iTd1L6aS2LHjh3TP//5T/385z/X5s2bdfLkSf3973/XE088oS+//FIHDhyQdOZE/sgjj3gkkYsuukhr1qyxHN/KlSt1yy23KC0tTQ6HQytXrlRWVpZHQXWuyspK9ejRw31jZUMHDx7Uf//3f2v27Nm64YYbvIqhYaxPPvmkrrzySmVmZqpbt27uuddn/37Od2wtJWpfIYkA8KW33npLv/rVrxQbG6uePXvqf/7nf/TnP/+5xT/33Xff6b333tOkSZPUqVMnXXnllRo3bpylfX/33XcqKSnRb3/7W3Xu3Fl9+vTRE0884bH/lStXqrCw0P3F14oVKzxeS9If//hH/fa3v3XfExobG6s77rjDUiwN93c2D53d3+rVq5tc0fMf//iHvvrqK02ZMkUXXXSROnTo0CgHFRcX65lnntEnn3yiyy+/3HJMXbp00ddff636+nr17t1bv/zlLz0+37t3b7Pbraqq0t///ne9+OKL6tChg6655hrl5eV59XfcoUMH97265/5/t27ddPvtt6tDhw6KiorSmDFj9MMf/lAffvih5WNDcKPAgVJSUnTzzTerffv2+vbbb3Xs2LEWlzdet26djh49qqeeekrt2rXTkCFDNHLkyEY3KJ7rfCey82kpiXmbRJ5++mn3KjZdu3bVPffcYzmWs/sbN26ctm7dqpMnT2rFihX68Y9/rIqKCtXW1jbqX1NTo8WLF+u1115TTEyM2rVrp5tuuqnRNh944AG99957Sk9PtxxTly5ddOzYMR06dEjdu3fXxIkTPT4/39h7k6ib06FDB3Xo0KHR/0vS3XffrYsvvlgRERG67bbbNHbsWEuLSwDA+Tz//PP6/PPP9cUXX2jTpk1av369nn/+ea/+bGFhobp166aamhrNnz9fb731lsdVcW889thj+uabb/Svf/1Lq1ev1oIFC/TGG2+4P1+5cqW6du3qLjgavpak6dOnq7S0VEuWLNHhw4e1du1aZWZmWoqjuf2tXr1aF110UZNfvElnzv0jR45U//79tWfPHlVVVen+++9v1G/evHn6zW9+o2XLljV6HEBLJk+erGuvvVb19fX629/+pvfee8/j8xdffFG/+tWvdPDgQT355JON/vzo0aPVt29fVVdX6/3339fEiRO1dOnS8+4zKSlJ3377rbZu3SrpzMyLHTt2SJKio6P1/PPPa//+/aqtrXUv8nC+xYUQumyfJ0ezt11zzTVm3bp15vDhw+bAgQPmgw8+MJdddpmZOHGimT9/vrtfwxvnBw4caFasWGEOHTpktmzZYu68805336but+nfv78pKyszBw8e9LgBvql27rzcDh06mOnTp5vq6mpTXV1tpk+f7nH/ye23326MMe4b96+66ipjjDH33XefxzbHjh1rvvjiC1NfX2/27NljZs2a5f7s3BvuW2oXX3yxOXHihPmf//kf93t79+41r732WrNj1b17dzNnzhxTU1Nj6urqzLvvvmukxvPER4wYYWpqatw3oDbVmppbftlll5nly5ebI0eOmB07dpiCggKP/Q8ePNjs2LHD1NXVue8TOveY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\n"},"metadata":{}}]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg survey for partial"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF"},"outputs":[],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_true_open_idxth], short_max_tpg]\n","long_max_datas = [long_max_outg[long_true_open_idxth], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v3"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oVifICO4-Grk"},"outputs":[],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","val_list = np.arange(-0.0, 1.0, 0.03)  # prcn 2\n","# val_list = np.arange(-0.695, -0.75, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.ei_k = set_val\n","  # config_list_copy[0].ep_set.ep_out_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    # enlist_rtc(res_df, config_, np_timeidx)\n","    enlist_tr(res_df, config_, np_timeidx)\n","  open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","\n","  try:\n","    result.append(get_res_v5(res_df, open_info_df, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx = open_info_df.index.to_numpy()\n","  len_df = len(res_df)\n","  s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","  s_open_info_df = open_info_df[s_idx]\n","  s_open_idx = open_idx[s_idx]\n","\n","  open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","  side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v5(res_df, s_open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v13(res_df, len_df, config_list[0], high, low, s_open_idx, side_arr, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8LiKwfiJ4bvM"},"outputs":[],"source":["def plot_info_v6(gs, gs_idx, sample_len, tr, prcn, rc, bars_in, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    # title_str = \"prcn : {:.3f} rc : {:.3f}\\n len_pr : {} dpf : {:.3f}\\n wr : {:.3f} sr : {:.3f}\\n acc_pr : {:.3f} sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f} liqd : {:.3f}\\n acc_mdd : -{:.3f} sum_mdd : -{:.3f}\\n leverage {}\"\n","    # title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n rc : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n wave_bias : {:.3f}\\n bars_in : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    plt.title(title_str.format(tr, prcn, rc, bars_in, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"]},{"cell_type":"code","source":["def ffill_line(line_, idx_):\n","  len_line = len(line_)\n","  total_en_idx = np.zeros(len_line)\n","  total_en_idx[idx_] = 1\n","  idx_line_ = np.where(total_en_idx, line_, np.nan)\n","  idx_line = pd.Series(idx_line_).ffill().to_numpy()\n","\n","  return idx_line\n","\n","def get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj):\n","  \n","  short_op_idx = short_obj[-1].astype(int)\n","  short_en_idx = short_obj[2].astype(int)\n","  short_en_tp1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)   # en_idx 에 sync 된 open_idx 를 사용해야함\n","  short_en_out0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","  long_op_idx = long_obj[-1].astype(int)\n","  long_en_idx = long_obj[2].astype(int)\n","  long_en_tp1 = ffill_line(res_df['long_wave_1_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","  long_en_out0 = ffill_line(res_df['long_wave_0_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","\n","  bias_info_tick = config.tr_set.bias_info_tick\n","\n","  # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","  # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","  # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","  len_df_range = np.arange(len_df)\n","  last_idx = len_df - 1\n","  shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","  short_en_tp1_touch_idx = pd.Series(np.where(low <= short_en_tp1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[short_en_idx]  \n","  short_en_out0_touch_idx = pd.Series(np.where(high >= short_en_out0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[short_en_idx]\n","\n","  long_en_tp1_touch_idx = pd.Series(np.where(high >= long_en_tp1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[long_en_idx]\n","  long_en_out0_touch_idx = pd.Series(np.where(low <= long_en_out0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[long_en_idx]\n","\n","  short_true_bias_idx = short_en_tp1_touch_idx < short_en_out0_touch_idx  # true_bias 의 조건\n","  long_true_bias_idx = long_en_tp1_touch_idx < long_en_out0_touch_idx\n","\n","  short_false_bias_idx = short_en_tp1_touch_idx >= short_en_out0_touch_idx  # false_bias 의 조건\n","  long_false_bias_idx = long_en_tp1_touch_idx >= long_en_out0_touch_idx\n","\n","  # return short_true_bias_idx.ravel(), short_false_bias_idx.ravel(), long_true_bias_idx.ravel(), long_false_bias_idx.ravel()\n","  return short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1[short_en_idx], short_en_out0[short_en_idx], long_en_tp1[long_en_idx], long_en_out0[long_en_idx]\n","\n","  \n","def wave_bias(true_idx, false_idx):  # 정확하게 하려고, true & false 로 기준함\n","    true_sum = np.sum(true_idx)\n","    false_sum = np.sum(false_idx)\n","    return true_sum / (true_sum + false_sum)"],"metadata":{"id":"aFpEbTaECnGW"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_pr_v4(open_side, h, l, obj, tpout, lvrg, fee, p_ranges, p_qty_ratio, inversion=False):  # --> 여기서 사용하는 ex_p = ex_p\n","\n","    en_p = obj[0]\n","    # ex_p = obj[1]\n","    tp, out = np.split(tpout, 2, axis=1)\n","    len_p = len(p_ranges)\n","    en_ps, tps, outs, lvrgs, fees = [np.tile(arr_, (1, len_p)) for arr_ in [en_p, tp, out, lvrg, fee]]\n","\n","    np_obj = np.array(obj).T[0]\n","    assert len(np_obj.shape) == 2\n","\n","    # iin == iout 인 경우 분리\n","    en_idx = np_obj[:, 2]\n","    ex_idx = np_obj[:, 3]\n","    equal_idx = en_idx == ex_idx\n","\n","    min_low = np.full_like(en_p, np.nan)\n","    min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","    max_high = np.full_like(en_p, np.nan)\n","    max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","\n","    if open_side == \"SELL\":\n","        p_tps = en_ps - (en_ps - tps) * p_ranges\n","        # min_low = np.full_like(en_p, np.nan)\n","        # min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","        tp_idx = (np.tile(min_low, (1, len_p)) <= p_tps) * (np.tile(max_high, (1, len_p)) <= outs)  # entry_idx 포함해서 out touch 금지 (보수적 검증)\n","    else:\n","        p_tps = en_ps + (tps - en_ps) * p_ranges\n","        # max_high = np.full_like(en_p, np.nan)\n","        # max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","        tp_idx = (np.tile(max_high, (1, len_p)) >= p_tps) * (np.tile(min_low, (1, len_p)) >= outs)\n","\n","    ex_ps = outs.copy()\n","    ex_ps[tp_idx] = p_tps[tp_idx]\n","\n","    if open_side == \"SELL\":\n","        if not inversion:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","    else:\n","        if not inversion:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","\n","    return pr.reshape(-1, 1), liqd"],"metadata":{"id":"642Dt6urKfvF"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v13(res_df, len_df, config, high, low, open_idx, side_arr, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5), fontsize=15, signi=False):\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        fig = plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","    \n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","      sample_len = int(len_df * sample_ratio)\n","    else:\n","      sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","    point1_arr, valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res    \n","    assert len(valid_openi_arr) != 0, \"assert len(valid_openi_arr) != 0\"    \n","    short_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.SELL)[0]  # valid_openi_arr 에 대한 idx, # side_arr,\n","    long_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.BUY)[0]\n","\n","    valid_open_idx = open_idx[valid_openi_arr].reshape(-1, 1)\n","\n","    short_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[short_valid_openi_idx]\n","    long_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[long_valid_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_point1_arr, long_point1_arr = [point1_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)    \n","    # print(\"elapsed time :\", time.time() - start_0)\n","\n","    short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1, short_en_out0, long_en_tp1, long_en_out0 = \\\n","    get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj)\n","\n","    len_short, len_long = len(short_valid_openi_idx), len(long_valid_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","      # start_0 = time.time()      \n","      if len_short == 0:\n","        short_pr = []\n","        gs_idx += 1\n","      else:\n","        short_tr = short_tr_arr.mean()\n","        short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","        short_cum_pr = np.cumprod(short_total_pr)\n","        # short_liqd = liquidation_v2(OrderSide.SELL, h, short_obj[:4], short_lvrg_arr, short_fee_arr)\n","        short_prcn, short_rc = precision(short_pr, short_true_bias_idx), wave_bias(short_true_bias_idx, short_false_bias_idx)\n","        short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","        if signi:\n","          short_idep_res_obj = (short_prcn, short_rc) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, short_tr, short_prcn, short_rc, short_trade_ticks, short_pr, short_total_pr, short_cum_pr, short_liqd, short_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in short plot_data :\", e)\n","\n","    try:\n","      # start_0 = time.time()   \n","      if len_long == 0:\n","        long_pr = []\n","        gs_idx += 1\n","      else:\n","        long_tr = long_tr_arr.mean()\n","        long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","        long_cum_pr = np.cumprod(long_total_pr)\n","        # long_liqd = liquidation_v2(OrderSide.BUY, l, long_obj[:4], long_lvrg_arr, long_fee_arr)\n","        long_prcn, long_rc = precision(long_pr, long_true_bias_idx), wave_bias(long_true_bias_idx, long_false_bias_idx)\n","        long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","        if signi:\n","          long_idep_res_obj = (long_prcn, long_rc) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, long_tr, long_prcn, long_rc, long_trade_ticks, long_pr, long_total_pr, long_cum_pr, long_liqd, long_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in long plot_data :\", e)\n","\n","    \n","    try:\n","      # start_0 = time.time()\n","      if len_short * len_long == 0:\n","        both_pr = []\n","        gs_idx += 1\n","      else:\n","        both_tr = (short_tr + long_tr) / 2\n","        both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","        both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","        both_cum_pr = np.cumprod(both_total_pr)\n","        both_liqd = min(short_liqd, long_liqd)\n","        both_true_bias_idx = np.vstack((short_true_bias_idx, long_true_bias_idx))  # vstack for 2d arr\n","        both_false_bias_idx = np.vstack((short_false_bias_idx, long_false_bias_idx))\n","        both_prcn, both_rc = precision(both_pr, both_true_bias_idx), wave_bias(both_true_bias_idx, both_false_bias_idx)\n","        both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","        if signi:\n","          both_idep_res_obj = (both_prcn, both_rc) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, both_tr, both_prcn, both_rc, both_trade_ticks, both_pr, both_total_pr, both_cum_pr, both_liqd, lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","      if len_short * len_long > 0:\n","        for obj, cum_pr in zip([short_obj, long_obj, both_obj], [short_cum_pr, long_cum_pr, both_cum_pr]):\n","          try:\n","            # start_0 = time.time()\n","            gs_idx = frq_dev_plot_v3(gs, gs_idx, len_df, sample_len, obj[-2], cum_pr[-1], fontsize)\n","            # print(\"elapsed time :\", time.time() - start_0)          \n","          except Exception as e:\n","            gs_idx += 1\n","            print(\"error in frq_dev_plot_v3 :\", e)\n","        plt.show()\n","        plt.close()\n","\n","      return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_true_bias_idx, short_false_bias_idx, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_true_bias_idx, long_false_bias_idx, long_point1_arr, long_en_tp1, long_en_out0\n","        \n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v5(res_df, open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs):  # 이미 충분히 줄여놓은 idx 임\n","    side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","    id_idx_arr = id_idx_arr.astype(int)\n","\n","    ep_out, ep_loc_point2, lvrg_set = funcs\n","\n","    point1_list, valid_openi_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(8)]\n","    len_df = len(res_df)\n","    len_open_idx = len(open_idx)\n","    i, open_i = 0, -1  # i for total_res_df indexing\n","\n","    while 1:\n","        # ------------ entry phase ------------ #\n","        open_i += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i >= len_open_idx:\n","            break\n","\n","        # ------ ep_loc ------ #\n","        op_idx = open_idx[open_i]  # open_i 는 i 와 별개로 운영\n","        if op_idx < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ dynamic data by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        id_idx = id_idx_arr[open_i]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        open_side = side_arr[open_i]\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()  # => eptpout arr_list 만들어서 꺼내 사용하면 될 것\n","        point_idxgap_arr = res_df['{}_point_idxgap_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        ep_arr = res_df['{}_ep_{}'.format(side_pos, selection_id)].to_numpy()  # Todo - while loop 내에서 to_numpy() 반복하느니, pd_indexing 이 낫지 않을까\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","        # bias_info_arr = res_df['{}_bias_info_{}'.format(side_pos, selection_id)].to_numpy()  # ex. rolling(entry ~ end)'s high\n","        # bias_thresh_arr = res_df['{}_bias_thresh_{}'.format(side_pos, selection_id)].to_numpy()  # ex. close + dc_T20 * 0.5\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ ei_k & point2 ------ #\n","        i = op_idx + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        point_idxgap = point_idxgap_arr[op_idx]\n","        if np.isnan(point_idxgap):\n","            continue\n","        else:\n","            # ------ allow point2 only next to point1 ------ #\n","            open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","            tp_j = int(op_idx - point_idxgap)\n","            if np.sum(open_arr[tp_j:op_idx]) != 0:\n","                continue\n","\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side,\n","                                                                                 [*ohlc_list, ep_arr], ep_out, ep_loc_point2)\n","        i = exec_j\n","\n","        if not entry_done:\n","            continue\n","\n","        # ------ leverage ------ #\n","        out = out_arr[out_j]  # lvrg_set use out on out_j\n","        leverage = lvrg_set(res_df, config, open_side, en_p, out, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","        if leverage is None:\n","            continue\n","\n","        exit_done, cross_on = 0, 0\n","        # ------ check tpout_onexec ------ #\n","        # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","        if config.ep_set.entry_type == \"LIMIT\":\n","            if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                tp_j = exec_j\n","            if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                out_j = exec_j\n","\n","        while 1:\n","            # ------------ exit phase ------------ #\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ out ------------ #  # out 우선 (보수적 검증)\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_market_out_exec_v2(config, res_df, np_timeidx, open_i, i, len_df, fee, open_side, cross_on, exit_done)\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out != \"None\":\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_out(config, open_i, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","              if not exit_done:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                           [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                point1_list.append(tp_j)\n","                valid_openi_list.append(open_i)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                # bias_list.append([bias_info_arr[exec_j], bias_thresh_arr[exec_j]])  # backtest 에서만 가능한 future_data 사용\n","                # bias_list.append([bias_info_arr[exec_j], tp_arr[tp_j]])  # bias_info 는 entry_idx 부터 & tp = bias_thresh\n","                tr_list.append(tr_arr[op_idx])\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(point1_list), np.array(valid_openi_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side, np_datas, ep_out, ep_loc_point2):\n","    o, h, l, c, ep_arr = np_datas\n","    ep_j = op_idx\n","    # tp_j = op_idx\n","    out_j = op_idx\n","\n","    selection_id = config.selection_id    \n","    allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ ei_k ------ # - limit 사용하면 default 로 ei_k 가 존재해야함\n","            if ep_out(res_df, config, op_idx, e_j, tp_j, [h, l], open_side):\n","              break\n","\n","            # ------ point2 ------ #\n","            if not allow_ep_in:\n","                allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","                if allow_ep_in:\n","                  if config.ep_set.point2.entry_type == \"LIMIT\":\n","                    ep_j = e_j\n","                    # print(\"e_j in point2 :\", e_j)\n","                    continue\n","\n","            # ------ check ep_exec ------ #\n","            if allow_ep_in:\n","              if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","                entry_done = 1\n","                ep = c[e_j]\n","                break\n","              else:\n","                if open_side == OrderSide.SELL:\n","                    if h[e_j] >= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                            ep = o[e_j]\n","                        break\n","                else:\n","                    if l[e_j] <= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] <= ep_arr[ep_j]:\n","                            ep = o[e_j]\n","                        break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = c[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, j, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        try:\n","            if config.tr_set.decay_gap != \"None\":\n","                decay_share = (j - open_i) // config.tp_set.decay_term\n","                decay_remain = (j - open_i) % config.tp_set.decay_term\n","                if j != open_i and decay_remain == 0:\n","                    if open_side == OrderSide.SELL:\n","                        tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","                    else:\n","                        tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        except:\n","            pass\n","\n","        if open_side == OrderSide.SELL:\n","            if l[j] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if l[j] <= tp_arr[j] <= h[j]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[j]:\n","                        tp = o[j]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[j]\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if h[j] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    if o[j] > tp_arr[j]:\n","                        tp = o[j]\n","                    else:\n","                        tp = tp_arr[j]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if o[j] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_market_out_exec_v2(config, res_df, np_timeidx, open_i, j, len_df, fee, open_side, cross_on, exit_done):    \n","    close = res_df['close'].to_numpy()\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[j] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and j != open_i:\n","            exit_done = 1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[j - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[j] < 50 - config.loc_set.point.osc_band):\n","                exit_done = 1\n","        else:\n","            if (rsi_T[j - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[j] > 50 + config.loc_set.point.osc_band):\n","                exit_done = 1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[j] < ha_c[j]):# & (ha_o[j] == ha_l[j]):   # 양봉 출현\n","    #           exit_done = 1\n","    #     else:\n","    #       if (ha_o[j] > ha_c[j]):# & (ha_o[j] == ha_h[j]):  # 음봉 출현\n","    #           exit_done = 1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[j] < bb_lower_5T[j] < close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] > bb_upper_5T[j] > close[j - 1]:\n","                exit_done = 1\n","        else:\n","            if close[j] > bb_upper_5T[j] > close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] < bb_lower_5T[j] < close[j - 1]:\n","                exit_done = 1\n","\n","    if exit_done:\n","        ex_p = close[j]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_out(config, open_i, j, out_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if h[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if l[j] <= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if c[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if c[j] <= out_arr[out_j]:  # check out only once\n","                ex_p = c[j]\n","                exit_done = 1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = c[j]\n","\n","        if open_side == OrderSide.SELL:\n","            if o[j] >= out_arr[out_j]:\n","                ex_p = o[j]\n","        else:\n","            if o[j] <= out_arr[out_j]:\n","                ex_p = o[j]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# del np_df\n","del np_plot_params"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rMIwv1Nr1ojX"},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","front_plot = 3    # 0 : whole, 1 : open, 2 : ep_tick, 3 : tp_tick, 4 : bias_tick\n","bias_plot = 1     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","pr_descend = 0    # 1 : 큰 pr 부터, 0 : 작은 pr 부터\n","position = 1      # -1 : short 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 50 #  100 20\n","# post_plotsize = 60\n","post_plotsize = config.tr_set.bias_info_tick\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_point1_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_en_tp1, short_en_out0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_point1_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_en_tp1, long_en_out0]\n","pr, obj, [point1_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, false_bias_arr, en_tp1, en_out0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","\n","# ------ pr_descend ------ #\n","true_pr_idx = pr > 1\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # pos_str 으로 이곳에서 정의함\n","\n","# ------------------ data chunknize ------------------ #\n","np_df = res_df.to_numpy()\n","\n","# left_end_idx = obj[2] - prev_plotsize  # left_margin 기준 - entry_idx\n","left_end_idx = obj[4] - prev_plotsize  # left_margin 기준 - open_idx\n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, point1_arr, lvrg_arr, fee_arr, tpout_arr, en_tp1, en_out0))[invalid_left_end:]  # all arr should have same dimension\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = false_bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2,"status":"ok","timestamp":1651464131260,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"d2124eda-adb6-4357-d425-2ab609f292d2","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["s_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf = 'T'\n","wave_period = 5\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","step_col_list.append([['dc_base_{}{}'.format(wave_tf, wave_period)], 1, '#5b9cf6', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_tf2 = '15T'\n","dc_period2 = 1\n","\n","# step_col_list.append([['dc_upper_{}'.format(dc_tf1), 'dc_lower_{}'.format(dc_tf1)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}'.format(dc_tf2), 'dc_lower_{}'.format(dc_tf2)], 1, '#ff00ff', 4])\n","# step_col_list.append([['dc_base_{}'.format(dc_tf2)], 1, '#5b9cf6', 4])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ff00ff', 7, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_tf, wave_period)], 1, '#ff00ff', 5, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_tf, wave_period)], 1, '#00ff00', 5, 'o'])\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T1', 'dc_lower_15T1'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1ima4Cu1E6-ibP4hpccFiKuoRtmKpFLvk"},"executionInfo":{"status":"error","timestamp":1651468782310,"user_tz":-540,"elapsed":72102,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"ce448188-0700-4d9d-e047-df0e673f3b58"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["_ = [plot_check_v5(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v5(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, lvrg, fee, tp_line, out_line, en_tp1, en_out0 = params\n","\n","    # if ep > out_line:  # for tp > ep > out plot_check\n","    #   break\n","\n","    # ------------ add_col section ------------ #\n","    a_data = data[int(iin):int(iout + 1)]\n","    # a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v5(config, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                    front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline_v3 :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v5(config, en_p, ex_p, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  point1_tick = open_tick - int(open_idx - point1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if front_plot == 1:\n","    x_max = open_tick + 20\n","  elif front_plot == 2:\n","    x_max = entry_tick + 20 \n","  elif front_plot == 3:\n","    x_max = exit_tick + 20\n","  elif front_plot == 4:\n","    x_max = bias_info_tick + 20\n","\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  plt.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ wave_line ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  plt.axhline(en_tp1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_tp1, ' wave_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  plt.axhline(en_out0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_out0, ' wave_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  point1_ymax, open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [point1_tick, open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(point1_tick, 0, point1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff7722')\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["VdukVo5-Suzj","Bw5JibDKSuzj","Pe0QpnORSuzk","E0n53hflJbnp","MlFkpO1MSuzl","t1E_eAyPSuzm","nUs4fjVHSuzl","L7l5CTJfSuzn","x_XGJqBi8Jex","MSUY4nnku3s9","epgS5Dksu-HX","Iy76iO7gztne","O87s8_EUakqS","EOXQbXixiQcK","c2729DJ6h720","RZJ6uIA_VcJs","xpyP5t8Ht_pE","EQ63Jwpvr7qA","MuD_2vY7TI_8","mScdfR9hmjVu","xivLUsSGC4VF","EJ4f-3Zf4ImT","zmYbP-Gc1ojs","5rdQZm_71ojv","tApzvz_gK9lR","OJqkmkpsLCYC"],"name":"stem5_2_vec_backi2(0502).ipynb","toc_visible":true,"provenance":[],"machine_shape":"hm","authorship_tag":"ABX9TyOCqdLCzagxAO+c4ABizRn0"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}