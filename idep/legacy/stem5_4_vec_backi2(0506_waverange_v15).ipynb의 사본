{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651992606523,"user_tz":-540,"elapsed":26054,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"821eeffe-f2fa-4709-b4a4-2c9f7baf8438"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1651992634003,"user_tz":-540,"elapsed":14436,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","import IPython\n","import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","source":["\n","def bb_level_v2(res_df, itv, period):\n","\n","    bb_base = res_df['bb_base_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_upper2 = 'bb_upper2_{}{}'.format(itv, period)\n","    bb_lower2 = 'bb_lower2_{}{}'.format(itv, period)\n","    bb_upper3 = 'bb_upper3_{}{}'.format(itv, period)\n","    bb_lower3 = 'bb_lower3_{}{}'.format(itv, period)\n","\n","    level_gap = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy() - bb_base\n","\n","    res_df[bb_upper2] = bb_base + level_gap * 2\n","    res_df[bb_lower2] = bb_base - level_gap * 2\n","\n","    res_df[bb_upper3] = bb_base + level_gap * 3\n","    res_df[bb_lower3] = bb_base - level_gap * 3\n","\n","    return res_df"],"metadata":{"id":"kuf6ZhccgRj9"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    # df = bb_line_v3(df, df_15T, 60)\n","\n","    df = bb_level_v2(df, 'T', 60)\n","    print(\"bb phase done\")\n","\n","    c_itv = '15T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":620},"executionInfo":{"status":"ok","timestamp":1651545996678,"user_tz":-540,"elapsed":1771,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"b5353fd4-ce5b-465e-d2e1-295fe2bf48a0"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n","bb phase done\n"]},{"output_type":"execute_result","data":{"text/plain":["                         upper_wick_ratio_15T  lower_wick_ratio_15T  candle_updown_15T  bb_upper_T60  bb_lower_T60  bb_base_T60  bb_upper2_T60  bb_lower2_T60  bb_upper3_T60  bb_lower3_T60\n","index                                                                                                                                                                                      \n","2022-04-27 08:41:59.999              0.128921              0.107881                  1   2823.126867   2790.340133  2806.733500    2839.520235    2773.946765    2855.913602    2757.553398\n","2022-04-27 08:42:59.999              0.128921              0.107881                  1   2822.498326   2790.088008  2806.293167    2838.703485    2773.882848    2854.908644    2757.677689\n","2022-04-27 08:43:59.999              0.128921              0.107881                  1   2821.914551   2789.914116  2805.914333    2837.914768    2773.913898    2853.914986    2757.913681\n","2022-04-27 08:44:59.999              0.128921              0.107881                  1   2821.473171   2789.742162  2805.607667    2837.338676    2773.876657    2853.204181    2758.011153\n","2022-04-27 08:45:59.999              0.089172              0.248408                  0   2820.842501   2789.526499  2805.184500    2836.500502    2773.868498    2852.158503    2758.210497"],"text/html":["\n","  <div id=\"df-4fad65f7-26d2-4307-b7f0-3be83cd9e560\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>upper_wick_ratio_15T</th>\n","      <th>lower_wick_ratio_15T</th>\n","      <th>candle_updown_15T</th>\n","      <th>bb_upper_T60</th>\n","      <th>bb_lower_T60</th>\n","      <th>bb_base_T60</th>\n","      <th>bb_upper2_T60</th>\n","      <th>bb_lower2_T60</th>\n","      <th>bb_upper3_T60</th>\n","      <th>bb_lower3_T60</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","      <td>2823.126867</td>\n","      <td>2790.340133</td>\n","      <td>2806.733500</td>\n","      <td>2839.520235</td>\n","      <td>2773.946765</td>\n","      <td>2855.913602</td>\n","      <td>2757.553398</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","      <td>2822.498326</td>\n","      <td>2790.088008</td>\n","      <td>2806.293167</td>\n","      <td>2838.703485</td>\n","      <td>2773.882848</td>\n","      <td>2854.908644</td>\n","      <td>2757.677689</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","      <td>2821.914551</td>\n","      <td>2789.914116</td>\n","      <td>2805.914333</td>\n","      <td>2837.914768</td>\n","      <td>2773.913898</td>\n","      <td>2853.914986</td>\n","      <td>2757.913681</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>0.128921</td>\n","      <td>0.107881</td>\n","      <td>1</td>\n","      <td>2821.473171</td>\n","      <td>2789.742162</td>\n","      <td>2805.607667</td>\n","      <td>2837.338676</td>\n","      <td>2773.876657</td>\n","      <td>2853.204181</td>\n","      <td>2758.011153</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>0.089172</td>\n","      <td>0.248408</td>\n","      <td>0</td>\n","      <td>2820.842501</td>\n","      <td>2789.526499</td>\n","      <td>2805.184500</td>\n","      <td>2836.500502</td>\n","      <td>2773.868498</td>\n","      <td>2852.158503</td>\n","      <td>2758.210497</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-4fad65f7-26d2-4307-b7f0-3be83cd9e560')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-4fad65f7-26d2-4307-b7f0-3be83cd9e560 button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-4fad65f7-26d2-4307-b7f0-3be83cd9e560');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":86}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":846,"status":"ok","timestamp":1651546010001,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"cf5e52a8-36e5-4fe3-d8ea-4d7e10f33b6a"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651992638958,"user_tz":-540,"elapsed":4957,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d1a6b563-6f1c-4fc9-f9ef-04f538193774"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 3.8679261207580566\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["def wave_range_v11(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","\n","    if itv != 'T':\n","        assert ltf_df is not None, \"assert ltf_df is not None\"\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","    else:\n","        ltf_df = t_df\n","\n","    return ltf_df\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n"],"metadata":{"id":"RVFfP9VcDG2_","executionInfo":{"status":"ok","timestamp":1651995143972,"user_tz":-540,"elapsed":1364,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":40,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":36,"metadata":{"id":"YqBXjVPzdccC","executionInfo":{"status":"ok","timestamp":1651995046560,"user_tz":-540,"elapsed":485,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","i = 74470\n","\n","plot_size = 100\n","t_df = res_df.iloc[i - plot_size:i]\n","# t_df = res_df.iloc[i - plot_size:i - 22]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":43,"metadata":{"id":"-Dr_tTk9csFm","colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"status":"ok","timestamp":1651995215265,"user_tz":-540,"elapsed":1479,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"4c61adf5-8d06-479d-c670-02e3d6558bf5"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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vXt3lZcLAADAoaooAH7zm9/MV77ylezbty9JMnbs2LzyyivZu3dvkmTTpk2ZOHFikmTKlCk57rjj8sMf/rDXMYuiyLJly/Jv//ZvmT17do/9Zs+enfb29rS3t2fcuHEV3SkAAAC6Gt5XhxkzZmTbtm1ZsWJFzjjjjF77NjU15R//8R/zJ3/yJ31OfPrpp+f555/Pu9/97tx3331Zs2ZNHnnkkS79FixYkAULFiSJawUBAAD6oc8AOH369Jx77rn5T//pP6WlpSVHHXVUrr/++owePTrDhg3L3r17M2nSpGzevDnvete78od/+Id56KGHkiStra1ZunRpzj333PziF784YNznn38+SfLiiy9myZIl+dCHPtRtAAQAAKA6+nwL6Ny5c3Pcccelra0tF154YR544IF89rOfzYMPPpgLLrggSTJr1qzcdddd2bFjR9797nenra0tbW1tWb58ebfhb9SoUTnyyCM7//7xj388Tz755ADcPQAAAN5yyPsAXnXVVfnSl76UdevWZezYsVm4cGGv/d/znvfk3nvvTZJMmDAhP/3pT/PYY4/l5z//ee699978+Mc/PtSlAAAAUIE+3wL6Tg8//HAefvjhJPv38TvttNN67f/Rj3608+8vvPBCZsyY0fm9p5xyysGuFQAAgH445FcAAQAAaCwCIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAADW3tzEtqvYSGIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJNCUpar2ISu3YsSNPP/10rZcBXYwbNy7bt2+v9TKgW45P6pVjk3rl2KSeve9978tRRx11yN8/vIprGXBPP/10pk6dWutlQBft7e2OTeqW45N65dikXjk2qWft7e39+n5vAQUAACgJARAAAKAkhiX5eq0XcTBWrFhR6yVAtxyb1DPHJ/XKsUm9cmxSz/pzfDbUh8AAAABw6LwFFAAAoCQEQAAAgJJoiAD4iU98ImvWrMm6dety1VVX1Xo5lNykSZPywAMP5Je//GWefPLJXH755UmSMWPGZNmyZVm7dm2WLVuW0aNH13illFVzc3NWrFiRu+++O0kyefLkLF++POvWrcttt92WESNG1HiFlNHRRx+dO+64I6tXr85TTz2VadOmOW9SN6688so8+eSTWbVqVRYvXpzDDz/cuZOaWLhwYbZu3ZpVq1Z13tbbufL666/PunXr8vjjj2fKlCkVz1PUczU3NxfPPPNM0dbWVowYMaJ47LHHipNPPrnm61LlrdbW1mLKlClFkuLII48snn766eLkk08urr322uKqq64qkhRXXXVVcc0119R8raqc9cUvfrFYtGhRcffddxdJiu9+97vFH//xHxdJihtvvLG49NJLa75GVb769re/XVx88cVFkmLEiBHF0Ucf7byp6qKOPfbYYv369UVLS0uR7D9nzpo1y7lT1aQ+/OEPF1OmTClWrVrVeVtP58pzzjmn+OEPf1gkKU477bRi+fLllc5T+zvaW02bNq340Y9+1Pn1nDlzijlz5tR8XUq9VT/4wQ+Ks846q1izZk3R2tpaJPtD4po1a2q+NlW+mjhxYnH//fcXH/3oRzsD4IsvvlgMGzasSLqeU5UajDrqqKOK9evXd7ndeVPVQx177LHFc889V4wZM6YYNmxYcffddxcf//jHnTtVzer4448/IAD2dK6cP39+ceGFF3bbr7eq+7eATpw4MRs3buz8etOmTZk4cWINVwRvO/744zNlypQ8+uijmTBhQrZs2ZIk2bJlSyZMmFDj1VFG3/zmN/OVr3wl+/btS5KMHTs2r7zySvbu3ZvEOZTaaGtry4svvph/+Zd/yYoVK7JgwYKMGjXKeZO68Pzzz+fv//7v89xzz+WFF17Iq6++ml/84hfOndSNns6Vh5qT6j4AQr064ogjcuedd+bKK6/Ma6+91qW9KIoarIoymzFjRrZt22bvKurO8OHDc+qpp+bGG2/Mqaeemp07d2bOnDld+jlvUgujR4/Oeeedl7a2thx77LE54ogjcvbZZ9d6WdCj/p4r6z4Abt68Occdd1zn15MmTcrmzZtruCLY/z8zd955ZxYtWpQlS5YkSbZu3ZrW1tYkSWtra7Zt21bLJVJC06dPz7nnnpsNGzbktttuy5lnnpnrr78+o0ePzrBhw5I4h1IbmzZtyqZNm/Lzn/88SfK9730vp556qvMmdeGss87Khg0bsn379uzZsyff//73M336dOdO6kZP58pDzUl1HwDb29tz4oknZvLkyRkxYkQuvPDCLF26tNbLouQWLlyY1atX57rrruu8benSpZk1a1aSZNasWbnrrrtqtTxKau7cuTnuuOPS1taWCy+8MA888EA++9nP5sEHH8wFF1yQxLFJbWzdujUbN27MSSedlCT52Mc+lqeeesp5k7rw3HPPZdq0aRk5cmSSt49P507qRU/nyqVLl+Zzn/tckuS0007Lq6++2vlW0b7U/EL6VdCnAAAe4UlEQVTHvuqcc84pnn766eKZZ54p5s6dW/P1qHLX9OnTi6Ioiscff7xYuXJlsXLlyuKcc84pjjnmmOL+++8v1q5dW9x3333FmDFjar5WVd4644wzOj8Epq2trXj00UeLdevWFbfffntx2GGH1Xx9qnz1gQ98oGhvby8ef/zxYsmSJcXo0aOdN1Xd1Ne//vVi9erVxapVq4rvfOc7xWGHHebcqWpSixcvLp5//vni9ddfLzZu3Fh8/vOf7/Vc+a1vfat45plniieeeKL44Ac/WNEcTW/+BQAAgCGu7t8CCgAAQHUIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBICIAAAQEkIgAAAACUhAAIAAJSEAAgAAFASAiAAAEBJCIAAAAAlIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBIC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6aeLk08+ubj22muLq666qkhSXHXVVcU111xT87WqctYXv/jFYtGiRcXdd99dJCm++93vFn/8x39cJCluvPHG4tJLL635GlX56tvf/nZx8cUXF0mKESNGFEcffbTzpqqLOvbYY4v169cXLS0tRbL/nDlr1iznTlWT+vCHP1xMmTKlWLVqVedtPZ0rzznnnOKHP/xhkaQ47bTTiuXLl1c6T+3vaG81bdq04kc/+lHn13PmzCnmzJlT83Up9Vb94Ac/KM4666xizZo1RWtra5HsD4lr1qyp+dpU+WrixInF/fffX3z0ox/tDIAvvvhiMWzYsCLpek5VajDqqKOOKtavX9/ldudNVQ917LHHFs8991wxZsyYYtiwYcXdd99dfPzjH3fuVDWr448//oAA2NO5cv78+cWFF17Ybb/equ7fAjpx4sRs3Lix8+tNmzZl4sSJNVwRvO3444/PlClT8uijj2bChAnZsmVLkmTLli2ZMGFCjVdHGX3zm9/MV77ylezbty9JMnbs2LzyyivZu3dvEudQaqOtrS0vvvhi/uVf/iUrVqzIggULMmrUKOdN6sLzzz+fv//7v89zzz2XF154Ia+++mp+8YtfOHdSN3o6Vx5qTqr7AAj16ogjjsidd96ZK6+8Mq+99lqX9qIoarAqymzGjBnZtm2bvauoO8OHD8+pp56aG2+8Maeeemp27tyZOXPmdOnnvEktjB49Ouedd17a2tpy7LHH5ogjjsjZZ59d62VBj/p7rqz7ALh58+Ycd9xxnV9PmjQpmzdvruGKYP//zNx5551ZtGhRlixZkiTZunVrWltbkyStra3Ztm1bLZdICU2fPj3nnntuNmzYkNtuuy1nnnlmrr/++owePTrDhg1L4hxKbWzatCmbNm3Kz3/+8yTJ9773vZx66qnOm9SFs846Kxs2bMj27duzZ8+efP/738/06dOdO6kbPZ0rDzUn1X0AbG9vz4knnpjJkydnxIgRufDCC7N06dJaL4uSW7hwYVavXp3rrruu87alS5dm1qxZSZJZs2blrrvuqtXyKKm5c+fmuOOOS1tbWy688MI88MAD+exnP5sHH3wwF1xwQRLHJrWxdevWbNy4MSeddFKS5GMf+1ieeuop503qwnPPPZdp06Zl5MiRSd4+Pp07qRc9nSuXLl2az33uc0mS0047La+++mrnW0X7UvMLHfuqc845p3j66aeLZ555ppg7d27N16PKXdOnTy+Koigef/zxYuXKlcXKlSuLc845pzjmmGOK+++/v1i7dm1x3333FWPGjKn5WlV564wzzuj8EJi2trbi0UcfLdatW1fcfvvtxWGHHVbz9any1Qc+8IGivb29ePzxx4slS5YUo0ePdt5UdVNf//rXi9WrVxerVq0qvvOd7xSHHXaYc6eqSS1evLh4/vnni9dff73YuHFj8fnPf77Xc+W3vvWt4plnnimeeOKJ4oMf/GBFczS9+RcAAACGuLp/CygAAADVIQACAACUhAAIAABQEgIgAABASQiAAAAAJSEAAgAAlIQACAAAUBL/P1dWozZHwiEAAAAAAElFTkSuQmCC\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","config.tr_set.wave_period = 5\n","wave_itv, wave_period = 'T', config.tr_set.wave_period\n","# t_df = wave_range_v11(t_df, config, ltf_df=None)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# wave_high_fill2_ = t_df['wave_high_fill2_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# wave_low_fill2_ = t_df['wave_low_fill2_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","# ============ plot_check ============ #\n","dc_base_ = t_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in paired_cu_idx if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_fill_, alpha=1.0, color='yellow', linewidth=2)\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","# plt.step(len_df_range, wave_high_fill2_, \"*\", alpha=1.0, color='#0000ff', markersize=6)\n","# plt.step(len_df_range, wave_low_fill2_, \"*\", alpha=1.0, color='#ff0000', markersize=6)\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","plt.xlim(0, len_df)\n","\n","plt.show()"]},{"cell_type":"markdown","source":["###### data_window"],"metadata":{"id":"c2yVTn1tnxMn"}},{"cell_type":"code","source":["roll_list[0][60]\n","roll_list[1][60]"],"metadata":{"id":"_SloTr3bWvHV","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651995254687,"user_tz":-540,"elapsed":497,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"b7bc71cc-2ec4-4a6c-c7a2-56ff3d4e8ac8"},"execution_count":45,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([405.08, 405.  , 405.5 , 404.54])"]},"metadata":{},"execution_count":45}]},{"cell_type":"code","source":["# print(paired_cu_idx)\n","# high_terms_list\n","# wave_high_prime_idx\n","i"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"RGFsCh-g7MmO","executionInfo":{"status":"ok","timestamp":1651995019780,"user_tz":-540,"elapsed":481,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"05b8fc8c-7928-4423-8aad-fdbccc8ec6c4"},"execution_count":33,"outputs":[{"output_type":"execute_result","data":{"text/plain":["74470"]},"metadata":{},"execution_count":33}]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# roll_wave_hl_v2(t_df, config, roll_hl_cnt=4)[0][-1]\n","# roll_wave_hl_v2(t_df, config, roll_hl_cnt=4)[1][50]\n","roll_list = roll_wave_hl_v3(t_df, config, roll_hl_cnt=4) # [0][60]\n","# roll_wave_hl(t_df, itv, period1)[0][150]"],"metadata":{"id":"G5jpriueRpxH","executionInfo":{"status":"ok","timestamp":1651995165547,"user_tz":-540,"elapsed":467,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":41,"outputs":[]},{"cell_type":"code","source":["res_df = t_df"],"metadata":{"id":"rT6ugNM1k1Ii","executionInfo":{"status":"ok","timestamp":1651995050084,"user_tz":-540,"elapsed":498,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":37,"outputs":[]},{"cell_type":"code","source":["term_thresh1=1\n","term_thresh2=1\n","\n","itv = 'T'  # '15T'\n","\n","if itv != 'T':\n","  offset = '1h' if itv != 'D' else '9h'\n","  t_df = to_htf(res_df, itv, offset=offset)\n","else:\n","  t_df = res_df\n","\n","period1 = config.tr_set.wave_period\n","# print(period1)\n","\n","itv_num = to_itvnum(itv)\n","# print(itv_num)\n","\n","t_df = donchian_channel_v4(t_df, period1)\n","\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","# short_open_res = np.ones(len_df)\n","# long_open_res = np.ones(len_df)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","# high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","# high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","paired_cu_idx1 = high_terms[:, 1]\n","paired_co_idx1 = low_terms[:, 1]\n","\n","# ------ 생략 이전 terms' hl ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","# ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","# cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","# co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","# high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","# high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                      co_bool,\n","                                                                                                                                      len_df,\n","                                                                                                                                      len_df_range,\n","                                                                                                                                      True)\n","\n","paired_cu_idx2 = high_prime_terms[:, 1]\n","paired_co_idx2 = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","wave_high_[paired_cu_idx2] = wave_prime_highs\n","wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","# wave_high_fill2_ = fill_arr(wave_high_)\n","# wave_low_fill2_ = fill_arr(wave_low_)\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# wave_high_terms_low_ = np.full(len_df, np.nan)\n","# wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","# wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","# wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","# wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","# wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","# t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","# t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","# ------ for roll prev_hl ------ #\n","t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","\n","if itv != 'T':\n","    join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","        "],"metadata":{"id":"TqMmmSAGuChM","executionInfo":{"status":"ok","timestamp":1651995052192,"user_tz":-540,"elapsed":1,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":38,"outputs":[]},{"cell_type":"code","source":["roll_hl_cnt = 4\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","\n","roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]"],"metadata":{"id":"PR0E7u_UhwWq","executionInfo":{"status":"ok","timestamp":1651995058187,"user_tz":-540,"elapsed":493,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":39,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"code","source":["\n","    \n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","    \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","  for col_, itv_ in zip(future_cols, itv_list):\n","    back_col_ = 'b1_' + col_\n","    res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","  return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n"],"metadata":{"id":"841i4oo2abh-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"code","source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"],"metadata":{"id":"3vHLGont-BFe"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"],"metadata":{"id":"Mh3w2s-j34Zs"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"eQ06-kWq4m6F","executionInfo":{"status":"ok","timestamp":1651799326382,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["11\n","11\n"]}]},{"cell_type":"code","source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"],"metadata":{"id":"SUFmr9Z_kcCN"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"],"metadata":{"id":"_3pOQtt2ttfk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"kKaD1fK3WPRP","executionInfo":{"status":"ok","timestamp":1651756811396,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"metadata":{},"execution_count":79}]},{"cell_type":"code","source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"],"metadata":{"id":"YoZpr7lDn7z-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"code","source":[""],"metadata":{"id":"1eZov-szzNuB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"],"metadata":{"id":"nLWAP1Cl2Hvu"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":4,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1651992644252,"user_tz":-540,"elapsed":5297,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1651992645055,"user_tz":-540,"elapsed":816,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","sys_log = logging.getLogger()\n","\n","def get_line(touch_idx, rtc_):\n","    touch_idx_copy = touch_idx.copy()\n","\n","    nan_idx = np.isnan(touch_idx_copy)\n","    touch_idx_copy[nan_idx] = 0  # for indexing array\n","    touch_line = rtc_[touch_idx_copy.astype(int)].copy()\n","    touch_line[nan_idx] = np.nan  # for true comp.\n","\n","    return touch_line\n","\n","\n","def enlist_rtc(res_df, config, np_timeidx):\n","    selection_id = config.selection_id\n","    # ------------ rtc_gap ------------ #\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","\n","    wave_itv = 'T'\n","    wave_period = config.tr_set.wave_period\n","    \n","    # roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)   # Todo, df 저장할 방법 고민\n","    roll_high_, roll_low_ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)   # Todo, df 저장할 방법 고민\n","\n","    res_df[short_tp_1_] = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)]\n","    res_df[short_tp_0_] = roll_high_[:, -2]  # res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)]\n","    res_df[long_tp_1_] = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)]\n","    res_df[long_tp_0_] = roll_low_[:, -2]   # res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)]\n","\n","    if config.tr_set.p2_itv1 != \"None\":\n","        p2_period1 = config.tr_set.p2_period1\n","        p2_period2 = config.tr_set.p2_period2\n","        res_df[short_epout_1_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[short_epout_0_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","        res_df[long_epout_1_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[long_epout_0_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","    else:\n","        res_df[short_epout_1_] = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)]\n","        res_df[short_epout_0_] = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)]  # roll_high_[:, -2]\n","        res_df[long_epout_1_] = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)]\n","        res_df[long_epout_0_] = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)]  # roll_low_[:, -2]\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df[short_tp_1_] - res_df[short_tp_0_])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df[long_tp_1_] - res_df[long_tp_0_])\n","    res_df['short_epout_gap_{}'.format(selection_id)] = abs(res_df[short_epout_1_] - res_df[short_epout_0_])\n","    res_df['long_epout_gap_{}'.format(selection_id)] = abs(res_df[long_epout_1_] - res_df[long_epout_0_])\n","\n","    # ------------ dtk_gap ------------ #\n","    # res_df['short_dtk_1_{}'.format(selection_id)] = res_df['bb_lower_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['short_dtk_0_{}'.format(selection_id)] = res_df['dc_upper_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['long_dtk_1_{}'.format(selection_id)] = res_df['bb_upper_%s' % config.loc_set.zone.dtk_itv]\n","    # res_df['long_dtk_0_{}'.format(selection_id)] = res_df['dc_lower_%s' % config.loc_set.zone.dtk_itv]\n","\n","    # res_df['short_dtk_gap_{}'.format(selection_id)] = abs(\n","    #     res_df['short_dtk_0_{}'.format(selection_id)] - res_df['short_dtk_1_{}'.format(selection_id)])\n","    # res_df['long_dtk_gap_{}'.format(selection_id)] = abs(\n","    #     res_df['long_dtk_1_{}'.format(selection_id)] - res_df['long_dtk_0_{}'.format(selection_id)])\n","\n","    return res_df\n","\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","    selection_id = config.selection_id\n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","    short_open_res = np.ones(len_df)\n","    long_open_res = np.ones(len_df)\n","\n","    short_tp_1_col, short_tp_0_col, short_tp_gap_col = 'short_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(\n","        selection_id), 'short_tp_gap_{}'.format(selection_id)\n","    long_tp_1_col, long_tp_0_col, long_tp_gap_col = 'long_tp_1_{}'.format(selection_id), 'long_tp_0_{}'.format(\n","        selection_id), 'long_tp_gap_{}'.format(selection_id)\n","    short_epout_1_col, short_epout_0_col, short_epout_gap_col = 'short_epout_1_{}'.format(selection_id), 'short_epout_0_{}'.format(\n","        selection_id), 'short_epout_gap_{}'.format(selection_id)\n","    long_epout_1_col, long_epout_0_col, long_epout_gap_col = 'long_epout_1_{}'.format(selection_id), 'long_epout_0_{}'.format(\n","        selection_id), 'long_epout_gap_{}'.format(selection_id)\n","\n","    tp_cols = [short_tp_1_col, short_tp_0_col, short_tp_gap_col, long_tp_1_col, long_tp_0_col, long_tp_gap_col]  # Todo - public_indi 이전에 해야할지도 모름\n","    epout_cols = [short_epout_1_col, short_epout_0_col, short_epout_gap_col, long_epout_1_col, long_epout_0_col,\n","                  long_epout_gap_col]  # Todo - public_indi 이전에 해야할지도 모름\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","\n","    short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_ = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_ = [res_df[col_].to_numpy() for col_ in epout_cols]\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ---------------- point - support_confirmer---------------- #\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","\n","    wave_itv = 'T'\n","    wave_period = config.tr_set.wave_period\n","\n","    if p2_itv1 != \"None\":\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","    else:  \n","        # ------ p1 only ------ #\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = 0  # default\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = 0 \n","        \n","        # ====== wave_point ====== #\n","        short_open_res *= res_df['wave_cu_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        long_open_res *= res_df['wave_co_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ wave_mm ------ #\n","        wave_high_terms_cnt_fill_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        wave_low_terms_cnt_fill_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        short_open_res *= (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater1)\n","        long_open_res *= (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater1)\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ low in bb_level3 ------ #     \n","        # wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        # wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ tf2_base < wave_base ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        short_open_res *= (dc_base_ > wave_base_) & (dc_base_ > close)\n","        long_open_res *= (dc_base_ < wave_base_) & (dc_base_ < close)\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))     \n","        \n","        # ------ first_high ------ #        \n","        wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_dc_base < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res\n","\n","    # ------------------ tr_set ------------------ #\n","    # ------------ tpep ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = short_tp_1_ - short_tp_gap_ * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = long_tp_1_ + long_tp_gap_ * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg = config.tr_set.ep_gap\n","        # res_df['short_ep_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * epg\n","        \n","        wave_cu_marker_ = res_df['wave_cu_marker_{}{}'.format(wave_itv, wave_period)]\n","        wave_co_marker_ = res_df['wave_co_marker_{}{}'.format(wave_itv, wave_period)]\n","        res_df['short_ep_{}'.format(selection_id)] = wave_cu_marker_ + short_epout_gap_ * epg\n","        res_df['long_ep_{}'.format(selection_id)] = wave_co_marker_ - long_epout_gap_ * epg\n","\n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep_{}'.format(selection_id)] = close\n","        res_df['long_ep_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    res_df['short_out_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * outg\n","    res_df['long_out_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * outg\n","\n","    # ------------ point validation ------------ #\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","    short_open_res *= (short_tp_ < short_ep_) & (short_ep_ < short_out_)\n","    # short_open_res *= close < short_ep_   # reject open_execution\n","    short_open_res *= close < short_out_    # reject open_execution\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res * (not config.pos_set.short_ban)\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","    long_open_res *= (long_tp_ > long_ep_) & (long_ep_ > long_out_)\n","    # long_open_res *= close > long_ep_   # reject open_execution\n","    long_open_res *= close > long_out_    # reject open_execution\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res * (not config.pos_set.long_ban)\n","\n","    if show_detail:\n","      sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","      sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","    \n","    # ------------ wave_bias ------------ #\n","    wb_tpg = config.tr_set.wb_tp_gap\n","    wb_outg = config.tr_set.wb_out_gap\n","    res_df['short_wave_1_{}'.format(selection_id)] = short_tp_1_ - short_tp_gap_ * wb_tpg\n","    res_df['long_wave_1_{}'.format(selection_id)] = long_tp_1_ + long_tp_gap_ * wb_tpg\n","    res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0_ + short_epout_gap_ * wb_outg\n","    res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0_ - long_epout_gap_ * wb_outg\n","\n","    # ------ tr ------ #\n","    res_df['short_tr_{}'.format(selection_id)] = abs(\n","        (short_ep_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep_ / short_out_ - config.trader_set.market_fee - 1))\n","    res_df['long_tr_{}'.format(selection_id)] = abs(\n","        (long_tp_ / long_ep_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    if config.tr_set.c_ep_gap != \"None\":\n","        # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","        # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","        res_df['short_ep2_{}'.format(selection_id)] = short_epout_1_ + short_epout_gap_ * config.tr_set.c_ep_gap\n","        res_df['long_ep2_{}'.format(selection_id)] = long_epout_1_ - long_epout_gap_ * config.tr_set.c_ep_gap\n","\n","    # ------ zoned_out ------ #\n","    if config.tr_set.t_out_gap != \"None\":\n","        # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","        # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","        res_df['short_out2_{}'.format(selection_id)] = res_df['short_epout_0_{}'.format(selection_id)] + res_df[\n","            'short_epout_gap_{}'.format(selection_id)] * config.tr_set.t_out_gap\n","        res_df['long_out2_{}'.format(selection_id)] = res_df['long_epout_0_{}'.format(selection_id)] - res_df[\n","            'long_epout_gap_{}'.format(selection_id)] * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":6,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1651992647898,"user_tz":-540,"elapsed":2847,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    # ====== public ====== #\n","    # res_df = wave_range_v11(res_df, config) \n","    res_df = wave_range_v15(res_df, config, term_thresh1=2, term_thresh2=3)\n","    res_df = wave_range_v15(res_df, config, itv='15T', term_thresh1=2, term_thresh2=3)\n","\n","    # ------ wrr ------ #\n","    # res_df = wave_range_ratio(res_df, config, 'T', 60)\n","    # res_df = wave_range_ratio_v2(res_df, config)\n","    res_df = wave_range_ratio_v3(res_df, config)\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    itv_list = ['15T', '15T', '15T', '15T']\n","    res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def ep_out_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_out(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_out_v2(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    ep_out = 0\n","\n","    if config.tr_set.ep_out_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.ep_out_tick:\n","            ep_out = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k or h[e_j] >= short_tp_0_[tp_j] - short_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()\n","            long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k or l[e_j] <= long_tp_0_[tp_j] + long_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                ep_out = 1\n","\n","    return ep_out\n","\n","\n","def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","    allow_ep_in = 1\n","    if config.selection_id in ['v5_2']:\n","        if side == OrderSide.SELL:\n","            dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","            dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","            allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","                           (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","        else:\n","            dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","            dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","            allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","                           (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","    if config.selection_id in ['v3_4']:\n","        wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","        wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","        close = res_df['close'].to_numpy()\n","        if side == OrderSide.SELL:\n","            sup_T = res_df['sup_T'].to_numpy()\n","            allow_ep_in *= close[i] < sup_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","        else:\n","            resi_T = res_df['resi_T'].to_numpy()\n","            allow_ep_in *= close[i] > resi_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","    if allow_ep_in:\n","        out_j = i\n","    return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #\n","    if config.loc_set.point.short_tr_thresh != \"None\":\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point\n","    if config.loc_set.point.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point.wrr_32 != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point.wrr_32\n","        mr_res *= cu_wrr_32_ >= config.loc_set.point.wrr_32 - 0.5\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point.wrr_32\n","        mr_res *= co_wrr_32_ >= config.loc_set.point.wrr_32 - 0.5\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    if config.loc_set.point.short_wick_ratio != \"None\":\n","      b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","      b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()      \n","      if ep_loc_side == OrderSide.SELL:\n","          # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","          mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point.short_wick_ratio, mr_res[c_i]))\n","      else:\n","          # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","          mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    if config.loc_set.point.crr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","      mr_res *= b1_crr_ >= config.loc_set.point.crr\n","      if show_detail:\n","          sys_log.warning(\"b1_crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone.use_zone:\n","\n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["      \n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1651992647899,"user_tz":-540,"elapsed":18,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_4\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-04-08\\\\2022-04-08 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 0.0002,\n","    \"market_fee\": 0.0004,\n","    \"initial_asset\": 10,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"api_retry_term\": 3,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"15T\",\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"wave_period\": 5,\n","    \"wave_greater1\": 5,\n","    \"wave_greater2\": 2,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"p1_itv1\": \"15T\",\n","    \"p1_itv0\": \"T\",\n","    \"p1_period1\": 1,\n","    \"p1_period2\": 5,\n","    \"p2_itv1\": \"None\",\n","    \"p2_itv0\": \"T\",\n","    \"p2_period1\": 20,\n","    \"p2_period2\": 40,\n","    \"ei_k\": 0.0,\n","    \"ep_out_tick\": 10,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap\": -0.0,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 240\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":8,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1651992647899,"user_tz":-540,"elapsed":17,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"6c84cb3d-4893-4636-d789-a8291712ae75"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_4\" {\n"," \"point\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"15T\",\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"wave_period\": 5,\n"," \"wave_greater1\": 5,\n"," \"wave_greater2\": 2,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"p1_itv1\": \"15T\",\n"," \"p1_itv0\": \"T\",\n"," \"p1_period1\": 1,\n"," \"p1_period2\": 5,\n"," \"p2_itv1\": \"None\",\n"," \"p2_itv0\": \"T\",\n"," \"p2_period1\": 20,\n"," \"p2_period2\": 40,\n"," \"ei_k\": 0.0,\n"," \"ep_out_tick\": 10,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap\": -0.0,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 240\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [ep_out_v2, ep_loc_point2_v2, lvrg_set]  # ep_out for p1 & p2\n","funcs = [ep_out, ep_loc_point2_v2, lvrg_set]     # ep_out for p1-only\n","# funcs = [ep_out_v0, ep_loc_point2_v2, lvrg_set]  # ep_out for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\""]},{"cell_type":"code","execution_count":14,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":7488,"status":"ok","timestamp":1651993064346,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"9a3bea66-9478-42fa-8582-edae221e1205"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 5.615908861160278\n","make data_list elapsed time : 0.00032711029052734375\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_iYcJk8nK8Yq"},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","config_list[0].tr_set.wave_greater1 = 1\n","config_list[0].tr_set.wave_greater2 = 1\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].tr_set.tp_gap = 1.5\n","# config_list[0].tr_set.ep_gap = -1.\n","# config_list[0].tr_set.out_gap = 0\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 500\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004"]},{"cell_type":"code","execution_count":15,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":472,"status":"ok","timestamp":1651993070874,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"8c677c68-d50e-43bc-b880-ff9dae7a6bb1"},"outputs":[{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 84452\n","np.sum(long_open_res == 1) : 83193\n","np.sum(short_open_res == 1) : 41218\n","np.sum(long_open_res == 1) : 41494\n","np.sum(short_open_res == 1) : 14212\n","np.sum(long_open_res == 1) : 15398\n","np.sum(short_open_res == 1) : 14192\n","np.sum(long_open_res == 1) : 15381\n"]},{"output_type":"stream","name":"stdout","text":["enlist_rtc elapsed time : 0.23361611366271973\n","enlist_tr elapsed time : 0.14278125762939453\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  start_0 = time.time()\n","  res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":16,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1651993075449,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point.wrr_32 = \"None\" # \"None\" 1 0.5\n","config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","config_list[0].loc_set.point.wrr = \"None\" # \"None\" # 2.5\n","config_list[0].loc_set.point.cu_es = \"None\" # \"None\" # -2\n","config_list[0].loc_set.point.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point.crr = 2\n","config_list[0].loc_set.point.short_wick_ratio = \"None\" # \"None\" 0.6 0.4\n","config_list[0].loc_set.point.long_wick_ratio = 0.6 # \"None\" 0.4\n","# config_list[0].loc_set.point.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point.short_tr_thresh = 1.5  #  \"None\" 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point.long_tr_thresh = 1.5   #  \"None\" 0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":17,"metadata":{"executionInfo":{"elapsed":680,"status":"ok","timestamp":1651993078083,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"0a1a98fb-bb8f-4852-cd55-2a81a036e3b4"},"outputs":[{"output_type":"stream","name":"stderr","text":["short_tr_ >= short_tr_thresh : nan 1.50000 (0.0)\n","long_tr_ >= long_tr_thresh : nan 1.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9439289569854736\n"]}],"source":["open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.ei_k = -0.5\n","# config_list[0].tr_set.ep_out_tick = 10\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","config_list[0].tp_set.p_ranges = \"[1]\"\n","config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.5, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","config_list[0].lvrg_set.leverage = 1\n","config_list[0].lvrg_set.static_lvrg = 0\n","config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":18,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":644},"executionInfo":{"elapsed":3322,"status":"ok","timestamp":1651993083256,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"aa46ab1c-5888-449e-aca2-e12df2374289"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.8823776245117188\n","short_obj.shape : (2895, 5)\n","long_obj.shape : (3023, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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f/6J999/X1n/888/o127dvjHP/4BIyMjHDx4EBMnTsSZM2eeO/atW7cgIvj6669haWmpPD/nX//6V1UeUpH09PRQp04dqFSq5/YdN24cAGDbtm1FrlepVKUe61nW1tbw9PSEmZkZbty4gTlz5mDt2rUafS5duoQPP/wQrVq1QmZmJm7evIl3330XmzZtKvP+iIhIN1hftZWnvubl5cHLywsdOnRAdnY29u/fj3fffVfjGyEDBgyAoaEhnJyc4OTkpDHmokWLsHjxYgBAREQEpk6ditatW0OlUuH69evw8PDAxo0by3zcRESkO6yx2sp7Dvvqq6+ic+fOSq0syuLFi+Hg4KAs//TTTwA0ayzRi6DCk7dxEREREREREREREVEl40u4iIiIiIiIiIiIiKoIH0FAVE76+vrFrsvPz3+BMyEiIqo5WF+JiIiqBmsske7wDliicvD09EReXl6xefrlGkRERFQ6rK9ERERVgzWWSLf4DFiicmjYsCHatm1b7PqoqCg8evToBc6IiIio+mN9JSIiqhqssUS6xQuwRERERERERERERFWEjyCgGicqKgorVqzQ9TReGD09PXzyySc4duwYEhMTkZiYiP379+ONN97Q6tuhQwf4+fkhLi4OqampOHnyJIYOHarVb/r06YiIiEB2djauX7+OSZMmafUREa2cOnWqSo6RiIheDrWtxgLAokWLEBoaitTUVDx+/Bjnzp3DuHHjtPo1aNAAv/76Kx49eoSUlBRs3LgRDRs2VNaXtl43bdoUO3fuRHR0NLKysvDgwQNs27YNHTp0qPJjJSIi3aiN9dXHx6fIc0obGxuNfl26dMH+/fuRkZGBhIQErFmzBvXq1dPoM3jwYGzevBlRUVEQESxcuLDIfdrZ2WH//v1ISkpCUlISDh48iDfffLPKjpHoabwAS1TNGRsb47PPPsO5c+fg4eGByZMnQ61W48SJE+jRo4fSr379+jh48CDatWuH999/H2PGjMGDBw+we/du9OzZU+nn7u6On3/+Gf7+/hg+fDj27duH9evXY+TIkVr7XrlyJXr37q1k2rRpL+SYiYiIXpQGDRrgt99+w/jx4+Hm5oYLFy7gjz/+gJubm0a/bdu2wcHBAdOnT8eUKVPQs2dP7Ny5U1lf2nptYmKC5ORkfPHFF3BycsJHH30EGxsbHD58GGZmZi/suImIiKpa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+uqrHDlyhJKSErZt28aYMWPc87RaLY8//jipqamUlpaybds24uPjATjttNNYv349hYWF5Obm8vjjj7e4nYCAAN59912KiorYs2cPZ599doP5jz32mHs7e/bs4aqrrgLAYDBQWFjI0KFD3cv26NGDiooKoqNbf7v7jBkzWLx4MXv37qW4uJhnnnmGW2+91eOyU6ZM4aOPPmLv3r3YbDaeeeYZxo0bR79+/U5qu6tWraKyshKAAwcO8M4777Bnz55Wr0sIIUTXIBnbPhm7detW3nnnHSwWC3a7nVdeeYVTTz2VyMjIVtcshBCi65F8Pfl83bp1K0uXLuXgwYMen//++++zbt06ysrKmsy75JJLSEhI4JFHHqG0tBS73c727dtb/XqEaA3pgBV+Y+vWrZxxxhlERkaybNkyPvroI0wmEwAPPfQQN954I5deeilhYWHcfvvtVFZWEhISwtdff826deuIjY3llFNO4ZtvvmlxO7Nnz6Z///7079+fiRMnMmPGjAbz09LSOP/88wkPD2fu3LksXbqUmJgYbDYby5cvZ/r06e5lb7zxRr755hsKCgqabCchIQGLxUJCQoLHOoYMGcKOHTvc0zt27CAmJqbZizaNRtPk3/WD9PLLL6ewsJDdu3dz1113eVxHUFAQ1113HUuWLPE4XwghhH+SjG3/jAUYO3YsOTk5FBUVuR8788wzyc/PZ//+/Tz11FPodLpmny+EEKJrkXxtW76erNGjR7N//36WLFlCQUEBW7ZsYezYsW1erxAt0QA+GbQxLy+Pw4cPt3k90dHRHn/xRev5274844wz2L9/P1VVVQwdOpTMzEyKi4sbLBMZGUlMTAx79+494fWefvrpHD58mNLSUsC132JjY9m5c6d7mfr78rTTTiM7O5vi4mKCg4Pp168fu3btAmDw4MHk5uZisVha/fqGDh3KkSNH3HVoNBpGjBjBzp07sVqtDZYNDQ2lX79+HDhwgOrqavr06UN0dDTp6ekUFRUREBCAw+HAZrMRHBxM//79yczMbHABWLe/4uLi3PXXZzKZOP3009m2bVurX0tL/O249KWuti8TExPp2bOnr8vokiRjOx9/25eSscd4K2MNBgODBw9uMK9uXDyr1UpgYCD9+vVz3+3kDf52XPpSV9uXkrEnR/K18/G3fSn5eszx8rX+cn379vV4jQqQlJRETU0N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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.732208490371704\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_point1_arr, long_en_tp1, long_en_out0 = \\\n","get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=False)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_open_i = short_obj[-1].astype(int)\n","long_open_i = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_0 = res_df['short_epout_0_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_epout_0 = res_df['long_epout_0_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_gap = res_df['short_epout_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_epout_gap = res_df['long_epout_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","# ------ pairing 된 en, ex_idx 기준으로 survey 진행 ------ #\n","# 0. high, low (exit_done 까지의) -> partial (tpg) 과 outg survey 목표\n","#   a. short -> tpg - low, outg - high\n","#   b. long -> tpg - high, outg - low\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_epout_gap)\n","# long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_epout_gap)\n","\n","# ------ 0. tp 까지 도달하는 최소 idx 도출, en_idx 부터 ------ #\n","#   a. bias_info_tick 의 limit 을 정해주지 않으면 굉장히 길어질 수 있다고 봄\n","# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","\n","current_tpg= config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_tf = 'T'\n","wave_period = config.tr_set.wave_period\n","\n","public_cols.append('cu_wrr_21_{}{}'.format(wave_tf, wave_period))\n","# public_cols.append('cu_wrr_32_{}{}'.format(wave_tf, wave_period))\n","public_cols.append('co_wrr_21_{}{}'.format(wave_tf, wave_period))\n","# public_cols.append('co_wrr_32_{}{}'.format(wave_tf, wave_period))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A","colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"status":"ok","timestamp":1651670961786,"user_tz":-540,"elapsed":2896,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"1840cae3-1019-488c-bef4-c771eed85b54"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1080 with 12 Axes>"],"image/png":"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nvL6/uB7DEF4KxISEsz+/ftNv379jCQTExNjrrvuOvPyyy+b7777zqSkpJigoCDz2muvma+++spIMiEhIaakpMQ8//zzJjQ01IwZM8YcPXrUJCQkGElm0aJF5siRI+a2224zHTp0MB07djSLFi0ys2bNajWfoKAgs2PHDvOHP/zBdOnSxXTs2NGMGjXKSDIvv/yyWbJkiXPdmJgYY4wxwcHBl9xep06dzHfffWf69OljQkJCTHV1tamsrDTdunUznTp1Mg0NDaZ3795GkikrKzP5+fkmOjradOrUybn9rKws06VLF9OpUyeXj2tqaqqpqqpq9vj1119vzNlxaW5FWVmZSU5ObvJYWlqaOX78uKmrqzN79uwxL7300mWPBUEQhK/HuXNhaWmpSUlJcT7+s5/9zJSVlRlJJikpyTQ0NDQ5H9bU1JgRI0aYoKAgc+rUKWe9kmRmzZpltmzZctn9TpgwweTl5bX43MX1LSkpyVRUVLT6Xvbv32+GDh1q/v3f/928+eabZtu2bWbAgAHmscceM2vXrnWuZ4wxY8aMabL9kydPmo4dO7p17G6++WZz6NAhc/vttzd7Ljk52Xn83AljjLn++uubPDZw4EDTr18/ExQUZG699VZTVVVlJkyYYPnPDtF+IkSAF505c0YdO3bUoEGDVFdXp/Lycudzn3/+uT744ANJ0pIlSzR16lRJ0siRI9WtWzfNnj1bxhht2rRJ77//vh566CG98sorkqS1a9fqyy+/lCSdPHnS5XyGDx+u/v3767nnntOZM2ckSV988cUVv7/vv/9edrtdo0ePVlVVlQoKCnTkyBGNGjVKJ0+eVElJib799lvn+n/6059UWVnZZBszZ85UQ0ODy/uMiorS/Pnz9eyzz15x3q747LPPdNNNN6m8vFw//vGP9e677+r06dOaPXu2V/cLAFbr379/k3pVXl6u/v37O5cPHTrkrCGS1NDQoG7duulHP/qRQkNDmwwba20ImXT2RvpvvvnGQ9mftXnzZt1555264YYbtHnzZh05ckRJSUm69dZbmw0xvjjHuro6t2rr9ddfrw8++EDPPPOM874YbykuLnb+/auvvtK8efP0wAMPKDs726v7he9gWBq86ptvvtHUqVM1c+ZM1dbWavny5erXr58kqbq62rleQ0ODOnfurODgYPXv318VFRVNbowvLy9XVFSUc9mVYtESm82m8vLyJkXpap0rIKNHj9bmzZv16aefKikpSUlJSa0WkEs9dikRERHKzc3VG2+84fUTeVlZmf75z3/KGKPCwkL9v//3//TAAw94dZ8A0B5UVVUpJibGuXzttdeqqqqq1dfV1dWpsbFR0dHRzsdsNlurr6uoqNB1113X4nMnTpxQly5dnMsXzkZ2Oedq0x133KHNmzdr8+bNl6xNF09E4+rENNLZY/Pxxx9r1qxZeuedd1x+nacYY9ShQ4c23y/aL5obeN3y5ct1xx13OO9hmTNnzmXXr6qqks1ma3Kyuvbaa+VwOJzLV3oirqio0LXXXtvifTRXW0DONTfuFBB3cg8PD1dubq5ycnL02muvufQaT6KAAAgUy5cv10svvaSIiAj16dNHv/nNb1z6xf2HH37Q6tWrNXPmTHXu3FkDBgzQxIkTW33d+++/r379+umZZ55RWFiYunXrpuHDh0uSduzYoXvvvVe9evVS3759naMcWrN582aNGTNGnTt3lsPh0JYtW3TPPfeoT58+ys/Pd2kbrenfv782btyo119/XW+++Waz5zt06KCOHTsqNDS0yd+vxv333++8vykxMVFTpkxpMsEOQHMDr0pISNCYMWMUFham77//Xt99951++OGHy75m27Ztamho0LRp0xQSEqKkpCSNGzfuslcqampqLvmp14W2b9+uAwcOaPbs2erSpYs6duyo2267TdLZAjJ69GjZbDb16NHDOVNNa7788ksNGDBAw4cP1/bt21VUVKSYmBiNGDFCn332mUvbaE337t314Ycf6osvvrhkXh07dnTO5nPh36/UPffco2uuuUaSNGDAAP33f/83BQRAQHj11Vf197//XV9//bV27typvLw8vfrqqy69dvLkyerZs6eqq6u1ZMkSLV++vNUhXsePH9dPf/pTjRs3TtXV1SopKdGYMWMknR22XVBQoH/+85/Kzc3Vu+++61IeJSUlOn78uHOmtmPHjmnfvn364osvWq3DrnryySd1/fXXa+bMmU2+NuCc0aNH6/vvv9cHH3ygmJgYff/998rNzb2qfU6YMEGlpaU6duyYFi9erDlz5mjx4sVX+1bgZyy/8Yfw37j55pvNtm3bzNGjR82hQ4fMunXrTL9+/Vq9eX/QoEHm008/NUeOHDG7du0y48ePd67b0uQBN9xwg8nPzzeHDx82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Cxecy/v27ZN0sQA9d+6c8/V33nnHK/sG30VxA7+wcuVKPfvss2aH4TUzZ87U3/72N7W1tam+vl5Lly5VcHCw8/2f/vSnstls+uKLL7Ry5cpu1/foo486E8O5c+fU0dHhXD5z5owkafv27fr888+drx04cMBr+wcAMN+VeeWSoKDr/6nYp08fzZw5U0OGDNGkSZM0Z84c/fM//7Pz/draWi1YsEBvvvmmS9v/zW9+o8GDB2vw4MH6yU9+og8//NC5/O1vf9vZb+rUqc7XJ06c6MYeIhBQ3MDn3ejA21t1lUC6eu2SAQMGaN68eYqOjlZqaqrS0tI6nSFrbGzUc889p//93/91aftr1651Job09HQ1NjY6lwcPHuzsN2fOHOdr3/rWt9zYQwDwXWFhYVq2bJkcDoccDoeWLVumsLAwSdK4ceNUX1+v+fPnq7m5WY2NjfqXf/kX52e/9rWvqbS0VG1tbdqzZ4+effZZffDBB91u86677lJZWZlOnDihpqYmPf30093Gcj3vv/++vv/970uS7rvvPhmGocmTJ0uSxo8fr4qKCklSVlaWdu7cqRdffFGtra1avHixVq5cqf/+7//Wm2++qc8++0wPPvjgdbfzu9/9ThUVFero6NChQ4dUUlKiMWPGON9ftWqV3n77bedJM6An+N5fhfA5CxYsUENDg06fPq0DBw5o/Pjxki4esAsLC3X69Gnt27dP3/nOd5yf+da3vqXt27fr5MmT2rdvn6ZOnep87+oDb3Z2th577DEtWLBAZ86cUWlp6Q3jiYuL04YNG9TS0qLW1lb913/9l6SLZ6B++ctf6u9//7uam5tVWFio8PDwG67rtdde0/z58yVJQ4cOlWEY+rd/+zdJ0h133KETJ06oT58+zmS4YMECHTt2TCtXrtSiRYu0fv16rV69Wm1tbZ2S49X+53/+Rzt37lR7e7saGxu1Zs2aTglk06ZNKikp0YkTJ24YLwCge7/85S81evRo3XPPPRoxYoRGjRqlX/3qV873Y2NjFRERIYvFouzsbL388suKjIyUJL388ss6e/asYmNjlZWVpaysrG63N2jQIL333nt6++23NXToUH3zm9/U1q1bXYqlKzt27NADDzwg6WIx9sknn2js2LHO5R07djj7pqam6vDhw4qJidGvf/1rSRev7v/617/W4MGDtXPnTpfH7f7779f+/ftd7n+z1qxZo5aWFr3zzjv6x3/8R69vD77HoNG81ZKSkoyjR48at99+uyHJiI+PN+644w5j0aJFxueff26kp6cbQUFBxvPPP298+OGHhiQjJCTEsNvtxtNPP22EhoYaDz74oHH69GkjKSnJkGSsXLnSOHXqlHHfffcZffr0Mfr27WusXLnSePbZZ7uNJygoyNi7d6/x4osvGgMGDDD69u1rjBkzxpBkzJo1y7Db7UZCQoIxcOBAY8OGDcaqVatuuL5Zs2YZpaWlhiTjkUceMWpra42ioiLne3/84x8NSca4ceOM9vZ2Y8mSJUZYWJjRr18/Y9GiRcb58+eNjIwMo0+fPka/fv1cHtdNmzYZv/nNb655/dlnnzVWrlzp1s9o3LhxRn19/TWvb9++3WhpaTGOHz9u7Ny50xg3bpzpv080Go3mzVZXV2ekpaUZtbW1Rnp6uvP1733ve0ZdXZ0hXTxmnjt3zggODna+39zcbKSmphpBQUHG+fPnnflKunhc/uCDD2643czMTKO8vLzL924Uy/Xa+PHjjcrKSkOS8dZbbxnZ2dnOHPv+++8b//RP/2RIMrKysowjR450+uzKlSuNwsJCt8du8eLFxt69e42wsLBr3lu9erWxaNEit9aXlZXV5bjdd999Rr9+/Yz+/fsbeXl5xrFjx4yIiAjTf3dovadx5QZe1dHRob59++quu+5SSEiIjhw5osOHD0uSdu7cqbfeektfffWVVq9erREjRkiSRo8erUGDBmnJkiVqb2/X9u3b9ac//UmPPPKIc70lJSX661//KsMw9OWXX7ocz6hRozR06FD94he/0Llz5/Tll1/qL3/5iyTpscce04svvqi6ujqdPXtWTz/9tDIzM294u9iOHTv03e9+V3369NHYsWP129/+1nlF5eqzY1999ZUWLVqk8+fP64svvpAkffjhhyopKZFhGM7XujNr1izde++9euGFF1ze75uRm5urO+64QxaLRa+88oo2b96sO+64w6vbBIDeYOjQoTpy5Ihz+ciRIxo6dKhz+cSJE+ro6HAunzt3ToMGDdLXv/51hYaGqr6+3vnelf++HqvVqk8++eSmYunKhx9+qKSkJN1222265557tGrVKlmtVkVFRWnUqFH685//fMP4XIn5Sj/96U81c+ZMTZkyRefPn3frs+7661//qi+++EKff/65lixZolOnTun+++/36jbhWyhu4FWffPKJ5s2bp8WLF6ulpUWvv/66br/9dklSU1OTs9+5c+fUv39/BQcHa+jQoaqvr5dhGM73jxw5IovF4lx298B7idVq1ZEjRzolpUu6SiChoaGKiYm57voOHz6ss2fP6p577tH999+vP/3pT2psbFRSUtI1xc3x48evKcTc3Y+MjAz95je/UXp6utdvQduzZ48+++wznT9/XqtWrdJf/vIX5z3bAODPGhsbFR8f71z+xje+ocbGxm4/d/z4cbW3tysuLs75mtVq7fZz9fX11z15dDOxfP755/roo4/05JNPat++fWpvb9df//pXzZ8/X5988kmn/HFlrr3Ra9cza9Ys5eXlKS0tTQ6Hw+XPeYphGOrTp0+Pbxe9F8UNvO7111/X/fffr/j4eBmGoaVLl96wf2Njo6xWa6eD1Te+8Y1OB82rD7yuHojr6+v1jW98o8urMV0lkPb2djU3N99wnTt27ND06dMVFhamxsZG7dixQ1lZWRoyZIj27t17wxjdSSATJ05Ufn6+pk6d6pwSsyeRQAAEitdff12/+tWvFB0draioKP3Hf/yH/vCHP3T7ua+++kobN27U4sWL1b9/f915552aOXNmt5/705/+pNtvv11PPvmkwsLCNGjQII0aNeqWYtmxY4fmzJnjPMn2/vvvd1r2hEcffVTPP/+8HnroIdXV1V3zfkhIiPr27augoKBO/75ZVqtV9913n0JDQ9W3b1/9/Oc/V3R0tPMODECiuIGXJSUl6cEHH1RYWJjzMvJXX311w8/s3r1b586d04IFCxQSEqJx48Zp6tSpKioquu5nmpubXbplas+ePTp27JiWLFmiAQMGqG/fvrrvvvskXUwgTz31lIYNG6aBAwfq+eef1xtvvNHlVZ4rXUogly7zX0ogO3fu7HZfXfXggw9qzZo1+sEPfiCbzXbN+8HBwerbt6+Cg4M7/ftmRURE6Hvf+55zPY8++qjGjh2rt99++1Z2AwB8wnPPPae//e1v+vjjj1VVVaXy8nI999xzLn12zpw5ioiIUFNTk1avXq3XX3+929unP/vsMz300EOaOnWqmpqaZLfbnbOU3WwsO3bsUHh4uDM3Xb3sCc8995yioqJks9mcjw1YsWKF8/38/Hx98cUXevTRR/WrX/1KX3zxhX70ox/d9PYGDx6sFStW6OTJ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\n"},"metadata":{}}]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg survey for partial"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF","colab":{"base_uri":"https://localhost:8080/","height":741},"executionInfo":{"status":"ok","timestamp":1651810855851,"user_tz":-540,"elapsed":1684,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"804a766a-6321-41bc-dcb6-85eaab111963"},"outputs":[{"output_type":"stream","name":"stdout","text":["52\n","52\n","52\n","52\n","pkx : [0.03997647 2.0167238  2.73054922]\n","pkx : [-0.03767855  0.18363707  0.58602909  0.7268663   0.88782311  1.39081314]\n","\n","74\n","74\n","65\n","65\n","pkx : [-5.71029994 -5.09579043 -3.40588927 -1.25510598]\n","pkx : [-3.72574064 -3.42625567 -2.45292953 -1.18011842]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_true_open_idxth], short_max_tpg]\n","long_max_datas = [long_max_outg[long_true_open_idxth], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v3"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oVifICO4-Grk","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1651708709995,"user_tz":-540,"elapsed":12994,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d58c1e2f-2121-4d5b-8ca8-f6b255ccb77a"},"outputs":[{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.08211874961853027\n","short_obj.shape : (183, 5)\n","long_obj.shape : (92, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2087397575378418\n","en_ex_pairing elapsed time : 0.10305666923522949\n","short_obj.shape : (183, 5)\n","long_obj.shape : (92, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20801091194152832\n","en_ex_pairing elapsed time : 0.09827303886413574\n","short_obj.shape : (183, 5)\n","long_obj.shape : (92, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21625757217407227\n","en_ex_pairing elapsed time : 0.1836376190185547\n","short_obj.shape : (183, 5)\n","long_obj.shape : (92, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21225714683532715\n","en_ex_pairing elapsed time : 0.1327199935913086\n","short_obj.shape : (183, 5)\n","long_obj.shape : (92, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2113633155822754\n","en_ex_pairing elapsed time : 0.14110636711120605\n","short_obj.shape : (183, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2062058448791504\n","en_ex_pairing elapsed time : 0.14747834205627441\n","short_obj.shape : (183, 5)\n","long_obj.shape : (91, 5)\n","idep_plot elapsed time : 0.19914889335632324\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.15386390686035156\n","short_obj.shape : (183, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20255589485168457\n","en_ex_pairing elapsed time : 0.18609309196472168\n","short_obj.shape : (183, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2053663730621338\n","en_ex_pairing elapsed time : 0.18819427490234375\n","short_obj.shape : (182, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20166349411010742\n","en_ex_pairing elapsed time : 0.19433093070983887\n","short_obj.shape : (182, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20362114906311035\n","en_ex_pairing elapsed time : 0.2056262493133545\n","short_obj.shape : (181, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2042984962463379\n","en_ex_pairing elapsed time : 0.20847702026367188\n","short_obj.shape : (181, 5)\n","long_obj.shape : (91, 5)\n","idep_plot elapsed time : 0.19941377639770508\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.22302722930908203\n","short_obj.shape : (181, 5)\n","long_obj.shape : (91, 5)\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20234036445617676\n","en_ex_pairing elapsed time : 0.23124480247497559\n","short_obj.shape : (180, 5)\n","long_obj.shape : (91, 5)\n","idep_plot elapsed time : 0.19838428497314453\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.24717402458190918\n","short_obj.shape : (180, 5)\n","long_obj.shape : (91, 5)\n","idep_plot elapsed time : 0.19729161262512207\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 100681\n","np.sum(long_open_res == 1) : 99012\n","np.sum(short_open_res == 1) : 17353\n","np.sum(long_open_res == 1) : 18310\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n","np.sum(short_open_res == 1) : 2078\n","np.sum(long_open_res == 1) : 2018\n"]},{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.2515571117401123\n","short_obj.shape : (180, 5)\n","long_obj.shape : (91, 5)\n","idep_plot elapsed time : 0.202378511428833\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAABXQAAAILCAYAAABIJhRYAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdeXxM5/4H8E9mMllFFiG7CMIVhCCqLVLUtbSqrV4X7RVLcdXSVHupbmguF63bRVVRFNdSrbU/tPTWRTUlISIhKsuI7BLZ9+35/RE5NU1kkcmcmcnn/Xp9X6/MOWfOPGdOznxnnnnm+5gAECAiIiIiIiIiIiIivaeQuwFERERERERERERE1Djs0CUiIiIiIiIiIiIyEOzQJSIiIiIiIiIiIjIQ7NAlIiIiIiIiIiIiMhDs0CUiIiIiIiIiIiIyEOzQJSIiIiIiIiIiIjIQ7NClVmvZsmXYtWuX3M0gIiKiOqjVaowYMULuZhAREdEDCCHQpUsXrewrMDAQ586d08q+iFoDdugSacn27dsRHBwsdzOIiIiIiIiI9JanpyeEEFAqlXI3hchgsUOXSAsUCl5KRERERERERETU8tgLRUZv8eLFSEpKQl5eHm7cuIHhw4dL68zMzLBjxw7k5eUhKioK/fv3l9b96U9/wunTp5GdnY2oqCiMGzdOWrd9+3Z8/vnnOHbsGAoKCjBz5ky8+OKLWLx4MfLz83H06FGdHiMREZExMzMzw0cffYTk5GQkJyfjo48+gpmZGQAgICAAiYmJWLRoEdLT05GSkoJp06ZJ93VwcMDRo0eRm5uLixcvIjg4mD/pJCIi0pKxY8ciLi4OGRkZWLt2LUxMTAAAJiYmePvtt3Hr1i2kp6djx44daNu2LQDg7NmzAICcnBzk5+dj0KBB0v4++OADZGVlIT4+HqNHj9b9AREZEMFgGGt069ZN3L59W7i4uAgAwtPTU3Tu3FkAEMuWLRPFxcVizJgxQqFQiFWrVomQkBABQJiamoqYmBixdOlSoVKpxLBhw0ReXp7o1q2bACC2b98ucnJyxGOPPSZMTEyEubm52L59uwgODpb9mBkMBoPBMIZQq9VixIgRAoBYsWKFCAkJEe3btxeOjo7i/Pnz4v333xcAREBAgCgvLxcrVqwQpqamYsyYMaKwsFDY2dkJAGLv3r1i7969wtLSUvTo0UPcvn1bnDt3TvbjYzAYDAbD0EMIIX766Sdhb28vPDw8xG+//SZmzpwpAIjp06eLmJgY4eXlJaytrcWBAwfEzp07BVD9uVwIIZRKpbSvwMBAUVZWJl5++WWhUCjE3//+d5GcnCz7MTIYehyyN4DBaLHo0qWLSE9PFyNGjBCmpqYa65YtWyZOnTol3e7Ro4coKioSAMTgwYNFamqqMDExkdbv2bNHLFu2TADVHbo7duzQ2B87dBkMBoPB0F7c36EbGxsrxowZI63785//LNRqtQCqO3SLioo0PhSmp6eLRx55RCgUClFWViZ9IQtABAcHs0OXwWAwGAwthBBCjBo1Sro9d+5c8eOPPwoA4scffxRz586V1nXr1k2UlZUJpVL5wA7dmJgY6balpaUQQggnJyfZj5PB0MdgyQUyanFxcQgKCsLy5ctx584d7N27Fy4uLtL6tLQ06e+ioiJYWlpCqVTC1dUViYmJEEJI6xMSEuDm5ibdTkxM1M1BEBERtXKurq5ISEiQbickJMDV1VW6fffuXVRWVkq3i4qK0KZNG7Rv3x4qlUojZzN/ExERac/9efX+/FxX7lapVHBycnrgvu7/fF5cXAwAaNOmjbabTGQU2KFLRm/v3r0YMmSINJPmmjVrGrxPSkoKPDw8pPo/ANCxY0ckJydLt+/v7K3rNhEREWlHSkoKPD09pdsdO3ZESkpKg/fLyMhAeXk53N3dpWUeHh4t0kYiIqLW6P68en9+rit3l5eXIz09nZ+dibSAHbpk1Lp164Zhw4bBzMwMJSUlKC4uRlVVVYP3u3DhAoqKirB48WKYmpoiICAA48aNw759+x54n/T0dHTu3FmbzSciIiJUfzn7zjvvwNHREe3atcN7772H//znPw3er6qqCgcPHsTy5cthaWmJ7t27Y+rUqTpoMRERUevwj3/8A3Z2dnB3d8err76Kr7/+GkB17n7ttdfQqVMnWFtbY9WqVfj6669RWVmJjIwMVFZW8vMzUTOwQ5eMmrm5OVavXo3MzEykpaWhQ4cOWLp0aYP3Ky8vx7hx4zBmzBhkZmbi888/x9SpU/Hbb7898D5bt26Fj48PsrOzcejQIW0eBhERUav2z3/+E2FhYbh69SoiIyNx+fJl/POf/2zUfefPnw9bW1ukpaVh165d2Lt3L0pLS1u4xURERK3DkSNHcOnSJVy5cgXHjh3D1q1bAQDbtm3Drl27cPbsWajVapSUlGDBggUAqssprFy5EufPn0d2djYeeeQROQ+ByCCZoLqYLhERERGR0Vu9ejWcnZ0xbdo0uZtCRERERPRQOEKXiIiIiIxW9+7d0bt3bwCAv78/Zs6cyV/SEBEREZFBM5W7AURERERELcXGxgZ79+6Fq6sr0tPTsW7dOhw5ckTuZhERERERPTSWXCAiIiIiIiIiIiIyECy5QERERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLREREREREREREZCDYoUtERERERERERERkINihS0RERERERERERGQg2KFLRFCr1RgxYoTczSAt2b59O4KDgxvczsLCAkePHkVOTg7279+vg5YREbUuzK/GhfmViEh/MMcaF+bYpmOHrg5MnjwZt27dQkFBAQ4dOgR7e/sHbtunTx+EhYWhsLAQYWFh6NOnj8b61atXIzMzE5mZmVi9enVLN11vCSHQpUsXuZtBOmZvb4+DBw+ioKAAt27dwuTJk+vdvr7rpaFrrTV44YUX4OTkhHbt2mHixIn1btuU17Eaf/vb3yCEwMyZM6Vlb7zxBiIjI5GXl4f4+Hi88cYbzT4Oat2YY7WPObb1YX7VrpbKr5s2bcKNGzdQWVmJwMBAjXWBgYGoqKhAfn6+FAEBAVo5Hmq9mGO1i/m1dWKO1S5+hv0dO3Tvo1Qqtb5PHx8fbNq0CX/729/g5OSEoqIifP7553Vuq1KpcOTIEfznP/+B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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","val_list = np.arange(0.0, 0.5, 0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  # config_list_copy[0].tr_set.ep_gap = set_val \n","  config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.ei_k = set_val\n","  # config_list_copy[0].ep_set.ep_out_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    # enlist_rtc(res_df, config_, np_timeidx)\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","\n","  try:\n","    result.append(get_res_v5(res_df, open_info_df, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx = open_info_df.index.to_numpy()\n","  len_df = len(res_df)\n","  s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","  s_open_info_df = open_info_df[s_idx]\n","  s_open_idx = open_idx[s_idx]\n","\n","  open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","  side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v5(res_df, s_open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v13(res_df, len_df, config_list[0], high, low, s_open_idx, side_arr, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8LiKwfiJ4bvM"},"outputs":[],"source":["def plot_info_v6(gs, gs_idx, sample_len, tr, prcn, rc, bars_in, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    # title_str = \"prcn : {:.3f} rc : {:.3f}\\n len_pr : {} dpf : {:.3f}\\n wr : {:.3f} sr : {:.3f}\\n acc_pr : {:.3f} sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f} liqd : {:.3f}\\n acc_mdd : -{:.3f} sum_mdd : -{:.3f}\\n leverage {}\"\n","    # title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n rc : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n wave_bias : {:.3f}\\n bars_in : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    plt.title(title_str.format(tr, prcn, rc, bars_in, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"]},{"cell_type":"code","source":["def ffill_line(line_, idx_):\n","  len_line = len(line_)\n","  total_en_idx = np.zeros(len_line)\n","  total_en_idx[idx_] = 1\n","  idx_line_ = np.where(total_en_idx, line_, np.nan)\n","  idx_line = pd.Series(idx_line_).ffill().to_numpy()\n","\n","  return idx_line\n","\n","def get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj):\n","  \n","  short_op_idx = short_obj[-1].astype(int)\n","  short_en_idx = short_obj[2].astype(int)\n","  short_en_tp1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)   # en_idx 에 sync 된 open_idx 를 사용해야함\n","  short_en_out0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","  long_op_idx = long_obj[-1].astype(int)\n","  long_en_idx = long_obj[2].astype(int)\n","  long_en_tp1 = ffill_line(res_df['long_wave_1_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","  long_en_out0 = ffill_line(res_df['long_wave_0_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","\n","  bias_info_tick = config.tr_set.bias_info_tick\n","\n","  # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","  # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","  # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","  len_df_range = np.arange(len_df)\n","  last_idx = len_df - 1\n","  shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","  short_en_tp1_touch_idx = pd.Series(np.where(low <= short_en_tp1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[short_en_idx]  \n","  short_en_out0_touch_idx = pd.Series(np.where(high >= short_en_out0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[short_en_idx]\n","\n","  long_en_tp1_touch_idx = pd.Series(np.where(high >= long_en_tp1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[long_en_idx]\n","  long_en_out0_touch_idx = pd.Series(np.where(low <= long_en_out0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[long_en_idx]\n","\n","  short_true_bias_idx = short_en_tp1_touch_idx < short_en_out0_touch_idx  # true_bias 의 조건\n","  long_true_bias_idx = long_en_tp1_touch_idx < long_en_out0_touch_idx\n","\n","  short_false_bias_idx = short_en_tp1_touch_idx >= short_en_out0_touch_idx  # false_bias 의 조건\n","  long_false_bias_idx = long_en_tp1_touch_idx >= long_en_out0_touch_idx\n","\n","  # return short_true_bias_idx.ravel(), short_false_bias_idx.ravel(), long_true_bias_idx.ravel(), long_false_bias_idx.ravel()\n","  return short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1[short_en_idx], short_en_out0[short_en_idx], long_en_tp1[long_en_idx], long_en_out0[long_en_idx]\n","\n","  \n","def wave_bias(true_idx, false_idx):  # 정확하게 하려고, true & false 로 기준함\n","    true_sum = np.sum(true_idx)\n","    false_sum = np.sum(false_idx)\n","    return true_sum / (true_sum + false_sum)"],"metadata":{"id":"aFpEbTaECnGW"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_pr_v4(open_side, h, l, obj, tpout, lvrg, fee, p_ranges, p_qty_ratio, inversion=False):  # --> 여기서 사용하는 ex_p = ex_p\n","\n","    en_p = obj[0]\n","    # ex_p = obj[1]\n","    tp, out = np.split(tpout, 2, axis=1)\n","    len_p = len(p_ranges)\n","    en_ps, tps, outs, lvrgs, fees = [np.tile(arr_, (1, len_p)) for arr_ in [en_p, tp, out, lvrg, fee]]\n","\n","    np_obj = np.array(obj).T[0]\n","    assert len(np_obj.shape) == 2\n","\n","    # iin == iout 인 경우 분리\n","    en_idx = np_obj[:, 2]\n","    ex_idx = np_obj[:, 3]\n","    equal_idx = en_idx == ex_idx\n","\n","    min_low = np.full_like(en_p, np.nan)\n","    min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","    max_high = np.full_like(en_p, np.nan)\n","    max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","\n","    if open_side == \"SELL\":\n","        p_tps = en_ps - (en_ps - tps) * p_ranges\n","        # min_low = np.full_like(en_p, np.nan)\n","        # min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","        tp_idx = (np.tile(min_low, (1, len_p)) <= p_tps) * (np.tile(max_high, (1, len_p)) <= outs)  # entry_idx 포함해서 out touch 금지 (보수적 검증)\n","    else:\n","        p_tps = en_ps + (tps - en_ps) * p_ranges\n","        # max_high = np.full_like(en_p, np.nan)\n","        # max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","        tp_idx = (np.tile(max_high, (1, len_p)) >= p_tps) * (np.tile(min_low, (1, len_p)) >= outs)\n","\n","    ex_ps = outs.copy()\n","    ex_ps[tp_idx] = p_tps[tp_idx]\n","\n","    if open_side == \"SELL\":\n","        if not inversion:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","    else:\n","        if not inversion:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","\n","    return pr.reshape(-1, 1), liqd"],"metadata":{"id":"642Dt6urKfvF"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v13(res_df, len_df, config, high, low, open_idx, side_arr, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5), fontsize=15, signi=False):\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        fig = plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","    \n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","      sample_len = int(len_df * sample_ratio)\n","    else:\n","      sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","    point1_arr, valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res    \n","    assert len(valid_openi_arr) != 0, \"assert len(valid_openi_arr) != 0\"    \n","    short_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.SELL)[0]  # valid_openi_arr 에 대한 idx, # side_arr,\n","    long_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.BUY)[0]\n","\n","    valid_open_idx = open_idx[valid_openi_arr].reshape(-1, 1)\n","\n","    short_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[short_valid_openi_idx]\n","    long_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[long_valid_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_point1_arr, long_point1_arr = [point1_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)    \n","    # print(\"elapsed time :\", time.time() - start_0)\n","\n","    short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1, short_en_out0, long_en_tp1, long_en_out0 = \\\n","    get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj)\n","\n","    len_short, len_long = len(short_valid_openi_idx), len(long_valid_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","      # start_0 = time.time()      \n","      if len_short == 0:\n","        short_pr = []\n","        gs_idx += 1\n","      else:\n","        short_tr = short_tr_arr.mean()\n","        short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","        short_cum_pr = np.cumprod(short_total_pr)\n","        # short_liqd = liquidation_v2(OrderSide.SELL, h, short_obj[:4], short_lvrg_arr, short_fee_arr)\n","        short_prcn, short_rc = precision(short_pr, short_true_bias_idx), wave_bias(short_true_bias_idx, short_false_bias_idx)\n","        short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","        if signi:\n","          short_idep_res_obj = (short_prcn, short_rc) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, short_tr, short_prcn, short_rc, short_trade_ticks, short_pr, short_total_pr, short_cum_pr, short_liqd, short_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in short plot_data :\", e)\n","\n","    try:\n","      # start_0 = time.time()   \n","      if len_long == 0:\n","        long_pr = []\n","        gs_idx += 1\n","      else:\n","        long_tr = long_tr_arr.mean()\n","        long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","        long_cum_pr = np.cumprod(long_total_pr)\n","        # long_liqd = liquidation_v2(OrderSide.BUY, l, long_obj[:4], long_lvrg_arr, long_fee_arr)\n","        long_prcn, long_rc = precision(long_pr, long_true_bias_idx), wave_bias(long_true_bias_idx, long_false_bias_idx)\n","        long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","        if signi:\n","          long_idep_res_obj = (long_prcn, long_rc) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, long_tr, long_prcn, long_rc, long_trade_ticks, long_pr, long_total_pr, long_cum_pr, long_liqd, long_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in long plot_data :\", e)\n","\n","    \n","    try:\n","      # start_0 = time.time()\n","      if len_short * len_long == 0:\n","        both_pr = []\n","        gs_idx += 1\n","      else:\n","        both_tr = (short_tr + long_tr) / 2\n","        both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","        both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","        both_cum_pr = np.cumprod(both_total_pr)\n","        both_liqd = min(short_liqd, long_liqd)\n","        both_true_bias_idx = np.vstack((short_true_bias_idx, long_true_bias_idx))  # vstack for 2d arr\n","        both_false_bias_idx = np.vstack((short_false_bias_idx, long_false_bias_idx))\n","        both_prcn, both_rc = precision(both_pr, both_true_bias_idx), wave_bias(both_true_bias_idx, both_false_bias_idx)\n","        both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","        if signi:\n","          both_idep_res_obj = (both_prcn, both_rc) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, both_tr, both_prcn, both_rc, both_trade_ticks, both_pr, both_total_pr, both_cum_pr, both_liqd, lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","      if len_short * len_long > 0:\n","        for obj, cum_pr in zip([short_obj, long_obj, both_obj], [short_cum_pr, long_cum_pr, both_cum_pr]):\n","          try:\n","            # start_0 = time.time()\n","            gs_idx = frq_dev_plot_v3(gs, gs_idx, len_df, sample_len, obj[-2], cum_pr[-1], fontsize)\n","            # print(\"elapsed time :\", time.time() - start_0)          \n","          except Exception as e:\n","            gs_idx += 1\n","            print(\"error in frq_dev_plot_v3 :\", e)\n","        plt.show()\n","        plt.close()\n","\n","      return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_true_bias_idx, short_false_bias_idx, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_true_bias_idx, long_false_bias_idx, long_point1_arr, long_en_tp1, long_en_out0\n","        \n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v5(res_df, open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs):  # 이미 충분히 줄여놓은 idx 임\n","    side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","    id_idx_arr = id_idx_arr.astype(int)\n","\n","    ep_out, ep_loc_point2, lvrg_set = funcs\n","\n","    point1_list, valid_openi_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(8)]\n","    len_df = len(res_df)\n","    len_open_idx = len(open_idx)\n","    i, open_i = 0, -1  # i for total_res_df indexing\n","\n","    while 1:\n","        # ------------ entry phase ------------ #\n","        open_i += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i >= len_open_idx:\n","            break\n","\n","        # ------ ep_loc ------ #\n","        op_idx = open_idx[open_i]  # open_i 는 i 와 별개로 운영\n","        if op_idx < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ dynamic data by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        id_idx = id_idx_arr[open_i]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        open_side = side_arr[open_i]\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()  # => eptpout arr_list 만들어서 꺼내 사용하면 될 것\n","        point_idxgap_arr = res_df['{}_point_idxgap_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        ep_arr = res_df['{}_ep_{}'.format(side_pos, selection_id)].to_numpy()  # Todo - while loop 내에서 to_numpy() 반복하느니, pd_indexing 이 낫지 않을까\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","        # bias_info_arr = res_df['{}_bias_info_{}'.format(side_pos, selection_id)].to_numpy()  # ex. rolling(entry ~ end)'s high\n","        # bias_thresh_arr = res_df['{}_bias_thresh_{}'.format(side_pos, selection_id)].to_numpy()  # ex. close + dc_T20 * 0.5\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ ei_k & point2 ------ #\n","        i = op_idx + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        point_idxgap = point_idxgap_arr[op_idx]\n","        if np.isnan(point_idxgap):\n","            continue\n","        else:\n","            # ------ allow point2 only next to point1 ------ #\n","            open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","            tp_j = int(op_idx - point_idxgap)\n","            if np.sum(open_arr[tp_j:op_idx]) != 0:\n","                continue\n","\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side,\n","                                                                                 [*ohlc_list, ep_arr], ep_out, ep_loc_point2)\n","        i = exec_j\n","\n","        if not entry_done:\n","            continue\n","\n","        # ------ leverage ------ #\n","        out = out_arr[out_j]  # lvrg_set use out on out_j\n","        leverage = lvrg_set(res_df, config, open_side, en_p, out, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","        if leverage is None:\n","            continue\n","\n","        exit_done, cross_on = 0, 0\n","        # ------ check tpout_onexec ------ #\n","        # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","        if config.ep_set.entry_type == \"LIMIT\":\n","            if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                tp_j = exec_j\n","            if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                out_j = exec_j\n","\n","        while 1:\n","            # ------------ exit phase ------------ #\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ out ------------ #  # out 우선 (보수적 검증)\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_market_out_exec_v2(config, res_df, np_timeidx, open_i, i, len_df, fee, open_side, cross_on, exit_done)\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out != \"None\":\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_out(config, open_i, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","              if not exit_done:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                           [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                point1_list.append(tp_j)\n","                valid_openi_list.append(open_i)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                # bias_list.append([bias_info_arr[exec_j], bias_thresh_arr[exec_j]])  # backtest 에서만 가능한 future_data 사용\n","                # bias_list.append([bias_info_arr[exec_j], tp_arr[tp_j]])  # bias_info 는 entry_idx 부터 & tp = bias_thresh\n","                tr_list.append(tr_arr[op_idx])\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(point1_list), np.array(valid_openi_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side, np_datas, ep_out, ep_loc_point2):\n","    o, h, l, c, ep_arr = np_datas\n","    ep_j = op_idx\n","    # tp_j = op_idx\n","    out_j = op_idx\n","\n","    selection_id = config.selection_id    \n","    allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ ei_k ------ # - limit 사용하면 default 로 ei_k 가 존재해야함\n","            if ep_out(res_df, config, op_idx, e_j, tp_j, [h, l], open_side):\n","              break\n","\n","            # ------ point2 ------ #\n","            if not allow_ep_in:\n","                allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","                if allow_ep_in:\n","                  if config.ep_set.point2.entry_type == \"LIMIT\":\n","                    ep_j = e_j\n","                    # print(\"e_j in point2 :\", e_j)\n","                    continue\n","\n","            # ------ check ep_exec ------ #\n","            if allow_ep_in:\n","              if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","                entry_done = 1\n","                ep = c[e_j]\n","                break\n","              else:\n","                if open_side == OrderSide.SELL:\n","                    if h[e_j] >= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                            ep = o[e_j]\n","                        break\n","                else:\n","                    if l[e_j] <= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] <= ep_arr[ep_j]:\n","                            ep = o[e_j]\n","                        break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = c[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, j, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        try:\n","            if config.tr_set.decay_gap != \"None\":\n","                decay_share = (j - open_i) // config.tp_set.decay_term\n","                decay_remain = (j - open_i) % config.tp_set.decay_term\n","                if j != open_i and decay_remain == 0:\n","                    if open_side == OrderSide.SELL:\n","                        tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","                    else:\n","                        tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        except:\n","            pass\n","\n","        if open_side == OrderSide.SELL:\n","            if l[j] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if l[j] <= tp_arr[j] <= h[j]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[j]:\n","                        tp = o[j]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[j]\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if h[j] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    if o[j] > tp_arr[j]:\n","                        tp = o[j]\n","                    else:\n","                        tp = tp_arr[j]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if o[j] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_market_out_exec_v2(config, res_df, np_timeidx, open_i, j, len_df, fee, open_side, cross_on, exit_done):    \n","    close = res_df['close'].to_numpy()\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[j] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and j != open_i:\n","            exit_done = 1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[j - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[j] < 50 - config.loc_set.point.osc_band):\n","                exit_done = 1\n","        else:\n","            if (rsi_T[j - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[j] > 50 + config.loc_set.point.osc_band):\n","                exit_done = 1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[j] < ha_c[j]):# & (ha_o[j] == ha_l[j]):   # 양봉 출현\n","    #           exit_done = 1\n","    #     else:\n","    #       if (ha_o[j] > ha_c[j]):# & (ha_o[j] == ha_h[j]):  # 음봉 출현\n","    #           exit_done = 1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[j] < bb_lower_5T[j] < close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] > bb_upper_5T[j] > close[j - 1]:\n","                exit_done = 1\n","        else:\n","            if close[j] > bb_upper_5T[j] > close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] < bb_lower_5T[j] < close[j - 1]:\n","                exit_done = 1\n","\n","    if exit_done:\n","        ex_p = close[j]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_out(config, open_i, j, out_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if h[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if l[j] <= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if c[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if c[j] <= out_arr[out_j]:  # check out only once\n","                ex_p = c[j]\n","                exit_done = 1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = c[j]\n","\n","        if open_side == OrderSide.SELL:\n","            if o[j] >= out_arr[out_j]:\n","                ex_p = o[j]\n","        else:\n","            if o[j] <= out_arr[out_j]:\n","                ex_p = o[j]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_df\n","del np_plot_params"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rMIwv1Nr1ojX"},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","front_plot = 3    # 0 : whole, 1 : open, 2 : ep_tick, 3 : tp_tick, 4 : bias_tick\n","bias_plot = 0     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","pr_descend = 0    # 1 : 큰 pr 부터, 0 : 작은 pr 부터\n","position = 1      # -1 : short 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 150 #  100 20\n","# post_plotsize = 60\n","post_plotsize = config.tr_set.bias_info_tick\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_point1_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_en_tp1, short_en_out0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_point1_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_en_tp1, long_en_out0]\n","pr, obj, [point1_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, false_bias_arr, en_tp1, en_out0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","# ------------------ data chunknize ------------------ #\n","np_df = res_df.to_numpy()\n","\n","# left_end_idx = obj[2] - prev_plotsize  # left_margin 기준 - entry_idx\n","left_end_idx = obj[4] - prev_plotsize  # left_margin 기준 - open_idx\n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, point1_arr, lvrg_arr, fee_arr, tpout_arr, en_tp1, en_out0))[invalid_left_end:]  # all arr should have same dimension\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = false_bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":26,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1130,"status":"ok","timestamp":1651994450983,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"238668e7-7e8b-43d9-bd5a-ddec242dee9a","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["s_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","data_window_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_tf1 = 'T'\n","wave_period1 = 5\n","wave_tf2 = '15T'\n","wave_period2 = 5\n","\n","step_col_list.append([['dc_base_{}{}'.format(wave_tf1, wave_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_base_{}{}'.format(wave_tf2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 1\n","dc_tf2 = '15T'\n","dc_period2 = 1\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner #ffeb3b\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 60\n","\n","step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf1, wave_period1)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf1, wave_period1)], 1, '#00ff00', 7, '*'])\n","\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf2, wave_period2)], 1, '#e91e63', 10, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf2, wave_period2)], 1, '#2962ff', 10, '*'])\n","  \n","stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_tf1, wave_period1)], 1, '#ff00ff', 5, 'o'])\n","stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_tf1, wave_period1)], 1, '#00ff00', 5, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_{}{}'.format(wave_tf1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['cu_wrr_32_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['co_wrr_32_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_tf1, wave_period1)])\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_col_arr = strcol_tonumb(res_df, data_window_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_col_info\": data_window_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close'])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_tf2, wave_period2), 'wave_high_fill_{}{}'.format(wave_tf2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"OCLMABZT1ojb"},"outputs":[],"source":["_ = [plot_check_v6(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v6(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, lvrg, fee, tp_line, out_line, en_tp1, en_out0 = params\n","\n","    # if exit_idx - open_idx < 50:  # temporary\n","    #   break\n","\n","    ax = fig.add_subplot(gs[gs_idx])\n","\n","    # ------------ add_col section ------------ #\n","    a_data = data[int(iin):int(iout + 1)]\n","    # a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v5(config, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                    front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline_v3 :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *data[int(open_idx), params_[0]]) for params_ in col_idx_dict['data_window_col_info']]  # * for unsupported format for arr\n","    ps_msg_expand = pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    plt.title(ps_msg_expand)\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v5(config, en_p, ex_p, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  point1_tick = open_tick - int(open_idx - point1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if front_plot == 1:\n","    x_max = open_tick + 20\n","  elif front_plot == 2:\n","    x_max = entry_tick + 20 \n","  elif front_plot == 3:\n","    x_max = exit_tick + 20\n","  elif front_plot == 4:\n","    x_max = bias_info_tick + 20\n","\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  plt.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ wave_line ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  plt.axhline(en_tp1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_tp1, ' wave_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  plt.axhline(en_out0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_out0, ' wave_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  point1_ymax, open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [point1_tick, open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(point1_tick, 0, point1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff7722')\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","VdukVo5-Suzj","Bw5JibDKSuzj","Pe0QpnORSuzk","E0n53hflJbnp","MlFkpO1MSuzl","t1E_eAyPSuzm","nUs4fjVHSuzl","L7l5CTJfSuzn","x_XGJqBi8Jex","MSUY4nnku3s9","epgS5Dksu-HX","Iy76iO7gztne","x2yj2SwAXDLp","EOXQbXixiQcK","xpyP5t8Ht_pE","MuD_2vY7TI_8","mScdfR9hmjVu","xivLUsSGC4VF","sZAYhcdoXnm4","zmYbP-Gc1ojs","5rdQZm_71ojv","tApzvz_gK9lR","OJqkmkpsLCYC"],"name":"stem5_4_vec_backi2(0506_waverange_v15).ipynb","toc_visible":true,"provenance":[],"machine_shape":"hm","authorship_tag":"ABX9TyPso/yqFEV4NGVwtWvruZz/"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}