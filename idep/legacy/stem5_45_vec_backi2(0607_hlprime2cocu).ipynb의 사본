{"cells":[{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"6rmQpzEGXfCw","outputId":"2e94294b-2920-40aa-a850-5c61cc8eeb2a"},"outputs":[{"name":"stdout","output_type":"stream","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"9qGt60DKTZmf"},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df, dc_period=10)\n","    # df = dc_line_v4(df, df, dc_period=20)\n","    # df = dc_line_v4(df, df, dc_period=30)\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 100\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    \n","    # df = bb_line_v3(df, df_15T, 60)\n","    \n","    df = bb_line_v3(df, df, bb_period)\n","    df = bb_level_v2(df, 'T', bb_period)\n","    print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":620},"executionInfo":{"elapsed":2266,"status":"ok","timestamp":1655116351242,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"odqVwQHpYo1M","outputId":"d97c6c32-c922-4667-dd39-8ba2e5f50a0f"},"outputs":[{"name":"stdout","output_type":"stream","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n","bb phase done\n"]},{"data":{"text/html":["\n","  <div id=\"df-3131c86c-68b3-47d4-aee5-73a5acd716f2\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>dc_upper_T30</th>\n","      <th>dc_lower_T30</th>\n","      <th>dc_base_T30</th>\n","      <th>bb_upper_T100</th>\n","      <th>bb_lower_T100</th>\n","      <th>bb_base_T100</th>\n","      <th>bb_upper2_T100</th>\n","      <th>bb_lower2_T100</th>\n","      <th>bb_upper3_T100</th>\n","      <th>bb_lower3_T100</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2837.237331</td>\n","      <td>2799.074869</td>\n","      <td>2818.1561</td>\n","      <td>2856.318561</td>\n","      <td>2779.993639</td>\n","      <td>2875.399792</td>\n","      <td>2760.912408</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2836.921344</td>\n","      <td>2798.723056</td>\n","      <td>2817.8222</td>\n","      <td>2856.020487</td>\n","      <td>2779.623913</td>\n","      <td>2875.119631</td>\n","      <td>2760.524769</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2836.581771</td>\n","      <td>2798.433429</td>\n","      <td>2817.5076</td>\n","      <td>2855.655941</td>\n","      <td>2779.359259</td>\n","      <td>2874.730112</td>\n","      <td>2760.285088</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2836.200854</td>\n","      <td>2798.150546</td>\n","      <td>2817.1757</td>\n","      <td>2855.226008</td>\n","      <td>2779.125392</td>\n","      <td>2874.251162</td>\n","      <td>2760.100238</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2835.819768</td>\n","      <td>2797.817632</td>\n","      <td>2816.8187</td>\n","      <td>2854.820835</td>\n","      <td>2778.816565</td>\n","      <td>2873.821903</td>\n","      <td>2759.815497</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-3131c86c-68b3-47d4-aee5-73a5acd716f2')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-3131c86c-68b3-47d4-aee5-73a5acd716f2 button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-3131c86c-68b3-47d4-aee5-73a5acd716f2');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "],"text/plain":["                         dc_upper_T30  dc_lower_T30  dc_base_T30  bb_upper_T100  bb_lower_T100  bb_base_T100  bb_upper2_T100  bb_lower2_T100  bb_upper3_T100  bb_lower3_T100\n","index                                                                                                                                                                       \n","2022-04-27 08:41:59.999       2806.93       2761.27       2784.1    2837.237331    2799.074869     2818.1561     2856.318561     2779.993639     2875.399792     2760.912408\n","2022-04-27 08:42:59.999       2806.93       2761.27       2784.1    2836.921344    2798.723056     2817.8222     2856.020487     2779.623913     2875.119631     2760.524769\n","2022-04-27 08:43:59.999       2806.93       2761.27       2784.1    2836.581771    2798.433429     2817.5076     2855.655941     2779.359259     2874.730112     2760.285088\n","2022-04-27 08:44:59.999       2806.93       2761.27       2784.1    2836.200854    2798.150546     2817.1757     2855.226008     2779.125392     2874.251162     2760.100238\n","2022-04-27 08:45:59.999       2806.93       2761.27       2784.1    2835.819768    2797.817632     2816.8187     2854.820835     2778.816565     2873.821903     2759.815497"]},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gOQxwYqK0jCS"},"outputs":[],"source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmiB5VU5DN6B"},"outputs":[],"source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2274,"status":"ok","timestamp":1655116365309,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"ce293f99-8bb2-4281-a75d-52674fe761f6"},"outputs":[{"name":"stdout","output_type":"stream","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6093,"status":"ok","timestamp":1655649749469,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"7FPBG5Qqg2jB","outputId":"b4dbbe97-4312-4d7c-804a-7833cb2bb642"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 5.196773290634155\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if '3T' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gWOmz--hNaSR"},"outputs":[],"source":["def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    # valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])   # 이곳은 cross_idx 가 아님, 단지 chunknized 된 filled_idx 일뿐\n","    # valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)  # --> Todo, unavailable : not cross_idx\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    # ------------------------------------ #\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #   cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_ratio_v4_2(res_df, wave_itv, wave_period, roll_hl_cnt=3):\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    roll_highs = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    cu_wave1_range = roll_highs[-1] - roll_lows[-2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_highs[-1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_highs[-2] - roll_lows[-1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_lows[-1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_roll_wave_data_v2(res_df, valid_prime_idx, roll_idx_arr, data_col, roll_hl_cnt):\n","\n","    data = res_df[data_col].to_numpy()\n","    len_res_df = len(res_df)\n","    roll_cols = [data_col + '_-{}'.format(cnt_ + 1) for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    roll_data = pd.DataFrame(index=res_df.index, data=np.full((len_res_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    res_df[roll_cols] = roll_data.ffill()\n","\n","    return res_df\n","\n","def roll_wave_hl_idx_v5(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_co_idx_arr = np.array([valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_cu_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    \n","    assert len(roll_co_idx_arr) > 0 and len(roll_cu_idx_arr) > 0\n","\n","    return valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr\n","    \n","def to_lower_tf_v3(ltf_df, htf_df, cols, backing_i=1, show_info=False):\n","    ltf_itv = pd.infer_freq(ltf_df.index)\n","    assert ltf_itv == 'T', \"currently only -> 'T' allowed..\"\n","    # assert type(column[0]) in [int, np.int64], \"column value should be integer\"\n","\n","    # cols = htf_df.columns[column]  # to_lower_tf_v1 의 int col 반영\n","\n","    if show_info:\n","        print(\"backing_i :\", backing_i)\n","\n","    renamed_last_index = htf_df.rename(index={htf_df.index[-1]: ltf_df.index[-1]}, inplace=False).iloc[[-1]]\n","    if htf_df.index[-1] != renamed_last_index.index[-1]:  # cannot reindex a non-unique index with a method or limit 방지\n","        htf_df = htf_df.append(renamed_last_index)\n","\n","    downsampled_df = htf_df[cols].shift(backing_i).resample(ltf_itv).ffill()\n","\n","    if len(downsampled_df) > len(ltf_df):\n","        downsampled_df = downsampled_df.iloc[-len(ltf_df):]\n","\n","    downsampled_df.index = ltf_df.index[-len(downsampled_df):]\n","    # assert len(ltf_df) <= len(downsampled_df), \"for join method, assert len(ltf_df) <= len(downsampled_df)\"\n","\n","    # ------ check last row's validity ------ #\n","    assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0, \"assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0\"\n","\n","    return downsampled_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"euA18M1uyc3s"},"outputs":[],"source":["\n","def wave_range_cci_v3(t_df, wave_period):\n","\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    band_width = 100\n","    upper_band = band_width\n","    lower_band = -band_width\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)\n","    # cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #   cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v5(cu_idx, co_idx, len_df, len_df_range)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ get post_idx ------ #\n","    paired_cu_post_idx = high_post_terms[:, 1]   # Todo, 여기는 cross_idx (위에서 vstack 으로 cross_idx 입력함)\n","    paired_co_post_idx = low_post_terms[:, 1]\n","    \n","    cu_post_idx = np.full(len_df, np.nan)  # --> Todo, unavailable : not cross_idx\n","    co_post_idx = np.full(len_df, np.nan)\n","\n","    cu_post_idx[paired_cu_post_idx] = paired_cu_post_idx\n","    co_post_idx[paired_co_post_idx] = paired_co_post_idx\n","\n","    cu_post_fill_idx = fill_arr(cu_post_idx)\n","    co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_cu_post_idx] = wave_highs\n","    wave_low_[paired_co_post_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_cu_post_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_post_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    # ------ term cnt ------ #\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_post_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_co_post_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    # b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    # b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    # wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    # wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","    #\n","    # high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    # low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","    t_df['wave_update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool  # temporary, for plot_check\n","    t_df['wave_update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool   # * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool   # * ~update_high_co_bool    \n","    \n","    t_df['wave_co_post_idx_{}{}'.format(itv, wave_period)] = co_post_idx    # paired_\n","    t_df['wave_cu_post_idx_{}{}'.format(itv, wave_period)] = cu_post_idx    # paired_\n","    t_df['wave_co_post_idx_fill_{}{}'.format(itv, wave_period)] = co_post_fill_idx\n","    t_df['wave_cu_post_idx_fill_{}{}'.format(itv, wave_period)] = cu_post_fill_idx\n","\n","    # Todo, idx 저장은 sync. 가 맞는 tf_df 에 대하여 적용하여야함\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력 = 뜻 : high_term's prime co_idx (high_prime_idx = wave_high 를 만들기 위한 가장 앞단의 co_idx)\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","    # ------ for plot_checking ------ #\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","\n","    return t_df"]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","metadata":{"id":"O1uu9vQnY5dn"},"source":["##### plot_check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 370940\n","# i = 185369\n","i = 186060\n","\n","plot_size = 300 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PgaNnempXRd_"},"outputs":[],"source":["wave_itv1, wave_period1 = 'T', 20\n","roll_hl_cnt = 3\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)  # to_htf 는 ohlc, 4개의 col 만 존재 (현재까지)\n","    htf_df = wave_range_cci_v3(htf_df, wave_period1)\n","    \n","    cols = list(htf_df.columns)  # 그냥 다 넣어버리기 (추후 혼란 방지)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])  # wrr 은 4개의 cols\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  t_df = wave_range_cci_v3(t_df, wave_period1)\n","  # t_df = wave_range_cci_v2(t_df, wave_period1)\n","\n","  valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","  t_df = wave_range_ratio_v4_2(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":863},"executionInfo":{"elapsed":3595,"status":"ok","timestamp":1654600248530,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"-Dr_tTk9csFm","outputId":"d0a34398-34d4-4d56-add2-e66215f316f9"},"outputs":[{"data":{"image/png":"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\n","text/plain":["<Figure size 1080x1080 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","\n","wave_cu_prime_idx_ = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_ = t_df['wave_co_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_prime_idx_fill_ = t_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_fill_ = t_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_post_idx_ = t_df['wave_cu_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_ = t_df['wave_co_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_post_idx_fill_ = t_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_fill_ = t_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# ------ data check in gs[0] ------ #\n","plt.axvline(wave_cu_post_idx_fill_[230], color='r')\n","plt.axvline(wave_cu_prime_idx_fill_[230])\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"c2yVTn1tnxMn"},"source":["###### data_window"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":652,"status":"ok","timestamp":1654597305453,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"0DgdFydfB1f-","outputId":"a9078354-9c57-479e-cba0-052dbedd954f"},"outputs":[{"name":"stdout","output_type":"stream","text":["169.0\n","185.0\n"]}],"source":["print(wave_cu_post_idx_fill_[210])\n","print(wave_cu_prime_idx_fill_[210])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I_ZNM9n7hFOf"},"outputs":[],"source":["idx_ = 990\n","\n","# t_df[roll_cols].iloc[idx_]\n","t_df.iloc[:, -4:].iloc[idx_]\n","\n","# roll_cnt = 3\n","# valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_v4(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_cnt)\n","# roll_high = get_roll_wave_data(valid_high_prime_idx, roll_prev_high_idx_arr, len_df, wave_high_fill_, roll_cnt)\n","# roll_low = get_roll_wave_data(valid_low_prime_idx, roll_prev_low_idx_arr, len_df, wave_low_fill_, roll_cnt)\n","\n","# print(roll_high[idx_])\n","# print(roll_low[idx_])\n","# roll_prev_high_idx_arr\n","# valid_high_prime_idx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zj_d5wsfDzf_"},"outputs":[],"source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Z-EokTzIqb-T"},"outputs":[],"source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"TqMmmSAGuChM"},"outputs":[],"source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"50ucQUF-Jixd"},"outputs":[],"source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"]},{"cell_type":"markdown","metadata":{"id":"Q_1wJTcRYpm8"},"source":["##### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVFfP9VcDG2_"},"outputs":[],"source":["\n","def get_roll_wave_data(valid_prime_idx, roll_idx_arr, len_df, data, roll_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_idx_v4(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array(\n","        [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","    \n","def wave_range_ratio_v4_1(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    cu_wave1_range = roll_high_[:, -1] - roll_low_[:, -2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_high_[:, -1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_high_[:, -2] - roll_low_[:, -1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_low_[:, -1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def wave_range_ratio_v4(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])\n","    valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #         cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_dcbase_v11_3(res_df, config, itv='T', over_period=2):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    # b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    over_base = close > dc_base_\n","    prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","    prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = prev_over_base & ~over_base\n","    co_bool = prev_under_base & over_base\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","def wave_range_v11_2(res_df, config, itv='T'):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"841i4oo2abh-"},"outputs":[],"source":["\n","\n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","\n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_, _, _ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","    for col_, itv_ in zip(future_cols, itv_list):\n","        back_col_ = 'b1_' + col_\n","        res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","    return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1) \n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)   \n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","    \n","    # ============ modules ============ #  \n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","    wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    \n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    wave_high_[paired_cu_idx] = wave_highs\n","    wave_low_[paired_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","    \n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    cu_prime_idx = wave_high_prime_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","    co_prime_idx = wave_low_prime_idx\n","    co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","    # ============ enlist to df_cols ============ #       \n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ # \n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","    # ------ for first_high ------ # \n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","      \n","    if itv != 'T':\n","      assert ltf_df is not None, \"assert ltf_df is not None\"\n","      join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","      ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","      try:\n","        ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","      except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","    else:\n","      ltf_df = t_df    \n","\n","    return ltf_df\n"]},{"cell_type":"markdown","metadata":{"id":"02DcTVB2cYuR"},"source":["##### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Go7ARIUhfC1g"},"outputs":[],"source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pgA8QqyXZ66o"},"outputs":[],"source":["t_df[roll_cols].tail(100)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wF7fKJ3mOhaf"},"outputs":[],"source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3vHLGont-BFe"},"outputs":[],"source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Mh3w2s-j34Zs"},"outputs":[],"source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1651799326382,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eQ06-kWq4m6F","outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"outputs":[{"name":"stdout","output_type":"stream","text":["11\n","11\n"]}],"source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SUFmr9Z_kcCN"},"outputs":[],"source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_3pOQtt2ttfk"},"outputs":[],"source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1651756811396,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"kKaD1fK3WPRP","outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"outputs":[{"data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"execution_count":79,"metadata":{},"output_type":"execute_result"}],"source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YoZpr7lDn7z-"},"outputs":[],"source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","metadata":{"id":"RZJ6uIA_VcJs"},"source":["##### instant."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLWAP1Cl2Hvu"},"outputs":[],"source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"H_zPYIshbZgP"},"outputs":[],"source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"o3IUBc59VR5D"},"outputs":[],"source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u3yFd8Dcok5m"},"outputs":[],"source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JWj02LLGbnji"},"outputs":[],"source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SeJan_0t95yL"},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CB2yZdQ95Cdg"},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","      \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","\n","    # if config.tr_set.check_hlm == 2:  # 동일한 param 으로도 p2_hlm 시도를 충분히 할 수 있음 (csdbox 와 같은)\n","    #   assert not (wave_itv1 == wave_itv2 and wave_period1 == wave_period2)\n","\n","    roll_hl_cnt = 3\n","\n","    roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    \n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    res_df['short_tp_1_{}'.format(selection_id)] = wave_low_fill1_      # wave_low_fill_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = roll_highs1[-1]   # roll_high_[:, -2] wave_high_fill_\n","    res_df['long_tp_1_{}'.format(selection_id)] = wave_high_fill1_      # wave_high_fill_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = roll_lows1[-1]     # roll_low_[:, -2]  wave_low_fill_\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = wave_low_fill1_    # roll_low_[:, -2]\n","\n","    res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_out_0_{}'.format(selection_id)] = roll_highs2[-1]  # roll_high_[:, -2]\n","    res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_out_0_{}'.format(selection_id)] = roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill2_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill2_    # roll_low_[:, -2]\n","\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #     \n","    short_open_res1 = np.ones(len_df) #.astype(object)\n","    long_open_res1 = np.ones(len_df)  #.astype(object)\n","    short_open_res2 = np.ones(len_df) #.astype(object)\n","    long_open_res2 = np.ones(len_df)  #.astype(object)\n","    \n","    # ------------ wave_point ------------ #\n","    notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    short_open_res2 *= res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_cu\n","    long_open_res2 *= res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_co\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_point\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","    \n","    # ------ reject update_hl ------ #\n","    notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co\n","\n","    # short_open_res1 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # long_open_res1 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # short_open_res2 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # long_open_res2 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    if show_detail:\n","      sys_log.warning(\"reject update_hl\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","\n","    # ------ tf_entry ------ #    \n","    tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    if wave_itv1 != 'T':      \n","      short_open_res1 *= np_timeidx % tf_entry == (tf_entry - 1)\n","      long_open_res1 *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"tf_entry\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","    \n","    if wave_itv2 != 'T':      \n","      short_open_res2 *= np_timeidx % tf_entry == (tf_entry - 1)\n","      long_open_res2 *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"tf_entry\")\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    # ------ wave_mm ------ #\n","    wave_high_terms_cnt_fill1_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_terms_cnt_fill1_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    short_open_res1 *= (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","    long_open_res1 *= (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","\n","    wave_high_terms_cnt_fill2_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_terms_cnt_fill2_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    short_open_res2 *= (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","    long_open_res2 *= (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_mm\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------------ csd ------------ #\n","    # ------ dc ------ #\n","    # dc_upper_ = res_df['dc_upper_T30'].to_numpy()    \n","    # dc_lower_ = res_df['dc_lower_T30'].to_numpy()    \n","\n","    # # Todo, post_cu ~ co 의 dc_lower == low (=touched) 여부 조사\n","    # short_open_idx1 = get_index_bybool(short_open_res1, len_df_range)\n","    # long_open_idx1 = get_index_bybool(long_open_res1, len_df_range)\n","    # wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()   # co_prime_idx (wave_high 정보를 지정하기 위한 front co_idx 지정)\n","\n","    # # 1. dc_lower == low 여부 조사, np.nan 덕분에 vectorize 불가하다고 봄\n","    # short_valid_idx_bool = ~(pd.isnull(wave_co_post_idx_fill_) | pd.isnull(short_open_idx1)) # get_index_bybool\n","    # dc_upper_touch = dc_upper_ <= high\n","    # dc_upper_touch_span = np.full(len_df, np.nan)\n","    # dc_upper_touch_span[short_valid_idx_bool] = [dc_upper_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_co_post_idx_fill_, short_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # long_valid_idx_bool = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1)) # get_index_bybool\n","    # dc_lower_touch = dc_lower_ >= low\n","    # dc_lower_touch_span = np.full(len_df, np.nan)\n","    # dc_lower_touch_span[long_valid_idx_bool] = [dc_lower_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # short_open_res1 *= dc_upper_touch_span == 0\n","    # long_open_res1 *= dc_lower_touch_span == 0\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"csd - dc\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","    #   # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","    #   # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))   \n","    \n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # ------ base_15T < wave_base ------ #\n","    # dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","    # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    # short_open_res1 *= (dc_base_ > wave_base_) & (dc_base_ > close)\n","    # long_open_res1 *= (dc_base_ < wave_base_) & (dc_base_ < close)\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))     \n","        \n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","        epg2 = config.tr_set.ep_gap2\n","\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1        \n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","\n","        # p1_hlm 을 위해선, tp_0 를 기준할 수 없음 --> ep1 & ep2 를 기준으로 진행\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1      \n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","        \n","        # ------ fibo_ep ------ #\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1   \n","                \n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    if config.tr_set.check_hlm in [0, 2]:      # for p1_hhm, p2_hlm\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg   # p2's ep_box 를 out 으로 사용한다?\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg \n","    else:    # for p1 hlm\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg \n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg \n","      \n","      # ------ fibo_out ------ #      \n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg \n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res1 *= (short_tp_ < short_ep1_) # (short_ep_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) # (long_ep_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation     \n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution    \n","    long_open_res1 *= close > res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution   \n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out can be vectorized\n","    long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban)\n","    print(\"res_df['long_open1_{}'.format(selection_id)].to_numpy() :\", res_df['long_open1_{}'.format(selection_id)].to_numpy()) \n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","    \n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    \n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    if not config.tr_set.check_hlm:\n","      res_df['short_tr_{}'.format(selection_id)] = abs(\n","          (short_ep1_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep1_ / short_out_ - config.trader_set.market_fee - 1))\n","      res_df['long_tr_{}'.format(selection_id)] = abs(\n","          (long_tp_ / long_ep1_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep1_ - config.trader_set.market_fee - 1))\n","    else:      \n","      res_df['short_tr_{}'.format(selection_id)] = np.nan\n","      res_df['long_tr_{}'.format(selection_id)] = np.nan\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","metadata":{"id":"HuCb0phoPN83"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-DNPumVZi0xs"},"outputs":[],"source":["\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "]},{"cell_type":"markdown","metadata":{"id":"aTV4h3LjTZBp"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dc49JPmoTaPQ"},"outputs":[],"source":["\n","    \n","    csd_period = 40\n","    res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","    \n","    dc_upper_ = res_df['dc_upper_T{}'.format(csd_period)].to_numpy()    \n","    dc_lower_ = res_df['dc_lower_T{}'.format(csd_period)].to_numpy()  \n","\n","    short_open_res2 *= dc_upper_touch_span == 0\n","    long_open_res2 *= dc_lower_touch_span == 0\n","\n","    # ------ csdbox ------ # --> 결국 dc's upper & lower\n","    if show_detail:\n","      sys_log.warning(\"csdbox\")\n","      # sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","      \n","    # olds,\n","    # np.nan - np.nan = np.nan -> vectorize 가능할 것 => xx\n","    # 1. wave_high_prime_idx_ ~ long_open_idx1 의 valid(not_non) 한 idx 를 max_dc_lower 와 min_low 의 비교값으로 채워넣음\n","    # valid_idx = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1))\n","    # max_dc_lower_ = [dc_lower_[int(iin):int(iout)].max() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    # min_low = [low[int(iin):int(iout)].min() for iin, iout in zip(wave_high_prime_idx_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","# ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nzOYWA2kqZ0d"},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","# from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","  \n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and \n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2) \n","    \n","    # ------------ wave_period1 ------------ #\n","    if to_itvnum(wave_itv1) > 1: \n","      offset = '1h' if wave_itv1 != 'D' else '9h'\n","      htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","      htf_df = wave_range_cci_v3(htf_df, wave_period1)\n","      \n","      # cols = list(htf_df.columns[-15:-4])  # except idx col\n","      cols = list(htf_df.columns)  # 그냥 다 넣어버리기 (추후 혼란 방지)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      cols += list(htf_df.columns[-4:])\n","\n","      # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","      res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","      res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=1), how='inner') \n","    else:\n","      res_df = wave_range_cci_v3(res_df, wave_period1)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    # ------------ wave_period2 ------------ #\n","    if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","      res_df = wave_range_cci_v3(res_df, wave_period2)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    # itv_list = ['15T', '15T', '15T', '15T']\n","    # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면, \n","            # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","            # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                  (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                  idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:                                  \n","            # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","            # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave2, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #  # vectorize allow only for p1_hhm\n","    if config.loc_set.point1.short_tr_thresh != \"None\" and not config.tr_set.check_hlm:\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point1\n","    if config.loc_set.point1.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point1.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point1.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point1.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point1.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point1.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point1.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point1.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point1.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point1.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point1.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point1.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point1.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point1.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point1.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point1.wrr_32 != \"None\":            \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point1.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point1.wrr_32 - 0.1\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point1.wrr_32 # + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point1.wrr_32 - 0.1\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point1.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point1.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point1.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point1.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point1.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point1.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point1.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point1.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point1.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point1.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point1.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point1.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point1.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point1.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point1.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point1.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point1.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point1.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point1.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point1.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point1.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point1.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point1.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point1.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point1.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point1.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point1.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point1.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point1.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone.use_zone:\n","      # ------ bb_base uptrend ------ #\n","      bb_base_T100 = res_df['bb_base_T100'].to_numpy()\n","      b1_bb_base_T100 = res_df['bb_base_T100'].shift(1).to_numpy()\n","\n","      lb_period = config.loc_set.zone.bb_trend_period\n","      bb_base_downtrend = pd.Series(b1_bb_base_T100 < bb_base_T100).rolling(lb_period).sum().to_numpy() == 0\n","      bb_base_uptrend = pd.Series(b1_bb_base_T100 > bb_base_T100).rolling(lb_period).sum().to_numpy() == 0\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= bb_base_downtrend\n","        if show_detail:\n","            sys_log.warning(\"bb_base_downtrend : {:.5f} ({})\".format(bb_base_downtrend[c_i], mr_res[c_i]))       \n","      else:\n","        mr_res *= bb_base_uptrend\n","        if show_detail:\n","            sys_log.warning(\"bb_base_uptrend : {:.5f} ({})\".format(bb_base_uptrend[c_i], mr_res[c_i]))    \n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":            \n","      wave_itv2 = config.tr_set.wave_itv2\n","      wave_period2 = config.tr_set.wave_period2\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","\n","    if config.loc_set.point2.csd_period != \"None\":\n","      wave_itv2 = config.tr_set.wave_itv2\n","      csd_period = config.loc_set.point2.csd_period\n","      \n","      res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","      dc_upper_ = res_df['dc_upper_{}{}'.format(wave_itv2, csd_period)].to_numpy()    \n","      dc_lower_ = res_df['dc_lower_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        csdbox = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","        mr_res *= dc_upper_ <= csdbox\n","        if show_detail:\n","            sys_log.warning(\"dc_upper_ <= csdbox : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], csdbox[c_i], mr_res[c_i]))\n","      else:\n","        csdbox = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","        mr_res *= dc_lower_ >= csdbox\n","        if show_detail:\n","            sys_log.warning(\"dc_lower_ >= csdbox : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], csdbox[c_i], mr_res[c_i]))\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","metadata":{"id":"EQ63Jwpvr7qA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"csZwxsP5r_Pz"},"outputs":[],"source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q_4E-zH02WJy"},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_45\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 1e-10,\n","    \"market_fee\": 1e-10,\n","    \"initial_asset\": 24500,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 50, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"cu_wrr_21\": \"None\",\n","      \"co_wrr_21\": \"None\",\n","      \"wrr_32\": 0.3,\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"wrr_32\": 0.3,\n","      \"csdbox_range\": 0.3,\n","      \"csd_period\": 40\n","    },\n","    \"zone\": {\n","      \"use_zone\": 1,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"check_hlm\": 0,\n","    \"wave_itv1\" : 'T',\n","    \"wave_period1\": 30,\n","    \"wave_itv2\" : 'T',    \n","    \"wave_period2\": 30,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\" : 0,\n","    \"p2_box_k2\" : 0,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.12,\n","    \"ep_gap2\": -0.12,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 30000\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","metadata":{"id":"MuD_2vY7TI_8"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"EKag94Y2TMCO"},"outputs":[],"source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":14,"status":"ok","timestamp":1655649756234,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"qBJfPsmJzVIr","outputId":"359fa86d-130b-4543-95ec-49c2b4ed391b"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_45\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"cu_wrr_21\": \"None\",\n","  \"co_wrr_21\": \"None\",\n","  \"wrr_32\": 0.3,\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"wrr_32\": 0.3,\n","  \"csdbox_range\": 0.3,\n","  \"csd_period\": 40\n"," },\n"," \"zone\": {\n","  \"use_zone\": 1,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"check_hlm\": 0,\n"," \"wave_itv1\": \"T\",\n"," \"wave_period1\": 30,\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 30,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.12,\n"," \"ep_gap2\": -0.12,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 30000\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","config_list[0].tr_set.wave_itv1 = 'T'\n","config_list[0].tr_set.wave_period1 = 30\n","config_list[0].tr_set.wave_itv2 = 'T'\n","config_list[0].tr_set.wave_period2 = 30"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2236,"status":"ok","timestamp":1655649758459,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"513829c1-418c-4bbd-eeec-b48a377f6e34"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 0.8457365036010742\n","make data_list elapsed time : 0.00027632713317871094\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_iYcJk8nK8Yq"},"outputs":[],"source":["# ------ edit utils config ------ #\n","config_list[0].tr_set.check_hlm = 1\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","config_list[0].pos_set.short_ban = 0\n","config_list[0].pos_set.long_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_greater1 = 0\n","# config_list[0].tr_set.wave_greater2 = 0\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","config_list[0].tr_set.ep_gap1 = -0.65 # -0.618 -0.23 -0.382 0.19 0.8 -0.12\n","# config_list[0].tr_set.ep_gap2 = -0.12 # -0.618 -0.23 -0.382 0.19 \n","config_list[0].tr_set.out_gap = -0.35  # 0 -0.35\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 30000\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002  # utils 로 이곳에 배치\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004\n","\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":938,"status":"ok","timestamp":1655651414064,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"b5017709-6c03-4a93-8a6d-24b59663306f"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 11405\n","np.sum(long_open_res2 == 1) : 12629\n"]},{"output_type":"stream","name":"stdout","text":["res_df['long_open1_{}'.format(selection_id)].to_numpy() : [0. 0. 0. ... 0. 0. 0.]\n","enlist_tr elapsed time : 0.5996644496917725\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfDSOGMd91rE"},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.wrr_32 = 0.3 # \"None\" 1 0.5 0.382 0.302\n","config_list[0].loc_set.point2.wrr_32 = 1 # \"None\" 1 0.5 0.382 0.302 0.25\n","config_list[0].loc_set.point2.csd_period = \"None\"  # \"None\" 100\n","config_list[0].loc_set.zone.use_zone = 0\n","config_list[0].loc_set.zone.bb_trend_period = 150\n","# config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = 0.5  #  \"None\" 2 0.8 ## 0.7\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3030,"status":"ok","timestamp":1655651417502,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","outputId":"67852a13-2ef0-4494-f8c6-ac86712ab66e"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.7508656978607178\n"]},{"output_type":"stream","name":"stderr","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.065168857574463\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","# config_list[0].loc_set.tr_set.p2_box_k1 = 0\n","# config_list[0].tr_set.p2_box_k2 = 0.0\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","config_list[0].lvrg_set.leverage = 1\n","config_list[0].lvrg_set.static_lvrg = 0\n","config_list[0].lvrg_set.target_pct = 0.1  # 0.1 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":663},"executionInfo":{"elapsed":5705,"status":"ok","timestamp":1655651640992,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"cfa19046-f31c-4c5c-ecce-a0d39b53e7b6"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 2.287234306335449\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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398/EZFDhw6p2rZt2yahoaHKcvH36fXXX1faWrRooffahISESEZGhlhaWiptmzdvFhH16flTpkwREZHGjRuXObfCwkJZsGBBmX0KCgrk3Xff1Wu/fPmyfPzxx6Wut3v3brl586YkJiaKu7u7DB06VIKDg+XGjRvSunVrASAvvPCCiIg899xzqnU7duwoIiIODg4CQPbu3Svbtm3Te46ffvpJjh07Vi2/hwzD1M2wxrLGFrfVphp7b4KDg+XPP/9UtRlaYx955BH5+uuvxcnJSbRarXh5eUlubq78+uuvVfq7xzBM3Q9rLGtscVttqqNOuRQAACAASURBVLGG7McCkHfeeUcmT54sdnZ28uqrr8rx48clPz9fevfurTdmUFCQFAsLC5OHH3642n8fmfLDSxBQmX777TeIiLK8detWNGnSBF27dlX127Ztm/K1iOC3337D888/DwBo37492rVrh4CAANU6mzdvRrNmzfDMM88AuHMKxaRJkzBx4kQsXboUixYtQkRERIXmm5SUhNDQUGU5ISEB4eHhylzuNXnyZLz22mvw9PREenq60j548GDs27cPN2/ehKmpKUxNTZGVlYXw8HD06tVL6bdp0yZs2bIFO3fuRJcuXeDh4YHbt28DAOzt7XH79m1s27ZNGcPU1BTBwcHo1q0bTExM8PTTT6Ndu3bw8/Or0Hbea+/evarlc+fOlXgx9rv7paenIzk5Wa/fn3/+iZs3byrLFy5cQH5+Po4ePapqA6B3usu9zMzM8NFHHxm+IRWg0WjQtGlT5QLme/bswSuvvIKioiK8/fbbVfKcRESViTWWNbam1ti7PfLII9BqtarLD1TE9evXMW3aNGzfvh2HDh3CwoULMXPmTDg7O+PZZ5+t5NkSEd3BGssaW1NrrKH7sV999RVWr16Nw4cPY8uWLbC3t8eVK1cwf/58vTGnTZuGPn364LXXXsNDDz2EoKAgNGzYsErmT/ePB2CpTMnJySUut23bttx+xX2K/01KSlL1KV5u0aKF0nbgwAFcv34dJiYmWLNmzQPP99653M3JyQlff/015syZo3e3+1atWsHNzQ23bt1SZdCgQXrXjPH390ejRo2wf/9+5Q968RgNGjTAzZs3VWP88MMPMDMzQ9u2bdGyZUsAwLVr1yq8rXfLzMxULRcUFKiu6VORfiX1ycrKUv0HpqCgAABK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Zs0ajh07xnfffVeo87rVkDJg3QVPfZGXrUej08mZOm6LcBmci3B594ANTREugUAQfITGhqfGzp7tew67Z88eUlJSmD9/PgMHDuThhx9mzJgxjBw5klmzZsl9rVixgqNHj7Jq1So6depE3759mTlzJkuXLpU9dYsTpT0TxmTPjFGVUguCSJ1ddwusPJE8YKXzk+IbHi0ILCXvAesLEYAVhB1paWn06tWLKlWqsHbtWkaOHMlLL73kclHbuXMn7du3R6fTsXjxYr777jvatm0ri9zly5dp3bo1+/btY8aMGaxbt46hQ4dy5syZIo9RWrLuadXY888/z+bNmxk36j88Vr0OZ7Kusfu489KICxcu0LlzZ8pGaenZsCktatzOjO+WuAZgTa5FuBQKBUov1f2MubnyBKIgJ0+epGPHjtxxxx0kJSUxbNgw3nzzTacJHNgKFUhPGLP0YMz4gd69e3PnnXfy/fffM3v2bK5cucJDDz3k5FPUu3dvVqxYweLFiwF49dVXWbFiBRMmTABAFwVk/cBLQ3z3FWrkDNhSllziKQO2XDRYLLYt1ITagmDqrPOh6VgguIUpDfrqC0lfZ8yYwbx589i2bRuJiYlObSR9rVixIitXrmTYsGE8++yzfk0OlUolKlXhUvsLo69gsw148sknWbp0KT/88AOPPvoob775Jm+95fygVavVMmnSJDZt2sTYsWP5/vvv6datm5NNgcVioXPnzuzbt4958+axaNEiTpw4QceOHQtVefpWRFOEDFh/LAjMBgMqtdrBA9ZzADYvR+/xfq4oCI0VCIKP0Njw1NgffvA9h7VYLHTr1o2kpCTGjh3LunXrePrppxk/fjyjR4+W+zKZTHTs2JGzZ8+yfPlyZs6cycqVKxk6dGihzqmoSMWr5AzYUro0MVLr/qGlnAFrD7RKuill+ha0ILCEgQWBP/pqLYktJSWlRD5XbGILxlYhFqv1CNZXn/He7vZmTaxTD+6yTj24y9p/6v9z26bjq0OtUw/usn685ydr19dfcXn/7dVL5GNjb6tsrd6wvnXqwV3W7u++6fFzR29ebe3zwftBO99vP8F6cnNw+ho5wPbdxZQt+b/j2GG2sUwYXvJj8WezHrFtuX8678/707Zfv8/1vVBt991l+8zObUP3GUInxHcnNrGJTWzFvdVv1cI69eAua+177g742OdnfGx9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VGj48OGSpGnTpunYsWNR37fHo48+6v3TjZa2GQ19nzp1ShkZGerZs2eT+zraxzbaL5ryVYru88KDjCVjW0LGRv6cdFK+SmRsVxJNGRvt54WH0zLWifkqkbGRHCNOzlfJWRnbmfM1ZB8o29bKysqyTz75xMrKymzRokUR2ef69evtzJkz9r///c8qKirsySeftFtuucV27txpx48ftw8++MCSk5O96//973+3srIyO3r0qI0fP967/IknnjC3221ut9t+9rOfeZePHz/eioqKrKyszJYvX+5d3tI+WqtJkyaZmdmRI0fs8OHDdvjwYcvKyor6vkePHm0FBQV25MgRKyoqsueff94kWVpamh04cMDcbre99dZb1r17d5Nk8fHx9tZbb5nb7bYDBw5YWlqad1uLFi2ysrIyKy0t9X6TXktjKNg+2lPf//73vR9eHu09p6WlWWFhoRUWFlpxcbF3u9E+RiTZmDFjLD8/344cOWKbNm2ypKQkR/Tdq1cvO3/+vPXp06dN24yGvl988UUrKSmxoqIi++c//2ndu3eP+rFN3Vh1RL5KZCwZ2/YiY8nYYOXEfJXI2K5UvIdte99OzFin56tExkZifDsxXyVnZmxnzNdujf8BAAAAAAAAAIQYX8IFAAAAAAAAAGHCBCwAAAAAAAAAhAkTsAAAAAAAAAAQJkzAAgAAAAAAAECYMAELAAAAAAAAAGHCBCwAAAAAAAAAhAkTsAAAAAAAAAAQJkzAAgAAAAAAAECY/D+1PLgLSoTcLgAAAABJRU5ErkJggg==\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 2.923485040664673\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_bias_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_bias_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8lYgsqH-rfAM"},"outputs":[],"source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ #\n","short_max_outg = get_max_outg_v4(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)\n","long_max_outg = get_max_outg_v4(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","metadata":{"id":"tOFkzUX2imQu"},"source":["#### consecutive dur. value survey on bias"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CgvSrXaZEkMZ"},"outputs":[],"source":["res_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_itv1 = 'T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"elapsed":3342,"status":"ok","timestamp":1653807810574,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"Sahvc-R0jD1A","outputId":"6b83ac35-819d-487b-bf38-42144ad04c3b"},"outputs":[{"name":"stderr","output_type":"stream","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"data":{"image/png":"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a7311lu1vu7ChQtas2aN5syZo5YtW6p3796aNGmSS3MWFRXpuuuuq1O8gwYNUq9evdSsWTN17NhRf/zjH7V582adOnWq2te899576t69u/r376/+/fvr17/+tdLT09W/f39duHChTmMC3kDhg0ajV69eGj58uIKCgvTtt9/qm2++0YULF2p8zY4dO3TmzBnNmDFDAQEBio2N1dixY5WSklLta4qLi11OGO70vVLfvn3Vr18/+fn5qXXr1nrxxRdVUFCgrKysal+TmZmpiIgIZ3J5+OGHVVxcrP79+ysvL69OYwIAvOf555/XP//5T33xxRfKyMjQzp079fzzz7v02qlTp6p9+/YqKirS0qVLtWLFCpdOV5szZ46Sk5N14sQJ/fjHP3Yr3uuuu07vv/++ysrKlJmZqbNnz1Y6Pbwq586dU3FxsbOVlpbq/PnzKi4urvOYgLdYfqERjeZK+973vmd27NhhTp06ZY4dO2bWr19vunTpYmbPnm2WLl3q7HdpgYFLF4v27dvXfPzxx+bkyZNmz549Zty4cc6+VS1k0LNnT5Oenm5OnDhh1q5dW2NMd999t8nNzTUnTpwwTzzxxFVz19SGDx9u9u3bZ8rLy01xcbFZu3at6dmzp1v75MrFDTwxJo1Go9F8s82bN88sWbLE8jhotMbamv37fwAAAOBDevfuraCgIGVkZCg6OlobNmzQww8/rHXr1lkdGtAocaobAACAD2rbtq3WrFmj06dP6+2339aLL76odevW6bbbblNZWVmVzRVPPfVUla/dsGFDja+rbs7bbrvNE28X8DqO+AA1iIiI0N69e6t8rm/fvrWu3jZx4kS9/vrrVz2em5urm266qdrXZWZmVrlYwc9//nMtX768lqgBAABwJQofAAAAALYXYHUAklRSUlLp5l4AgIYXGRmpa6+91uowfBJ5CgCsV9885ROFT25urqKjo60OAwCaNIfDYXUIPos8BQDWq2+eYnEDAAAAALZH4QMAAADA9ih8AAAAANgehQ8AAAAA2/OJxQ2anHaSgi7bPifplEWxAAAaL/IJALiMwscKQZLeu2w7zqpAAACNGvkEAFzGqW4AAAAAbI/CBwAAAIDtcaqbr+P8bQAAAKDeKHx8HedvAwB8GV/QAWgkKHwAAEDd8QUdgEaCa3wAAAAA2B6FDwAAAADb41Q3AACaAneuxeG6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icIHHrdixQoNHTrUec3M/Pnza+xfWFioiIgINWvWzPlYt27dKn1g1vVDOi8vT926davyup36JpdLhY87ycWd2K8UGBhYKVGOGjVKSUlJGjt2rDIzM+s0Zk0uTy779+9XQEBApYtYSS4A7GLFihV69tlnFRISok6dOunXv/613nrrrVpfd+HCBa1Zs0Zz5sxRy5Yt1bt3b02aNKnW17377rvq0qWLHnvsMQUFBalNmzYaNGiQJGnXrl2666671KFDB3Xu3Nl5dkRttmzZouHDh6tly5YqKCjQ1q1bNXr0aHXq1Enp6ekujVGbkSNHqn///vLz81Pbtm310ksv6cSJE8rKypIkTZw4US+88ILuvPNO5eTkeGTOyZMn65prrpF0cTntp556ynk9VHZ2tnbt2qXZs2erefPmGjdunL7//e9r9erVHpkb9kPhA4/q1auXhg8frqCgIH377bf65ptvdOHChRpfs2PHDp05c0YzZsxQQECAYmNjNXbs2EpLZF6puLi42m/LLvf555/r8OHDmjdvnlq1aqXmzZs7l4XetWuXbr/9dkVERKhdu3bOFXVq8+mnn6p3794aNGiQPv/8c+3du1eRkZEaPHiw/vGPf7g0Rm0GDx6smJgYBQYGqkWLFpoxY4Y6d+6sHTt2SJKGDx+uZcuW6Z577pHD4fDInBMnTnR+U9mtWzf97//+rzO5nDlzRmvWrNFvfvMbtWrVSrfeeqvi4+O5NxMAW3j++ef1z3/+U1988YUyMjK0c+fOSqta1mTq1Klq3769ioqKtHTpUq1YsaLW08bKy8t15513auzYsSoqKlJ2draGDx8u6eKp4Lt379bXX3+tjRs36u2333YpjuzsbJWXlztXlCsrK9PBgwe1bdu2WvOwq4KDg7VixQqVlpbqq6++0vXXX6/Ro0c73+/zzz+vTp06yeFwOG+X8Nprr9VrzpiYGGVkZKi8vFwbNmzQhg0b9PTTTzufHz9+vG655RadOHFC8+bN07333qujR4/Wa07Ym+UXGtHs0773ve+ZHTt2mFOnTpljx46Z9evXmy5dutS6kEDfvn3Nxx9/bE6ePGn27Nljxo0b5+xb1UIGPXv2NOnp6ebEiRNm7dq1NcYUERFh1q5da44ePWqOHDliXnnlFedzf/7zn82JEydMdna2efjhh2td3OBS+/TTT01aWppz+5133jF7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YPr16+f1OLxVGjRocM20wMDAKuvfeuutpnnz5kaSadGihVm3bp156aWXjCTTrl0789JLL5nw8HATGBhokpOTzZEjR0zjxo0dimXUqFFm8+bN10zv3LmzPc6EhARz6tQpEx4ebiSZTp06mVOnTplevXqZxo0bm0WLFpklS5Z4vV0pvls444N6JzCw/m225d+I1TSt3Ndff62ePXsqNDRUt956q4KCgvTmm29KkoKCglRYWKjevXurefPmeu2117R06VJFR0dXOb/FixeradOmatq0qRITE1VSUmJ/3bRpU0nSX//6V8XExKh58+Z66KGH9Oabb+rOO++UJLVq1UqfffaZ/vznP6tly5b67rvv9Mknn9SlSQDAZ4SEhGj69OkqLi5WcXGxpk+frpCQEElS7969VVhYqJdfflmHDh1SSUmJnnrqKftnW7ZsqbS0NJ08eVLffvut3njjDW3evLnGZXbq1EmrV6/WsWPHdPDgQU2aNKnGWKqyceNGPfroo5KkX/3qVzLGaNCgQZKkvn37KjMzU5I0atQobdmyRR988IGOHj2q119/XXPnztVHH32kL7/8UmfOnNF9991X5XL27t2rkydPSpICAgJ06dIltW/fXtLlywanT5+ugwcP6tKlS0pJSVFISIg6duxYY1tUJycnR2VlZZIkY4yCg4MVFRUlSRoxYoQ+//xzbd68WWfPntWf//xnPfroo2rSpEmdlgn/Vf/+g4TPe+WVV1RUVKRTp04pPz9fffv2lXT5YD5//nydOnVKubm5uuuuu+yfuf3227VhwwYdP35cubm5Gjx4sP29qw/KY8aM0YgRI/TKK6/o9OnTSktLqzaeyMhIffrppzp8+LCOHj2qDz/8UNLlg/arr76qffv26dChQ5o/f76aNWtW7bzmzZunl19+WZJ0yy23yBijP/zhD5KkW2+9VceOHVNAQIC9o3zllVd04MABzZ07V1OmTNE///lPLVy4UCdPnqzQcV6tqKhIx44ds78uKyuzdy7nzp3T1KlTtX//fhlj9OWXX6qgoKBCe9bGzp07VVpaKuly52KM0W233SZJevTRR5WXl6dly5bp559/1uuvv64uXbrUuUMDAF/w6quv6u6771bXrl3VpUsXJSQk6LXXXrO/Hx4erubNmysiIkJjxozRrFmzFBoaKkmaNWuWzp49q/DwcI0aNUqjRo2qcXlNmjTR2rVr9e9//1u33HKL2rdvr3Xr1jkUS2U2bdqkPn36SLqcqO3Zs0e//vWv7a83bdpkr9ujRw/t3btXbdq00VtvvSVJGj58uN566y01bdpUW7ZsqXZZw4YN08mTJ3Xs2DF16dJFH3/8caX1unTpopCQENlsthrboyaff/65zp8/r2+//VYbN27Ud999J0m64447lJWVZa+3d+9elZaWqkOHDnVeJvyX1087UfyndOjQwfz444/m5ptvNpJMdHS0ufXWW82UKVPM+fPnTWJiogkMDDRvv/222bp1q5FkgoKCjNVqNZMmTTLBwcHmvvvuM6dOnTIdOnQw0uXL2k6cOGF+9atfmYCAANOwYUOHL3ULDAw0O3bsMB988IG58cYbTcOGDU3Pnj2NJDN69GhjtVpNu3btTOPGjc2nn35qFixYUO38Ro8ebdLS0owkM2zYMGOz2Uxqaqr9vX/9619Gkundu7e5cOGCmTZtmgkJCTGNGjUyU6ZMMaWlpSYpKckEBASYRo0aVbusnj17mhMnThhjjDlz5ox54IEHKq130003mfPnz5uOHTs69Dfq3bu3KSwsrPS9WbNmmbNnzxpjjPn+++/tlyjMmDHDfPTRRxXq5uTkmEcffdTr2xyFQqHUtpRf6maz2UxiYqJ9ev/+/U1BQYGRLh8zz507V+GysEOHDpkePXqYwMBAU1paau+vJJk33nij0ku2rixDhw4127dvr/S96mKpqvTt29dkZWUZSWblypVmzJgx9j5248aN5pFHHjHS5cvJ9u/fX+Gzc+fONfPnz3e67dq3b2/+8pe/mDZt2lzzXtOmTU12draZOHGiw/Or6lK38hIUFGQGDhxov7ROklm7dq0ZN25chXpFRUWmd+/eXt+2KL5ZOOMDlyorK1PDhg3VqVMnBQUFaf/+/dq7d68kacuWLVq5cqUuXbqkhQsXqkuXLpKku+++W02aNNG0adN04cIFbdiwQV988YWGDRtmn++KFSv0zTffyBijn3/+2eF4EhISdMstt+hPf/qTzp07p59//llff/21pMunyD/44AMVFBTo7NmzmjRpkoYOHVrtJWibNm3Svffeq4CAAP3617/Wu+++q549e0q69lu1S5cuacqUKSotLdV//vMfSdLWrVu1YsUKGWPs06ry9ddfKzQ0VBEREXrvvfe0b9++a+oEBQVp0aJFmj9/vn744QeH26Uqzz77rJo2bap7771Xn332mb2tmzRpYr+8odzJkyftl8kBQH12yy23aP/+/fbX+/fv1y233GJ/fezYMfvlVtLlM+9NmjRR69atFRwcrMLCQvt7V/5elaioKO3Zs6dWsVRm69at6tChg2666SZ17dpVCxYsUFRUlFq1aqWEhAR99dVX1cbnSMxXs9lsysvL00cffVRheqNGjfT5559r27ZtmjZtmtPzrcrFixf173//W/3797dfFXLmzJlrrtRo1qyZTp8+7bLlwr+Q+MCl9uzZoxdffFGvv/66Dh8+rCVLlujmm2+WJB08eNBe79y5c7rhhhvUoEED3XLLLSosLJQxxv7+/v37FRERYX9dm4OydLlz2b9/f4UOq1xlnUtwcLDatGlT5fz27t2rs2fPqmvXrurVq5e++OILlZSUqEOHDtckPkeOHLkmSavNepSUlOjf//63UlNTK0wPCAjQwoULVVpaqvHjxzs936pcunRJX3/9tSIjI/X73/9eEp0LAP9WUlJS4T7Jtm3bqqSkpMbPHTlyRBcuXFBkZKR9Wvn9J9UpLCzUrbfe6rJYzp8/r++//14vvPCCcnNzdeHCBX3zzTd6+eWXtWfPngqXTl/Z11Y3zRFBQUH2S6Kly5e0/+tf/1JRUZHGjRtXq3k6s8y8vDz7l6iS1K5dOzVs2FC7d+92y7JR/5H4wOWWLFmiXr16KTo6WsYYvfPOO9XWLykpUVRUlAICAuzT2rZtq+LiYvvrqw/Kjh6kCwsL1bZt20rP4lTWuVy4cEGHDh2qdp6bNm3SY489ppCQEJWUlGjTpk0aNWqUWrRooR07dlQbo6s6F0maM2eO2rRpoyFDhujixYu1mq+jy7y6c7nxxht12223KS8vz+XLBQBPW7JkiV577TWFhYWpVatW+u///m/94x//qPFzly5d0meffabXX39dN9xwgzp27KiRI0fW+LkvvvhCN998s1544QWFhISoSZMm9qGfaxvLpk2bNH78ePsXcBs3bqzw2hXGjBmj1q1bS5Li4uI0adIk+71JQUFBWrZsmc6fP69Ro0bVur+7UseOHTVw4EA1atRIQUFBGjFihH7961/b12nRokUaPHiw7r33Xt144436y1/+os8++0xnzpyp87Lhn0h84FIdOnTQfffdp5CQEP3nP//R+fPndenSpWo/k5GRoXPnzumVV15RUFCQevfurcGDB19zhuNKhw4dqvLbsit9++23OnDggKZNm6Ybb7xRDRs21K9+9StJlzuXl156STExMWrcuLHefvttffLJJ5WeHbpSeedSfulAeeeyZcuWGtfVUcOHD7d/a9i2bVu99dZb9s5FkmbPnq24uDgNHjy4xkvmHNG6dWs98cQTaty4sQIDA9W/f38NGzbMvszly5frF7/4hR599FE1bNhQ//3f/63s7GyXXF4HAN725ptv6rvvvlN2drZycnK0fft2+0iaNRk/fryaN2+ugwcPauHChVqyZEmNl2SfOXNGDzzwgAYPHqyDBw/KarXaR1OrbSybNm1Ss2bN7H3T1a9doWfPnsrJydGZM2eUnp6u9PR0TZ48WdLl0eQGDx6s/v3768SJE/bn8dx77721Xl5AQID9CpIjR47ohRde0BNPPGEfpW7nzp165plntGjRIh0+fFhNmza1DzgEVMXrNxpR/Kd07tzZZGRkmFOnTpljx46Zzz//3Nx8883XPMcnOjraGGPsN4t26tTJbNy40Zw4ccLk5eWZhx9+2F63soEM2rdvbzIzM83x48fN8uXLq40pKirKLF++3Bw9etQcOXLEzJw500gyAQEB5s9//rP58ccfzeHDh83ChQtNaGhojevYoUMHY4wxI0eONJJMs2bNzIULF8wrr7xir1PZAALOPMvozTffNIWFhebMmTOmsLDQfPzxx6Zly5ZGkmnbtq0xxpjz589XeBbP8OHDHZp3ZbGFhYWZjRs3muPHj5uTJ0+a7Oxs87vf/a5CnX79+pldu3aZc+fOmQ0bNpjo6Givb28UCoXia2XatGlm3rx5Xo+DQqFcWwL+9xcAAAA4qWPHjgoJCVFOTo7i4+OVnp6u3/3ud1qxYoW3QwNwFS51AwAAqKWmTZvqs88+09mzZ/XJJ5/o/fff14oVK3TvvffaL/e6utTGpEmTKp1Xenq6S9cnNze30uUMHz681vOcPXt2pfOcPXu2CyMHHOP1004USl1KVFRUhUu+rixRUVFOz2/48OGVzis3N9elcaenp1e6nEmTJtV6npMmTap0nunp6V7/O1EoFAqFQqF4s3CpGwAAAAC/F+TtACTp8OHDFZ6nAgDwvOjoaN10003eDsMn0U8BgPfVtZ/yicRn//79io+P93YYAHBds1gs3g7BZ9FPAYD31bWf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fCCv16v8/PygltlXJD5BSEtLU2trq/91W1ub0tLSOpUZM2aMxowZo3fffVcHDhxQYWFhtMOMuGDa4emnn9aDDz6o1tZWbd26VUuXLo12mLYKpo36k4ULF2rbtm12hxF1f/M3f6P7779fr7zyit2hIMrCtQ/Iy8tTUlKSjh075p/385//XLW1tXrhhReUlJQUlnil0GMePHiwXC6XDhw44P/jZOTIkTp//rwuXbrUp2VGOuYOs2bN0uuvv95pXqTaWbIe9+X70ECfTUtLU1tbW9DLjGbMl4vlPn1lzHb06XDE3SGa/TrYmH/84x/L6/Xqueee06OPPtrjZyP5txSJT5gMGjRI2dnZKigo0OzZs1VeXq7hw4fbHVbUzZ49W+vXr1dGRoamTZumTZs2acCAAXaHBRsUFBRo4cKFYb82Nx6sWrVKZWVl/qNagBWpqanatGmTFixY4O9DTz75pG6++Wbl5eXp2muvjantKjMzU3l5eZozZ45WrVqlb33rW3aHFJTU1FSNGzdO27dv98+LpXaeO3euJk6cqOeff962GKwKFHMs9+nuYo6HPt1TW8div3755Zc1evRolZWV6ac//WnU19+BxCcIPp9PGRkZ/tfp6eny+XydyrS1tamqqkoXL17UBx98oObmZmVnZ0c71IgKph0WLlyoyspKSV+fgh08eLBSUlKiGqedgmmj/mDcuHH6j//4D5WUlPR6SZgTTZw4URUVFWppadEDDzygl19+OWyn6RHbQt0HDB06VG+//baWL1/uv3RJkk6ePClJam9v17p165Sfnx8zMXdc0tzS0qJ9+/YpNzdXZ8+eVXJysgYOHNinZUY6ZkmaOXOm3nrrLV28eNE/L5LtLAUf9x133KHly5fr3nvvVXt7e4+f9fl8nS53squtu4tZiu0+HShmO/p0OOKWot+vrW6LFRUV/ksEe+rTkfxbKiI/dnLSNHDgQHPs2DGTlZXl/5HV2LFjO5UpLCw069evN5LMyJEjzZ/+9Cdz7bXX2h57tNth69atZv78+UaSufnmm43P57M97nBPmZmZAX/UPm3atE43N6ipqbE93mi3QUZGhvF4PGby5Mm2x2lXG1w+RfrH0kyxNQWznwzUNxITE82uXbvMY4891qVsamqq//8vvvii+cUvfhETMScnJ5ukpCQjfT32NTc3+3+EXFlZ2emH4D/60Y9i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\n","text/plain":["<Figure size 1008x1080 with 12 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_p1_idx]\n","  long_open_data = long_data[long_p1_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  # short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  short_false_data = short_open_data[~short_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  # long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  long_false_data = long_open_data[~long_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":881},"executionInfo":{"elapsed":1048,"status":"ok","timestamp":1655247369557,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"jHh0uFkXC4VF","outputId":"4b52c9bd-27b5-419c-8cc7-2ea8842b4a72"},"outputs":[{"name":"stdout","output_type":"stream","text":["216\n","516\n","216\n","516\n","216\n","516\n","216\n","516\n","pkx : [0.05938207 0.14572174 0.35293692 0.75009936]\n","pkx : [0.09674712 0.29884854 0.77654281]\n","\n","56\n","84\n","56\n","84\n","56\n","84\n","56\n","84\n","pkx : [-0.23163787 -0.16862213 -0.14386594 -0.10785695 -0.07409851 -0.0155839 ]\n","pkx : [-0.32640606 -0.24710795 -0.18102619 -0.11494443 -0.03234223]\n","\n"]},{"data":{"image/png":"iVBORw0KGgoAAAANSUhEUgAAAsIAAAHiCAYAAADiVqpyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdd1RU19oG8GdmaDJIiQgoIHYUNYo6dsVCkSiiMbFXvEQTTTQaS0xyNWrUmOL1RmMMUWMvsTcEFEFUwFGKgCCIBOlIlaLU/f3hx1wIQ3Vmzgzz/tY6K8xp+znEdXw9s8/ePAAMhBBCCCGEqBk+1wEIIYQQQgjhAhXChBBCCCFELVEhTAghhBBC1BIVwoQQQgghRC1RIUwIIYQQQtQSFcKEEEIIIUQtUSFMmmXDhg04cuQI1zEIIYTUISEhAePGjeM6BiFKjQphohQOHjyIzZs3N2pfVby529nZISkpiesYhBCiEIwxdOnShesYTTJ//nwEBARwHYMoGBXChHN8vmz/GAoEApmejxBCiGzRfZooE0YLLfUta9asYcnJyezly5csJiaGjR07lm3YsIGdOnWKHTp0iL18+ZJFRkayAQMGSI7p0aMHu3XrFsvNzWWRkZHMxcVFsu3gwYPs119/ZVevXmWFhYXM3d2dlZaWspKSElZQUMAuXbpUZ5bDhw+ziooKVlxczAoKCtjq1auZlZUVY4wxNzc3lpiYyPz9/ZmdnR1LSkqqcWxCQgIbN24cA8B4PB5bu3Yte/r0KcvKymKnTp1iRkZGDf4uXFxcWGRkJMvNzWW3bt1iPXr0kGxjjLEuXbrUuM7NmzczXV1dVlxczCoqKlhBQQErKChg7dq1Yzo6OuzPP/9kOTk57PHjx2z16tW1MtNCCy20NHepuudpaWmxnTt3spSUFJaSksJ27tzJtLS0GADJvXLlypUsIyODpaamsgULFkjO8c4777BLly6x/Px8dv/+fbZ582YWEBBQb7v+/v6MMcYKCwtZQUEBmzZtmqSdNWvWsLS0NHb48GE2f/78Wueqfh/V0tJiP/zwA0tMTGTp6els7969TEdHp8Hr/te//sXi4uJYdnY2u3jxImvXrh0DIPm7QiAQSPa9desWW7RoEevRowd79eoVKy8vZwUFBSw3N7fZ10+Lyi2cB6BFiZfu3buz58+f17iRdO7cmW3YsIG9evWKOTs7Mz6fz7Zu3coCAwMZAKahocHi4uLYl19+yTQ1NdmYMWPYy5cvWffu3RnwpkDMy8tjw4YNYzwej2lra0uKxsZkql7QVmVijLFDhw4xXV1dpqOj02Ah/Nlnn7HAwEBmbm7OtLS02G+//caOHz9eb7vdunVjhYWFzN7enmloaLDVq1ezuLg4pqmpyYC6C2EAUvNs27aN+fn5MUNDQ2Zubs7Cw8OpEKaFFlpktlTd87799lsWGBjI2rZty4yNjdndu3fZpk2bGPDm3lRWVsa+/fZbpqGhwZydnVlRUREzNDRkANiJEyfYiRMnWKtWrVjPnj3Z8+fPG1UI/vN+WNXO9u3bmZaWFtPR0WmwEP7555/ZxYsXmZGREdPT02OXLl1iW7durbfdMWPGsBcvXjBbW1umpaXF/vvf/zJ/f38G1F8IA5Cap7nXT4tKLZwHoEWJly5durCMjAw2btw4pqGhIVm/YcMG5uPjI/ncs2dPVlxczACwESNGsLS0NMbj8STbjx8/zjZs2MCANwXioUOHarQji0K4U6dOknUNFcKPHz9mY8eOlWwzMzNjpaWlNW6Q/1y+/vprdurUKclnHo/HkpOTmZ2dHQOaXgjHx8czR0dHyedFixZRIUwLLbTIbKm65z19+pQ5OztL1js6OrKEhAQGvLk3FRcX17j3ZWRksMGDBzM+n89KS0slDzEANPqJqLRCuKSkhGlra0vWNVQIFxYWss6dO0u2DRkyhD179qzedv/44w/2/fffSz4LhUJWWlrKrKysmlwIv83106I6iwYIqUd8fDxWrFiBjRs3olevXvDy8sLKlSsBAOnp6ZL9iouL0apVKwgEArRv3x5JSUlgjEm2JyYmwtzcXPJZHi+ONeWcVlZWOH/+PCorKyXrKioqYGpqitTUVKnHtG/fHomJiZLPjDEkJSXVuK6mqPo9VaGX6Qgh8vDPe1diYiLat28v+ZydnY2KigrJ5+LiYujp6aFt27bQ1NSU2X3qxYsXKCkpadS+bdu2hVAoxMOHDyXreDxeg32L27dvj5CQEMnnoqIiZGdnw9zcHCkpKU3KK+vrJ8qJXpYjDTpx4gRGjhwJKysrMMbw/fff17t/amoqLC0twePxJOs6dOhQ4yZUvUiW9rk+de1bfX1RURF0dXUln/l8Ptq2bSv5nJSUBGdnZxgZGUmWVq1a1VkEV12XlZVVjXWWlpaS6/pnm2ZmZvVmTktLg4WFRY1zEUKIrP3z3tWhQ4d673VVXrx4gbKyMpndp/55H/znPdPU1FTyc1ZWFoqLi9GrVy/JPdrQ0BCtW7eut41/Xquuri7atGmDlJQUFBUVSdZVqe8+LevrJ8qJCmFSr+7du2PMmDHQ0tLC69ev8erVqxpPUaUJDg5GcXEx1qxZAw0NDdjZ2cHFxQUnT56s85iMjAx07ty5UZkas29sbCx0dHTw3nvvQUNDA19//TW0tbUl23/77Td899136NChAwDA2NgYkyZNqvecp0+fxoQJEzB27FhoaGhg1apVKCkpwb179wAAYWFhmDVrFvh8PpycnGBnZ1cjc5s2baCvr1/jfF9++SUMDQ3Rvn17LFu2rFHXTwghTXHixAl8/fXXMDY2Rps2bfDvf/8bR48ebfC4yspKnDt3Dhs3bkSrVq1gbW2NefPmNarN9PT0Bu/T4eHh6NWrF/r27QttbW1s3LhRso0xBg8PD+zcuVPyEKN9+/ZwdHSs95wnTpzAwoUL0bdvX2hpaWHr1q0IDg5GYmIisrKykJycjDlz5oDP52PhwoU1hnjLyMiAhYUFNDU13/r6ieqgQpjUS1tbG9u3b0dWVhbS09NhYmKCL7/8st5jysrK4OLiAmdnZ2RlZeHXX3/FvHnz8OTJkzqP2b9/P2xsbJCbm4vz58/Xe/5t27bh66+/Rm5uLlatWiV1n5cvX+KTTz7BH3/8IXkSkJycLNm+a9cuXLp0Cd7e3nj58iWCgoIwePDgetuNjY3FnDlz8MsvvyArKwsuLi5wcXFBWVkZAGD58uVwcXFBXl4eZs+ejQsXLkiOffLkCU6cOIFnz54hNzcX7dq1w6ZNm5CcnIyEhATcuHEDZ86cafTXhoQQ0lhbtmzBgwcP8OjRI0RERCAkJARbtmxp1LHLli2DgYEB0tPTceTIEZw4caJR96mNGzfi0KFDyM3NxYcffih1n7i4OGzatAk3btxAXFwc7ty5U2P72rVr8fTpUwQFBSE/Px83btyAtbV1ve3evHkT33zzDc6ePYu0tDR06dIFM2bMkGx3d3fH6tWrkZ2djV69ekkeZACAr68voqKikJ6ejhcvXrzV9RPVwcObzsKEEI4tWbIEM2bMwOjRo7mOQgghUm3fvh1mZmZYsGAB11E4oe7X3xLRE2FCOGJmZoZhw4aBx+Ohe/fuWLVqVYNPwwkhRJGsra3Rp08fAIBIJMKiRYvU6j6l7tevLjgfuoIWWqovlpaWkokn/rlYWlrKte1Zs2ZJbTcyMlLmbXXo0IFFRESwwsJClpyczH788UfJmMS00EILLcqwDBw4kMXFxbGioiL27Nkztm7dOga8GSazrvu0vDN9+eWXUtu9du2awq6flpazUNcIQgghhBCilqhrBCGEEEIIUUtUCBNCCCGEELXE2cxymZmZSExMxMBq6x5wFYYQQprIysoKJiYmXMdQmKp7dn3ofk4IUVZ13bM5K4QTExMhEolqdFAWcRWGEEKaSCwWcx1Boaru2fWh+zkhRFnVdc+mrhGEEEIIIUQtUSFMCCGEEELUEhXChBBCCCFELVEhTAghhBBC1FKTC+H9+/cjIyMDERERknU7duxAdHQ0wsPDce7cORgYGMg0JCFEuc2cCSQkABUVb/47cybXiVo+CwsL+Pr6IioqCpGRkfjss88AAEZGRvD29kZsbCy8vb1haGgo9fh58+YhNjYWsbGxmDdvniKjE0I4Rvfsmpo0Fd3IkSOZra0ti4iIkKxzcHBgAoGAAWDbt29n27dvb/A8YrGYAWCs2tLULLTQQgv3y8yZYIWFYIz9byksfLOe62zyXKruYVwtZmZmzNbWlgFgenp67MmTJ6xnz57s+++/Z2vXrmUA2Nq1a6Xej42MjFh8fDwzMjJihoaGLD4+nhkaGr719TLQ/ZwWWpR9oXt2zaXJT4QDAgKQk5NTY52Pjw8qKioAAEFBQbCwsGjqaQkhKmrbNkAorLlOKAS2buUmj7pIT09HaGgoAKCwsBDR0dEwNzeHq6srDh06BAA4dOgQJk+eXOtYJycn+Pj4IDc3F3l5efDx8cH48eMVmp8Qwo2tW6Xfs7//Xj17y8r8qt3c3ODp6Sl1m7u7O8RiMcRiMYyNjWXdNCFEwZYtW4YOHXhSt3XoAAiNDCA0MoCOnlDqPkQ2rKysYGtri+DgYJiamiI9PR3Am2LZ1NS01v7m5uZISkqSfE5OToa5uXmt/eieTYjy0NETvvX9VENDA1ZW0rdZWDDMmTOn2edWVTIthNevX4/y8nIcO3ZM6nYPDw+IRCKIRCJkZWXJsmlCiII5OTlh165deP26rdTtyck8uO/dCfe9OyHQ5GzunhZPKBTi7NmzWLFiBQoKCmptZ4w1+9x0zyZEeQg0Nd7qftqhQwf4+fmBx5NeCZeUmODIkSM4efKkWr3rJbNCeP78+Zg4cSJmz54tq1MSQpRU165dceLECYSHh+Pjj3NRVFRze2WlDn74uQ034dSIhoYGzp49i2PHjuH8+fMAgIyMDJiZmQEAzMzMkJmZWeu4lJQUWFpaSj5bWFggJSVFMaEJIQrn6uqKsLAw9OnTB7/80q7WPbuoCFi0KAPr16/H+++/jzNnzoDHk/5tX0sjk0LYyckJa9aswaRJk/Dq1StZnJIQoqT09PRw4cIFVFRUYMqUKTh0qAzu7sDffwOVlUB6ujYqKn5Df9sfuI7a4u3fvx/R0dHYuXOnZN2lS5cwf/58AG8eUFy8eLHWcV5eXnB0dIShoSEMDQ3h6OgILy8vheUmhCiOm5sbLly4gKdPn8LW1haffRZU457999+Auztw/Diwbds2LF26FPb29liyZAnX0RWmSW/dHT9+nKWmprLS0lKWlJTE3NzcWFxcHHv+/DkLDQ1loaGhbO/evY1+e4+B3jKmhRZVWjZu3MgYY2zs2LF17vPHH3+wgoICtvbMYbbi5AEmNDLgPLesF65HjRg+fDhjjLHw8HDJvdfZ2Zm988477MaNGyw2Npb5+PgwIyMjBoANGDCAeXh4SI5fuHAhi4uLY3FxcWzBggUyuV4Gup/TQou8FqGRQZPvpzNnzmQVFRXM09OTaWlpNfq469evs8LCQtapUyfOr1tWSz33MG4DMdCNkxZaVGXR19dnOTk57Ny5c/XuN2TIEMYYYyeCA6gQbiELFcK00MLt0tRCeMqUKaysrIz5+vqyVq1aNaktCwsLlpeXx/z8/BiPx+P82mWxyGz4NEKI+lq6dCmMjIywZcuWevcLCgpCdEw0hnTurqBkhBBCqvTs2RPHjh2DWCxuVrfV5ORkLF++HHZ2dpg7d66cUioHKoQJIY0iFAqxcuVKXL16FSEhIQ3u/+eRI+hobAIzA+kzmxFCCJE9LS0tHD9+HIWFhZgyZQoKCwubdZ5Dhw7h0aNHWLFihYwTKhcqhAkhjbJ48WIYGxs3+DS4yslTJ1FeUUFPhQkhRIG2bt2Kfv36YeHChcjIyHirc+3evRu2trYYPny4jNIpHyqECSEN0tbWxurVq3Hjxg0EBQU16pjsnBxEpDzHQKsu0NbWlnNCQggh9vb2WLVqFfbs2YOrV6++9fmOHTuGnJwcfPbZZzJIp5yoECaENGjSpEkwMzPDjh07mnRc0LNYCLV1MN7RSU7JCCFEfVXNNic0MoCeoQF+/fVXxMTEYPXq1fXu29DsdFX78rQ1cejIYbz//vtSZ59sCagQJoQ0aP78+UhKSsLNmzebdNzTzDS8Ki3F2NGj5ROMEELUWNVsc+57d8Jt4UJ069YNX3zxhdSX46rv29DsdNX39ThwADweDx9//LG8LoNTVAgTQuplamoKJycnHDlyBJWVlU06tpIxxL9Ix2i70fIJRwghBFoCDXy5Zi0CAgJk0iWiuudJz3H58mV89NFHLbKbGxXChJB6zZw5ExoaGjhy5Eizjo/NSEWXzp1hZWUl42SEEEIAYFR3G5iZmWHdunVyOf/evXvRtm1bODm1vG5uVAgTQuo1b9483L9/HzExMc06Pi4jDQAwbtw4WcYihBACQFdLG2N79MFVT0/cu3dPLm34+voiLy8Prq6ucjk/l6gQJoTUqU+fPrC1tcXhw4ebfY70l3lIT0+nQpgQQuRgVHcbaGtqYtOWzXJro7y8HFevXoWLiwv4/JZVOrasqyGEyNS8efNQWlqKkydPvtV5/G77UyFMCCEypqGhgaGduyM6LRlR0Y/l2taFCxfQtm1bDBs2TK7tKBoVwoQQqXg8HmbNmoVr164hOzv7rc7ld/s2TE1N0bt3bxmlI4QQ4jJhAvRb6eLe0+Z1XWuK69evo6SkBJMnT5Z7W4pEhTAhRKqBAweiffv2+Ouvv976XH7+/gConzAhhMjSvxYuQk5RAaLTU+TeVmFhIW7evNni+glTIUwIkWrSpEkoLy+Hp6fnW58rOSUZsbGxsLe3l0EyQggh1tbWsBs1Cvfin4AxppA2L1y4gK5du6JXr14KaU8RqBAmhEjl4uKCu3fvIjc3Vybnu3nzJuzs7KChUf9A7qRx9u/fj4yMDEREREjWnTx5EqGhoQgNDUVCQgJCQ0OlHpuQkIBHjx4hNDQUYrFYUZEJITK0ZMkSlJaWIvhZnMLavHz5MgC0qO4RVAgTQmrp0KED+vbti0uXLsnsnL6+vmjdujX69+8vs3Oqsz///BPjx4+vsW7GjBmwtbWFra0tzp49i3PnztV5/JgxY2BrawuRSCTvqIQQGWvVqhXmz5+Pi5cvobDktcLaTU9PR2BgIBXChJCWzcXFBcD//vUvC4GBgQCAwYMHy+yc6iwgIAA5OTl1bp82bRpOnDihwESEEEWZPHkyjIyMcODPPxXe9pUrVzBw4EC0adNG4W3LAxXChJBaJk2ahJiYGMTFye4rt5SUFCQnJ1MhrAAjR45ERkYGnj59KnU7Ywze3t548OAB3N3dFZyOEPK2PvzwQyQnJ+POvbsKb9vPzw/Am/tMS0CFMCGkhtatW2P06NEyfRpcJSgoCEOGDJH5eUlNM2fOrPdp8IgRIzBgwAA4Oztj6dKldf6F5u7uDrFYDLFYDGNjY3nFJYQ0QevWreHs7IyzZ88q7CW56sRiMV69egU7OzuFty0PVAgTQmpwdHSElpaWTPsHVwkODkaXLl3Qtm1bmZ+bvCEQCPD+++/j1KlTde6TmpoKAHjx4gXOnz+PQYMGSd3Pw8MDIpEIIpEIWVlZcslLCGma8Y5O0NHRwenTpzlpv6ysDIGBgVQIE0JaJhcXF2RnZ0v69MpSUFAQAOonLE/29vaIiYlBSor0cUV1dXWhp6cn+dnR0RGRkZGKjEgIeQvvu05GcnKyXO7RjeXv74++ffvCwMCAswyyQoUwIaQGR0dHeHt7o6KiQubnfvjwIcrLy6kQloHjx48jMDAQ1tbWSEpKgpubG4A3I0f8s1tEu3btcPXqVQCAqakp7ty5g7CwMNy/fx9Xr16Fl5eXwvMTQppOW0MTDvb2nHWLqOLv7w8+n48RI0ZwlkFWmjyg5/79+zFx4kRkZmaiT58+AAAjIyOcOnUKHTt2xN9//41p06YhLy9P5mEJIfJlY2ODdu3a4caNG3I5/6tXrxAeHk79hGVg1qxZUtcvXLiw1rq0tDRMmDABwJsxhPv16yfXbIQQ+ejV3hI6OjoymfHzbQQHB6OkpAR2dnaSf2SrqiY/EZY2duW6detw8+ZNdO/eHTdv3sS6detkFpAQojhVUyDfvHlTbm0EBQVh0KBB4PPpCylCCGmKvpYdkZqainv37snsnDp6QgiNDKCjJ5S6nTFAaGRQY5/Xr1/j/v37sLOzkxxf3zmUWZP/JpI2dqWrqysOHToEADh06FCLGmiZEHUybtw4PH36FImJiXJrIygoCPr6+ujZs6fc2iCEkJZGKBSiZztzXLh8SabdIgSaGnDfuxMCTemdBPgCPtz37qy1j7+/P/r37w8DI0Op21WFTB7JmJqaIj09HcCbWUdMTU1lcVpCiAIJBAKMHj1ark+DAXphjhBCmmOM3WhoCjRw9do1rqMAeFMIa2hoYHAdo86oCrl8N1nXv1RoTEpClNfAgQNhYGAg90L46dOnyM7Opn7ChBDSBE4ODnhdVop7QdyNFlHdvXv3UFZWhhHDhnMd5a3IpBDOyMiAmZkZAMDMzAyZmZlS96MxKQlRXlX9g319feXeVnBwMIYOHSr3dgghpKVwdHDAk/RUlJWVcR0FAFBcXIyHDx9i+LBhXEd5KzIphC9duoT58+cDAObPn4+LFy/K4rSEEAWyt7dHaGgosrOz5d5WcHAwbGxsJOPZEkIIqdu7774L8/bmeJyWxHWUGoKCgtC3z7vg83hcR2m2JhfC0sau3L59OxwcHBAbGwt7e3ts375dHlkJIXLSqlUrDBs2TG7Dpv2TWCwGn89H//79FdIeIYSosvfeew8AEJ0mfaIcrjx48ABCoRAm+qo7sUaTX++ra+xKe3v7tw5DCOHG8OHDoa2tLff+wVXEYjEAQCQS4fbt2wppkxBCVNWECRMQEhqKgtevuI5Sw4MHDwAAlkbGSM9XzfkjaCBPQgjGjRuH0tJSBAQEKKS9rKwsJCQkYJCKv21MCCHyZmRkhKFDh8L7hg/XUWqJjY1FQUEBLN9R3QEQqBAmhMDOzg5isRjFxcUKa1MsFkMkEimsPUIIkTd5TC7h5OQEgUCA696Nnwq9oUkypKk+cQaP17jykDGGsPBwdKBCmBCiqnR1dTFw4ED4+/srtF2xWIxOnTrRUIqEkBajanIKWU4u8d577+HFixcICQ1tco6mZKg+cQaa8O7bw9AQtDc0gkBFZwtVzdSEEJkZNmwYNDU1FV4I379/HwDoqTAhhNSBx+Nh/PjxuH79OiorK7mOI1VoWCg0BRow0zfkOkqzUCFMiJqzs7NDeXm5TOeub4yQkBBUVlZSIUwIIXWwtbVF27Ztcf36da6j1KnqSbWq9hOmQpgQNTdq1CiEhISgsLBQoe0WFhYiOjqaCmFCCKmDo6MjAChsaMvmSPj7bxSXllAhTAhRPTo6Ohg8eLDCu0VUEYvFNHIEIYTUwcnJCaGhoXXO2KssknKyYGnUhusYzUKFMCFqbPDgwdDW1uasEL5//z5MTEzQoUMHTtpXZfv370dGRgYiIiIk6zZs2IDk5GSEhoYiNDQUzs7OUo91cnJCTEwM4uLisHbtWkVFJoQ0gZ6eHoYNGwYvr8aPFsGV5zlZaGdgBG1tba6jNBkVwoSoMTs7O1RWVuLOnTuctF99Yg3SNH/++SfGjx9fa/3OnTtha2sLW1tbeHp61trO5/OxZ88eODs7w8bGBjNnzkTPnj0VEZkQ0gSjR4+GlpYWvL29uY7SoKScbGgIBOjdqxfXUZqMCmFC1JidnR3CwsKQn5/PSfuPHj1CaWkpdY9ohoCAAOTk5DT5uEGDBuHp06dISEhAWVkZTp48CVdXVzkkJIS8DUdHRxQVFeHu3btcR2lQUm4WAKB/P1uOkzQdFcKEqCktLS0MHTq02d0iqg8cr2ug36wB5EtLSxEWFkaFsAwtW7YM4eHh2L9/PwwNaw9nZG5ujqSkJMnn5ORkmJubSz2Xu7s7xGIxxGIxjfdMiII5OjrCz88PpaWlXEdpUF5xEQpfv0bfvn25jtJkVAgToqZEIhFatWqF27dvN+v46gPH8zUEzR5APjg4GCKRCAKBoFk5yP/s3bsXXbp0Qb9+/ZCWloaffvrprc7n4eEBkUgEkUiErKwsGaUkhDTEysoK1tbWKtEtokpqfg562dhwHaPJqBAmRE3Z2dkBQLMLYVkJDAyEUChE7969Oc3REmRmZqKyshKMMXh4eEh90p6SkgJLS0vJZwsLC6SkpCgyJiGkAVXDpqnCi3JV0vJzYdOjJ3i8JkxLpwSoECZETdnZ2eHRo0fN6mcqS0FBQQCAIUOGcJqjJTAzM5P8PGXKFERGRtbaRywWo1u3bujYsSM0NTUxY8YMXLp0SZExCSENcHJywvPnz/HkyROuozRaal4uhEIhOnfuzHWUJqFCmBA1pKGhgeHDh3M2bFp1CQkJyMjIwNChQ7mOolKOHz+OwMBAWFtbIykpCW5ubtixYwcePXqE8PBwjBkzBp9//jkAoF27drh69SoAoKKiAsuWLYOXlxeio6Nx+vRpPH78mMtLIYRUo6GhAXt7e6WeTU6atPxcAECfPn04TtI0Te/QRwhReQMHDoRQKISfnx/XUQC8eSpMT4SbZtasWbXWHThwQOq+aWlpmDBhguSzp6en1KHVCCHcGzJkCAwMDFSqWwQApOfnorKyEn369MGFCxe4jtNo9ESYEDWkLP2DqwQFBcHa2hrvvPMO11EIIYRTTk5OKC8vx82bN7mO0iRlFRWIf/YM7777LtdRmoQKYULU0OjRoxEVFaU0IwEEBgYCeDPTHSGEqLPx48cjMDCQs/Hd38bj6Mcq1zWCCmFC1IxAIMDw4cOVplsEADx48AAVFRXUPYIQotbatm2LgQMHqlz/4CpRjx+ja9euaNWqFddRGo0KYULUTP/+/dG6dWuleFGuSlFRER49ekQvzBFC1FrVsGmqWghHRkVBIBDARoXGE6ZCmBA1M3r0aABQqkIYeNNPePDgweDz6bZECFFP48ePR2ZmJkJDQ7mO0ixRj6MA1B45omom0qbOPqoI9DcOIWrGzs4O0dHRyMzM5DpKDUFBQZsZRDYAACAASURBVNDX10ePHj24jkIIIQrH4/Hg5OQEb29vMMa4jtMsCX//jeLi4lqFcNVMpM2ZfVTeZFoIr1ixApGRkYiIiMDx48ehra0ty9MTQt6SQCDAyJEjle5pMPC/F+aoewQhRB31798fbdu2VdluEQBQWVmJyMhIlRo5QmaFcPv27fHZZ59h4MCB6NOnDwQCAWbMmCGr0xNCZGDAgAHQ19dXqhflqsTFxSErKwvDhw/nOgohhCics7MzKisr4ePjw3WUtxIREaFSI0fI9ImwhoYGWrVqBYFAAF1dXaSmpsry9ISQt+Tg4AAASjs+5e3btyVjHBNCiDpxdXVFcHCw0nVba6qIiAiYmprCxMSE6yiNIrNCODU1FT/++COeP3+OtLQ05Ofnq/y/aghpaezt7RESEqI04wf/k7+/Pzp37gxLS0uuoxBCiMKYm5tj4MCBuHjxItdR3tqjR48AqM5UyzIrhA0NDeHq6opOnTqhffv2EAqFmD17do193N3dIRaLIRaLYWxsLKumCSGNIBQKMWzYsHr/gVr1Zq/QyAC6BvoKf8u3qu8yPRUmhKiTSZMmAUCLKIQjIyMBAL169eI4SePIrBC2t7dHQkICsrKyUF5ejnPnzmHYsGE19vHw8IBIJIJIJFLaJ1KEtFSjRo2ClpZWvYVw1Zu97nt3gq8hUPhbvhEREcjNzaVCmBCiViZNmoS4uDjExMRwHeWtvXjxAtnZ2ejZsyfXURpFZoXw8+fPMWTIEMlsIuPGjUN0dLSsTk8IeUsODg54/fo17t69y3WUOlVWVlI/YUKIWmndujXGjh3bIp4GV4mOjla/Qvj+/fs4c+YMQkJCEBERAT6fj99//11WpyeEvCUHBwcEBATg9evXXEepl7+/P7p164b27dtzHYUQQuSmqiva5A/eh5aWlsoVwlX5ebzapaRaFsIAsHHjRvTs2RN9+vTBvHnzUFpaKsvTE0KaqV27dujdu7dKvMBK/YQbZ//+/cjIyEBERIRk3Y4dOxAdHY3w8HCcO3cOBgYGUo9NSEjAo0ePEBoaCrFYrKjIhJBqqrqiLd/wDbKysnDv3j2uIzVJVX7wam97/PgxTExM0KZNG8UHayKaWY4QNTBu3DgAUIlCOCwsDPn5+VQIN+DPP//E+PHja6zz8fFB79690bdvX8TGxuLLL7+s8/gxY8bA1tYWIpFI3lEJIXXg83jo2c4Cnt5eqKys5DqOzFR1jVWFp8JUCBOiBhwcHJCZmYnw8HCuozSosrISd+7coUK4AQEBAcjJyamxzsfHBxUVFQDeTFltYWHBRTRCSCN1NWkHXS1tXL12jesoMkWFMCFEafB4PDg4OODmzZsqM3+9n58fevToAVNTU66jqCw3Nzd4enpK3cYYg7e3Nx48eAB3d3cFJyOEVBlo1QWvSkvgc/MG11FkKikpCUVFRVQIE0K4N2jQILRr1w5XrlzhOkqjVfUTHjNmDMdJVNP69etRXl6OY8eOSd0+YsQIDBgwAM7Ozli6dClGjhwpdT8a+50Q+dHV1UUfCyuEJf2NkpISruPIFGMMMTExVAgTQrjn6uqK8vJyXFOhr94ePnyInJwcODo6ch1F5cyfPx8TJ06sNaFRdampqQDejPd5/vx5DBo0SOp+NPY7IfIzYbwzdDQ18TAxnusochEdHQ0bGxuuYzSICmFCWjhXV1f4+/sjLy+P6yiNVllZCR8fHzg5OXEdRaU4OTlhzZo1mDRpEl69eiV1H11dXejp6Ul+dnR0lMwERQhRnBnTpyO3qBDPXmRwHUUuHj9+jA4dOkAoVNzspM1BhTAhLVjXrl1hY2OjcuNTAoCXlxfat2+vMvPVK9rx48cRGBgIa2trJCUlwc3NDbt370br1q3h4+OD0NBQ7N27F8Cb4fOuXr0KADA1NcWdO3cQFhaG+/fv4+rVq/Dy8uLyUghROyYmJhg3ZiweJj6Dary50XRVL8z16NGD4yT1U9zcqYQQhXN1dQWgmvPXe3t7A3jzlLP6WLnkjVmzZtVad+DAAan7pqWlYcKECQDejCHcr18/uWYjhNRv+vTp0NDQwIPEp1xHkZvqI0fEPFPe66QnwoS0YK6urggNDcXz58+5jtJkKSkpiIiIoO4RhJAWZ+7cuQgLD0fGy3yZnZMxQGhkUOdsb4oWHx+PsrIypX9hjvvfFCFELtq2bYvhw4er5NPgKl5eXhg5ciR0dXW5jkIIITLRr18/iEQinDh9Sqbn5Qv4cN+7s87Z3hStvLwccXFxSv/CHBXChLRQEydOBJ/PV+lC+Pr169DW1sbo0aO5jkIIITLx+eefo7CwEEfrGN6wJYmOjqYnwoQQbkyZMgWJiYkICwurdz8dPaHcv06r/pWdjl79bxBXz/MgLBTFxcXUPYIQ0iKYmZlhxowZOHDgAPJl2C1CWT1+/BhdunSBpqYm11HqRIUwIS2QsbExxo8fj1OnGv7qTaCpIfev06p/ZSfQrP8d3ep5yisr4Ofnh/Hjx8snGCGEKNDSpUuhoaGBXbt2cR1FIaKjo6GhoYGuXbpwHaVOVAgT0gLNmDEDmpqaOHLkCNdR3tr169fRvXt3dO7cmesohBDSbDo6OliyZAkuXbqEZ8+ecR1HIZ48eQIA6Na1G8dJ6kaFMCEt0Ny5cxEWFtYiJkqoGv924sSJHCchhJDmmzt3LoyNjfHzzz9zHUVhqgrh7t2oECaEKEj37t0xaNCgFvE0GACePXuGx48fUyFMCFFZGhoaWLVqFR4+fIiAgACu4yhMUVERkpOT6YkwIURx5s6di4qKChw/fpzrKDJz5coV2NnZoXXr1lxHIYSQJlu0aBGsra3x7bffch1F4WJiYtC9OxXChBAF4PF4mDNnDm7cuIH09HSu48jM5cuXoaWlRaNHEEJUjp6eHr799lv4+/vj8uXLXMcBoNjJN548eUJPhAkhijFixAh07NixxXSLqBIYGIjs7GzqHkEIUTlffPEFTE1NsXr1aq6jSChy8o2YmBgYGhigtU4r+TbUTFQIE9KCLFq0CAUFBTh//jzXUWSqoqICnp6eeO+998Dn022LEKIa2rVrhy+++AKnTp2CWCzmOg4nql6YM2mtz3ES6ehvFEJaiDZt2mD69Ok4fPgwiouLuY4jc5cvX0bbtm0xePBgrqMQQkijbN26FZqamli/fj3XUTjzv0LYgOMk0lEhTEgLsWjRIujo6ODXX3/lOopceHl5oaysDC4uLlxHIYSQBjnY22PBggX44Ycf1GbcYGmSkpJQXFwME30qhAkhcsLn8/Hxxx/Dz88Pjx8/5jqOXOTn5yMgIIAKYUKI0tPR1MTu/+xCVFQUNm3axHUcTjHG8DQ+Xj2eCBsYGOCvv/5CdHQ0Hj9+jCFDhsjy9ISQOrz33nvo2LEj9uzZw3UUubp8+TJ69+6Njh07ch2Fc/v370dGRgYiIiIk64yMjODt7Y3Y2Fh4e3vD0NBQ6rHz5s1DbGwsYmNjMW/ePEVFJkRtTOorgpmpGRYuXIjS0lKu43AuNi5WPZ4I79q1C9evX0fPnj3Rt29fREdHy/L0hJA6LF26FCkpKbhw4QLXUeTqypUrAGiWOQD4888/MX78+Brr1q1bh5s3b6J79+64efMm1q1bV+s4IyMjbNiwAYMHD8agQYOwYcOGOgtmQkjT9TAzx9Au1ti1+xe1fUHun+KePsU7unrQ1tbmOkotMiuE9fX1MWrUKOzfvx8AUFZWhvz8fFmdnhBSh65du2L8+PH4/fffUV5eznUcuXr69CliYmKoewSAgIAA5OTk1Fjn6uqKQ4cOAQAOHTqEyZMn1zrOyckJPj4+yM3NRV5eHnx8fGoV1ISQ5mnXrh1mDx6F1LxcfLd9G9dxlEZsXBz4fD66dO7MdZRaZFYId+rUCS9evMDBgwcREhICDw8P6Orq1tjH3d0dYrEYYrEYxsbGsmqaELW2cuVKlJSU4Pfff+c6SqNUH8hdR0/Y5OMvX76M0aNHQ09PTw7pVJupqalkIpX09HSYmprW2sfc3BxJSUmSz8nJyTA3N5d6PrpnE9J4AoEAh/7YD02BAIfu3UJJSQnXkRQ6cUZ9YuPiAEApJ9aQ2W9FQ0MD/fv3x969e9G/f38UFRXV+lrOw8MDIpEIIpEIWVlZsmqaELVlYmKChQsX4vDhwyozk1z1gdwFmhpNPv7KlSvQ0tKCo6OjHNK1LIyxtzqe7tmENN6WLVswbOgwnH5wD5kFyvGNuCInzqjP0/inAIDu3VpwIZycnIzk5GTcv38fAHDmzBn0799fVqcnhEjx6aefQktLCz/++CPXURTm7t27yMnJoe4RUmRkZMDMzAwAYGZmhszMzFr7pKSkwNLSUvLZwsICKSkpCstISEs0efJkrFu3DvsPHkDIc/UdKq0uRUVFyC0uatlPhDMyMpCUlITu3bsDAMaNG9dih3EiRBkIhUIsXboUFy5cQGxsLNdxFIZmmavbpUuXMH/+fADA/PnzcfHixVr7eHl5wdHREYaGhjA0NISjoyO8vLwUHZWQFqNv3744evQogoKCsGb9l1zHUVovXua37CfCwJunU8eOHUN4eDj69euHrVu3yvL0hJBq3N3dYWRkhB07dnAdReGuXLkCExMTDBo0iOsonDl+/DgCAwNhbW2NpKQkuLm5Yfv27XBwcEBsbCzs7e2xfft2AMCAAQPg4eEBAMjNzcXmzZslfX83bdqE3NxcLi+FEJVlYmKCS5cuIScnB5MnT1aKfsHKKqMgH926deU6Ri1N76BXj/DwcIhEIlmekhAihaamJj7//HP4+/sjODiY6zgKd/36dZSXl8PFxQVBQUFcx+HErFmzpK63t7evte7hw4dwd3eXfD548CAOHjwot2yEqINWrVrh/PnzMDY2xogRI5CRkQGhkXKOlasMMl/mw6BbT5iZmSnVOy30vSIhKmjBggXo0KGD5ImfusnLy8OdO3cwYcIErqMQQtSQhoYGTp06hSFDhmDu3LkIDQ3lOpLSyyzIAwD06NGD4yQ1USFMiIrR1NTEV199haCgIFy/fp3rOJzx9PRE37590a5dO66jEELUCI/Hw/79++Hi4oJPPvkE586d4zqSSsh4+WYkDSqECSFvxc3NDVZWVtiwYQPXUTjl6ekJADQZBCFEoXbu3Il58+bh66+/xr59+7iOozLyXxWjsLCQCmFCSPNpaWnhq6++wr179+Dt7c11HE5FREQgJSUFzs7OXEchhKgBPp+P33//HcuXL8fPP/+M7777jutIKic2Lk7pCmGZvixHCJGvRYsWwdLSEm5ublxHUQrXr1/H1KlTIRAIUFFRwXUcQoiK0NETSib0qSgrx+vConr31dFtBY+9v+GD96di8+bN+Pe//92kczQ3G6tk4PHfzITB5cxwzVH9Oqqyx8bFYujgIVzGqkW1fquEqDFdXV189dVXuHPnDm7cuMF1HKXg6ekJQ0NDDBmiXDdWQohyE2hqNHqGS7N2Zrj/6BE+eH8q1v/7a/z73/9u8jmam42vIVCKmeGao/p1VGWPjYuDlZUVdHV1uQ1XDRXChKiINWvWwNzcHGvWrOE6itK4ceMGysvLqXsEIUQuBg0ahIBbfrBq0xbHgm/jv7t3cx1JpcXGvZn8ydramuMk/0OFMCEqwMLCAqtXr8aJEycQGBjIdRylkZ+fj3v37lEhTAiRKT6fj5UrVyIgIABlZeX4782rePB3PNexVN6T/58FVZn6CVMhTIgK2LZtG3g8HtatW8d1FKXj6emJ/v37w9TUlOsohJAWoFu3brh9+zZ++uknXLt2DaPGjkZKXg7XsVqE+GfPUFFRQYUwIaTxBg0ahDlz5uCnn37C8+fPuY6jdGgYNUKILPD5fKxYsQJhYWGwsbHBnDlzMGXKFOTm5XEdrcUoLS3Fs2fPqBAmRN3o6AkhNDKA0MgAOnrCRh+nqamJvXv3Ii0trdmzyDW37SqModHHV99XEW846+gJ8fT538jIyMB46h5BCGmmqqfAO3fuhK+vL3r37o1jx45xHatFiomJoUKYEHXT3LeLN2zYgP79+2PJkiUoKmre0Dxv+2YzX8Bv9PHV91XEG85V15b0qhBjx4wBj6dir1UTQjg3e+YshIWFoWfPnpg7dy5cXFyQmprKdawWKyYmBt27dwefrxwlqHKkIITUMmzYMKxbtw779+/HpUuXuI6j1GIzUmFiYoLevXtzHYUQoiI0BQLMGDQC+/b8iqCgIPTq1QtHjx7lOlaLFxMTAx0dHVhZWXEdBQAVwoQoJT09PRw+fBiJiYlYsWIF13GUXmzGm6c3Dg4OHCchhChCVZevpnb3qjqufXtzLB83AaKOXbFtx/dwcHBAenq6nNLKlqK7oDWl7cZki4mJAaA8I0dQIUyIktHU1MTx48fRqVMnzJs3D4WFhVxHUnr5r4rxJPYJ7O3tuY7Cue7duyM0NFSy5OfnY/ny5TX2sbOzQ15enmSfb775hqO0hDRPVbeopnb3Emhq4JvjB+Hr5Y02eq3hcdsH323fhsrKSjkllT1Fd0FrStuNyaZshTBNsUyIEuHz+Th69ChcXFywZMkS3L17l+tIKsP3lh/mzZkDLS0tlJaWch2HM7GxsbC1tQXw5s9TSkoKzp8/X2u/gIAAuLi4KDoeIZwaOXwEPhv7HnKzs/GL7zWk5uVyHUnt5OTk4MWLF0pTCNMTYUKUBJ/Pxx9//IFp06Zh5cqV2LdvH9eRVMotfz8IhUIMHTqU6yhKY9y4cYiPj6dh9wgB4OLigvN/nUH+q2KMdXKiIphDMTExsLGx4ToGACqECVEKnTp1gp+fHxYuXIgNGzZg586dXEdSOQF376C8vJy6R1QzY8YMnDhxQuq2oUOHIiwsDNeuXVOav5AIkZfZs2fj3LlziIiKxC++nkhJTeE6klqLiopCr169uI4BgAphQjglEAjw0UcfITw8HO+++y7mzZuHTZs2cR1LJRUUFCA4OJhemPt/mpqamDRpEv76669a20JCQmBlZYV+/frhl19+wYULF6Sew93dHWKxGGKxGMbGxvKOTIhcrFq1CkePHoW/vz9cpkxGcWkJ15HUXmRkJIyMjNCuXTuuo1AhTAgXtLW1sWTJEsTGxmLfvn24f/8++vTpgyNHjnAdTaX5+Phg4MCBMDQ05DoK55ydnRESEoLMzMxa2woKCiTjUnt6ekJTUxNt2rSptZ+HhwdEIhFEIhGysrLknpkQWdLS0sL+/fvx448/4vTp05gwYQK9fKwkoqKiAEApngpTIUyIAmlraGD5p58iISEBe/fuRWZmJlxdXeHg4ICkpCSu46m8GzduQCAQYMyYMVxH4dzMmTPr7BZhamoq+VkkEoHP5yM7O1tR0QiRu65du+LGjRtwc3PDxo0bMWPGDJSU0JNgZREZGQkASjH2O40aQYgC8Hg8jOpuA0ebfhBO1YaPjw9mz56NW7ducR2tRbl//z4KCwsxZswYqSMlqAtdXV04ODhg8eLFknVVP+/btw8ffPABPv74Y5SXl+PVq1eYMWMGV1EJkanWrVvj66+/xooVK1BSUoLp06fj9OnTXMci/5CVlYXMzEyleCIs00KYz+fjwYMHSElJoWF5CPl/VlZWOHL0KEbaDkZ0WjKWzJ2H2zepAJaHsrIy3LlzB2PHjuU6CqeKi4tr9emtPgrJnj17sGfPHkXHIkSmNPgCWJhbQNipC0QiEZycnDBu3Djo6+vjwIEDWL9+PTIyMriOSeqgLC/MybQQXr58OaKjo6Gvry/L0xKist577703X0/zgOPBARD//RQPQ0K4jtWi+fr6YseOHTAxMZHaP5YQonq0tbUxc/YsTJo0CVYdrGDVoQPatGmDHz6cJ9knMTERJ0+exO+//46HDx9K1uvoCSUTbyh6JrbGqpqRDVDejLIWGRmJ+fPncx1Ddn2Ezc3NMWHCBPzxxx+yOiUhKs3FxQXnz59HbGwshowYAfHfT7mOpBZ8fX0BgPoJE9ICCIVC7NixAykpKTi4/wBG29ujlVlbnL90EVcfPcTS5Z/C1dUV1tbW6NixIxYvXlyjCAb+NwsdFzOxNRaXs8VxJSoqCvr6+rC0tOQ0h8yeCP/nP//BmjVr0Lp1a1mdkhCVVTVsVWhoKJycnFCuHv/AVwqhoaHIy8vD2LFjcerUKa7jEEKaqVOnTrhw4QJ69eqFM2fO4MiJY+g+cwoYgD9Wf4F/7fkJh44cQVFuPtdRSTNUjRzRu3dvTl8Wl8lfzxMmTEBmZiZCGvjKl8akJOpgzJgxOHPmDEJCQuDo6Ij8fNncpHX0hBAaGUBoZABdA30IjQygoydscF9pX7M1tF1Rqr4OrOs6pGkoe2VlJfz9/dW+nzAhqmzs2LEQi8WwsLCAs7MzZsyYAb/bt8G4DkZkRlmGUJPJ34DDhw/HpEmTkJCQgJMnT2Ls2LFSx0OlMSlJS9exY0ecPn0asbGxcHJywsuXL2V27upf7/E1BHDfu1PS762+faV9zaYsXxVWfR1Y13VI05jsvr6+6Nq1K+dfuRFCmm7YsGG4du0a0tLSIBKJ4OPjw3UkIge5ublITU1tGYXw+vXrYWlpiU6dOmHGjBnw9fXF3LlzZXFqQlSGrq4uLly4AIFAAFdXV5kWwaRpqJ8wIaqpqjtEYmIiRo0ahWfPnnEdichRZGQk52MJU89FQmTkwIED6N27N2bOnIn4+Hiu46i1qKgovHjxgrpHEKJC9PX1ceXKFQgEAkycOBG5ublcRyJyFhUVBRsbG/B43H01KfNC2N/fn8YQJmpnxYoVmD59OtavXw8vLy+u46g9xhhu3bpFhTAhKuTYsWPo1q0bpk6diri4OK7jEAWIioqCrq4uOnXqxFkGeiJMyFsaPnw4duzYgXPnzmHHjh1cxyH/z9fXF5aWlujWrRvXUQghDVi2bBkmTpyIlStXws/Pj+s4REGqplrmsp8wFcKEvAUTExOcPn0af//9NxYuXMh1HFIN9RMmRL6qj+DSlJFf/qlXr1744Ycf4Ol1HQePHalxLkWPcCNtdJ7mtls1Ks4/fz9VbajLxBn1efz4MQBw2k+Y/i8Q0kxaWlo4ffo0DA0NMXXqVHo5TsnExcUhOTmZukcQIifVR3Bpysgv1Wlra+PEiRPIz8/HJ58uq3UuRY9wI210nua2W32SDGnXpC4TZ9SnoKAAz549Q9++fTnLINMplglRFzweD4cPH4adnR1mzpyJiIgIriMRKXx9fTF+/HiuYxBC6rB9+3b06dMHzs7OeEHDqqqlkJAQ9O/fn7P26YkwIc3www8/YPr06Vi9ejVOnjzJdRxSB19fX5iYmHA+TiUhpDYHBwesWLEC//3vf3H9+nWu4xCOhISEoFu3btDX1+ekfSqECWkCHo+HjRs3YtWqVfjPf/6DH3/8ketIpB63bt0CAOoeQYiSadOmDf78809ERUVh7dq1XMchHKqalbhfv36ctE+FMCGNZGhoiIsXL2LDhg04ePAgVq5cyXUk0oDnz58jPj6eCmFClMy+fftgbGyM2bNn4/Xr11zHIRwKDQ0FAM66R1AhTEgDNDU1MXXqVDx48ABOTk5YunQp3NzcwBjNeq8KfH19MXr0aPD56nO7S0hIwKNHjxAaGgqxWCx1n127diEuLg7h4eGwtbVVcEKizhYvXoypU6di/fr1CA8P5zoO4VhmZiaSk5M5K4TpZTlC/sHAwADdunVDt27dMGDAAMyZMwempqaIj4+HnZ0dgoKCuI5ImsDX1xfu7u6wtbXFw4cPuY6jMGPGjEF2drbUbc7OzpI/44MHD8bevXsxZMgQBSck6kgkEmHXrl3w9PTEzz//zHUcoiS4fGGOCmGi9vr374+FCxdi0KBB6NKlC9q0aSPZVl5ejsuXL2Pfvn3w8fFBZWUlh0lJc1T1Ex4zZoxaFcL1cXV1xeHDhwEAwcHBMDQ0hJmZGdLT0zlORlqyNm3a4MyZM0hLS8OcOXPoWzUiERISggkTJkBXVxfFxcUKbZsKYaK2Jk6ciM2bN6Nfv3549eoV7t69i7/++gvx8fGIi4tDXFwc4uPjUVJSwnVU8hYyMjIQFRWFsWPHqs3LjYwxeHt7gzGGffv2wcPDo8Z2c3NzJCUlST4nJyfD3NycCmEiNwKBAMePH4eJiQmGDx+OnJwcriMRJRISEgKBQIB3331X4d+6UiHcDDp6Qsng2BVl5XhdWMRxIsWSdv3V17FKBh6fV2O7sqjKufaL1fhm/VeIjonG8s8/x6GDB5Gfn891PABN+/NVNXMRUPP3Lq8Zi6q3p4hZkaRdX1ParfpdBty9i7mzZ0NLSwulpaXyiqs0RowYgdTUVLRt2xY+Pj6IiYlBQEBAk8/j7u6Ojz76CABgbGws65hEjfz2229wdHTEokWLJKME1EXR9xlFaInXJEuPn8QAAIaOGI6wyAiF1g30f6MZZDGbjiqTdv3SZuNRxt+Pnn5r3AkLxTfrv8KJ06dwMFKM/YeUpwgGmvbnq/rMRdV/7/Kasah6e4qYFUna9TWl3arfpUbPzhAKhRg6dKj8wiqR1NRUAMCLFy9w/vx5DBo0qMb2lJQUWFpaSj5bWFggJSWl1nk8PDwgEokgEomQRZMdkGbatGkT/vWvf2HLli04cOBAg/sr+j6jCC3xmmQp/UUmCl6/wrSPP1J43UCFMHlrM2cCj8Ne4udpbvhm4mp8+L7ydiXYs+u/eNeyIy6GifHRJx+jrKKC60hEAZ5mpqO8vByOjo5cR5E7XV1d6OnpSX52dHREZGRkjX0uXbqEefPmAQAGDx6M/Px86hZB5GLp0qX45ptv8Mcff+Cbb77hOg5RYsm52bAwatPwjjJGhTB5Kx9OLYWHB9ChAwOPB7wjzMbu/xSjf4dArqPVsnTpUkz74ENci3gIvyeRDR9AWoyS8jLcfyCGg4MD11HkztTUFHfu3EFYWBju37+Pq1evwsvLC4sXL8bixYsBANeu+Vib6QAAIABJREFUXcOzZ8/w9OlTeHh44JNPPuE4NWmJFi9ejN27d+PixYtYsmQJ13GIkkvOzUY7AyNoaWkptF3l+t6aqBQdTU385ydtCIWvaqzX1QUmvHsOIc+V52voIUOG4Oeff8ZVT0/4vqQnX+rI99YtrF+7Du+8806LflEnISFB6gxN+/btq/F52bJliopE1NDSpUuxe/duXL58GdOnT0cFfftGGpCSmw0Bnw+bnj1xN+OFwtqlJ8KkWTq8Y4wvHF2h31p631ojXeUpNIyMjPDXX38hKSkJiz9ZAhqwRz35+t0Cn8/HuHHjuI5CSIu2YsUK7N69G+fPn8fUqVNp5B3SKM9z3ox7PmigSKHtUiFMmuyTxUvw2bgJ4PGAjExtqfvweB0womtPBSeT7rvvvoOZmRmmTZuGPCV6KY4o1sOQEOTl5alF9whCuLJ+/Xrs3LkTf/31F6ZNm4aysjKuIxEVkVtciLziIgxT8EvNVAiTJlm4cCF2bNuOqNQk/OB1CV9+zUPRP0Y5KS4Gnmd/jin9B8NlwkRugv6/AQMGSPqpNTRkD2nZKioqcOvWLSqECZGTLVu24LvvvsPhw4cxc+ZMlJeXcx2JqJhnLzIwbAgVwkRJjRs3Dvv27cMN35s4dO8WXpeV4q+zWnB3B54/54ExIKeoDZat0MXuW0Z4nvMCB3734GzqVh6Phz179iAzMxMbNmzgJANRLt7e3ujYsSO6devGdRRCWpTNG7/FV199hX379mHBggXUJ5g0S/yLdLRv3x6dOnVSWJtUCJNGsbGxwdmzZxEdHY25CxegstrUmCdOADb99LHy9AFsvvID/jqnjbKKCvwRcAMpqak4c+YM9PX1FZ7Zzc0NgwcPxhdffIGXL18qvH2ifHx8fACAngoTlaKjJ4TQyAA6esJa6+paX32dvDn3tsXnny3Hnj17sGTJkganTq4rOyHPsjIAACNHjlRYm1QIkwbp6enh/PnzKC4uxsSJE1FQUNCo44pKSrDQfRHMzMywY8cOOaesycDAANu3b8ft27dx7NgxhbZNlFd8fDyePXsGJycnrqMQ0mhVE8NUn2igrol3pO0rTw42feHYqx8OHj6ETz/9tFHHqPukVKRuGfl5yMnNVc1C2MLCAr6+voiKikJkZCQ+++wzWZ2acGz37t3o0qULpk+fjqSkpCYdGxoWhp9++gmLFy/G6NGj5RNQirVr18LY2BjLly9XWJtENVy7dg329vbQ0dHhOgohKu3jjxbjvT79IU54is8+X9Hgk2BCGsIABAYFqWYhXF5ejlWrVqFXr14YMmQIli5dip49lWPUANJ8s2fPxvz587F582YEBAQ06xwbN25EXFwcPDw80KpVKxknrM3c3BwrVqzAkSNHEBYWJvf2iGq5fPkydHV1MXbsWK6jEKKyPvjgA3y/dRseJSfihPgOFcFEZu4F3YO1tTVMTEwU0p7MCuH09HSEhoYCAAoLCxEdHQ1zc3NZnZ5woEuXLti7dy9u376NLVu2NPs8r169gru7O7p27YqNGzfKLmAdNm3aBD6fT9N5Eqn8/PxQUFAAFxcXrqMQopJGjRqFo0ePIuh+MI4G+VMRTGTqXuCbmWlHjBihkPbk0kfYysoKtra2CA4OlsfpiQJoamri5MmTKCsrw+zZs9/6DWB/f38cOHAAn3/+OaytrWWUsrbevXtjwYIF+OWXX5CYmCi3dojqKi0thbe3NyZO5HZoP0Kaa+ZM4HHYS/w8zQ3fTFyND6eWKqxtGxsbXLx4EfHx8Zg+aybKaHQIImNh4eEoLi5WWPcImfdSFwqFOHv2LFasWFHrpSp3d3d89NFHAABjY2NZN622dPSEkhcOKsrK8bqwqIEjGrZt2zYMHDgQkydPRnJy8lufDwC+/PJLvP/++/hl925MmfYBANnkrX79P/z4I/Lz87F161ap23m8+v/t15jfZdU+rJKBx+cBQIM/V2+XMUBoZFCrjarz1rVvQ9lVmayvU9rvsrrLly9j6tSpsLW1lXyTRYgqmDkT8PAAhMI3T2HfEWZj9y6g5P/Yu++wKK62D8C/3WWpIiIoIs1GVZqCYomAxkKMmldNhCS2GIy+tmgSE9PUWN6YRI2xJmjUGEWNFZWoqKiAiCCggqigdESk97rz/cG3G4mUBWZ3dtnnvq65hN0z5zwz4NmHM2fOlNWv4CNLRkZGCAwMREVFBby8vFBQQg8oIuyrqanBLTnOE2b1k1VNTQ0nTpzAoUOHcOrUqVfe9/Pzg6urK1xdXZGbm8tm0yqN7Ttwx48fj08++QQ7duzAmTNnWIiwnng93zGvv46tASdYi1d8/D+dOorx48Zh/fr1KCgoeOV9311bAJ50dTUXm7gMX00gKdvS1y+3yxfwm73bu6myLcWuzNg+zsbO5csCAwMhEoloegRROhs2ADr/WnFMR7v+dVnS1tbG2bNnYWhoiDfffBNpaWmybZCotJCQEDg5Ocll6VVWE+G9e/ciISEBW7ZsYbNaIkfGxsY4cOAA7t27h08//ZT1+nfu3IkHCQ/wltNgCAUC1url83h4y2kwnjx9im3btrFWL+mYXrx4gVu3blEiTJQGj8fDvLkfwsKi8b/uLCzqp7TJgkAgwOHDhzFw4EB4e3vTUzqJzF2+fBkCgQBjx46VeVusJcLDhw/HzJkzMWrUKMTExCAmJgZeXl5sVU/kQFNTE6dPn4a2tja8vb1RWVnJehu1tbX49PPPYdBJF6/bOrJWr1sfK/TQ08c3q1ehulp+8+WI8jp79ixcXFxgbGzMdSikDVTpoQwO9g74+PUJ2PzjT6iuNmq0DI9ngQcPHuCtSZNYbZvH48HPzw+TJ0/G4sWLce7cuUbLiac3NfWAD229zpL3G5v+9e/X2+Ll34mm2msvNuMlTbt58yZyc3MxefJkmbfF2k8xLCwMPB4Pjo6OcHZ2hrOzM/7++2+2qidy8Pvvv8PFxQXvvvsuEhISZNbOjdAQRKYkYbStPexYWGJPr7MevAYMRFLOMwScO8tChEQVnD1b/7vS0W6ak2ZNd3d3dxQWFkoGLZRxhRVVeSjDsmXLcOPKVXTR0sFs3w9xLHoiqmvVG5QpKwe+/74zKioq8Of+PzBrqAc667JzSXnTpk2YM2cOvv32W+zatavJci1N+Xp5ypispn+9/DvRVHvtpSrT1bgmEolw7tw5TJgwAWpqsv3/TX/OEADAl19+CR8fH3z55ZeSBEGWzsTeRkVNNX7Z8jN4vPb1Jl9+8QW0NTRwJjaSpeiIKoiPj8eff/6JZ8+ecR0Kq6Rd0z0kJEQyaLF27VoOIiXN4fF42LRpEzZv3oxzgefx/d+ncOLUSUSnDcXRyFlIS+eDYYD8MgMsWqqFlSvvw8nJCd+sXgV7UwuEXrsOFxeXdsXw3XffYdmyZdi6dSv9jhC5O3PmDPT19WW+jBolwgRLly7F+vXrcfDgQWzcuFEubZZVVeFM7G24DR6Cjz76qM31jBw5EgvmfYSwpIfIKMhjMUKiCmbMmNHkpV5lRWu6Kz+hUIjDhw9j+fLl+PnnnzFjzmxU1Pwz5Ss6bSj6O+th+bHfsfbcj/jrRP0IsUgkwpZftmL71b+hpqaGsLAwfPrpp60ebFBTU8OePXvwzTffYO/evVi2bBmrx0eINIKCglBZWSnz6RGUCKu4r776Cj///DNOnDiBDz/8UK5tR6U8QfC1a9i4cSN69erV6v11dHSwb98+JKek4NzdKPYDJETJNbem+9ChQxEbG4vAwEDY2dlxEB1pjLq6Ok6cOAFvb2989tlnWLZsWasfWJGSl4NhI0cgICAAP/74Iy5evIgePXpItW/nzp1x9uxZzJ07F2vWrMGHH35ID8wgnCgrK8Ply5cxieV57/9GibCKEgqF2Lx5M9atW4c//vgD06dP5+Qms8XLlqKurg6nTp2CtrZ2q/b98ccf0atXL8xf+F9U19XKKEJClFNza7pHR0fDwsICTk5O2LZtG06fPt1oHb6+voiMjERkZCSt/S4HGhoaOHnyJCZOnIgFCxbgp59+anNdhUVFePvtt+Hr64vhw4fj4cOH+Pbbb6Grq9toeT6fD19fXzx+/BijR4/GBx98IJcngRLSnDNnzqBPnz4YMGCAzNqgRFgFOTs7IyoqCsuWLcO2bdswe/bsdj85rq1SUlPh4+MDBwcH7N27V+r9pk6digULFmDz5s0Ij7glwwgJUT4treleUlKCsrL6B7n8/fffEAqFMDAweKUcrf0uP5qamjh58iQmTJiAefPmYffu3azUu2fPHjg7O+Py5ctYs2YNnj59iu3bt2Pu3Llwc3PDtGnTsGHDBty9exe//fYbHj9+DDc3N+zbt4+V9glpD/HUNVlOj6BEWIX07dsXP//8MyIiImBoaIiJEydiyZIlnF/2unjxIlauXAlvb298/vnnLZafPHky/P39cfPmTaW8250QWWtpTXcjo3+W4HJ1dQWfz0deHs2x50rnzp1x8eJFjB8/Hh9++CH8/PxYrf/x48eYNm0aBg0ahLCwMMyYMQN79uxBeHg4/vrrL3z66aeorKzEtGnTMHLkSFonmCiM7Oxs3Lp1C2+99ZbM2ui4a84QAPUfeGPGjIGPjw/eeOMN1NTU4I8//sBnn33W4OlrXPvhhx/g7OyM77//Hubm5li+fDmqqqpeKffmm2/i2LFjuHPnDsaPH4/KykroaGlwEDEhikm8pvu9e/ckN819+eWXMDc3BwD8+uuvmDZtGhYsWIDa2lpUVFTA29uby5BVmqGhIS5evAh7e3v4+Pjg2LFjMmsrOjoab731Fng8Hnr37o3+/fsjMzMTcXFxtP46UVh//fUXNm3ahAEDBiAuLo71+ikR7mAMunbFWI9RcHd3h6enJxwcHAAAWVlZWL16NX799VdkZ2dzHGXjZsyYgfT0dHz22WcYOnQoFi5ciNjYWFRUVMDJyQnLly+Ht7c3YmJiMG7cuFfmPRJC/lnTvTk7duzAjh075BQRaYqDgwNOnDiBnj17YtKkSbhw4YJc2mUYBk+fPsXTp0/l0h4h7bF//36sX78eCxYswMKFC1mvnxLhDsDIyAivWdrCwdQCPz2aCYFAgPLycoSHh+Pzzz/HpUuXcPfuXc6nQLSktrYWK1aswI0bN3DgwAHcvHkTIpEIz549g4mJCUpKSrBjxw6sXr0axcXFXIdLCGkHzU46kgcv1NXUorK0rM11iZ/2JU1drWm3rTFKs9+sWbOwa9cu5OfnY/To0bh1q+33Orx8/G152llT8b78OiNiwOPzpDoP7Y1H3tiIV1yHMhyvonj596u585afn4+jR49ixowZ+Pzzz1FaWspqHPQTU2L9+/fHvn37kHD3PqYMdEMnDU38uHkThg8fji5duuD111/HDz/8gNjYWIVPgl927tw52NjYYOrUqVi1ahWCg4Px6aefwszMDMuWLUNRURHXIRJC2omNJ8MNNA/HN29+hpK8IqSlq2HX+XdarKs17bY1xub2MzExweHDh7F//37cvHkTzs7O7UqCgfY/7aypeBt7Ups050HZnr7GRrziOpTheBXFy79fLZ23nTt3QldXF++//z7rcdCIsBLq168fNm7ciClTpqCsrAx79+1DoVk35JQUwe9/G1BWoPyJ4osXL3Dy5EmcPHmS61AIIQro7anVmO56AOpq9XNbu+rkYbrrAVydKsD+PRwH1whdXV0sXboUX3zxBQQCAVatWoV169ZBJBJxHRohCu/27duIjo7GggULWFtRRUzpEuHGLtUAjV9+ak3Z1hpoHo4JDiex6e0ipKUBX34J+Ps3H29T7YrLtBSXvr4+vvnmGyxatAiVlZVY//3/8KvfbygoLMKHOzfVH2cLlwibOieNnZ+myr58CaOly0GtuWTZVJyt2U/cXlv2ARo/NqDp428veV9C7MiX71o6l039PNnoD4h8ODo6YsyYMXB3d4eX1wIIBBkN3ldXq8ZvO3tihNs2XLt2DZcvX+b0nggejwe3IUPw7tvTMX36dOjo6OCvv/7CZ599htTUVM7iIkQZ7dy5E3v27MHw4cMRFhbGWr1K92nY2KWapi7XtKZsa4hHIrrq5IHPB3r1Avz8AB+f5uNtql1xmSbfFwgwf/58PH78GEuWLMG+ffvg6DoIub17YOqGbxtcUnj5Ek9rzklj56epso2119RljZbiaUpbL0mK22vLPk0dW3PH317yvoTYkS/ftXQum/p5trc/ILJlamqKlStXIj4+HrGxsfjxxx9haWkJPj+j0fJqas8wZcoUHDx4EJmZmQgNDcWyZcvQu3dvmcapra0NOzs7vPXWW/jk42X48LXXsf4tH1z++yLeeecdHD58GK6urnjnnXcoCSakDfz9/VFYWIgFCxawWm+H+QR4e2o1Vn0FmJtDMkIbIIMbcLW1tfH9ekZyOU5MRwfYulUb4eHdkZKSwlp7b775JtatWwdHR0dcu3YNS5cuxb179yQjW4QQ0hGNGjUKCxcuxOTJkyEQCHDjxg3MmzcPZ8+eRXZ2NlJTeTA3f/Xeh/R0oHdvQzg4OODNN9/ElClTsHnzZmzevBlxcXG4EHQJuj1MkJ4v3QNCtNXV0UVbB+PGjEXXznro2bMnjI2N0a1bN3Tv3h1GRkbo0aMHOnfu3GC/58WFiElPgd//fsDxo8dYv8GHEFVTXl6ONWvWsH6zfIdIhAeah2PK1gro/P8TesUjtBofs7MuopWVFaZOnYqxY8di2LBhUFfXbLRct24VSE5OxosXLxAWFobLly8j7Hbrb4IQCoWYMGECvv76awwaNAhPnjzBtGnTcOLEifYeCiGEKCwNDQ28++67WL58OQYMGIDc3Fz88MMP+O23314ZYFi1VhO/7qprMChRXauOVWsFEIkqEBsbi9jYWKxbtw69e/fGpEmTMHHiRHy8eAnU1Oo/+ua5vIaszEzk5OSgpKQEGhoa0NTUhL6+Pnr06AFjY+N/Hv0+7p8F/V+8eIGcnBzk5OQgJiYGz549w7Nnz5Ceno5Hjx4hKzcH3j98BwD46+QJlFESTAgrfv75Z9brVPpEWF9bB1MGBkDnX89U0NEBdmzthMj0wcgrK8FTD0901tRCcWVFi3Xy+Xy4urrCy8sLU6ZMgb29PQDgzp072LJlC+bM0UT37q/W8+yZEN99twCDBw+Gu7u75EkoheVlePriOXhzP0RUxG08evQIOTk5kv0EAgG6deqMiRPexKiR7pg6dSq6du2KpKQkzJ49G4cOHUJtbW07zhIhhCiurvr6WLZwMRYtWgQjIyPExsZi9uzZOHLkSKMP1gGAv06oY9QH72CCw0l00cpDYYUBzt+bgr9OHAPQsH9OTk7G1q1bsXXrVhiZmeDr/b/BvGs3lD9+iq5d9GFmZgZdXV1UVVWhqqoKRUVFiIiIQG5BPsyHDUZheRkOrFmPpIRHeP78OWpqapo9HrpiR4jyUMpEuIu2Dob1tca80JuwtbEB0PhTkbS0cuHWxwoaQiGmHK8fTS2trMTb5tZ4/Ogxnj59irKyMtTU1EBNTQ19+/aFpaUlBg0aBAMDA9TV1eHmzZtYsmQJTpw4gaysLADAwyQt/LpLvcFIRFkZ8Mkn1fD33y25o7FPnz6YMGkiZn28GH279cDmH3+SlC8vL0dNTQ3q6uqgo6MDDQ0NYMJUlJSU4PTp0zh69CguXLiAuro6GZ1FQgjhVhdtHXhaD8C6e3HQ0dHB+fPnsWnTJgQHB0u1f3TaUESnDcWehZ/gwx0//v+rzT+ZrbS0FE9ePMeTF8/ht2BZs6vs6Ojr1c85BxAZFdUhVuQhhDSkVInw8OHD8clnn2LShEngAbgecgOPKorgaW0APe1X53ulpwNbwv9EJw1NRP5+CPNWfw1jPX2IRAxef/11mJqaNihfWFiIxMREBAQE4OLFiwgKCkJ+fv4r9f57JKKpVSOePn2K3w/sh8DNEQDw97pNsOhpAmtra5ibm0NNTQ0CgQDVdbUwHuqC375ejYjQm6isrGTtnBFCCJcaWwHGxsYGX3/7LbwnTAMA+B85gu83bMCT1BQIhGrQ0ddrcVWbpjS2OkhrVwYRxyzNKjIttdHYfk0dW1Nft3eVl5ZWC2rqOFtafUURVp9RtHhI86T5eYnLtLUPaC2lSoS//vprDB4yBNcexSMsKQE/zpmPD3dsQknlfzDF0U8yRxioH6FdtVYTXV4HSqsqEXbzJmwTEwBAMgqgrq4ODQ0NCIVCiEQiFBYWSh2LeCSipRGFl2VkZuBRXDwuXbrU4HXxqEPUnTuUBBNCOhTxCjAAEL59Lz5ZshRTp05FZWUlQpMScO1hPH5c9F+UFRQ1GIGtH+Xd9MrXfguWNdseX8B/Zb+W9mkq5j0LP2m2XmnaaGy/po6tua/b4+WfQWNtNHecLR0P1xQtHtI8aX5e4jJt7QNaHROrtcnYvHnzYD3ADufuRaGg/J+/BqLThmLRUi2kpAAiEZCSAvj61o/cNqe6uholJSXIz89vVRJMCCFEemb6BvhgxGjcCgnFuHHj8L///Q92jvY4HXMbhRW0hjMhhDtKNSKcnp7e5E0If51Qx/49DW+Q0NGXR1SEEEIa4+LignUb1mPcmLEoq6rCuv9twKYffkRhYSHdUEYIUQhKlQgTQghRHiNGjIDLwEE4dy8KoYkPsf3HH1BWSDecEUIUh1JNjSCEEKI8du/eDTsnB1xJuI+q2uaXHCOEEC6wmgiPGzcODx8+RGJiIj7//HM2qyaEECKllvpidXV1HDlyBImJibh16xYsLCxkEkdlZSXKymgOMCFEcbGWCPP5fOzYsQNeXl6ws7ODj48PbG1t2aqeEEKIFKTpi+fOnYuCggJYWlpiy5Yt2LhxI0fREkIIt1hLhAcPHoykpCQkJyejpqYGR44cweTJk9mqnhBCiBSk6YsnT56MAwcOAACOHz+O0aNHcxEqIYRwjrVE2MTEBOnp6ZLvMzIyYGJiwlb1hBBCpCBNX/xymbq6OhQVFcHAwECucRJCiCLgAWDYqGjq1KkYP348fH19AQDvv/8+hgwZgsWLF0vK+Pr6Yt68eQAAa2trPHr0CABgaGiI3NxXnwynSugc0DlQ9eMHlOscWFhYoHv37lyH8Qpp+uL79+9j/PjxyMzMBAAkJSVhyJAhyMvLa1BXU312c5TpZ8gWOmbVoGrH3NGOt7k+m2Fjc3NzYy5cuCD5/osvvmC++OILqfaNjIxkJQZl3ugc0DlQ9eOnc8DOJk1ffOHCBcbNzY0BwAgEAubFixf0M6RjpmOmY1bJ42VtakRkZCQsLS3Rq1cvCIVCeHt7IyAggK3qCSGESEGavjggIACzZs0CAEybNg1Xr17lIlRCCOEcaw/UqKurw6JFi3Dx4kUIBAL8/vvvePDgAVvVE0IIkUJTffGaNWsQFRWFs2fPYu/evTh48CASExORn58Pb29vrsMmhBDOcD4s7evry3kMXG90DugcqPrx0znoGJsq/gzpmFVjU7VjVpXjZe1mOUIIIYQQQpQJPWKZEEIIIYSoJLkmwory2E8utXQOli1bhvj4eNy9exeXL1+Gubk5B1HKjrSP4Z4yZQoYhsGgQYPkGJ18SHMO3n77bcTHxyMuLg6HDh2Sc4Sy19I5MDMzw9WrVxEdHY27d+/Cy8uLgyhJc1SxP1e1/lsV+2tV7J+pP5bTHAw+n88kJSUxvXv3ZoRCIRMbG8vY2to2KLNgwQJm165dDABm+vTpzJEjRzifOyLvc+Dh4cFoaWkxAJj58+d3qHMgzfEDYDp16sRcv36dCQ8PZwYNGsR53PI+B/369WOio6OZLl26MACYbt26cR63vM/Br7/+ysyfP58BwNja2jLJycmcx01b636GHa0/V7X+WxX7a1Xsn6k/ZnH5tJbQYz+lOwfXrl1DRUUFAODWrVswNTXlIlSZkPYx3GvXrsXGjRtRWVnJQZSyJc058PX1xY4dO1BYWAgAePHiBRehyow054BhGHTu3BkAoKenh6ysLC5CJU1Qxf5c1fpvVeyvVbF/pv5YjlMj6LGfrX8M9dy5c/H333/LIzS5kOb4nZ2dYWZmhsDAQHmHJxfSnAMrKytYWVkhNDQU4eHhGDdunLzDlClpzsHq1avx/vvvIz09HYGBgQ2eika4p4r9uar136rYX6ti/0z9MYvrCBN2vffee3BxcYG7uzvXocgNj8fD5s2bMXv2bK5D4ZSamhosLS3h4eEBU1NT3LhxA/b29igqKuI6NLnx8fHB/v37sXnzZri5ueHgwYMYMGAAGIbhOjRCWqQK/beq9teq2D939P5YbiPCmZmZMDMzk3xvamoqec59Y2UEAgH09PSQl5cnrxBlTppzAACjR4/GV199hUmTJqG6ulqeIcpUS8evq6uLAQMG4Nq1a0hOToabmxsCAgI6xA0YYtL8DmRkZCAgIAC1tbVISUnB48ePYWlpKe9QZUaaczB37lwcO3YMQP0lZk1NTRgaGso1TtI0VezPVa3/VsX+WhX7Z+qP68llMrJAIGCePHnC9OrVSzIh287OrkGZ//73vw1urjh69Cjnk6jlfQ6cnJyYpKQkpl+/fpzHy8Xxv7wFBwcr/c0XbTkH48aNY/bv388AYAwMDJi0tDSma9eunMcuz3MQGBjIzJo1iwHA2NjYMJmZmZzHTVvrfoYdrT9Xtf5bFftrVeyfqT8GA3k25uXlxTx69IhJSkpivvzySwYAs2bNGmbixIkMAEZDQ4M5duwYk5iYyERERDC9e/fm+uTI/RwEBQUx2dnZTExMDBMTE8OcOXOG85jlefwvbx2hY23rOdi0aRMTHx/P3Lt3j5k+fTrnMcv7HNja2jKhoaFMbGwsExMTw4wZM4bzmGlr3c+wI/bnqtZ/q2J/rYr9s6r3x/RkOUIIIYQQopLoyXKEEEIIIUQlUSJMCCGEEEJUEiXChBBCCCFEJVEiTAghhBBCVBIlwoQQQgghRCX6PDteAAAgAElEQVRRIkwIIYQQQlQSJcKEEEIIIUQlUSJM2mzVqlU4ePAgJ21bWVkhJiYGxcXFWLx4cbNlLSwswDAMBAKBnKIjhBDFkJycjNGjR3PS9rBhw/D48WOUlJRg8uTJzZZ1d3dHenq6nCIj5B+UCBOFsW/fPqxdu1aqsitWrEBwcDA6d+6Mbdu2yTiy5jEMg759+3IaAyGEKJrvvvsO27dvh66uLs6cOcNZHDQYQppDiTBRCHx+634VLSwsEB8fL6NoCCGEtBf100QZUCJMpLJixQpkZGSguLgYDx8+xKhRowAA6urqOHDgAIqLixEXF4dBgwZJ9rGxsUFwcDAKCgoQFxeHiRMnSt7bt28fdu7cifPnz6O0tBRz587Fe++9hxUrVqCkpAQBAQFNxnLlyhV4enpi+/btKCkpgaWlJd544w1ER0ejqKgIaWlpWLVqVZP7z5o1C0+ePEFxcTGePn2Kd999V/LenDlz8ODBA+Tn5+PChQswNzdv9rxcv34dAHD37l2UlJTgnXfekVziW7lyJV68eIHk5OQGbXTt2hUBAQEoKirC7du3sXbtWoSEhDTbDiGEtIe6ujq2bNmCzMxMZGZmYsuWLVBXVwfwz7SE5cuX4/nz58jKysLs2bMl+7alz0pKSkKfPn1w9uxZlJSUQF1dHbNnz8aDBw9QXFyMJ0+eYN68eU3u39RnDo/Hw+eff46kpCTk5ubi6NGj0NfXbzaWGzduAAAKCwtRUlICNzc3zJo1C6Ghodi2bRsKCwuRkJAgaQMAevXqhevXr6O4uBhBQUHYvn07Z1MBiewxtNHW3GZlZcWkpaUxxsbGDADGwsKC6dOnD7Nq1SqmoqKC8fLyYvh8PrNhwwYmPDycAcCoqakxiYmJzMqVKxmhUMh4enoyxcXFjJWVFQOA2bdvH1NYWMgMGzaM4fF4jIaGBrNv3z5m7dq1UsUUHBzMzJ07V/K9u7s7M2DAAIbH4zH29vZMdnY2M3nyZEm8DMMwAoGA0dbWZoqKiiRx9OjRg7Gzs2MAMJMmTWISExMZGxsbRiAQMF999RUTFhbWYiwMwzB9+/ZtEEtNTQ2zadMmRl1dnRk5ciRTWloqadPf35/x9/dntLS0GFtbWyYtLY0JCQnh/OdMG220dbwtOTmZGT16NLNmzRomPDyc6datG2NoaMiEhYUx3333HQP802etWbOGUVNTY7y8vJiysjKmS5cuDND2Pkvctvj7N954g+nTpw8DgBk5ciRTVlbGODs7S2JIT09ngKY/cwAwS5YsYcLDwxkTExNGXV2d2b17N3P48OFm43j5M0D82qxZs5iamhrm448/ZtTU1Jh33nmHKSwsZPT19RkAzM2bN5kff/yREQqFzPDhw5mioiLm4MGDnP88aZPJxnkAtCn41rdvX+b58+fM6NGjGTU1Ncnrq1atYoKCgiTf29raMuXl5QwAZsSIEcyzZ88YHo8nef/w4cPMqlWrGKA+ET5w4ECDdtqTCP9727JlC7N582YGeDURLigoYKZMmcJoamo22CcwMJD54IMPJN/zeDymrKyMMTc3bzaWphJhbW1tyWtHjx5lvv76a4bP5zPV1dWSpBgAs3btWkqEaaONNpls4mQ0KSmJ8fLykrw+duxYJjk5mQHq+6zy8vIGieLz58+ZIUOGtKvP+nci/O/t1KlTzJIlSyQxiBPhpj5zADAPHjxgRo0aJfm+R48eTHV1dYPY/701lQhnZmY2KBcREcG8//77jJmZGVNTU8NoaWlJ3jt48CAlwh10o6kRpEVPnjzBxx9/jNWrVyMnJwf+/v4wNjYGAGRnZ0vKlZeXQ0tLCwKBAD179kR6ejoYhpG8n5qaChMTE8n3bN4hPHjwYFy9ehU5OTkoLCzE/PnzYWho+Eq58vJyTJ8+HfPnz8ezZ89w7tw5WFtbA6ifz7Z161YUFBSgoKAA+fn54PF4DWKWVkFBAcrLyyXfp6amomfPnujWrRuEQmGDY6c7pQkhstazZ0+kpqZKvhf3SWJ5eXmoq6uTfF9eXo5OnTqx2meNHz8e4eHhyMvLQ0FBAd54441G++nmPnMsLCxw6tQpST+dkJCAuro6GBkZtTqezMzMBt+Lz0nPnj2Rn5+PiooKyXvUT3dclAgTqfj7++O1116T3H27cePGZstnZWXBzMwMPB5P8pq5uXmDjuflJLmx71vj8OHDCAgIgJmZGbp06YLdu3c3aPtlly5dwtixY2FsbIyHDx/Cz88PQH1H99FHH0FfX1+yaWtrIzw8vNXxiPcVMzc3R1ZWFl68eIGamhqYmppK3jMzM2t1/YQQ0hpZWVmwsLCQfC/uk1rCVp+lrq6OEydO4KeffoKRkRH09fURGBjYZD/d1GdOeno6vLy8GvTTWlpazR5LU58t/x7kEJ+TZ8+eoWvXrtDS0pK8R/10x0WJMGmRlZUVPD09oa6ujsrKSlRUVEAkEjW7T0REBMrLy7FixQqoqanB3d0dEydOxJEjR5rc5/nz5+jTp0+bYtTV1UV+fj6qqqrg6ura4Oa0l3Xv3h2TJk2CtrY2qqqqUFpaKjmW3bt3Y+XKlbCzswMAdO7cGdOmTWux7ezs7EbjXrNmDYRCIUaMGIE333wTf/31F0QiEU6ePInVq1dDS0sL1tbWmDlzZpuOmRBCpOXv74+vv/4ahoaGMDAwwLfffos///yzxf3Y6rPU1dWhoaGBFy9eoLa2FuPHj8fYsWMbLdvcZ87u3buxfv16yY3MhoaGmDRpUrNtv3jxAnV1da/00927d8eSJUugpqaGadOmwdbWFoGBgUhLS0NUVBRWr14NoVAINze3Bjd7k46FEmHSIg0NDXz//ffIzc1FdnY2unfvjpUrVza7T01NDSZOnAgvLy/k5uZi586dmDlzJh49etTkPnv37oWdnR0KCgpw6tSpVsX43//+F9999x2Ki4vx7bff4tixY42W4/P5WL58ObKyspCfnw93d3csWLAAAHD69Gls3LgRR44cQVFREeLi4uDl5dVi26tXr8aBAwdQUFCAt99+G0B9clxQUICsrCwcOnQI8+fPlxz7okWLoKenh+zsbBw8eBD+/v6oqqpq1fESQkhrrFu3DlFRUbh37x7u37+P6OhorFu3Tqp92eizSktLsWTJEhw7dgwFBQV49913m1wdqLnPnK1btyIgIACXLl1CcXExbt26hSFDhjTbdkVFBdavX4+wsDAUFBRIykdERMDS0hK5ublYv349pk2bhvz8fADAe++9h6FDhyIvLw/r1q3D0aNHqZ/uwDifqEwbbR1pe/mmD2m277//ntm/fz/ncdNGG220SbN1hD5r1qxZrbpJ+ciRI8zq1as5j5s29jcaESZEzqytrWFvbw8AcHV1xdy5c1s9Ak4IIfKiin2Wi4sL+vTpAx6Ph3HjxmHy5Mk4ffo012ERGVDjOgBCGmNmZoYHDx40+p6dnZ1c7+AdMWIE/v7770bf09XVbXV9urq68Pf3R8+ePfH8+XNs2rSJ08ePEkJIc5rqs9juG9vj3Xffxa+//vrK66mpqRgwYECr6+vRowdOnjwJAwMDZGRkYMGCBYiNjWUjVKJgeKgfGiaEEEIIIUSl0NQIQgghhBCikigRJoQQQgghKomzOcI5OTkNnnJDCCHy5vLS11Gt3NfCwgLdu3dnMxyFRn02IURRtKXvbqrP5iwRTk1NhaurK1fNE0JIgxskWtsbRUZGshmKwqM+mxCiKNrSdzfVZ9PUCEIIIYQQopIoESaEEEIIISqJEmFCCCGEEKKSKBEmhBBCCCEqqcVEWENDAxEREYiNjUVcXBxWr179Shl1dXUcOXIEiYmJuHXrFiwsLGQRKyGEEBYlJyfj3r17iImJUbmb/wghBJAiEa6qqsKoUaPg5OQEJycnjB8/HkOGDGlQZu7cuSgoKIClpSW2bNmCjRs3yixgQlSJjw+QnAzU1dX/6+PDdUSko/H09ISzszOtCEEIaTNl/qySampEWVkZAEAoFEIoFIJhGj6VefLkyThw4AAA4Pjx4xg9ejTLYRKienx8AD8/oFcvgM+v/9fPT7k6GEIIIR2bsn9WSZUI8/l8xMTEICcnB0FBQbh9+3aD901MTJCeng4AqKurQ1FREQwMDNiPlhAVsmEDoKPT8DUdHeD773ncBEQ6HIZhcOnSJURFRcHX15frcAghSuinn4SNflZt2MBNPK0l1QM1RCIRnJ2doaenh1OnTqF///6Ij49vdWO+vr6YN28eAMDQ0LDV+xPFpdlJBwKhGupqalFZWsZ1OB2CuXnjr5uZ/XNFRlXPu/i4AajcsbNpxIgRyMrKQrdu3RAUFISHDx8iJCRE8j712YQ0jfohYP369ejZ8+tG32vqM0zRtGrViKKiIgQHB2P8+PENXs/MzISZmRkAQCAQQE9PD3l5ea/s7+fnB1dXV7i6uiI3N7cdYRNFIxCqwXfXFkmnQNovI6PxkV+RyBSampoAVPe8i49bFY+dTVlZWQCAFy9e4NSpUxg8eHCD96nPJqRpqt4PaWpqYvHixSgvb/yP5LQ0OQfURi0mwoaGhtDT0wNQf9BjxozBw4cPG5QJCAjArFmzAADTpk3D1atXZRAqIaolKmoKAO0Gr1VW8iEQfC/5/0ZIW2lra6NTp06Sr8eOHYu4uDiOoyKEKIuxY8dCV1cXP//cHWX/GgwvKwO+/JKbuFqrxUTY2NgYwcHBuHv3LiIjIxEUFITz589jzZo1mDhxIgBg7969MDAwQGJiIpYvX44vvvhC5oET0pF1794dY8fux82bc5CSAohEQEoK8MEHIty+bYnly5eDz6dlwEnbGRkZITQ0FLGxsbh9+zbOnz+Pixcvch0WIURJTJs2DXl5eVi16hF8fes/oxgGYBhzrFzZFf7+XEconRbH8u/fv4+BAwe+8vqqVaskX1dVVeGdd95hNzJCVNj8+fOhpaWFWbMuIimp4Xu1tT/h2LFjmDRpEoKuB3MTIFF6ycnJcHJy4joMQogSUldXx8SJE3Hy5EnU1tbC3x/w9wcsLCyQkpICPb1vAKzjOkyp0JASIQpo9OjRiI6ORtK/s2AAJ0+eRHJyMj755BMOIiOEEKLqRo8ejS5duuD48eMNXk9NTcWVK1cwe/Zs8HjKscIRJcKEKBgtLS24ubkhOLjx0d66ujrs2bMHI0aMQPdu3eQcHSGEEFU3bdo0FBYW4sqVK6+8t3//fvTt2xfDhw/nILLWo0SYEAUzbNgwqKurN5kIA5DM5fRw95BTVIQQQgigpqaGyZMn4+zZs6iurn7l/bNnzwIAJcKEkLbx9PREbW0tQkNDmywTExODvLw8jPLwlGNkhBBCVJ2HhwcMDAxemRYhVlRUhNTUVNjb28s5srahRJgQBePp6YnIyEiUlpY2WUYkEuHKlSsY5eEhv8AIIYSovDfeeAPl5eW4dOlSk2Xu378PBwcHOUbVdpQIE6JAdHR04Orq2uy0CLGgoCD07NkTRp315BAZIYQQAgwZMgRRUVGorKxsssy9e/dgY2MDoVAox8jahhJhQhTIiBEjIBQKpUqEL1++DACwNjKRdViEEEII1NTUMHDgQNy+fbvZcvfv34dQKISNjY2cIms7SoQJUSCenp6orq5GWFhYi2VTUlLw5OlTWPXoKYfICCGEqDp7e3toamq2mAjfu3dPUl7RUSJMiALx9PREREQEKioqpCoffC0Y/br1UIrLT4QQQpTb4MGDAaDFRPjx48eorq5WinnClAgToiB0dXUxaNAgqaZFiF29dg0aQiEGu7jKMDJCCCGkPhHOyclBampqs+Vqa2vx4MEDGhEmhEjP0dERAoEAt27dknqf6zduQCQSwZNWjyCEEJnz8QGSk4G6OuBBbDEGmodzHZJcDR48uMXRYDFlWTmCEmFCFIT4L+e7d+9KvU9RcRGyigow2JVGhAkhRJZ8fAA/P6BXL4DPB8zNGUx3PaAyyXCnTp1gZ2cndSJ87949mJqaQl9fX8aRtQ8lwoQoCAcHB+Tn5yMrK6tV+6XlvcCggQOV5rnuhBCijDZsAHR0Gr6mrlaNCQ4nuQlIzgYNGgQ+n9+qRBhQ/BvmKBEmREE4ODhIOo7WSM1/Ab3OekqxTA0hhCgjdXV1WFg0/p6+dp58g+GI+Ea5yMhIqcrfv38fABR+egQlwoQoAB6PhwEDBkg6jtZIzXsBoH6Rc0IIIew7cOAAeLzGM+Hiym5yjoYbQ4YMQVJSEvLz86Uq/+zZM+Tm5tKIMCGkZRYWFujcuXObRoRziotQVFxEiTAhhMjAmDFj4O3tjRMnBqGsrOF7DKON0spvuQlMzlpzo5yYMtwwR4kwIQpA3FG0JRFmANyJjqZEmBBCWKauro7t27fj8ePHePfdc/D1BVJSAJEISEvjISbtC5joL4KDvWIne+1lbGwMMzOzVifC9+7dw4ABAxT6HhZKhAlRAOJEOD4+vk37R0VFwd7eHlpaWmyGRQghKu3TTz+FlZUVFi9ejOrqavj7A717AwIBYOfUGX/d6Y2K6mosX7qU61BlysXFBYD084PF7t+/j06dOqFXr14yiIodlAgTogDs7e2RlJSEsn9fd5NS5J07UFNTw6BBg1iOjBBCVJOFhQW++uorHD9+HJcuXWq0TGVNDW4+eYT/TH4Lffr0kXOE8uPk5ASRSNSq5T0BICkpCQAU+txQIkyIAmjrihFiUXeiANANc4QQwpbPPvsMAoEAy5Yta7bcjcfxqK2txaeffiqnyOTPwcEBT548afVgTXJyMgCgd+/esgiLFZQIE8IxTU1NWFpatmnFCLEXublITk6mRJgQQljQuXNnzJo1C/7+/sjIyGi2bHFlBQ4f8cecOXPQvXt3OUUoX46Ojq0eDQaAjIwM1NTUUCJMCGmanZ0dBAJBu0aEASAiIoISYUIIYcGcOXPQqVMnbNu2Tary23fthKamJt5++20ZRyZ/Ojo66Nu3b5s+o0QiEdLS0pQ7ETY1NcXVq1cRHx+PuLg4LFmy5JUy7u7uKCwsRExMDGJiYvDNN9/IJFhCOqL2rBjxsoiICJibm6NHjx5shEUIISqJx+Nh0aJFCA0NRXR0tFT7PHr8GAkJCZg8ebKMo5O/AQMGgM/nt2lEGKifHqHUiXBtbS0++eQT9O/fH25ubli4cCFsbW1fKRcSEgJnZ2c4Oztj7dq1MgmWkI7IwcEB5eXlePr0abvqiYiIAAC4urqyERYhhKgkLy8v9OvXT+rRYLGAgAB4eHigc+fOMoqMG+0drFH6RDg7OxsxMTEAgNLSUiQkJMDExETmgRGiKuzt7REfHw+RSNSuemJjY1FXV0crRxBCSDssWbIEmZmZOHnyZKv2O3PmDIRCIby8vGQUGTccHR1RXFyMlJSUNu2fkpICIyMjaGtrsxsYS1o1R9jCwgLOzs6SkaeXDR06FLGxsQgMDISdnR1rARLS0dnY2ODBgwftrqeiogIPHjyQrPdICCGkdSwtLTFu3Djs2rULtbW1rdo3IiICOTk5HW56RHtXNRKvHGFh0fgjqrkmdSKso6ODEydO4OOPP0ZJSUmD96Kjo2FhYQEnJyds27YNp0+fbrQOX19fREZGIjIyEoaGhu2LnJAOQEdHB6ampnj8+DEr9UVFRVEiTAghbfTBBx+gtrYWe/bsafW+IpEIZ8+ehZeXF4RCoQyi44aDg0Ob5wcDir+EmlSJsJqaGk6cOIFDhw7h1KlTr7xfUlIiWVvu77//hlAohIGBwSvl/Pz84OrqCldXV+Tm5rYzdEKUn6WlJQDg0aNHrNQXFRUFIyMjmJqaslIfIYSoCoFAgFmzZiEwMBDPnz9vUx0BAQHo0qULRo4cyXJ03LCwsICenh4rI8JKnQjv3bsXCQkJ2LJlS6PvGxkZSb52dXUFn89HXl4eOxES0oFZWVkBAGsjwnfu3AEAmidMpMbn8xEdHY2zZ89yHQohnBo3bhyMjY3x+++/t7mOoKAgVFRUYNKkSSxGxh1HR0cAaNeI8PPnz1FeXq68ifDw4cMxc+ZMjBo1SrI8mpeXFz766CN89NFHAIBp06YhLi4OsbGx+OWXX+Dt7S3zwAnpCKytrSESiZCYmMhKfXfv3kVtbS1NjyBSW7p0KRISErgOgxDOffDBB3j+/DnOnz/f5joqKioQFBTUYeYJOzg4QCQSIS4url31pKSkKGwirNZSgbCwMPB4vGbL7NixAzt27GAtKEJUhZWVFdLS0lBZWclKfZWVlYiLi6NEmEjFxMQEEyZMwPr167F8+XKuwyGEM4aGhpg0aRJ++eWXVt8k929nz57FpEmTYGNjg4cPH7IUITfa+mjlf1PkJdToyXKEcMja2pq1aRFid+7coUSYSOXnn3/GihUr2r10HyHK7v3334dQKMS+ffvaXdfVq1cBAJ6enu2ui2uOjo7tftgTQIkwIaQJ1tbWrN0oJxYVFQVDQ0OYm5uzWi/pWCZMmICcnJxmn5xFK/0QVTFnzhxEREQgPj6+3XU9ffoUaWlpSp8Ia2tro1+/fi3OD9bspAMdfT3o6OtBs5NOo2WSk5PRpUsX6OnpySLUdqFEmBCOGBkZoXPnzqyPCEdFRQEAjQqTZg0fPhyTJk1CcnIyjhw5glGjRuHgwYMNytBKP0QVuLi4wMHBgZXRYLHg4GB4eHi0OLVUkfXv3x98Ph/3799vtpxAqAbfXVvgu2sLBMLGZ9yKH8ahiKPClAgTwhFra2sA7C2dJnbv3j1UV1dTIkya9eWXX8LMzAy9e/eGt7c3rl69ihkzZnAdFiFyN3fuXJSXl8Pf35+1Oq9du4Zu3bop9QPG2vto5Zcp8hJqlAgTwhG2l04Tq66uphvmCCFEClpaWvDx8cHx48dRXFzMWr3BwcEAlHuesIODA0pLSyVJbHtQIkwIeYW1tTUqKiqQlpbGet2RkZFwcXFR6styRH6uX7+OiRMnch0GIXI3depU6OnpYe/evazWm5qaiuTkZKVOhO3t7REXFweGYdpdV2FhIQoLCykRJoT8w9raGomJiax0Mv92+/Zt6Ovro1+/fqzXTQghHcXcuXORmJiIGzdusF53cHAw3N3dlXZAwsHBgZVpEWKKunIEJcKEcMTKyor1aRFiERERAIAhQ4bIpH5CCFF2ffv2hYeHR7ueJNec4OBgGBgYSObaKhNjY2MYGBhQIkwIkQ01NTX06dOH9RvlxBISElBSUkKJMCGENOGDDz5AXV0dDhw4IJP6r127BgDw8PCQSf2yJE7eW1oxojWSk5PRq1cv1upjCyXChHCgd+/eEAqFMhsRFolEiIqKwuDBg2VSPyGEKDOhUIg5c+YgMDAQz549k0kbGRkZSEpKUsp5wvb29gDYTYTT09Ohra2Nrl27slYnGygRJoQDslo67WURERFwcnKChoaGzNoghBBl9NZbb8HY2Bi7du2SaTvBwcEYOXKk0s0TdnBwQEZGBgoKClirMz09HQBgZmbGWp1soESYEA7Iaum0l92+fRvq6upwdHSUWRuEEKKMFi5ciKdPn+LChQsybSckJAT6+vro37+/TNthm729PavzgwFIVkhStKeeUiJMCAcsLS2Rl5fH6l/b/0Y3zBFCyKv69+8Pd3d37Nq1Syar9rwsNDQUADBixAiZtsMmNTU12NnZsTotAqARYULIS2S5YoRYVlYWMjIyKBEmhJCXLFiwAJWVlaw+UrkpycnJyMzMxGuvvSbztthiZWUFdXV11keEc3JyUF1dTYkwIaR+RDgxMVHm7dy+fZtumCOEkP+nq6uLmTNn4siRI8jLy5NLm6GhoUo1IiyLFSMAgGEYZGRkUCJMiKrT0tKCmZmZXBLhiIgIWFpaKtxduoQQwoX3338furq62Llzp9zaDAkJgbm5ucLNjW2Kg4MDampq8PDhQ9brTktLU7jzQIkwIXLWt29fAJDbiDAAuLq6yrwtQghRZDweD0uWLEFkZCQiIyPl1q6yzRO2t7fHw4cPUVNTw3rd6enpNCJMiKqztLQEIJ9EOCoqCnV1dRg6dKjM2yKEEEU2btw42NjYYMuWLXJt9/79+ygqKlKaecIODg6sT4sQS09Ph4mJCfh8xUk/FScSQlSEPBPh0tJSREdHw93dXeZtEUKIIlu2bBkyMzNx/PhxubYrEolw8+ZNpRgR1tfXh7m5OWJjY2VSf3p6OoRCIYyMjGRSf1tQIkyInFlZWSE7OxslJSVyae/69etwc3OjB2sQQlSWnZ0dxo4di+3bt8vkkn9LQkNDMWDAAIW/X0O87rysEmFFXEuYEmFC5ExeK0aIXbt2DZqamnBzc5Nbm4QQokiWLl2K8vJy/Pbbb5y0HxISAgAYNmwYJ+1Ly8nJCQBw9+5dmdSviGsJUyJMiJzJOxEODQ1FXV0dPDw85NYmIYQoCgMDA8yYMQN//PEH8vPzOYkhMjIS1dXVCj9P2NHREc+ePUNOTo5M6qdEmBAV16lTJxgbG8s1ES4qKkJsbCwlwoQQleTr6wstLS388ssvnMVQWVmJyMhIhZ8n7OTkJLNpEQBQWFiI0tJS5UqETU1NcfXqVcTHxyMuLg5LlixptNzWrVuRmJiIu3fvwtnZmfVACekI+vXrB0A+N8q97Nq1azRPmBCicgQCARYsWICgoCAkJCRwGktoaChcXFygqanJaRxNEQqFsLOzk2kiDCjeWsItJsK1tbX45JNP0L9/f7i5uWHhwoWwtbVtUMbLywuWlpawtLTEvHnzsGvXLpkFTIgyk+eKES8TzxOmxy0TQlTJxIkTYW5uju3bt3MdCkJDQ6Gurq6w67rb2tpCXV1dZvODxRRtLeEWE+Hs7GzExMQAqF+KKSEhASYmJg3KTJ48GX/88QeA+idZdenSBT169JBBuIQoNysrKwBAUlKSXNsNCQmBSCSi6RGEEJWyaNEipKam4ty5c1yHgrCwMABQ2HnC4hvlZD0irGiJsFprCltYWMDZ2RkRERENXjcxMZkaWC0AACAASURBVJFMgAaAjIwMmJiYIDs7u0E5X19fzJs3DwBgaGjYpoA1O+lAIKwPu66mFpWlZW2qh6i2xn6P5PG7ZWlpiYyMDJSXl0sVByNiwOPzGnzdlthenif83XffvfI+/b8ihHQ0tra2GD16ND7//HOIRCKuw0FBQQHi4uIUdp6wk5MTysvLZX7FMi0tDcbGxlBXV0d1dbVM25KG1DfL6ejo4MSJE/j444/bvP6pn58fXF1d4erqitzc3DbVIRCqwXfXFvju2iL54CaktRr7PZLH79a/V4xoKQ6+muCVr9sa27Vr1zB06NBG5wnT/ytCSEezcOFCVFZWYu/evVyHIhEaGophw4Yp1JPVxJycnHDv3j2Z/9EgHjj99+wCrkj1k1BTU8OJEydw6NAhnDp16pX3MzMzGwxzm5qaIjMzk70oCekg5L102ssuX74MTU1NjBo1ipP2CSFEXnR1dTFz5kz4+/sjLy+P63AkQkJCoKenhwEDBnAdyiscHR1lPj8YULwl1KRKhPfu3YuEhIQmn88dEBCAmTNnAgCGDBmCoqKiV6ZFEKLqunTpgm7dunGWCF+5cgXFxcX4z3/+w0n7hJCOz8cHSE4G6urq//Xx4SaOadOmQVdXF7t37+YmgCaEhoYCULx5wmZmZujatavM5wcDSpgIDx8+HDNnzsSoUaMQExODmJgYeHl54aOPPsJHH30EAAgMDMTTp0+RlJQEPz8//Pe//5V54IQoGxsbGwDgbAmf6upqBAYGYvLkyQp5WY4Qotx8fAA/P6BXL4DPr//Xz4+bZHjmzJl49OgRbt++Lf/Gm5GWlob09HSFmycsrxvlAMVLhFucDBgWFgYej9diRYsWLWIlIEI6KvGygw8fPuQshlOnTsHb2xvDhg2TjEwQQggbNmwAdHQavqajU/+6v7/84rCwsICHhwe++uor+TXaCiEhIXB3d+c6jAacnJwgEolw//59mbdVUVGB3NxchVlLmIaFCJETGxsbVFVVITk5mbMYAgMDUVVVRdMjCCGsayqvkXe+89577wEADh06JN+GpRQaGgoTExP06tWL61AknJyckJSUhLIy+awYpEhLqFEiTIic2Nra4vHjx5wu41NaWoqgoCBMmTKFsxgIIR1TWlrjr5eXG8g1jpkzZ+LatWtITU2Va7vSCgkJAaBY84RdXFxw584dubWXlpZGiTAhqsbGxobzR3wC9dMjevXqJZkTRgghbNixoycYRrvBazU1QmhqboaxsbFcYnB1dYW1tTUOHjwol/baIj4+HgUFBQozT7h79+4wNzdHVFSU3NpUpMcsUyJMiBxoaGigT58+nM4PFgsICEBdXR1Nj1BxGhoaiIiIQGxsLOLi4rB69WquQyJKzsPjN5SX/4z0dD5EIiAlBfjssy7g89/H/Pnz5RLDzJkzUVFRgePHj8ulvbZgGEah5gm7uLgAACIjI+XWZlpaGvT19aGrqyu3NptCiTAhctCvXz8IBAKFGBHOzc3F9evX8d5779HqESqsqqoKo0aNgpOTE5ycnDB+/HgMGTKE67CIkho9ejQmTJiAVasewdxcBIEA6N0b2Lr1Bc6dO4f58+dDXV1dpjEIBAJ4e3vjzJkzKC4ulmlb7XXjxg1YW1vDyMiI61Dg4uICkUiE6OhoubWZ9v/zaBRhVJg+BQmRA0VYMeJlu3btQt++ffHGG29wHQrhkPjGGKFQCKFQCIZhOI6IKKsZM2YgNzcX27Zte+W9X375Bd27d4e3t7dMY3jttddgaGiIo0ePyrQdNty4cQOAYswTdnV1RUJCgtxulAMoESZE5YjXEH706BHHkdQ7ffo00tPTsXTpUq5DIRzi8/mIiYlBTk4OgoKCFG7NVaI8PD09ERwcjOrq6lfeu3LlCuLj42Xe37z11luoqKjApUuXZNoOG2JiYlBaWoqRI0dyHQpcXV3lOi0CoESYEJVjY2ODlJQUVFRUcB0KAKC2thY7duzA66+/jv79+3MdDuGISCSCs7MzTE1NMXjw4Fd+F3x9fREZGYnIyEgYGhpyFCVRdH369IG5uTmCg4MBAJqddKCjrwcdfT1odqpfWPiXX37BwIEDMWzYMFbbfrmt//znP7h06RLKy8sbjUGaOhor25q6pI1ZQ1cHtyIiOE+ETU1NYWRk9MqNctIcs7gMj/dPKskwaHQ/cVnxa9nZ2aipqaFEmBBVYWtrqxDzg1/m5+eHiooKLF68mOtQCMeKiooQHByM8ePHN3jdz88Prq6ucHV1RW5uLkfREUXn4eEBAJJEWCBUg++uLfDdtQUCYf1zu/78809UVFTg7bffZrVtcVur/Q/A3Nwcp0+fbjKGlupoqmxr6mpNzGHhN2Fvbw99ff1219lWrq6uAF69UU6aYxaXwUvPXOML+I3uJy4rfk0kEiEjI4MSYUJUAY/Hg7W1tcLMDxbLz8/Hn3/+iRkzZkC/SxeuwyFyZmhoCD09PQCApqYmxowZo3C/o0Q5eHp6Ijs7u9nfn/LycgQHB2PChAkyicHexBx1dXU4d+6cTOqXhbCbN8Hn8zldRs3FxQU1NTW4e/eu3NtOTU2lRJgQVWBmZgYdHR2FGxEG6i9XamtrY8kiGhVWNcbGxggODsbdu3cRGRmJoKAgnD9/nuuwiBLy9PTEtWvXWix3/vx5WFpawtLSkvUYBphaIPzWLaW6cnEnJhqVlZWcTo9wdXXF/fv3UVVVJfe2FWUtYUqECZEx8Y1yijjaFhcXh4MHD2LJwkUw7MT9eo5Efu7fv4+BAwfC0dER9vb2WLt2LdchESVkaWkJExMTybSI5oj/0HrzzTdZjcFApxNMunTF2UDl+kOuqqoKERzPE3ZxcZH7jXJiaWlpMDU15XwZT0qECZEx8dJpijgiDAArVqxAdXU13nIazHUohBAl4+npCQBSJcKpqamIi4tjfXrEAJP6UcXzSpYIA/XLqA0cOBCdOnWSe9t9+/aFvr6+XJ8o97K0tDSoqanJ7amDTaFEmMiEjw+QnAzU1dX/6+PDdUTcsbGxQV5ensJessvOzsb3P/2A/ibmsDU25TocQogS8fT0RGZmJhITE6Uqf/78eYwcOZLVJ4oNMDFHVmE+UlJTWatTXm7cuAE1NTUMHz5c7m03daOcvCjKEmqUCBPW+fgAfn5Ar14An1//r5+f6ibDDg4OiI+P5zqMZu3cvRvPiwvxH+ch0NLS4jocQoiS8PDwkGo0WOzcuXMQCoUYO3YsK+3rddZDb0MjxGels1KfvIWFhaG6uhqjRo2Se9tDhgxBRUUFZ59PlAiTDmvDBkDnX8sO6ujUv65oBpqH40FsMerqgAexxRhoHs5q/QKBAE5OTrhz5w6r9bKtpqYGx+/cQjfdztjwHc0VJYS0zMbGBj169GhVIhweHo78/HzWpkeMHuUJAZ+PB1kZrNQnbxUVFQgPD+ckEX7ttdcQHh6O2tpaubcNAOnp9X+8UCJMOhRNTU1YWDT+XlOvc8XVIgLTXQ/A3JwBnw+YmzOY7nqA1WTY2toa2traCp8IA0BSzjNcfXgfvnM/xMSJE7kOhxCi4IYMGQIACA0NlXqfuro6XLhwAW+88QZ4PF7LO7Rg3JhxKKuqRGr+i3bXxZUrV65g4MCBcl1PWFdXF05OTggJCZFbm/9WWlqK/Px8SoRJx/L9uvXg8RrPeHk8C0ydOlXOETVuzOuvw3vI31BXa/g4UHW1akxwOMlaO4MGDQIAREdHs1anLAXej0bs3bv4/fffOb+BgRCi2BwcHFBeXo6kpKRW7Xf+/HkYGRlJ+se24vF4GPv663iYnQmGYdpVF5euXr0KPp8Pd3d3ubU5bNgwCAQCThNhQDGWUKNEmLDGwdQCH34wF2fPuqGsrOF7ZWXA48ez8eeff2Lo0KHcBPj/fH198dfhI+Ch8Tll+tp5rLU1cOBAlJWV4dGjR6zVKUt1IhHm+M6FlpYW9u/fz8qIDSGkY3JwcEBcXBxEIlGr9rt06RJEItErTzJsLRcXF3Tr1g0PninntAix27dvo7S0VK7TI1577TXU1NQgPJzd6YCtlZaWBguOLxdTIkxYYWpiiumuwxF15w6mTj0JX18gJQUQier/9fUFhg3bjvT0dAQEBKBnz56cxLlixQr89ttvuHz1CgrLuzZapqKmB2vtDRo0CLGxsa3+oOBSYlISli9fjrFjx2LhwoVch0MIUVCOjo64d+9eq/fLzc1FVFRUuxPhCRMmQCQS4eGzzHbVw7WamhqEhIRg9OjRcmtz5MiRiI6ORnl5udzabAyNCJMO47edu8Dn8TDHdy5qamrg7w/07v1/7d15PJXp/z/wF8dSqUEIg6JJqIkiS1pHe6F1Sk2jIm1TU1NTmWoKzTTVNEmbStI2ol1Mm0qfmkmirNmXhJCIUFnv3x99+bXg4Cz3Obyfj8d54NzXfV3v65zjvt9u131dAIfz/uvp00BhYSGsra0hJycHd3d3ocdobm6OrVu3ws/PDzO/m42gmKmorJb5qExtbUfISu2ANh/+QpWQkMCAAQPEYnzwpw4fPox//vkHO3bsqF8QhBBC6qiqqkJFRaVViTAAXLt2DRYWFlDgYXn3iRMn4mFEON5UCn9VNH67ffs2+vTpAzU1/l2IaYysrCzMzMxYHxYBvE+EFRUV+TqdXktRIkx4NnbsWAwbOhRBMY+Q8fRpk2WTk5OxdetWzJgxg2/T5zRHx44dcfz4cWRlZWHhwoWoqanB42eD4B8+F8+eSaC2Fnj2TAIXIx1RXWuH3/kwc0Lv3r3RuXNnsRkf/ClHR0eUlZXh1KlTkJaWZjscQogIMTQ0BIBWJ8JXr14Fh8PBqFGjWrW/qqoqBg4ciOs3brRqf1Fz69YtABDK8AhTU1PIysri7t27Am+Lm7op1LS0tFiLgWsi7O3tjfz8fMTGxja4ffjw4SguLkZkZCQiIyPx66+/8j1IItrc3NyQ+ewZHqQnN6v8jh07kJycjH379kFWVlbA0b23bds26OnpYf78+SgtLa1//vGzQejT/wtwOECf/l/g31Rj3EqIxSQbW55vXDA2Nn7fhpgmwvn5+Vi4cCFMTEywcuVKtsMhhIiQukS4sdyAm/DwcBQVFbV6eMT48eMBANeDg1u1v6iJjo5GUVGRUBLhuiWd//vvP4G3xY0ozCXMNRE+duwY1w/qvXv3MGDAAAwYMIDWq29nrK2tYWZmhu07/0RNM8fBVlZWYunSpdDV1YWzs7OAI3z/S//jjz/C3d0dd+7c4Vr+TlIcMp89w+7du3laA93ExARv375FfHx8q+tg26VLlxAUFISNGzeiW7dubIdDCBERhoaGyM7ORlFRUav2r6mpQXBwcKsTYVtbW2RnZyMmtnVXpEVNbW0tQkJChDJOeOjQoYiNjW31e8dPYpEI37t3TyReLCKa3NzckJaWBl+/0y3a79atW/Dz88O6deugoaEhoOjeL2ixd+9eZGRkYP369c3ap6qmBr+6bEL//v0xZ86cVrdtbGyMmJgY1NTUtLoOUbB69Wp07NgRv/32G9uhEEJEhKGhYauHRdS5du0aNDQ00K9fvxbtJycnh3HjxuHixYs8tS9qbt26BW1tbfTu3VtgbXA4HAwePFgkxgcDQG5uLqqqqlidOYIvY4QHDRqEqKgoXLlyBX369OFHlUQMTJ48GQMGDICrq2urVqZxdnaGhIQEfv/9dwFE997ChQthaGiIn3/+Ge/evWv2fhcuXUJMTAzWrFnTqnYlJCRgbGwsljfKfSo5ORl79+6Fo6Mj+vfvz3Y4hBCWSUlJoU+fPjwnwtevXweAFl8VHj9+PDp27Ijz58/z1L6ouXLlCgDwbdW9hhgZGaFLly4ikwjX1tbi2bNn0NHRYS0GnhPhx48fo0ePHujfvz/27t2LS5cuNVrWyckJ4eHhCA8Ph7KyMq9NE5atX78eKSkp8PX1bdX+mZmZ8PDwwPfff48BAwbwOTpAUVERW7Zswe3bt3HhQssXydi5cye+/vprjB07tsX79uzZE/Ly8mI7PvhTbm5uKCwsxK5du9gOhRDCst69e0NGRobnRDg3NxdRUVEtToSnTp2KgoKCFq1oJw4yMzMRGxsLa2trgbVR91o3Z5igsKSnp6Nnz56stc9zIlxaWory/1s94erVq5CWloaSklKDZb28vGBqagpTU1O8fPmS16YJi6ysrGBqaoodO3bw9K//rVu3oqioCDt37uRjdO+5ublBQUEBK1asaNX+fn5+yM7ObtVVYUtLSwBAREREq9oWNSUlJdiyZQu++eYb1hdEIYSwi9cZIz509epVDB06FF27Njyv+6dkZWVhbW2NS5cuif2ws4YEBQVh6NChkJeXF0j9NjY2ePjwIfLy8gRSf2uIfSKsqqpa/72pqSkkJSVRWMi/lbmIaHJ2dsbz589x4sQJnup5/fo1XFxcYGVlxde/go2MjLBkyRJ4enoiLi6uVXVUVVXBw8MDI0eObPEV64kTJyI3N5cvJwpR4e3tjcLCwlYPFyGEtA2GhoaorKzky4qZfn5+kJaWxrffftus8qNGjUKXLl3a3LCIOkFBQZCWlhbI9KLdunWDmZkZAgMD+V43L9LS0qCiosLaXMJcE2FfX1+EhoZCT08PWVlZcHBwwKJFi7Bo0SIAwPTp0xEXF4eoqCjs2bMHdnZ2Ag+asMvY2BijR4+Gu7s7Kisrea7v0KFDiI+Ph4eHBzp06MBzfRISEjhw4AAKCwt5ns7v8OHDeP36NVavXt3sfaSkpDB27Fj8888/YBiGp/ZFyZs3b3DgwAFMmjQJurq6bIdDCGGJoaEh4uPjW3VvyKdiYmIQGxvb7BuTp02bhuLiYty+fZvntkXRgwcPUFhYKJBxwhMnToSkpKTIJcLp6ekAwNo4Ya6J8OzZs/Hll19CRkYGWlpaOHr0KA4dOoRDhw4BAPbv34+vv/4a/fv3x6BBg1hft5oI3rp161BcXFz/GeBVdXU1fvjhB/Ts2RPr1q3jub558+bB0tISa9euRXFxMU91vX79Gl5eXpg5c2az72odPHgwFBQU8M8///DUtijat28fKisrsWrVKrZDIYSwhB8zRnzo1KlTGDJkCNdESEpKCra2tggMDERVVRXf2hcltbW1uHLlCiZMmMDT9J0NsbGxwbNnzxAdHc3XenlVlwizNTyCVpYjLaKvr4/p06fjwIEDHy1Mwas7d+7A19cXzs7OPP0yKCoqYvv27fj33395HrZRx93dHbW1tc2+KmxtbY2KigrcvHmTL+2LkhcvXuD48eOYO3cuVFRU2A6HECJkCgoK0NLSavVCGg2pu+H6u+++a7KclZUVlJSU2uywiDpBQUFQUVGBmZkZ3+qUlZXFmDFjEBQUxLc6+aUuEf7qq69YaZ8SYdIiv//+O8rKyuDu7s73un/++WdUVlZi7969ra5j165dUFRUxNKlS/k2LCEnJwcnT57EggULmpX8WVtb486dOygrK+NL+6Jm165dkJWVxZIlS9gOhRAiZAYGBgCAJ0+e8K3O7OxshISEcB0esWbNGuTm5uLatWt8a1sUXb9+HdXV1Xy9b+abb76BnJycyA2LAN7fjF1UVERXhInos7CwwNSpU7Fjxw6BzPqRm5uLTZs2YcKECVi8eHGL958zZw7mzZuHP/74g69XKwDgzz//hKysLJYvX95kuV69ekFfX18k/+rml+TkZNy4cQMODg6QkJBgOxxCiBDVJcKJiYl8rffvv/+Gnp4eBg4c2OB2CwsLjBo1Cjt37kRFRQVf2xY1JSUluHfvHiZPnsy3Oq2trVFeXo6QkBC+1clPbM4cQYlwOzBrFpCRAdTUvP86a1br6tm+fTvy8vIEcjW4zp49e3DlyhXs3r0bpqamzd6vd+/e8PT0xN27d+Hq6sr3uJKSknDx4kUsW7YMnTt3brRc3Q0ObXF88Id8fHzQo0cPWFlZsR0KIUSI9PX18fbtW2RmZvK13nPnzqGiogL29vYNbt+4cSNevnyJgwcP8rVdUeXv74++ffvybY59GxsbBAcHi+wfEZQIE4GZNQvw8gK0tQFJyfdfvbxangxPnDgRw4YNg4uLC968eSOIUAEADMNgzpw5yM3NxdmzZxudk/pDnTp1wpkzZ/Du3TvMnj1bYHNLbtu2DYqKik0OCZg4cSKePHmCjIwMgcQgKgICAvDq1SvMnz+f7VAIIUKkr6+P5ORk1NbW8rXekpIS+Pn5YfHixTA3N/9om7GxMSZOnIhdu3YJ9PwjSvz9/fHu3Tu+HGMHDx6M7t27IyAggA+RCUZaWhq0tbX5foNgc1Ai3MZt3QrIyX38nJwc4OHRqdn/1lZUVISHhweSk5Ph7e0tgCg/9urVK0yfPh1qamoIDAz8aK7qT3Xr1g137tzB119/DXt7e+Tk5AgsroiICAQFBWHz5s3o1avXZ9vNzc0xcuTIVq1iJ24qKirg6+uLqVOnCmzid0KI6DEwMOD7sIg6K1euRHZ2Nvz9/aGoqFj//MaNG/Hq1Svs27dPIO2KouLiYly8eBGzZ8+GjIwMT3UtXboUxcXFOHPmDJ+i47/09HTIyMhAQ0ND6G1TItyGSUpKorEZv1RU3iI0NBQWFhZN1sHhcODv7w8tLS3MmzePL/NGNsejR49gZ2cHQ0NDPH78uME49fT0EBoair59+2LKlCm4evWqwONatGgRKioqcPLkSXA4nPrnZWVl4ePjg6ysLOzYsUPgcYgCHx8fdOzYETNnzmQ7FEKIEMjKykJHRwcJCQkCqb+4uBjffvst1NTUcPz4cYwYMQKBgYGYMmUK9uzZw9eZisTBsWPHoKSkBBsbm1bX0a1bN0yfPh3Hjh0T6avpbE6hRolwG7Zx40ZISDScCb982QlaWloIDQ3F4cOHoaCg0GC5nTt3YvTo0Vi8eLHQ54i+dOkSLCws8ObNG/zvf/9DUFAQnJ2dsWTJEty8eRNPnjxB586d6w+WwvD8+XMsWbIEFhYWcHZ2rn9+06ZNMDAwwMKFC9vsbBGfevToEeLi4mh4BCHthK6uLjgcjsCuCAPvjyurV6+GjY0NQkJCYGZmhs2bN2Pr1q0Ca1NU3bx5E9nZ2Zg3b16r63B0dISMjAw8PT35F5gAsJkISwm9RSIUQ4cOxaZNm3D3bj5MTA59NDyivBz48cdyXL7cG5s3b8ZPP/0EGxsbbNmyBdeuXUN6ejrMzMywcuVKzJo1C+7u7vDx8WGlH3FxcTA1NYWbmxusrKzqb0ZLSkrC1q1bcfjwYWRnZws1pjNnzsDW1hYuLi4YPHgwUlNTsWTJEnh7e+PGjRtCjYVtPj4++Ouvv6Cvry/QkyMhhH36+voA+D9jxKf279+Pjh07ori4GKdOncK7d+8E2p6oqq2txYkTJ7Bu3TqoqakhLy+vRftLSkpi8eLFuHnzJpKTkwUUJX9kZWWhurqalbmE6YpwG9S1a1f8/fffSE9Px8SJf8PJCXj6FKitff/VyQk4fRooLy/H2rVrMXDgQDx79gz79+9HWloaCgoKEBYWhgkTJmD79u1Ys2YNq/0pLi7Gjz/+iK+//hrKysrQ09ODvr4+Nm3aJPQkuM4PP/yAo0ePQk1NDU5OTsjJyWnRMsxtha+vL2pra2lpdULaAX19fdTW1golqdq5cyeOHDnSbpPgOseOHQOHw2l0No2mTJw4Ed27d8eBAwcEEBl/1dTUIDMzk64IE/44ePAgVFVVMWjQIJSVleH06feJb2Oio6Nhbm4OPT09WFlZYdCgQQgLC8Px48dF7t/8hYWFKCwsZDsMlJSUYNGiRQDej6OWlJRss0t+NiUvLw937tyBnZ0dXFxc2A6HtICmpiZOnDgBVVVVMAyDw4cPY8+ePWyHRUSYgYEBMjMz8fbtW7ZDaTdSUlJw69YtrF69GgcPHsTr16+bve/y5cuRk5ODy5cvCzBC/mFrCjW6ItzGmJub49tvv8WWLVvw+PHjFu2blJQET09P2NvbY//+/SKXBIuqmpqadpkE1/H394eenh6MjIzYDoW0QHV1NVavXo2+ffvCwsICP/zwQ/1iCYQ0hIZAsWPt2rVQVlbGhg0bmr3PlClTMHr0aLi7uwtsSlF+o0SY8IWrqysKCgoEuugFIR86f/48qquraXiEmMnLy0NkZCQAoKysDAkJCaxMXUTEg4SEBPT09AQ2YwRp3OPHj3H8+HGsWLECOjo6XMsrKChg//79iIyMhIeHhxAi5I+0tDSoqKigS5cuQm2XEuE2xNLSEmPHjsX27dtRXl7OdjiknSgsLERwcDBNoybGevTogQEDBiAsLOyj552cnBAeHo7w8HAoKyuzFB0RBVpaWpCTk/voinCHznKQU5SHnKI8Osl/Uf+9hETTqUVj+3XoLNfs/biV5ebDuhqLt64Mt/4AAMOgxf1piQ0bNqCqquqz6Tkbek127twJFRUVODg4fDTlKbfXrzmvSUvUvSbNra9u5ojmJPv8RIlwG+Lq6or8/HyRnyaFtD3+/v7Q0dGBmZkZ26GQFpKTk8P58+excuXKz+Zp9fLygqmpKUxNTfHy5UuWIiSioKEZIzjSUnDydIeTpzskpTj134PLWk2N7ceRbvq2pQ/341aWmw/raizeujLc+gMAkhzJFvenJXJzc7F9+3ZMnz79o3mFP31NRo8eDUdHR+zYsQNRUVEN9qex2JrzmrRE3WvS3PrqEuGGFqwSJEqE24ghQ4Zg1KhR2LZtm0hPmk3apkuXLqGiooKGR4gZKSkpnD9/Hn///TcuXrzIdjhEhNWNH6ehEez566+/EBUVhQsXLtTfrP2hefb2CAgIQEJCAtzc3FiIkDd1s5HU/dElLJQItxHr1q1Dfn4+Dh48yHYopB0qKSnBtWvXMGPGjGYv3U3Y5+3tjYSEBLqngHClr6+PwsJC+s8Ai96+fYthw4bh+vXrOHjwIPbu3Qtbaxv0/VILcyyGYd/uPbh79y6GDx+OiooKtsNtsfLySOQ83wAAIABJREFUcmRmZgr9pl1KhNsAXV1dWFtb48CBA+1+zkXCHj8/P2hoaGDIkCFsh0KaYfDgwbC3t4eVlRUiIyMRGRmJ8ePHsx0WEVE0Y4RoKC0txaRJk+Dh4YFly5bB98RJLBg6CgO0dOD62xaMHz8eBQUFbIfZagkJCejTp49Q26R5hNuAH3/8ERUVFXQ1mLAqMDAQb968wcyZM3Hv3j22wyFc/Pfff3T1njSbgYEBgoKC2A6D4P2UnStXrsTu3buhqqmBb39di/KKCvy56y8wDMN2eDyJj4/HsGHDICEhIbS+0BVhMaegoID58+fD19cXL168YDsc0o6Vl5cjKCgI06dPB4fDYTscQgifKCoqQlVVlcYHi5inT58i7kkcsl8V4tWbtjHvf0JCAjp16oQePXoIrU1KhMWco6Mj5OTkxGquQNJ2+fv7Q1VVFSNGjGA7FEIIn9CNckRY4uPjAUCo44QpERZjHA4Hy5YtQ0hICKKjo9kOhxBcuXIFpaWlNKcwIW1IXVJSl6QQIih1f2wJc5ww10TY29sb+fn5iI2NbbSMh4cHUlJSEB0djQEDBvA1QNK4yZMnQ1tbm64GE5Hx7t07BAQEYOrUqZCWlmY7HEIIHxgYGODNmzfIzMxkOxTSxr169Qp5eXmidUX42LFjGDduXKPbx48fD11dXejq6mLhwoW0mIMQrVq1CmlpaQgMDGQ7FELq+fn5QUlJCaNGjWI7FEIIHxgYGCApKUnsb8Qi4kHYM0dwTYTv3buHoqKiRrdPmjQJJ06cAACEhYVBQUEBampq/IuQNMjMzAyWlpbw8PBAbW0t2+EQUu/GjRsoLCzEnDlz2A6FEMIHBgYGND6YCE1CQoJoXRHmRkNDA1lZWfU/Z2dnQ0NDg9dqCRc//fQTSkpK4OPjw3YohHykqqoKvr6+mDp1KhQUFNgOhxDCg44dO6JHjx6UCBOhiY+Ph4KCAtTV1YXSnlDnEXZycsLChQsBAMrKygJtq0Nnufq1tGuqqvGurLxF+zW0T2vrbGh/ppaBhKREq2L7UlUN06dPx+7du1FW9vmUKQ21U/f1w+daG0dTGAaQU5QH8PFrVBdTY3E01X5D/Wlt7HV1SUg0/TdgY/1oKKbmts9tn7o2ucXGLV5uryuvsTf0un/6/p4+dxbLly/HrFmzWjRcitffMUIIf+np6UFSUpISYSI0dZ81AwMD5ObmCrw9nq8I5+TkQEtLq/5nTU1N5OTkNFjWy8sLpqamMDU1FfgyjRxpKTh5usPJ073+xNqS/Rrap7V1NrS/pBSn1bEtWbIEEhIS2Lt3b7Pbqfva2Pet6U9DJDmSDb5GdTE1FkdT7TfUH15fQ3BZR6CxfjQUU3Pb57ZPXZvcYuMWL7fXldfYG3rdP31/zZfOR3RMDBwcHFrUD15/xwgh/EVTpxFhq5udRFjjhHlOhC9fvgx7e3sAgLm5OUpKSpCXl8dzYKRhcjKyWDDfAWfPnsWzZ8/YDoeQRp3y/RsDBw5Ev3792A6FENJKBgYGqK6uRkpKCtuhkHYiLy8PxcXFQhsnzDUR9vX1RWhoKPT09JCVlQUHBwcsWrQIixYtAvB+3tD09HSkpqbCy8sLS5cuFXjQ7dk3+v0gJyeHLVu2sB0KIU3yP3sGFRUVmD9/Pt/qnDULyMgAXr8swa/Wa2DcPZRvdRNCPmdgYIC0tDRUVVWxHQppR+Lj44V2RZjr/x5nz57NtZJly5bxJRjStG4qKhiiq4+z58/RxOZE5BW9eoWAgAB8//33cHZ2RmVlJU/1zZoFeHkBcnLvf+4qV4iZpsdxexoHx47wIWBCyGdoxgjChoSEBFhbWwulLVpZToz8tGIlpCU5+GPHdrZDIaRZDh06BGVlZcybN4+nemRlZXHggHx9ElxHRqoSrr++46luQkjDOBwOdHV1KREmQhcfHw9VVVUoKSkJvC1KhMWEuro6Fsx3QHhmGlLT0tgOh5BmuX37Nu7fv48NGza0eqW5vn374uHDh1BQeN3gdk1NmuSfEEH46quvICMjQ4kwEbro6GgAQP/+/QXeFiXCYuKvv/4Ch8NB8JMotkMhpEVcXFzQvXv3Vo0VnjVrFsLDw6Gqqor8fNkGy7wuVYCERCum2iCENIlmjCBsefToEQBg4MCBAm+LEmExMGXKFMyaNQvbd/6JwvLP5w0mRJQFBwe36qrw9KlTcfLkSYSFhcHQ0BA//fQO5Z9MK1xT2wEvXqyAlBRNtUYIv9UlwomJiSxHQtqb4uJipKamUiJMACUlJXh6euLRo0f4a7c72+EQ0ip1V4WbO69wP40eOHLwMP79919MmDABL168wOnTgJMT8PQpUFsLFJUrwTfsewz55jDd0U6IABgYGCArK6vBhZsIEbSIiAhKhAmwb98+KCoqYv78+aiurmY7HEJaJTg4GP/++y/++OMP9O7du8myRprasB80HBGPH8Ha2hpv376t33b6NKCjA3yhLI8tQX/i8bNBePPmjaDDJ6Rd6tevH548ecJ2GKSdioiIgLa2tsBXIqZEWIT99ttvsLOzg5ubG2JjY9kOhxCezJkzB1VVVQgKCkLXrl0bLDN/7lzYW47As6ICTP32W7oSRQhLpKSk0KdPn/qblggRtoiICACCHydMibCI+vXXX7FhwwYcPnwYW7duZTscQniWmZmJyZMnQ0tLC+fPn4fcB3OhKSoq4o8//sBedw8k5Gbj4P9u4HVpw7NEEEIET19fH7KyspQIE9Y8fvwYgOATYbrDRMRIS0vD1dUVv/zyC3x8fLB48WIwDE0PRdqG0NBQODg4wNfXFwUFBQgODkZ+fj5mz54NOTk5nPT9G1FSVailzzwhrDI0NAQASoQJa0pLS5GYmEhXhNsTExMTRERE4JdffsGRI0ewYMECSoJJm3P69GlYWlri8OHDMDIygr29Pfz9/dGvXz8sWfYDJcGEiAAjIyNUVFQgOTmZ7VBIOxYeHk6JcFO+nVaJjAygpgbIyHi/BKs4MjExwalTpxAWFgZlZWXY2trCyckJtbW1bIdGiECEhoZi5cqV0NbWxhdffAFHR0fExcWxHRYh5P8YGRnhyZMndJM2YVVERAQ0NDSgrq4usDbENhE27h6KfR5voa0NSEoC2tqAl5f4JMMdOnSASY+euPHPFURERMDGxgbu7u7o06cPAgMD2Q6PEKGprKxkOwRCyCcMDQ0RExPDdhiknau7Yc7ExERgbYhtIjzR8ALkOn38nJwcsH27aHdJsZMcbI1MkRT7BHMshqNbN1WsWrUKmpqaWLNmDUpKStgOkRBCSDumoqICdXV1Gh9MWBcVFYWamhqYmpoKrA2xvVlOsVNRg89rajI4dOgQPI8cFnJETevXrx82u7pg8sTJAIBLlwOQJ98RztNnoayomOXoCCGEkPeMjIwA0I1yhH1v3rxBfHy8QMcJi/bl00YM1P4KEhLdG9xWVqYIe3t7PHrwENNNBqGDtIyQo/tY3759cfbsWcTExGDUyJH4X9IT/BZ0DvMWOCL1RS7dDEcIIUSk1M0YQUMjiCiIiIiAmZmZwOoXu0TYZqI1ZpkOQW7xz/h0QanycmDRoiJ0794dBw4dxKCevfHL+CmYPnWq0OPs3bs3fH19ERMTgzFjxsDNzQ19jQwRGBOB4rflQo+HEEIIaQ4jIyPk5OSgsLCQ7VAIwd27d6GsrIy+ffsKpH6xSoRHjRqFY0e88azoJXbfkscPKzri6VOgthZ4+hRwcnq/BGtBQQGcN6yH+80glLx9g2NHjuLGjRtcl3blB2NjY/z999+Ij4+HjY0Ntm3bBm1tbWzevBnFNP6XECIivL29kZ+fT6tWks8YGRnR1WAiMkJCQgAAVlZWAqlfrBLh9evXIyU1FYfvBqOyuhpnz8tARwfgcAAdnfdJ8IeyXxXC/WYQfvp5NUxNTREbGwt3d3doaWnxNa6uXbvCwcEBd+7cwaNHj2BtbY1du3ahZ8+e2LBhA169esXX9gghhFfHjh3DuHHj2A6DiBhpaWkYGBjQ+GAiMjIzM5Geno5vvvlGIPWLVSI8adIk2E6djLdVzZ9uiWEYeB31hp6eHk6dOoUffvgB6enpOHXqFKZMmQJ5efkWxSAjJQW1LxQwycYW27Ztw507d5CXlwdvb29oaGhg9erV0NLSwtq1a1FQUNDSLhJCiFDcu3cPRUUN33RM2i99fX3IyMjQFWEiUm7fvo0RI0ZAUpL/aatYzRpRWlqKWqnWvQgvXryAo6MjXFxcsHLlSixYsADfffcdampq8OTJE2RnZyM3Nxe1YNDHZBAM3Xejg4wsunTpAkVFRSgrK0NZRQVKXbu+r3D8FFRUVCAqKgo7d+7EmTNnEBUVxcfeEkIIIcJFM0YQURQSEoIFCxbAyMgIkZGRfK1brBJhfsjKysLq1avh7OwMc3NzjB49Gv3794e6ujqMjIwgKysL2c5y+GqsAkpLS1FaWori4mJERUWhpPQ1vjQdgKLyMhz51RVh/96nxQAIIW2Wk5MTFi5cCABQVlZuVR0dOsuBI/3+VFNTVY13ZeVNPt+W1fVZlPtrbmGBt2/fIqcgHx06y30W54fvm4QE9wtTDAPIKcqz2ue6GADhfta4tfvhdqaWgYSkxGffN/Q701gfWtJPQZXlprG6Pvxc1fX/w+2hD8MAAOOsJyAhJRng43soVkMj+Kmqqgr//vsvNm/ejEmTJsHMzAyamprQ7t0LmwL80KuPPnr37g0TExOMHDkSdnZ2WLV2DW4lxiIyKwOPIyMpCSaEtGleXl4wNTWFqakpXr582ao6ONJScPJ0h5One/2Jrqnn27K6Potyfy0sLJBTWoL5e/9sMM4P3zdIcK9PkiPJep/rYhB2HNza/XC7pBSnwe8b+p1prA8t6aegynLTWF0ffq7q+v/h9heFL5H/uhhzFi/i+3vYbhNhQgghhPx/HTt2hJGhIZ6+fMF2KIR8JuVFLnqqqEFKioVEeOzYsUhMTERKSgrWrVv32fa5c+fixYsXiIyMRGRkJBwdHfkaJCGEEP7y9fVFaGgo9PT0kJWVBQcHB7ZDIiwbOHAgpKWl8bSQEmEielLz89BBWhoD+vfna71c02pJSUns378fo0ePRnZ2NsLDw3H58mUkJCR8VM7f3x/Lly/na3CEEEIEY/bs2WyHQESMpaUlANAVYSKSUgtyAQDDhw4Dgm/xrV6uV4TNzMyQmpqKjIwMVFVVwc/PD5MmTeJbAIQQQghhn6WlJZJTUlBeWcF2KIR8pryiAs+LizBs6FC+1ss1EdbQ0EBWVlb9z9nZ2dDQ0Pis3LRp0xAdHY2zZ89CU1OzwbqcnJwQHh6O8PDwVt+BTAghhBD+GzRoEMLCH7IdBiGNOv/4Adb+4szXOvlys1xgYCC0tbVhZGSE4OBgHD9+vMFy/LgDmRBCCCH81atXL6ioqCDs/6apIkQUpRfkIzEpia91ck2Ec3JyPlqSWFNTEzk5OR+VKSoqqp9K7MiRIzAxMeFrkIQQQggRnLrxwWEP6YowaV+4JsLh4eHQ1dWFtrY2pKWlYWdnh8uXL39URk1Nrf57W1vbz26kI4QQQojosrS0RHFxMd+vthEi6rjOGlFTU4Nly5bh+vXr4HA4OHr0KOLj4+Hq6oqIiAgEBgbixx9/hK2tLaqrq1FUVIR58+YJIXRCCCGE8IOlpSVCQ0PBMAzboRAiVM2alfjq1au4evXqR89t3ry5/vv169dj/fr1/I2MEEIIIQInLy+Pvn374syZM2yHQojQ0cpyhBBCSDs2ePBgSEpK4v79+2yHQojQUSJMCCGEtGPW1tYoKyvDf//9x3YohAgdJcKEEEIEyrh7KH61XoPXL0uQkQHMmsV2RORDtra2uH79OioqaCEN0v40a4wwIYQQ0hrfTqvETNPjkJF6P8Wmtjbg5QXIrqxkNzACADA2NoaGhsZns0ER0l7QFWFCCCEC4/rru/okuI6cHPCbazVLEZEP2djYoKamBleuXGE7FEJYQYkwIYQQgdHUbHg6ri/VqzHoKz0hR0M+ZWtri9DQUFrtlbRblAgTQggRiM2bN0NSskeD295VqGDGQEssGjYGKsrKQo6MAO9XijU2NqZhEaRdo0SYEEKIQJw9exa+/oaorJb56PnycmDp8lKcjbiPniqquHDmHDp37sxSlO2XtbU1AFAiTNo1SoQJIYQIRHx8PBYuuQv/8LkoKldCbS3w9Cng5AScPS+D+2lJOH4/BP2+/hpnz56FlBTdvy1Mtra2SE5ORhItq0zaMUqECSGECNTjZ4OwJehPfKEsDx0d4PTp/78tPjcbP676CePGjYOXlxd7QbYz8vLysLKyQmBgINuhEMIq+vObEEIIq06cOgllBUW4ubkhOjoau3fvZjukNm/BggWQlZXFqVOn2A6FEFbRFWFCCCGs27JlCy5evIgdO3bA3Nyc7XAExrh7KOKjXqOmBqwtLsLhcLBs2TL873//Q1RUlPADIESEUCJMCCFEJDg4OCA7Oxv+/v5QVFRkOxy+q1tcpHt3BpKS/39xEWEnw7a2ttDW1oaHh4dwGyZEBFEiTAghRCQUFxdjxowZUFdXx/HjxyEhIcF2SHwjKyuLbb+jwcVFtm4VbiwrVqxARkYGAgIChNswISKIEmFCCCEiIyIiAqtXr4aNjQ3WrVvHdjg8U1BQwC+//IKnT59Ctdu7Bst07y68ePr374/hw4dj3759qK2tFV7DhIgoSoQJIYSIlH379sHX1xe//fYbrKys2A6n1b7//ntkZmZi69atiIyMREFBx0ZKamHu3LlCiWnFihUoKyuDt7e3UNojRNRRIkwIIUTkLFy4EImJifDz84Ompibb4bSInJwcfHx8cOLECTx+/BhGRkaYMGEC1q5nPltc5M0bCSQm2uPYsWM4d+4cunbtKrC4LCwsYG9vDy8vL5SUlAisHULECSXChBBCRE55eTmmTp0KWVlZXLx4EV26dGE7pGbR1dXFw4cPYW9vDxcXF4wcORIxMTEA3i8i4h8+F8+eSdQvLrJgAYN+/f7AmjVrYGNjg/DwcPTt25fvcXXo0AE+Pj7IysrC5s2b+V4/IeKKEmFCCCEiKTk5GbNmzUL//v0REBCADh06sB1Sk0aPHo2wsDCoqKhg5MiRcHV1/Wwc7uNng9Cn/xfgcFC/uEhtbS127tyJoUOHomPHjggNDYWtrS1fY3Nzc4O+vj4cHR1RWlrK17oJEWeUCBNCCBFZV65cwdy5czF8+HD4+/uL7DLMP/30E65evYqsrCyYmprizp07La7j4cOHGDhwIBITExEQEIAtW7aAw+HwHJuFhQVWrVqFgwcP4tatWzzXR0hbQokwIYQQkebr64tly5bB1tYWFy5cgLy8PNsh1VNSUsLly5exa9cuBAQEwNLSEpmZma2u7/nz5xg2bBiOHj2KjRs3Ijg4GGpqaq2uz9zcHIGBgcjKysLatWtbXQ8hbRUlwoQQQkSep6cnli5dinHjxiEiIgL9+vVjOySMGzcOUVFRGDNmDJYvX45p06ahvLyc53rfvXsHR0dHzJ07F+bm5oiOjoaDgwMkJVt2yp4wYQJu376N4uJijBw5koZEENKAZv1WjR07FomJiUhJSWlwXkcZGRn4+fkhJSUFDx48QI8ePfgeKCGEEP7idmwXNZ6enhgxYgQ6deqEBw8e4Ndff8UXX3wh9DiMjIxw48YNXL16FWVlZbCwsMC+ffv43s6JEydgamqKlJQUeHt7Izw8HGPHjuWaEKurq2PHjh0ICAhAfHw8LC0tkZ6ezvf4CGkLuCbCkpKS2L9/P8aPH48+ffpg1qxZMDAw+KiMo6MjXr16BV1dXbi7u2P79u0CC5gQQgjvmnNsF0X379+HsbExrl+/Djc3Nzx9+hSbN2+Gvr6+QNvt0qUL5s6di+DgYDx+/BjGxsZYsWIFDA0NERUVJbB24+PjMWTIENjZ2UFZWRnXrl1DTk4O9u7dixkzZmDw4MHo1asXBg8eDAcHB3h7eyMjIwOrVq2Cr68vvvnmGxQUFAgsPkLEHde7DszMzJCamoqMjAwAgJ+fHyZNmoSEhIT6MpMmTYKLiwsA4Ny5cwL5y5gQQgj/NOfYLqry8/MxdepUDBgwAJs2bYKLiwtcXFzw9OlThISEICkpCSkpKcjKykJxcTFevXqFt2/foqKiAtXV1Z/Vx+FwICsrCzk5OcjJyUFJSQlffvklNDU10a9fPwwcOBBGRkaQkZFBWloaXF1dsWfPHhQXFwutz/7+/rh06RImTpwIOzs7ODo6YtmyZZ+VKy8vx5EjR/DXX3/Vv7eEkMZxTYQ1NDSQlZVV/3N2djbMzc0bLVNTU4OSkhIoKSmhsLCQz+ESQgjhh+Yc20VdZGQkpkyZAi0tLYwbNw7jx4/H+PHjMX/+/Cb3+3BKM27DDIqLi/Ho0SO4u7vj0qVLePDgAV9ib42KigpcuHABFy5cQKdOnaCjowMNDQ2oqanhxYsXSEpKQmZmJi2dTEgLSABgmiowbdo0jBs3Dk5OTgCAOXPmwNzcHMuXL68vExsbi3HjxiEnJwcAkJqaCnNz888SYScnJyxcuBAAoKenh6SkJH72RaQoKyvj5cuXbIchFNTXtqe99BNofV979OiBbt26CSAi4WjOsV1cjtni9HkVl1gpTv4Tl1jbapxNHbOZph4WFhbMtWvX6n92dnZmnJ2dPypz7do1xsLCggHAcDgcpqCgoMk628MjPDyc9Rior9RX6if1tbFHc47t4vIQp/dQXGKlONtvrO0tTq43y4WHh0NXVxfa2tqQlpaGnZ0dLl++/FGZy5cvY+7cuQCA6dOn4/bt29yqJYQQwqLmHNsJIaSt4zpGuKamBsuWLcP169fB4XBw9OhRxMfHw9XVFREREQgMDIS3tzdOnjyJlJQUFBUVwc7OThixE0IIaaXGju2EENLesH55uy0+nJycWI+B+kp9pX5SX9vDQ5zeQ3GJleJsv7G2tzi53ixHCCGEEEJIW0RLLBNCCCGEkHaJEmEeKCoq4saNG0hOTsaNGzegoKDwWRkjIyPcv38fcXFxiI6OxowZM+q3aWtr48GDB0hJSYGfnx+kpaWFGX6LNKevAHD16lW8evUKgYGBHz3v4+OD9PR0REZGIjIyEkZGRsIIu8V47WdbfE/t7e2RnJyM5ORk2Nvb1z8fEhKCxMTE+vdURUVFWKE3Cy9Lwzs7OyMlJQWJiYkYM2aMMMMmjWjO57V79+549OgRIiMjERcXh0WLFtVvMzY2RkxMDFJSUuDh4cFqnE2dF4R5rBSXc5i4nH/E6fwh6sd/YR+/WR/nIa6P7du3M+vWrWMAMOvWrWO2bdv2WRldXV2mV69eDABGXV2def78OSMvL88AYPz9/ZmZM2cyABhPT09m8eLFrPeJl74CYKysrBhra2smMDDwo+d9fHyYadOmsd4PQfezrb2nioqKTFpaGqOoqMgoKCgwaWlpjIKCAgOACQkJYUxMTFjvR0MPSUlJJjU1ldHR0WGkpaWZqKgoxsDA4KMyS5YsYTw9PRkAzMyZMxk/Pz8GAGNgYMBERUUxMjIyjLa2NpOamspISkqy3qf2/mjO51VaWpqRkZFhADBycnJMRkYGo66uzgBgwsLCGHNzcwYAc+XKFWbcuHGsxdnUeUGYx0pxOYeJy/lHnM4fonz8Z+H4LdgPRlt+JCYmMmpqagwARk1NjUlMTOS6T1RUVP1BpaCggOFwOAzw+ZyeovZoSV+HDx8utokwr/1sa++pnZ0dc/DgwfqfDx48yNjZ2TGAaCfCvMx//mnZD8vRg71HS4+3Xbt2ZTIzMxl1dXVGTU2NSUhIqN/26eeazTiBj88LwjxWiss5TFzOP+J0/hDl47+wj980NIIHqqqqyMvLAwDk5eVBVVW1yfKmpqb1a9UrKSmhuLgYNTU1AN4vb6qhoSHwmFurpX1tyO+//47o6Gjs2rULMjIy/A6RL3jpZ1t8TxtahvfDPvn4+CAyMhIbN24UfMAtwC3uT8t8uDR8c/Ylwtfc301NTU1ER0cjKysL27dvR25uLjQ0NJCdnV1fRpDvKS/nhTrCOlaKyzlMXM4/4nT+EOXjv7CP31znEW7vgoODoaam9tnzGzZs+Ow5hmEarUdNTQ0nT57E3LlzmyzHJn71tSG//PIL8vLyICMjg8OHD2PdunXYsmVLq2PlhSD7KWoE2dfvvvsOz58/R+fOnXH+/Hl8//33OHnyZKtjJYQfn9fs7GwYGRlBXV0dly5dwrlz50QyTqDh8wK/j5Xicg4Tl/OPOJ0/6PjfPJQIczF69OhGt+Xn50NNTQ15eXlQU1PDixcvGizXpUsX/PPPP9iwYQPCwsIAAIWFhVBQUACHw0FNTQ00NTWRk5MjkD40Fz/62pi6vzwrKyvh4+ODn3/+madYeSGofrbF9zQnJwcjRoyo/1lTUxN37twBADx//hwAUFZWBl9fX5iZmYnMgTAnJwdaWlr1Pzf0XtSVycnJAYfDgby8PAoLC5u1LxEMfv5u5ubmIi4uDkOHDsV///0HTU3N+m28vqeCOi8A/D9Wiss5TFzOP+J0/hDX47+wj980NIIHHy4tPXfuXAQEBHxWRlpaGhcvXsSJEydw/vz5j7aFhIRg+vTpTe4vKprT16Z8+Ffp5MmTERcXx9f4+IXXfra19/T69esYM2YMFBQUoKCggDFjxtSvRKakpAQAkJKSgrW1tUi9p7wsDX/58mXY2dlBRkYG2tra0NXVxcOHD4XeB/Kx5nxeNTQ00KFDBwCAgoIChgwZgqSkJOTl5eH169cwNzcH8P5OeEH9bvJ6XhDmsVJczmHicv4Rp/OHKB//2Th+C3wAeVt9dO3albl58yaTnJzMBAcHM4qKigwAxsTEhPHy8mIAMN999x1TWVnJREZG1j+MjIwYAIyOjg4TFhbGpKSkMGfOnKm/21kUH83pKwDm7t27zIsXL5g3b9779JA5AAABK0lEQVQwWVlZzJgxYxgAzK1bt5iYmBgmNjaWOXnyJCMnJ8d6nwTRz7b4ns6fP59JSUlhUlJSmHnz5jEAmE6dOjERERFMdHQ0ExcXx+zevVvkZlYYP348k5SUxKSmpjLr169nADCurq6MjY0NA4CRlZVlzpw5w6SkpDBhYWGMjo5O/b7r169nUlNTmcTERIHNLkCPlj2a83kdNWoUEx0dzURFRTHR0dEfrTxlYmLCxMbGMqmpqczevXtZjbOp84Iwj5Xicg4Tl/OPOJ0/RP34L8zjN60sRwghhBBC2iUaGkEIIYQQQtolSoQJIYQQQki7RIkwIYQQQghplygRJoQQQggh7RIlwoQQQgghpF2iRJgQQgghhLRLlAgTQgghhJB2iRJhQgghhBDSLv0/aJ/uA7kuq+AAAAAASUVORK5CYII=\n","text/plain":["<Figure size 864x576 with 4 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(short_max_data))\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"mScdfR9hmjVu"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"983aUwM76s6X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p_e8PtFXa7mc"},"outputs":[],"source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLZDkNNxbZPO"},"outputs":[],"source":["p1_hlm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":261,"status":"ok","timestamp":1653452376525,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WhCPOi1qbkHS","outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"outputs":[{"data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"execution_count":161,"metadata":{},"output_type":"execute_result"}],"source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wgERZ65F5RBB"},"outputs":[],"source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rAao95SEnOY0"},"outputs":[],"source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":267,"status":"ok","timestamp":1653119592395,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"OEQ9KWXVnQ2J","outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"outputs":[{"name":"stdout","output_type":"stream","text":["153\n","163\n"]},{"data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"execution_count":220,"metadata":{},"output_type":"execute_result"}],"source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hOtCGUeBQ4hn"},"outputs":[],"source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QPhjkZQhRLqr"},"outputs":[],"source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cFd7Fz0Y6ucU"},"outputs":[],"source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v4"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":78277,"status":"ok","timestamp":1655562981508,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oVifICO4-Grk","outputId":"99e914ea-98d2-4c52-c01e-d4c18738154e"},"outputs":[{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9718692302703857\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.069481611251831\n","en_ex_pairing elapsed time : 0.48963069915771484\n","idep_plot elapsed time : 0.19661450386047363\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9608440399169922\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0421018600463867\n","en_ex_pairing elapsed time : 0.4900686740875244\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20415735244750977\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9762113094329834\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0472276210784912\n","en_ex_pairing elapsed time : 0.4884374141693115\n","idep_plot elapsed time : 0.1992168426513672\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9757428169250488\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.061593770980835\n","en_ex_pairing elapsed time : 0.4922516345977783\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20275139808654785\n","get_open_info_df elapsed time : 0.9718272686004639\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0611577033996582\n","en_ex_pairing elapsed time : 0.49936604499816895\n","idep_plot elapsed time : 0.1955404281616211\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9695820808410645\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0577938556671143\n","en_ex_pairing elapsed time : 0.482999324798584\n","idep_plot elapsed time : 0.19686579704284668\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9735269546508789\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0826354026794434\n","en_ex_pairing elapsed time : 0.48934102058410645\n","idep_plot elapsed time : 0.19826126098632812\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9531569480895996\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.055222511291504\n","en_ex_pairing elapsed time : 0.5082666873931885\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21497869491577148\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9643127918243408\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0502116680145264\n","en_ex_pairing elapsed time : 0.502924919128418\n","idep_plot elapsed time : 0.19685792922973633\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.008805513381958\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.051682949066162\n","en_ex_pairing elapsed time : 0.5109684467315674\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.2049274444580078\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9716737270355225\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0618155002593994\n","en_ex_pairing elapsed time : 0.5181412696838379\n","idep_plot elapsed time : 0.20029854774475098"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9584364891052246\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0500702857971191\n","en_ex_pairing elapsed time : 0.5167996883392334\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20274782180786133\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.973966121673584\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0631885528564453\n","en_ex_pairing elapsed time : 0.5297532081604004\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20432114601135254\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.961554765701294\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0457618236541748\n","en_ex_pairing elapsed time : 0.5284707546234131\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21644258499145508\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9707987308502197\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0691368579864502\n","en_ex_pairing elapsed time : 0.5354645252227783\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21542096138000488\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9668304920196533\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0549356937408447\n","en_ex_pairing elapsed time : 0.5420842170715332\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21134018898010254\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9731390476226807\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0800542831420898\n","en_ex_pairing elapsed time : 0.5430054664611816\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21756911277770996\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9662141799926758\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0587058067321777\n","en_ex_pairing elapsed time : 0.5436177253723145\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21967387199401855\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9630858898162842\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.084143877029419\n","en_ex_pairing elapsed time : 0.5587177276611328\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.2225339412689209\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9734728336334229\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0562217235565186\n","en_ex_pairing elapsed time : 0.683725118637085\n","idep_plot elapsed time : 0.19470643997192383\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9524209499359131\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0482914447784424\n","en_ex_pairing elapsed time : 0.5747659206390381\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20411157608032227\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9617624282836914\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0563850402832031\n","en_ex_pairing elapsed time : 0.5843932628631592\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.2063751220703125\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9615845680236816\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0422992706298828\n","en_ex_pairing elapsed time : 0.5829193592071533\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21132826805114746\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9458277225494385\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.072371244430542\n","en_ex_pairing elapsed time : 0.5856218338012695\n","idep_plot elapsed time : 0.21661949157714844\n"]},{"data":{"image/png":"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ERFVDbt27cI///yD8+fPY+/evQgICAAA/PrrrwgKCsKxY8cQHx+PBw8e4MMPPwTwcBqHhQsX4uTJk0hPT0f79u1l7gKRTjHAw8l+iYiIiIjoMYsXL4a9vT3GjBkjOwoRERERUbnwF79ERERERP/j5uaGli1bAgC8vLwwbtw4nplDRERERDpJITsAEREREZG2sLS0xKZNm+Dg4IDU1FQsXboUu3btkh2LiIiIiKjcONUDERERERERERERkZ7hVA9EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0Skdq6urggPD0dWVhY+/PBD2XGoDGvWrIGfn98zl6tWrRp2796NjIwMbNmyRQPJiIioLKyxuoE1lohIt7C+6gbW1/LjwO8j4uPj4e3t/cT9Xbt2hVKplJCIHsc+0g3Tp0/HkSNHYGVlhZUrV1badmrUqIEdO3bg/v37uH79OkaMGFHmsvv27cO9e/dULS8vDxcuXFA93rFjR5w+fRpZWVmIiIhAp06dKi23rhkyZAjs7Oxga2uLYcOGleu5zs7OCAkJQXZ2NmJiYkp9//5r6NChOHnyJLKzs3HkyJEnHvfw8MDZs2eRnZ2Ns2fPwsPDo9z7QvLw81v7sY90A2usfmGNJXXg57f2Yx9pP9ZX/cL6+v848KvlpkyZgps3byIzMxMBAQEwMTEpdbmRI0eW+EDIzs6GEAJt2rQBAFhb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\n","text/plain":["<Figure size 1728x576 with 36 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","# val_list = np.arange(-0.0, -0.5, -0.03)  # prcn 2\n","val_list = np.arange(-0.1, -0.8, -0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point1.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point1.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap1 = set_val \n","  # config_list_copy[0].tr_set.ep_gap2 = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","  open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","  open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=2)\n","  open_info_df_list = [open_info_df1, open_info_df2]\n","\n","  try:\n","    result.append(get_res_v9(res_df, open_info_df_list, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'frq', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oE5zkT75Beiy"},"outputs":[],"source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if config_list[0].tr_set.check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v9(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v16(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    # print(\"short_obj.shape :\", short_obj.shape)\n","    # print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I9GysZ5_vv5J"},"outputs":[],"source":["def plot_info_v8(gs, gs_idx, len_df, sample_len, tr, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize) #, color='yellow')\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v9(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    close = ohlc_list[3]\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm        \n","        if show_detail:\n","          print(\"check_hlm :\", check_hlm)\n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ======\".format(op_idx1, open_side))\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry on p1_loop continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        if check_hlm in [0, 1]:\n","          i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","          if open_i2 >= len_open_idx2:  # open_i2 소진\n","              break\n","\n","          if show_detail:\n","            print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","          # ------ check side sync. ------ #\n","          if open_side != side_arr2[open_i2]:\n","            continue\n","\n","          op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","          if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","            continue\n","          \n","          if show_detail:\n","            print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","          \n","          i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          tp_ = tp_arr[op_idx1]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          \n","          # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","          # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","          if check_hlm:  # p1_hlm, p2_hlm\n","            if op_idx1 < op_idx2:\n","              expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","              if expire:   # p1's expiry\n","                  if show_detail:\n","                    print(\"expiry_p1 break {}\".format(touch_idx))\n","                  i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                  open_i2 = prev_open_i2\n","                  break   # change op_idx1\n","          \n","          # ------ point validation ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","          if open_side == OrderSide.SELL:\n","            if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","              break  # change op_idx1\n","            elif not (ep2_ < out_ and close[op_idx2] < out_):\n","              continue  # change op_idx2\n","          else:\n","            if not (tp_ > ep2_):              \n","              break\n","            elif not (ep2_ > out_ and close[op_idx2] > out_):\n","              continue\n","\n","          if check_hlm == 2:\n","            # ------ p2_box location ------ #\n","            if open_side == OrderSide.SELL:\n","              if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                if show_detail:\n","                    print(\"p2_box continue\")\n","                continue\n","            else:\n","              if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                if show_detail:\n","                    print(\"p2_box continue\")\n","                continue\n","                  \n","            # ------ check p2's expiry ------ #\n","            exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx2, out_1_, out_gap_, len_df, open_side,\n","                                                                                    [*ohlc_list, ep2_arr], expiry_p2)   # tp_j 는 op_idx1 사용\n","            i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","            if not entry_done:   # p2's expiry\n","                if show_detail:\n","                    print(\"expiry_p2 continue {}\".format(i))\n","                continue  # change op_idx2            \n","            \n","          # ------ tr_threshold ------ #   # en_p 에 대해 하는게 맞을 것으로봄\n","          if check_hlm:   \n","            if open_side == OrderSide.SELL:\n","              tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))              \n","              if config.loc_set.point1.short_tr_thresh != \"None\":\n","                if tr_ < config.loc_set.point1.short_tr_thresh:\n","                  continue\n","            else:\n","              tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))\n","              if config.loc_set.point1.short_tr_thresh != \"None\":  # thresh 여부는 short 기준 공통\n","                if tr_ < config.loc_set.point1.long_tr_thresh:\n","                  continue\n","          else:\n","            tr_ = tr_arr[op_idx1]\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ # --> p1_hlm 의 경우, 1번만 실행\n","          if not allow_exit:\n","            continue\n","\n","          while 1:\n","              if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                  tp_j = i\n","              if not config.out_set.static_out:\n","                  out_j = i\n","\n","              # ------------ out ------------ #  # out 우선 (보수적 검증)\n","              # ------ signal_out ------ #\n","              if not exit_done:\n","                  exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","              # ------ hl_out ------ #\n","              if config.out_set.hl_out != \"None\":\n","                  if not exit_done:  # and i != len_df - 1:\n","                      exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","              # ------------ tp ------------ #\n","              if not config.tp_set.non_tp and i != exec_j:\n","                if not exit_done:\n","                  exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                            [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                  # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                  # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","              if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                  # ------ append dynamic vars. ------ #\n","                  p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                  p2_idx_list.append(op_idx2)\n","                  pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                  pair_price_list.append([en_p, ex_p])\n","                  lvrg_list.append(leverage)\n","                  fee_list.append(fee)\n","                  tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                  tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                  # open_i += 1  # 다음 open_idx 조사 진행\n","                  break\n","\n","              # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","              # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","              i += 1\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done\n","            if show_detail:\n","                    print(\"exit_done = {} break {}\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:\n","            if check_hlm:\n","              if check_hlm == 1:   # exit only once in p1_hlm mode\n","                allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {} continue {}\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {} break {}\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_entry_v5(res_df, config, op_idx, wave1, wave0, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave0, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[i] < ha_c[i]):# & (ha_o[i] == ha_l[i]):   # 양봉 출현\n","    #           exit_done = -1\n","    #     else:\n","    #       if (ha_o[i] > ha_c[i]):# & (ha_o[i] == ha_h[i]):  # 음봉 출현\n","    #           exit_done = -1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[i] < bb_lower_5T[i] < close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] > bb_upper_5T[i] > close[i - 1]:\n","                exit_done = -1\n","        else:\n","            if close[i] > bb_upper_5T[i] > close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] < bb_lower_5T[i] < close[i - 1]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"qM6H6fmrKtsA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":260,"status":"ok","timestamp":1653436951068,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oLDZobRcgg6E","outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"outputs":[{"data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":["res_df.low.rolling(100) #> 1000"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"uB-I09hKKvmu"},"outputs":[],"source":["def get_touch_idx_fill(tp_1_touch_idxs, net_p1_pair, net_p1_idx, len_df):\n","\n","    tp_1_touch_idx = np.full(len_df, np.nan)\n","    tp_1_touch_idx[net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair]\n","    \n","    return fill_arr(tp_1_touch_idx)\n","    \n","def get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    # print(\"np.sum(long_p2_false_bias_bool != ~long_p2_true_bias_bool) :\", np.sum(long_p2_false_bias_bool != ~long_p2_true_bias_bool))\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_tpbox_p2exec_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_tpbox_p2exec_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FuIwazc3P5d1"},"outputs":[],"source":["def get_wave_bias_v4(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)  # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ------------------ touch idx ------------------ #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    short_tp_1_touch_idx = pd.Series(np.where(low <= short_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_tp_0_touch_idx = pd.Series(np.where(high >= short_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_1_touch_idx = pd.Series(np.where(high >= long_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_0_touch_idx = pd.Series(np.where(low <= long_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_out_1_touch_idx = pd.Series(np.where(low <= short_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_out_0_touch_idx = pd.Series(np.where(high >= short_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_1_touch_idx = pd.Series(np.where(high >= long_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_0_touch_idx = pd.Series(np.where(low <= long_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    # print(np.sum(np.isnan(short_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(short_tp_0_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_0_unq_p1_touch_idx)))\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","    \n","    # print(\"np.sum(short_net_p1_true_bias_bool) :\", np.sum(short_net_p1_true_bias_bool))\n","    # print(\"np.sum(long_net_p1_true_bias_bool) :\", np.sum(long_net_p1_true_bias_bool))\n","\n","    # print(\"np.sum(short_unq_p1_true_bias_bool) :\", np.sum(short_unq_p1_true_bias_bool))\n","    # print(\"np.sum(short_unq_p1_false_bias_bool) :\", np.sum(short_unq_p1_false_bias_bool))\n","    # print(\"np.sum(long_unq_p1_true_bias_bool) :\", np.sum(long_unq_p1_true_bias_bool))\n","    # print(\"np.sum(long_unq_p1_false_bias_bool) :\", np.sum(long_unq_p1_false_bias_bool))\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6YcqQQzsl6Ys"},"outputs":[],"source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"t7a5Hyyyd5Lk"},"outputs":[],"source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dsI-R8Zz7ls1"},"outputs":[],"source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":350,"status":"ok","timestamp":1652751452213,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"gMur2u8WeQ2K","outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"outputs":[{"data":{"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":872,"status":"ok","timestamp":1652756329304,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eoXMxRm3qdz2","outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"outputs":[{"data":{"image/png":"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\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dm7ZqzS9vqhm"},"outputs":[],"source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qOE2YSzntx8v"},"outputs":[],"source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_plot_params"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rMIwv1Nr1ojX"},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 4     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick, 5 : bias_tick (사용 금지)\n","                  # back_plot 사용시 custom x_max 반영됨\n","\n","bias_plot = 0     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = 1   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_max = 800\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 1000 #  150 100 20 500\n","post_plotsize = 160 # config.tr_set.bias_info_tick -> excessive bit 는 감당 못함\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","    if pr_descend == -1:\n","      pr_descend = 0\n","    pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":412,"status":"ok","timestamp":1655651664394,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"2bjxKCIh1ojZ","outputId":"cbf8a9ec-5cc7-46c4-d677-3d08fd3bf35a"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period1 = config.tr_set.wave_period1\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = 'T'\n","dc_period1 = 10\n","dc_tf2 = 'T'\n","dc_period2 = config.loc_set.point2.csd_period if config.loc_set.point2.csd_period != \"None\" else wave_period2 \n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ff00ff', 1]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 2]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 100\n","\n","step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","try:   # wave_range 단독 실행의 경우 tr_arr 이 존재하지 않기 때문에 try 처리함\n","  res_df['short_tr_{}'.format(selection_id)].iloc[short_obj[-1].astype(int).ravel()] = short_tr_arr\n","  res_df['long_tr_{}'.format(selection_id)].iloc[long_obj[-1].astype(int).ravel()] = long_tr_arr\n","  data_window_p1_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","  data_window_p1_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","except:\n","  pass\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  # \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"XfvH5ngyieS9"},"source":["#### session_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OCLMABZT1ojb"},"outputs":[],"source":["_ = [plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","metadata":{"id":"sZAYhcdoXnm4"},"source":["### whole_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jjFziVVIhgSr"},"outputs":[],"source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"50HXDIdJij28"},"source":["#### whole_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-tbLsXN9eN2p"},"outputs":[],"source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FtILHO-4kVlO"},"outputs":[],"source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v8(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v8(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","  elif back_plot == 5:\n","    x_max = bias_info_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------------ ax2 ------------ #\n","  # ------ band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  if back_plot == 5:\n","    ax1.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"ddL_BC24buq0"},"source":["### dump"]},{"cell_type":"markdown","metadata":{"id":"zgTrEWWqbwsT"},"source":["#### whole_plot thing"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M4zn8wxibzAR"},"outputs":[],"source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"4IhBjPMobzAS"},"outputs":[],"source":["cf.go_offline()\n","init_notebook_mode()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"n9WZkE9wbzAS"},"outputs":[],"source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","x2yj2SwAXDLp","14chOHeXh6JD","Q_1wJTcRYpm8","02DcTVB2cYuR","xpyP5t8Ht_pE","MuD_2vY7TI_8","983aUwM76s6X","_blyFhQJUd5X"],"name":"stem5_45_vec_backi2(0607_hlprime2cocu).ipynb의 사본","provenance":[],"toc_visible":true,"authorship_tag":"ABX9TyOIgvLgK/UkW6lqIL5l1hWj"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}