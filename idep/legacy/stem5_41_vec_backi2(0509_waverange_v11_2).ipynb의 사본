{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1652257469303,"user_tz":-540,"elapsed":21075,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"c7d725cd-85dd-4fe9-d638-a0095fda919b"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1652257496920,"user_tz":-540,"elapsed":8720,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","import IPython\n","import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","source":["\n","def bb_level_v2(res_df, itv, period):\n","\n","    bb_base = res_df['bb_base_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_upper2 = 'bb_upper2_{}{}'.format(itv, period)\n","    bb_lower2 = 'bb_lower2_{}{}'.format(itv, period)\n","    bb_upper3 = 'bb_upper3_{}{}'.format(itv, period)\n","    bb_lower3 = 'bb_lower3_{}{}'.format(itv, period)\n","\n","    level_gap = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy() - bb_base\n","\n","    res_df[bb_upper2] = bb_base + level_gap * 2\n","    res_df[bb_lower2] = bb_base - level_gap * 2\n","\n","    res_df[bb_upper3] = bb_base + level_gap * 3\n","    res_df[bb_lower3] = bb_base - level_gap * 3\n","\n","    return res_df"],"metadata":{"id":"kuf6ZhccgRj9"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    # df = bb_line_v3(df, df_15T, 60)\n","\n","    # df = bb_level_v2(df, 'T', 60)\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"status":"ok","timestamp":1652066331412,"user_tz":-540,"elapsed":2108,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"90cf9151-9050-4f0c-fa54-9f9a9a9e38bb"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                         bb_upper_T60  bb_lower_T60  bb_base_T60  bb_upper2_T60  bb_lower2_T60  bb_upper3_T60  bb_lower3_T60  upper_wick_ratio_5T  lower_wick_ratio_5T  candle_updown_5T\n","index                                                                                                                                                                                   \n","2022-04-27 08:41:59.999   2823.126867   2790.340133  2806.733500    2839.520235    2773.946765    2855.913602    2757.553398             0.354545             0.640260                 0\n","2022-04-27 08:42:59.999   2822.498326   2790.088008  2806.293167    2838.703485    2773.882848    2854.908644    2757.677689             0.354545             0.640260                 0\n","2022-04-27 08:43:59.999   2821.914551   2789.914116  2805.914333    2837.914768    2773.913898    2853.914986    2757.913681             0.354545             0.640260                 0\n","2022-04-27 08:44:59.999   2821.473171   2789.742162  2805.607667    2837.338676    2773.876657    2853.204181    2758.011153             0.354545             0.640260                 0\n","2022-04-27 08:45:59.999   2820.842501   2789.526499  2805.184500    2836.500502    2773.868498    2852.158503    2758.210497             0.089172             0.248408                 0"],"text/html":["\n","  <div id=\"df-882399d2-6441-4f90-a90e-e91ecbb1b52a\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>bb_upper_T60</th>\n","      <th>bb_lower_T60</th>\n","      <th>bb_base_T60</th>\n","      <th>bb_upper2_T60</th>\n","      <th>bb_lower2_T60</th>\n","      <th>bb_upper3_T60</th>\n","      <th>bb_lower3_T60</th>\n","      <th>upper_wick_ratio_5T</th>\n","      <th>lower_wick_ratio_5T</th>\n","      <th>candle_updown_5T</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2823.126867</td>\n","      <td>2790.340133</td>\n","      <td>2806.733500</td>\n","      <td>2839.520235</td>\n","      <td>2773.946765</td>\n","      <td>2855.913602</td>\n","      <td>2757.553398</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2822.498326</td>\n","      <td>2790.088008</td>\n","      <td>2806.293167</td>\n","      <td>2838.703485</td>\n","      <td>2773.882848</td>\n","      <td>2854.908644</td>\n","      <td>2757.677689</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2821.914551</td>\n","      <td>2789.914116</td>\n","      <td>2805.914333</td>\n","      <td>2837.914768</td>\n","      <td>2773.913898</td>\n","      <td>2853.914986</td>\n","      <td>2757.913681</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2821.473171</td>\n","      <td>2789.742162</td>\n","      <td>2805.607667</td>\n","      <td>2837.338676</td>\n","      <td>2773.876657</td>\n","      <td>2853.204181</td>\n","      <td>2758.011153</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2820.842501</td>\n","      <td>2789.526499</td>\n","      <td>2805.184500</td>\n","      <td>2836.500502</td>\n","      <td>2773.868498</td>\n","      <td>2852.158503</td>\n","      <td>2758.210497</td>\n","      <td>0.089172</td>\n","      <td>0.248408</td>\n","      <td>0</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-882399d2-6441-4f90-a90e-e91ecbb1b52a')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-882399d2-6441-4f90-a90e-e91ecbb1b52a button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-882399d2-6441-4f90-a90e-e91ecbb1b52a');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":94}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1071,"status":"ok","timestamp":1652066337627,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"c3a01224-f5a8-442f-8300-805b0988100d"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1652257500758,"user_tz":-540,"elapsed":3852,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5d7e5959-7f63-4e10-bac7-f2d2861d404e"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 2.807299852371216\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["\n","def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, high_prime_terms, low_prime_terms, high_prime_terms_cnt, low_prime_terms_cnt\n","\n","\n","def wave_range_v11_3(res_df, config, itv='T', over_period=3):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    # b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    over_base = close > dc_base_\n","    prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","    prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = prev_over_base & ~over_base\n","    co_bool = prev_under_base & over_base\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, \\\n","    high_prime_terms, low_prime_terms, high_prime_terms_cnt, low_prime_terms_cnt = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    paired_prime_cu_idx = high_prime_terms[:, 1]\n","    paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","def wave_range_v11_2(res_df, config, itv='T'):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n"],"metadata":{"id":"RVFfP9VcDG2_","executionInfo":{"status":"ok","timestamp":1652258043894,"user_tz":-540,"elapsed":2538,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":22,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":20,"metadata":{"id":"YqBXjVPzdccC","executionInfo":{"status":"ok","timestamp":1652257628500,"user_tz":-540,"elapsed":484,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","\n","plot_size = 60\n","t_df = res_df.iloc[i - plot_size:i + plot_size]\n","# t_df = res_df.iloc[i - plot_size:i - 22]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":23,"metadata":{"id":"-Dr_tTk9csFm","colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"status":"ok","timestamp":1652258054413,"user_tz":-540,"elapsed":1556,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"fc8189bc-0185-47c4-f380-17fb91fd1e08"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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8OBBFRUVaeTIkXr++ed15513yhijTz/9VKWlpTp37lxQVxAAAAAAIlmPR/qOHz+u8vJySdKf/vQnVVdXKzU1VZK0Zs0arVixQsYY7/zGGN10002SpJEjR+rMmTNqa2vT7NmztWPHDp09e1bnzp3Tjh07NGfOnGCsEwAAAADgmh6P9HU0YcIEZWRkaM+ePZo/f76ampq0b9++TvO8+uqrKi0t1dGjR3XTTTfpG9/4howxSk1N1ZEjR7zzNTY2epvHrrKzs/X4449LkpKSkvq6TgAAAACAa3rd9I0YMUIlJSVavny52tralJOTo1mzZvnMN3v2bO3du1f33nuvbrnlFu3YsUO33357n4rKz89Xfn6+JMnj8fTpvQAAAACAG3p1986YmBiVlJSoqKhImzZt0i233KL09HRVVFSooaFBaWlpKisrU3Jysh577DFt3LhRkvTf//3famho0G233aampibdfPPN3p+Zlpampqam4KwVAAAAAEBSL5u+goICVVdXa82aNZKkqqoqJScnKz09Xenp6WpsbNS0adPU3Nysw4cP67777pMkjRs3Trfeeqvq6+v161//WrNmzVJiYqISExM1a9Ys/frXvw7emgEAAAAAej69c/r06VqyZIn27dvnvaFLTk6Otm3b5nf+n/zkJ1q/fr327dunqKgorVy5UqdPn/bmrp+u+eMf/1hnz54drPUAAAAAAPgRJcn0OJeDLly4oIMHDzpdBsJAUlKSTp065XQZCBNsL+gtthX0BdsLeottBX1x6623atSoUQP6GcbN4fF4HK+BCI9gWyH6EmwvRG+DbYXoS7C9EL0NthWiLzHQ7aVX1/QBAAAAAMITTR8AAAAAWGyIpB85XURPysrKnC4BYYJtBX3B9oLeYltBX7C9oLfYVtAXA9leXH8jFwAAAABA/3F6JwAAAABYjKYPAAAAACzm2qZv9uzZqqmpUV1dnVauXOl0OXCZtLQ07dy5U/v371dVVZWeeeYZSdLo0aP14Ycfqra2Vh9++KESExMdrhRuER0drbKyMm3ZskWSNHHiRO3evVt1dXXasGGDhg4d6nCFcIuEhAS98847qq6u1oEDB5SVlcW+BX4tX75cVVVVqqysVHFxsYYPH86+BV4FBQVqbm5WZWWld1p3+5JXXnlFdXV1qqioUEZGhhMlwyH+tpWf/exnqq6uVkVFhTZu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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","config.tr_set.wave_period = 5\n","wave_itv, wave_period = 'T', config.tr_set.wave_period\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","t_df = wave_range_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# wave_high_fill2_ = t_df['wave_high_fill2_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# wave_low_fill2_ = t_df['wave_low_fill2_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","# ============ plot_check ============ #\n","dc_base_ = t_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=6)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=6)\n","\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in paired_cu_idx if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_fill_, alpha=1.0, color='yellow', linewidth=2)\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","# plt.step(len_df_range, wave_high_fill2_, \"*\", alpha=1.0, color='#0000ff', markersize=6)\n","# plt.step(len_df_range, wave_low_fill2_, \"*\", alpha=1.0, color='#ff0000', markersize=6)\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","plt.xlim(0, len_df)\n","\n","plt.show()"]},{"cell_type":"markdown","source":["###### data_window"],"metadata":{"id":"c2yVTn1tnxMn"}},{"cell_type":"code","source":["# valid_high_prime_idx\n","high_terms_vec[~np.isnan(high_terms_vec)]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"-Wva5F-oqSs0","executionInfo":{"status":"ok","timestamp":1652238778900,"user_tz":-540,"elapsed":317,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"3dc36254-8b70-4876-f173-bcb2af31c9bc"},"execution_count":54,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([31., 32., 33., 34., 35., 36., 37., 38., 39., 40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 61., 62., 63., 64., 65., 75., 76., 77., 78., 79., 80., 81., 82., 86., 87., 88., 89., 90., 91.])"]},"metadata":{},"execution_count":54}]},{"cell_type":"code","source":["# roll_high_idx_arr\n","# wave_high_fill_[valid_high_prime_idx]\n","# roll_high_.ffill().to_numpy()[60]\n","roll_low_.ffill().to_numpy()[60]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"NAbJGwUZqmGJ","executionInfo":{"status":"ok","timestamp":1651996623696,"user_tz":-540,"elapsed":4,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"502a5ffa-ec8b-424e-eb5f-47ca611f452e"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([405.08, 405.  , 405.5 , 404.54])"]},"metadata":{},"execution_count":61}]},{"cell_type":"code","source":["# roll_list[1][60]\n","roll_list[3]"],"metadata":{"id":"73pEGYBJrMEa"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# roll_wave_hl_v2(t_df, config, roll_hl_cnt=4)[0][-1]\n","# roll_wave_hl_v2(t_df, config, roll_hl_cnt=4)[1][50]\n","roll_list = roll_wave_hl_v3(t_df, config, roll_hl_cnt=4) # [0][60]\n","# roll_wave_hl(t_df, itv, period1)[0][150]"],"metadata":{"id":"G5jpriueRpxH"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["term_thresh1=1\n","term_thresh2=1\n","\n","itv = 'T'  # '15T'\n","\n","over_period = 3\n","\n","period1 = config.tr_set.wave_period\n","itv_num = to_itvnum(itv)\n","# print(itv_num)\n","\n","t_df = donchian_channel_v4(t_df, period1)\n","\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","# b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","# short_open_res = np.ones(len_df)\n","# long_open_res = np.ones(len_df)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","over_base = close > dc_base_\n","prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = prev_over_base & ~over_base\n","co_bool = prev_under_base & over_base\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, True)\n","\n","paired_cu_idx2 = high_prime_terms[:, 1]\n","paired_co_idx2 = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","wave_high_[paired_cu_idx2] = wave_prime_highs\n","wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","wave_high_[paired_cu_idx2] = wave_prime_highs\n","wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","# wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","# wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","# update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","# update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","# update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","# wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","# update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","# update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","# wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# wave_high_terms_low_ = np.full(len_df, np.nan)\n","# wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","# wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","# wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","# wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","# wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)"],"metadata":{"id":"TqMmmSAGuChM","executionInfo":{"status":"ok","timestamp":1652239958704,"user_tz":-540,"elapsed":295,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":65,"outputs":[]},{"cell_type":"code","source":["high_prime_terms"],"metadata":{"id":"50ucQUF-Jixd"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"code","source":["  def get_roll_wave_data(valid_prime_idx, roll_idx_arr, len_df, data, roll_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v4(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","\n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","\n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_, _, _ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","    for col_, itv_ in zip(future_cols, itv_list):\n","        back_col_ = 'b1_' + col_\n","        res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","    return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1) \n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)   \n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","    \n","    # ============ modules ============ #  \n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","    wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    \n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    wave_high_[paired_cu_idx] = wave_highs\n","    wave_low_[paired_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","    \n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    cu_prime_idx = wave_high_prime_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","    co_prime_idx = wave_low_prime_idx\n","    co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","    # ============ enlist to df_cols ============ #       \n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ # \n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","    # ------ for first_high ------ # \n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","      \n","    if itv != 'T':\n","      assert ltf_df is not None, \"assert ltf_df is not None\"\n","      join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","      ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","      try:\n","        ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","      except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","    else:\n","      ltf_df = t_df    \n","\n","    return ltf_df\n"],"metadata":{"id":"841i4oo2abh-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"code","source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"],"metadata":{"id":"3vHLGont-BFe"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"],"metadata":{"id":"Mh3w2s-j34Zs"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"eQ06-kWq4m6F","executionInfo":{"status":"ok","timestamp":1651799326382,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["11\n","11\n"]}]},{"cell_type":"code","source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"],"metadata":{"id":"SUFmr9Z_kcCN"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"],"metadata":{"id":"_3pOQtt2ttfk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"kKaD1fK3WPRP","executionInfo":{"status":"ok","timestamp":1651756811396,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"metadata":{},"execution_count":79}]},{"cell_type":"code","source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"],"metadata":{"id":"YoZpr7lDn7z-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"code","source":[""],"metadata":{"id":"1eZov-szzNuB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"],"metadata":{"id":"nLWAP1Cl2Hvu"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1652257516952,"user_tz":-540,"elapsed":2942,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":50,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1652259021116,"user_tz":-540,"elapsed":3015,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","# def get_line(touch_idx, rtc_):\n","#     touch_idx_copy = touch_idx.copy()\n","\n","#     nan_idx = np.isnan(touch_idx_copy)\n","#     touch_idx_copy[nan_idx] = 0  # for indexing array\n","#     touch_line = rtc_[touch_idx_copy.astype(int)].copy()\n","#     touch_line[nan_idx] = np.nan  # for true comp.\n","\n","#     return touch_line\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","      \n","    # ------ get candle_lastidx ------ #        \n","    tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    high_5T = res_df['high_5T'].to_numpy()\n","    low_5T = res_df['low_5T'].to_numpy()\n","\n","    b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","\n","    wave_itv = 'T'\n","    wave_period = config.tr_set.wave_period\n","    roll_hl_cnt = 4\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)   # Todo, df 저장할 방법 고민\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    res_df[short_tp_1_] = wave_low_fill_           # wave_low_fill_ b2_low_5T\n","    res_df[short_tp_0_] = roll_high_[:, -2]   # wave_high_fill_\n","    res_df[long_tp_1_] = wave_high_fill_           # wave_high_fill_ b2_high_5T\n","    res_df[long_tp_0_] = roll_low_[:, -2]     # wave_low_fill_\n","\n","    if config.tr_set.p2_itv1 != \"None\":\n","        p2_period1 = config.tr_set.p2_period1\n","        p2_period2 = config.tr_set.p2_period2\n","        res_df[short_epout_1_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[short_epout_0_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","        res_df[long_epout_1_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[long_epout_0_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","    else:\n","        res_df[short_epout_1_] = wave_low_fill_   # b2_low_5T\n","        res_df[short_epout_0_] = wave_high_fill_  # roll_high_[:, -2]\n","        res_df[long_epout_1_] = wave_high_fill_   # b2_high_5T\n","        res_df[long_epout_0_] = wave_low_fill_    # roll_low_[:, -2]\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df[short_tp_gap_] = abs(res_df[short_tp_1_] - res_df[short_tp_0_])\n","    res_df[long_tp_gap_] = abs(res_df[long_tp_1_] - res_df[long_tp_0_])\n","    res_df[short_epout_gap_] = abs(res_df[short_epout_1_] - res_df[short_epout_0_])\n","    res_df[long_epout_gap_] = abs(res_df[long_epout_1_] - res_df[long_epout_0_])\n","\n","    # ================== enlist tr_set ================== #    \n","    short_open_res = np.ones(len_df)\n","    long_open_res = np.ones(len_df)\n","\n","    tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","\n","    short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ---------------- point ---------------- #\n","    if p2_itv1 != \"None\":\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","    else:  \n","        # ------ p1 only ------ #\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = 0  # default\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = 0 \n","        \n","        # ============ wave_point ============ #\n","        short_open_res *= res_df['wave_cu_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        long_open_res *= res_df['wave_co_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        if show_detail:\n","          sys_log.warning(\"wave_point\")\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ wave_mm ------ #\n","        wave_high_terms_cnt_fill_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        wave_low_terms_cnt_fill_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        short_open_res *= (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater1)\n","        long_open_res *= (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater1)\n","\n","        if show_detail:\n","          sys_log.warning(\"wave_mm\")\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ================== pattern depiction ================== #  \n","        bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        b3_close = get_line(b3_candle_lastidx, close)\n","\n","        b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        b2_close = get_line(b2_candle_lastidx, close)\n","\n","        b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        b1_close = get_line(b1_candle_lastidx, close)\n","        b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        if show_detail:\n","          sys_log.warning(\"compare by back_idx\")\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","        \n","        # # ------ hhhl (long) ------ #\n","        # short_open_res *= (roll_high_[:, -2] > roll_high_[:, -1]) # & (roll_low_[:, -2] > roll_low_[:, -1])\n","        # long_open_res *= (roll_low_[:, -2] < roll_low_[:, -1]) # & (roll_high_[:, -2] < roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"hhhl\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # # ------ roll_high < bb_upper2 (long) ------ #\n","        # short_open_res *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","        # short_open_res *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","        # short_open_res *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","        # long_open_res *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","        # long_open_res *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        \n","        # if show_detail:\n","        #   sys_log.warning(\"roll_high < bb_upper2\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ base_15T < wave_base ------ #\n","        # dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # short_open_res *= (dc_base_ > wave_base_) & (dc_base_ > close)\n","        # long_open_res *= (dc_base_ < wave_base_) & (dc_base_ < close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))     \n","        \n","\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res\n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_tp_gap * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_tp_gap * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg = config.tr_set.ep_gap\n","        res_df['short_ep_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * epg\n","        res_df['long_ep_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * epg\n","        \n","        # res_df['short_ep_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * epg\n","        \n","        # wave_cu_marker_ = res_df['wave_cu_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        # wave_co_marker_ = res_df['wave_co_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        # res_df['short_ep_{}'.format(selection_id)] = wave_cu_marker_ + short_epout_gap * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = wave_co_marker_ - long_epout_gap * epg\n","\n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep_{}'.format(selection_id)] = close\n","        res_df['long_ep_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * outg\n","    # res_df['long_out_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * outg\n","    res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg\n","    res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    # ------------ point validation ------------ #\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","    short_open_res *= (short_tp_ < short_ep_) & (short_ep_ < short_out_)\n","    # short_open_res *= close < short_ep_   # reject open_execution\n","    short_open_res *= close < short_out_    # reject open_execution\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res * (not config.pos_set.short_ban)\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","    long_open_res *= (long_tp_ > long_ep_) & (long_ep_ > long_out_)\n","    # long_open_res *= close > long_ep_   # reject open_execution\n","    long_open_res *= close > long_out_    # reject open_execution\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res * (not config.pos_set.long_ban)\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","      sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","    \n","    # ------------ wave_bias ------------ #\n","    wb_tpg = config.tr_set.wb_tp_gap\n","    wb_outg = config.tr_set.wb_out_gap\n","    res_df['short_wave_1_{}'.format(selection_id)] = short_tp_1 - short_tp_gap * wb_tpg\n","    res_df['long_wave_1_{}'.format(selection_id)] = long_tp_1 + long_tp_gap * wb_tpg\n","    \n","    res_df['short_wave_0_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * wb_outg   # hhc\n","    res_df['long_wave_0_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg    # hlc\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    res_df['short_tr_{}'.format(selection_id)] = abs(\n","        (short_ep_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep_ / short_out_ - config.trader_set.market_fee - 1))\n","    res_df['long_tr_{}'.format(selection_id)] = abs(\n","        (long_tp_ / long_ep_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    if config.tr_set.c_ep_gap != \"None\":\n","        # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","        # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","        res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","        res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # ------ zoned_out ------ #\n","    if config.tr_set.t_out_gap != \"None\":\n","        # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","        # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","        res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","        res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["# # ------ compare by back_idx  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"compare by back_idx\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"aTV4h3LjTZBp"}},{"cell_type":"code","source":["# ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"],"metadata":{"id":"dc49JPmoTaPQ"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1652257524895,"user_tz":-540,"elapsed":2850,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    # ====== public ====== #\n","    res_df = wave_range_v11_3(res_df, config, over_period=2) \n","    # res_df = wave_range_v15(res_df, config, term_thresh1=2, term_thresh2=3)\n","    # res_df = wave_range_v15(res_df, config, itv='15T', term_thresh1=2, term_thresh2=3)\n","\n","    # ------ wrr ------ #\n","    # res_df = wave_range_ratio(res_df, config, 'T', 60)\n","    # res_df = wave_range_ratio_v2(res_df, config)\n","    res_df = wave_range_ratio_v3(res_df, config)\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    itv_list = ['15T', '15T', '15T', '15T']\n","    res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expire_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expire(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expire_v2(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k or h[e_j] >= short_tp_0_[tp_j] - short_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()\n","            long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k or l[e_j] <= long_tp_0_[tp_j] + long_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","    allow_ep_in = 1\n","    if config.selection_id in ['v5_2']:\n","        if side == OrderSide.SELL:\n","            dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","            dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","            allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","                           (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","        else:\n","            dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","            dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","            allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","                           (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","    if config.selection_id in ['v3_4']:\n","        wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","        wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","        close = res_df['close'].to_numpy()\n","        if side == OrderSide.SELL:\n","            sup_T = res_df['sup_T'].to_numpy()\n","            allow_ep_in *= close[i] < sup_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","        else:\n","            resi_T = res_df['resi_T'].to_numpy()\n","            allow_ep_in *= close[i] > resi_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","    if allow_ep_in:\n","        out_j = i\n","    return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #\n","    if config.loc_set.point.short_tr_thresh != \"None\":\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point\n","    if config.loc_set.point.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point.wrr_32 != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point.wrr_32 + 0.1\n","        mr_res *= cu_wrr_32_ >= config.loc_set.point.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point.wrr_32 + 0.1\n","        mr_res *= co_wrr_32_ >= config.loc_set.point.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone.use_zone:\n","\n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["      \n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":8,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1652257524895,"user_tz":-540,"elapsed":4,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_42\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-04-08\\\\2022-04-08 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 0.0002,\n","    \"market_fee\": 0.0004,\n","    \"initial_asset\": 10,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"api_retry_term\": 3,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"5T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"wave_period\": 5,\n","    \"wave_greater1\": 2,\n","    \"wave_greater2\": 2,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"p1_itv1\": \"15T\",\n","    \"p1_itv0\": \"T\",\n","    \"p1_period1\": 1,\n","    \"p1_period2\": 5,\n","    \"p2_itv1\": \"None\",\n","    \"p2_itv0\": \"T\",\n","    \"p2_period1\": 20,\n","    \"p2_period2\": 40,\n","    \"ei_k\": 0.0,\n","    \"expire_tick\": 10,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap\": -0.618,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 240\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":9,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1652257529455,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"615e6605-2bf2-4c5d-a0b8-2795e551d934"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_42\" {\n"," \"point\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"5T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"wave_period\": 5,\n"," \"wave_greater1\": 2,\n"," \"wave_greater2\": 2,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"p1_itv1\": \"15T\",\n"," \"p1_itv0\": \"T\",\n"," \"p1_period1\": 1,\n"," \"p1_period2\": 5,\n"," \"p2_itv1\": \"None\",\n"," \"p2_itv0\": \"T\",\n"," \"p2_period1\": 20,\n"," \"p2_period2\": 40,\n"," \"ei_k\": 0.0,\n"," \"expire_tick\": 10,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap\": -0.618,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 240\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expire, ep_loc_point2_v2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","# config_list[0].tr_set.wave_period = 5"]},{"cell_type":"code","execution_count":25,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3936,"status":"ok","timestamp":1652258190383,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"dbb66625-e76b-4d4a-d7f0-8b16c9df828f"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 1.926077127456665\n","make data_list elapsed time : 0.0001685619354248047\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":55,"metadata":{"id":"_iYcJk8nK8Yq","executionInfo":{"status":"ok","timestamp":1652259205681,"user_tz":-540,"elapsed":402,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","config_list[0].tr_set.wave_greater1 = 0\n","config_list[0].tr_set.wave_greater2 = 0\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","config_list[0].tr_set.ep_gap = 0.19 # -0.618 -0.23 -0.382\n","# config_list[0].tr_set.out_gap = 0\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 500\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004\n","\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":56,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1926,"status":"ok","timestamp":1652259207929,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"578d282a-e0cc-4aa5-d3f2-51284a3e46f0"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 882\n","np.sum(long_open_res == 1) : 910\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.7890136241912842\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":43,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1652258837697,"user_tz":-540,"elapsed":591,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point.wrr_32 = 0.302 # \"None\" 1 0.5 0.382 0.302\n","config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","config_list[0].loc_set.point.cu_es = \"None\" # \"None\" # -2\n","config_list[0].loc_set.point.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point.short_tr_thresh = \"None\"  #  \"None\" 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point.long_tr_thresh = 1  #  \"None\" 2 0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":57,"metadata":{"executionInfo":{"elapsed":1418,"status":"ok","timestamp":1652259209658,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"e9174400-201f-4c1a-a12e-f692cc03983b"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.3297228813171387\n"]}],"source":["open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.ei_k = -0.5\n","# config_list[0].tr_set.expire_tick = 10\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","config_list[0].tp_set.p_ranges = \"[1]\"\n","config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","config_list[0].lvrg_set.leverage = 1\n","config_list[0].lvrg_set.static_lvrg = 1\n","config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":58,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":644},"executionInfo":{"elapsed":1899,"status":"ok","timestamp":1652259211553,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"e2a57614-68ba-4d45-a5f7-70f6e2089a7f"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.05010199546813965\n","short_obj.shape : (29, 5)\n","long_obj.shape : (52, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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Cxm7d+9e3Hvvvfj973+veUxFRYUoZ++9996s7xcvXowNGzbIPquursZLL72EH//4x6iqqsKnn36K5557zvrNEESOYFSoUAH71a9+xX7xi1/IPnv11VfZbbfdxgCwMWPGsBdeeIG1t7ezrVu3sltuuUU8bt68eeyjjz5iR44cYXv37mW//OUvWTgcFr9njLGbbrqJbd68mW3dutVRPXft2sXOOeccze+LiorY4OAgmzx5svjZU089xe677z7V49va2tj111+v+t3ZZ5/Nurq6WFFRker3lZWVjDHGqqqq8v78qFChQoWKfwvJWPnn3/rWt9jSpUs1rxMIBNhll13GGGNs5MiReX9+VKhQoULFv2W4yFhpueeee9jjjz8u+6y+vp4xxpggCJrnnXbaaeyjjz5iX//619n7778vfn7DDTewDz/8UPy7qKiI9fX1salTp+b9+VGhAh9UgAoVX5R58+axPXv2sEAgwACw6upq1tvby0aNGsUCgQD79NNP2Y9//GMWDodZY2Mja2trYxdeeCEDwObOncvmz5/PBEFg9fX1bP369ezWW28Vf5sxxpYsWcIqKytZQUGB6vVXr17NrrnmGsN6Ggm0OXPmsN7eXtln3//+99lrr72WdexZZ53Furu7WXFxsepv/e53v8sSiNJy+eWXs7179+b92VGhQoUKFX8XkrHy7/QMs6tXr2aDg4OMMcb+93//N+/PjgoVKlSo+LsMFxkrLXqG2d27d7Ndu3ax3//+96y6ulr8PhgMss8++4zNnTuXLVq0SGaYffDBB9lvfvMb2e+1tLSwK6+8Mu/PjwoVCmVAEGmWL1+Ozs5OnH/++QCAhQsX4t1330V7ezvmzZuHkSNH4p577kEsFsO2bdvw2GOPYeHChQCAFStWYNmyZUgkEtixYwf+53/+Jyt+zn333YcjR45gYGBA9fqzZ8/Gn/70J8f3UVJSgq6uLtlnnZ2dKC0tzTp20aJFeOGFF9Db25v1XWFhIa666io88cQTqtepq6vDr3/9a/zLv/yL4zoTBEEQwxuSseaZPXs2ysrKcM011+CDDz5wVF+CIAhi+DNcZKwRhw4dwimnnIL6+nqcfPLJKC0txdNPPy1+/93vfhfLli3DihUrss4tKSlBZ2en7DMt+U0QXhPKdwUIwk88+eSTuO666/D222/juuuuw0MPPQQgFWi8trYW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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.5699920654296875\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_point1_arr, long_en_tp1, long_en_out0 = \\\n","get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=False)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_open_i = short_obj[-1].astype(int)\n","long_open_i = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_0 = res_df['short_epout_0_{}'.format(selection_id)].to_numpy()[short_open_i]\n","long_open_epout_0 = res_df['long_epout_0_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","short_open_epout_gap = res_df['short_epout_gap_{}'.format(selection_id)].to_numpy()[short_open_i]  # use open_i\n","long_open_epout_gap = res_df['long_epout_gap_{}'.format(selection_id)].to_numpy()[long_open_i]\n","\n","# ------ pairing 된 en, ex_idx 기준으로 survey 진행 ------ #\n","# 0. high, low (exit_done 까지의) -> partial (tpg) 과 outg survey 목표\n","#   a. short -> tpg - low, outg - high\n","#   b. long -> tpg - high, outg - low\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_epout_gap)\n","# long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_epout_gap)\n","\n","# ------ 0. tp 까지 도달하는 최소 idx 도출, en_idx 부터 ------ #\n","#   a. bias_info_tick 의 limit 을 정해주지 않으면 굉장히 길어질 수 있다고 봄\n","# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","\n","current_tpg= config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_tf = 'T'\n","wave_period = config.tr_set.wave_period\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_tf, wave_period))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_tf, wave_period))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_tf, wave_period))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_tf, wave_period))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A","colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"status":"ok","timestamp":1652096374378,"user_tz":-540,"elapsed":2193,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bbe0abff-666f-4dd9-de76-ad8e28c9a3ae"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1080 with 12 Axes>"],"image/png":"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6VbuAADPKSsrU0xMjHP7pptuUllZWaOvO3z4sKqrqxUdHe18zGazNTmPK+tgU17X0D2pgwYNUo8ePbR3714dOnRI8+bN06BBg3To0CHn62666SZ98MEHmjVrlt58880m5QK4guYGPmX58uUaOnSoc6nKOXPmNDi+rKxMNptNrVq1cj520003yeFwOLfrfuC7UwCuNfZ6isiVudYVGxurXr16acuWLTp06JDWrFmjHj166NChQ87iGR4eruzsbGVlZenVV19tUh4AAM9Yvny5Xn75ZUVERKhbt2762c9+5tI/7i9cuKA1a9ZoxowZatu2rfr06aPx48e7dMzy8nLdfPPNTcp30KBBiouLU6tWrdS1a1f9/ve/16ZNm3Ty5Mlrvuadd95Rr1691L9/f/Xv318/+9nPlJOTo/79++vChQvq2bOnNm7cqD/+8Y96/fXXm5QX4CqaG/iMuLg4DRs2TGFhYfrqq6/05Zdf6sKFCw2+Zvv27Tp79qymTJmikJAQJSUlafTo0Q1ezaioqHC5KLgztq6+ffuqX79+CgoKUvv27fWb3/xGDofjqiU0r5SXlyebzeYsIE8//bQqKirUv39/lZSUqGPHjnrvvff08ccf68UXX2xSXgAAz3nllVf0j3/8Q5999plyc3O1c+dOl5dWnjRpkjp37qzy8nItWbJEy5cvd2lq2YwZM5SRkaHjx4/rO9/5jlv53nzzzXr33Xd16tQp5eXl6dy5c7Wmctfn/PnzqqiocEZVVZWqq6tVUVEhSXr66ad1yy23aMaMGbV+PwfwFstv/CEIV+KOO+4w27dvNydPnjRHjx4169evNz169DDTp083S5YscY67dFP/pRs0+/btaz766CNz4sQJs2fPHjNmzBjn2PoWD7j11ltNTk6OOX78uFm7dm2DOT388MOmuLjYHD9+3PzkJz+56tgNxbBhw8y+ffvM6dOnTUVFhVm7dq259dZb3TondRcUGD9+vDHGmNOnT5tTp045w2azWf73RxAEQVxfzJ4927zxxhuW50EQLTla/fsPAAAAaEH69OmjsLAw5ebmKiEhQRs2bNDTTz/N75cBDWBaGgAAQAvUsWNHrVmzRmfOnNGKFSv0m9/8RuvWrdM999xTa3qXu1O9XnzxxXpfu2HDhgZfd61j3nPPPZ54u4BHcOUGaIDNZtPevXvrfa5v376Nror2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bOoHcUlJiW666aZ676O53gJyqblxp4C4k3tdoaGhtYrhyJEjlZ6ertGjRysvL69J+2wIBQRAoFi+fLlefvllRUREqFu3bvrZz36mN998s9HXXbhwQWvWrNGMGTPUtm1b9enTR+PHj2/0dW+//bZ69Oih5557TmFhYerQoYMGDRokSdq1a5cefPBBdenSRd27d3fOcmjM5s2bNWzYMLVt21YOh0NbtmzRqFGj1K1bN+Xk5Li0j8bcf//96t+/v4KCgtSxY0f99re/1fHjx51XVx577DG9+uqreuCBBzy2otnDDz/svL8pISFBzz77rNatW+eRfcM/0NzAq+Li4jRs2DCFhYXpq6++0pdffqkLFy40+Jrt27fr7NmzmjJlikJCQpSUlKTRo0c3eMm5oqLimt96XWnHjh06dOiQZs+erXbt2ql169bOJZV37dqle++9VzabTZ06dXKuVNOYTz75RH369NGgQYO0Y8cO7d27VzExMUpMTNTf//53l/bRmMTERA0ZMkShoaFq06aNpkyZou7du2v79u2SpGHDhmnp0qX69re/Lbvd7pFjjho1SjfeeKMkqU+fPvp//+//UUAABIRXXnlF//jHP/TZZ58pNzdXO3fu1CuvvOLSaydNmqTOnTurvLxcS5Ys0fLlyxud4nX69Gk98MADGj16tMrLy1VQUKBhw4ZJujhte/fu3frXv/6l7OxsrVixwqU8CgoKdPr0aedKbadOndIXX3yhjz/+uNE67Krw8HAtX75cVVVV+vzzz3XLLbdo1KhRzvf7yiuvqFu3brLb7c6fFFiwYMF1HXPcuHEqLCzUqVOntHjxYs2ZM0eLFy/2xNuBH7H8xh/Cf+OOO+4w27dvNydPnjRHjx4169evNz169Gj05v2+ffuajz76yJw4ccLs2bPHjBkzxjm2vsUDbr31VpOTk2OOHz9u1q5d22BONpvNrF271hw5csQcPnzYzJs3z/ncH//4R3P8+HFTUFBgnn766UYXFLgUn3zyidm4caNz+6233jJ79+6tNabuTfuuLFhwKe69916za9cu53n86KOPzNChQ53Pb9y40VRXV5tTp045Y8OGDS7/PdW3oMCvfvUrU15ebk6fPm0+//xzM3PmTBMSEmL5f1MEQRC+FLNnzzZvvPGG5XkQRKBEq3//AQAAANepT58+CgsLU25urhISErRhwwY9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8/y9995rampqjNR6zDx16pSJiory/LyhocFkZWWZyMhIc+bMGU++kmSeffZZ88EHH3S639zcXFNeXt7hzzqL5VJt9OjRZseOHUaSeeutt0x+fr4nx77//vvmH/7hH4wkk5eXZw4cONDmtUuXLjUlJSU+j90NN9xg/uM//sMMGDDgop/179/ffPLJJ2bOnDleby8vL6/DcbvjjjtM7969zRVXXGHmzJljvvjiCxMfH2/53w4teBpXbhBQLS0t6tWrl2666SZFR0frwIED2r9/vyRpy5Yteuutt3Tu3DktX75cw4YNkySNGDFC/fr104IFC3T27Flt2rRJf/jDH/Tggw96trt27Vr95S9/kTFGX331ldfxZGZmatCgQfrJT36iU6dO6auvvtKHH34oSXr44Yf1/PPPq6amRidPntTcuXOVm5vb6XSxzZs3684771RERITuvvtu/epXv9LIkSMlXXx27Ny5c3r66ad15swZ/e1vf5MkffTRR1q7dq2MMZ7nLuXDDz9UQkKCHA6Hfv3rX+uzzz67qE90dLRWrFihkpIS7d271+tx6UhhYaGuv/56ORwO/c///I/WrVun66+//rK2CQChYNCgQTpw4IDn8YEDBzRo0CDP48OHD6ulpcXz+NSpU+rXr5+uvvpqxcTEqLa21vOzC/99KSkpKfr000+7FUtHPvroIw0ZMkTXXHONbr31Vi1btkwpKSlKTExUZmam/vznP3canzcxt1ddXa1du3bpt7/9bZvne/furXXr1mnr1q1asGCBz9tt7y9/+Yv+9re/6fTp01qwYIGOHj2qu+6667K3C/uguEFAffrpp5o5c6bmz5+vxsZGvfbaa7r22mslSfX19Z5+p06d0hVXXKGoqCgNGjRItbW1MsZ4fn7gwAE5HA7P4+4ceKXWBHLgwIE2Sem8jhJITEyMBgwYcMnt7d+/XydPntStt96qu+66S3/4wx908OBBDRky5KLi5tChQxcVYt15HwcPHtSf/vQnlZaWtnk+IiJCy5cv15kzZzRjxgyft9vexx9/rBMnTujMmTNatmyZPvzwQ8+cbQCws4MHD7a5b/G6667TwYMHu3zdoUOHdPbsWSUnJ3ueS0lJ6fJ1tbW1lzx51J1YTp8+rf/93//Vk08+qcrKSp09e1Z/+ctfNGvWLH366adtpjlfmGs7e84b0dHR+ru/+zvP49jYWP3+979XXV2d/vVf/7Vb2+yKMUYREREB2TZCE8UNAu61117TXXfdpdTUVBljtHDhwk77Hzx4UCkpKW0OVtddd53cbrfncfsDr7cH4traWl133XUdXo3pKIGcPXtWDQ0NnW5z8+bNmjp1qmJjY3Xw4EFt3rxZeXl5uvLKK7V9+/ZOY/RXApGk4uJiDRgwQPfff7++/vrrbm23MyQQAOHitdde089+9jMlJSUpMTFR//7v/67f/e53Xb7u3LlzevPNNzV//nxdccUVuvHGGzVt2rQuX/eHP/xB1157rZ588knFxsaqX79+nmWTuxvL5s2bNWPGDM9Jtvfff7/NY3/Iz8/X1VdfLUkaOnSo5s6d67lXKDo6WqtWrdLp06eVl5fX7Xx3oZSUFN1xxx2KiYlRr1699G//9m9KSkryzMAAJIobBNiQIUP03e9+V7GxsZ7LyOfOnev0Ndu2bdOpU6c0e/ZsRUdHa9SoUZo8efJFVyou1NDQ4NWUqY8//lhffPGFFixYoD59+qhXr1664447JLUmkKeeekqDBw9W37599ctf/lKvv/56h1d5LnQ+gZy/zH8+gWzZsqXL9+qthx56yHP277rrrtMvfvELTwKRpCVLlmjo0KGaPHlyl9PbvBEfH697771XvXr1UlRUlB566CHdfffd+tOf/nTZ2waAYPfcc8/pr3/9qz755BPt3LlT5eXlnhUquzJjxgzFx8ervr5ey5cv12uvvdbl9OkTJ05o3Lhxmjx5surr6+VyuTyrlHU3ls2bNysuLs6Tm9o/9oeRI0dq586dOnHihNavX6/169dr3rx5klpXaZs8ebLuvfdeHT161PO1AnfeeWe399e/f38tWbJER44ckdvt1oQJE5Sdna0vv/zSX28JNmH5jT80+7ZbbrnFbNu2zRw7dswcPnzYrFu3zlx77bXm6aefNsuXL/f0S01NNcYYzw2aN910k3n//ffN0aNHza5du8yUKVM8fTtaPOCGG24wFRUV5siRI2bNmjWdxpSSkmLWrFljmpqazKFDh8yLL75oJJmIiAjz85//3Hz++eemsbHRLF++3CQkJHT5HocMGWKMMWbatGlGkomLizNnz541s2fP9vTp6Kb99mPQWXvuuedMbW2tOXHihKmtrTUvvfSSueqqq4wkc9111xljjDl9+rQ5fvy4pz300ENebbuj2JKS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\n"},"metadata":{}}]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg survey for partial"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF","colab":{"base_uri":"https://localhost:8080/","height":741},"executionInfo":{"status":"ok","timestamp":1651810855851,"user_tz":-540,"elapsed":1684,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"804a766a-6321-41bc-dcb6-85eaab111963"},"outputs":[{"output_type":"stream","name":"stdout","text":["52\n","52\n","52\n","52\n","pkx : [0.03997647 2.0167238  2.73054922]\n","pkx : [-0.03767855  0.18363707  0.58602909  0.7268663   0.88782311  1.39081314]\n","\n","74\n","74\n","65\n","65\n","pkx : [-5.71029994 -5.09579043 -3.40588927 -1.25510598]\n","pkx : [-3.72574064 -3.42625567 -2.45292953 -1.18011842]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_true_open_idxth], short_max_tpg]\n","long_max_datas = [long_max_outg[long_true_open_idxth], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v3"]},{"cell_type":"code","execution_count":54,"metadata":{"id":"oVifICO4-Grk","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1652259145074,"user_tz":-540,"elapsed":51599,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"15c11efd-8476-48f7-81af-ac91eaf15968"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1070\n","np.sum(long_open_res == 1) : 1076\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.98561692237854\n","en_ex_pairing elapsed time : 0.05893969535827637\n","short_obj.shape : (79, 5)\n","long_obj.shape : (123, 5)\n","idep_plot elapsed time : 0.1969587802886963\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1066\n","np.sum(long_open_res == 1) : 1074\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9760744571685791\n","en_ex_pairing elapsed time : 0.05620408058166504\n","short_obj.shape : (75, 5)\n","long_obj.shape : (122, 5)\n","idep_plot elapsed time : 0.20552992820739746\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1061\n","np.sum(long_open_res == 1) : 1067\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9734976291656494\n","en_ex_pairing elapsed time : 0.05585336685180664\n","short_obj.shape : (70, 5)\n","long_obj.shape : (118, 5)\n","idep_plot elapsed time : 0.19785642623901367\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1055\n","np.sum(long_open_res == 1) : 1061\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9835896492004395\n","en_ex_pairing elapsed time : 0.055999040603637695\n","short_obj.shape : (69, 5)\n","long_obj.shape : (109, 5)\n","idep_plot elapsed time : 0.19546866416931152\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1052\n","np.sum(long_open_res == 1) : 1057\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9867618083953857\n","en_ex_pairing elapsed time : 0.0564119815826416\n","short_obj.shape : (66, 5)\n","long_obj.shape : (104, 5)\n","idep_plot elapsed time : 0.20241785049438477\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1045\n","np.sum(long_open_res == 1) : 1047\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9958846569061279\n","en_ex_pairing elapsed time : 0.05605316162109375\n","short_obj.shape : (62, 5)\n","long_obj.shape : (99, 5)\n","idep_plot elapsed time : 0.1954793930053711\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1039\n","np.sum(long_open_res == 1) : 1042\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.976466178894043\n","en_ex_pairing elapsed time : 0.05942726135253906\n","short_obj.shape : (58, 5)\n","long_obj.shape : (91, 5)\n","idep_plot elapsed time : 0.20114374160766602\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1029\n","np.sum(long_open_res == 1) : 1038\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9998548030853271\n","en_ex_pairing elapsed time : 0.05476188659667969\n","short_obj.shape : (53, 5)\n","long_obj.shape : (90, 5)\n","idep_plot elapsed time : 0.19998598098754883\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1021\n","np.sum(long_open_res == 1) : 1030\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9690916538238525\n","en_ex_pairing elapsed time : 0.055519819259643555\n","short_obj.shape : (49, 5)\n","long_obj.shape : (86, 5)\n","idep_plot elapsed time : 0.19730353355407715\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 1014\n","np.sum(long_open_res == 1) : 1017\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9809539318084717\n","en_ex_pairing elapsed time : 0.054154396057128906\n","short_obj.shape : (48, 5)\n","long_obj.shape : (83, 5)\n","idep_plot elapsed time : 0.20033836364746094\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 998\n","np.sum(long_open_res == 1) : 1012\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9777100086212158\n","en_ex_pairing elapsed time : 0.056030988693237305\n","short_obj.shape : (44, 5)\n","long_obj.shape : (81, 5)\n","idep_plot elapsed time : 0.19577407836914062\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 981\n","np.sum(long_open_res == 1) : 1000\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9774794578552246\n","en_ex_pairing elapsed time : 0.05725836753845215\n","short_obj.shape : (42, 5)\n","long_obj.shape : (77, 5)\n","idep_plot elapsed time : 0.2030024528503418\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 965\n","np.sum(long_open_res == 1) : 983\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9710261821746826\n","en_ex_pairing elapsed time : 0.05236315727233887\n","short_obj.shape : (41, 5)\n","long_obj.shape : (69, 5)\n","idep_plot elapsed time : 0.19158506393432617\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 959\n","np.sum(long_open_res == 1) : 971\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9748063087463379\n","en_ex_pairing elapsed time : 0.06032609939575195\n","short_obj.shape : (40, 5)\n","long_obj.shape : (65, 5)\n","idep_plot elapsed time : 0.19276690483093262\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 942\n","np.sum(long_open_res == 1) : 964\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9906868934631348\n","en_ex_pairing elapsed time : 0.05193161964416504\n","short_obj.shape : (40, 5)\n","long_obj.shape : (63, 5)\n","idep_plot elapsed time : 0.19574499130249023\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 932\n","np.sum(long_open_res == 1) : 953\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9787445068359375\n","en_ex_pairing elapsed time : 0.05242204666137695\n","short_obj.shape : (35, 5)\n","long_obj.shape : (60, 5)\n","idep_plot elapsed time : 0.19339871406555176\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 916\n","np.sum(long_open_res == 1) : 946\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9695684909820557\n","en_ex_pairing elapsed time : 0.049555301666259766\n","short_obj.shape : (32, 5)\n","long_obj.shape : (58, 5)\n","idep_plot elapsed time : 0.19559359550476074\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 906\n","np.sum(long_open_res == 1) : 935\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9871079921722412\n","en_ex_pairing elapsed time : 0.04972243309020996\n","short_obj.shape : (32, 5)\n","long_obj.shape : (54, 5)\n","idep_plot elapsed time : 0.19104456901550293\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 896\n","np.sum(long_open_res == 1) : 923\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9768602848052979\n","en_ex_pairing elapsed time : 0.047910451889038086\n","short_obj.shape : (32, 5)\n","long_obj.shape : (53, 5)\n","idep_plot elapsed time : 0.20460772514343262\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 884\n","np.sum(long_open_res == 1) : 911\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9901659488677979\n","en_ex_pairing elapsed time : 0.04886054992675781\n","short_obj.shape : (29, 5)\n","long_obj.shape : (52, 5)\n","idep_plot elapsed time : 0.19721603393554688\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 871\n","np.sum(long_open_res == 1) : 899\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9765374660491943\n","en_ex_pairing elapsed time : 0.045633792877197266\n","short_obj.shape : (27, 5)\n","long_obj.shape : (47, 5)\n","idep_plot elapsed time : 0.19062566757202148\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 848\n","np.sum(long_open_res == 1) : 886\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9899089336395264\n","en_ex_pairing elapsed time : 0.044362783432006836\n","short_obj.shape : (22, 5)\n","long_obj.shape : (46, 5)\n","idep_plot elapsed time : 0.19950461387634277\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 821\n","np.sum(long_open_res == 1) : 866\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9726293087005615\n","en_ex_pairing elapsed time : 0.04307842254638672\n","short_obj.shape : (20, 5)\n","long_obj.shape : (43, 5)\n","idep_plot elapsed time : 0.19322705268859863\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 798\n","np.sum(long_open_res == 1) : 851\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9705297946929932\n","en_ex_pairing elapsed time : 0.04326605796813965\n","short_obj.shape : (19, 5)\n","long_obj.shape : (42, 5)\n","idep_plot elapsed time : 0.19417881965637207\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 778\n","np.sum(long_open_res == 1) : 839\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.988872766494751\n","en_ex_pairing elapsed time : 0.04237842559814453\n","short_obj.shape : (18, 5)\n","long_obj.shape : (39, 5)\n","idep_plot elapsed time : 0.19797563552856445\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","compare by back_idx\n","np.sum(short_open_res == 1) : 1078\n","np.sum(long_open_res == 1) : 1090\n","point validation\n","np.sum(short_open_res == 1) : 756\n","np.sum(long_open_res == 1) : 828\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 1.05318 0.30200 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 0.57249 0.30200 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9861412048339844\n","en_ex_pairing elapsed time : 0.040114641189575195\n","short_obj.shape : (17, 5)\n","long_obj.shape : (36, 5)\n","idep_plot elapsed time : 0.19478249549865723\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"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REZG4vr16zhy5Ag2b94MANiyZQt27NiB8+fPIy0tDY8fP8bcuXMBPBs24auvvsKlS5dQVFQEd3d3KR8CUZOihmeD5RIRERERNXurV6+GmZkZpk6dKnUqRERERET1wjNyiYiIiKjZcnBwQPfu3QEAffr0wbRp03jlDBERERE1SRpSJ0BEREREpCx6enoIDAyEubk58vLysHbtWhw6dEjqtIiIiIiI6o1DKxARERERERERERGpOA6tQERERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFLREREREREREREpOLYkUtERERERERERESk4tiRS0RERERERERERKTi2JFL1EKlpaXBy8tL6jRICbZu3YpVq1a9dD0dHR0EBwfj/v372Lt3byNkRkTUMrDGNk+sr0RE0mONbZ5YY+uOHbmNyNraGiEhIXj48CESEhL+9M1nzZo1yMjIQHFxMW7fvo0lS5ZUWz506FBERkaiuLgYqampmD59urLTVwlCCHTu3FnqNEhi8+bNw507d1BcXIzNmzdDS0urxvWcnJwQERGBwsJCFBYW4uTJk3BycpIv19LSwsaNG5Gbm4t79+4hODgY5ubmjfUwJPfWW2/B1NQUxsbGmDBhwp+uO3HiRNy+fRsPHjzAwYMHYWRkVON6xsbGuHjxIu7evYuioiJcvnwZAwYMkC/fuHEjSktL5fH48WOUlJQo9HFRy8Qa2zCsr/Q71tiGY32l5oT1teFYY+l3rLENxxr7jGjpoa6u3ij7uXz5sli7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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","val_list = np.arange(-0.382, 0.382, 0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.ei_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    # enlist_rtc(res_df, config_, np_timeidx)\n","    enlist_tr(res_df, config_, np_timeidx)\n","  open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","\n","  try:\n","    result.append(get_res_v5(res_df, open_info_df, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx = open_info_df.index.to_numpy()\n","  len_df = len(res_df)\n","  s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","  s_open_info_df = open_info_df[s_idx]\n","  s_open_idx = open_idx[s_idx]\n","\n","  open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","  side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v5(res_df, s_open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v13(res_df, len_df, config_list[0], high, low, s_open_idx, side_arr, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8LiKwfiJ4bvM"},"outputs":[],"source":["def plot_info_v6(gs, gs_idx, sample_len, tr, prcn, rc, bars_in, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    # title_str = \"prcn : {:.3f} rc : {:.3f}\\n len_pr : {} dpf : {:.3f}\\n wr : {:.3f} sr : {:.3f}\\n acc_pr : {:.3f} sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f} liqd : {:.3f}\\n acc_mdd : -{:.3f} sum_mdd : -{:.3f}\\n leverage {}\"\n","    # title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n rc : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n wave_bias : {:.3f}\\n bars_in : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    plt.title(title_str.format(tr, prcn, rc, bars_in, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"]},{"cell_type":"code","source":["def ffill_line(line_, idx_):\n","  len_line = len(line_)\n","  total_en_idx = np.zeros(len_line)\n","  total_en_idx[idx_] = 1\n","  idx_line_ = np.where(total_en_idx, line_, np.nan)\n","  idx_line = pd.Series(idx_line_).ffill().to_numpy()\n","\n","  return idx_line\n","\n","def get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj):\n","  \n","  short_op_idx = short_obj[-1].astype(int)\n","  short_en_idx = short_obj[2].astype(int)\n","  short_en_tp1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)   # en_idx 에 sync 된 open_idx 를 사용해야함\n","  short_en_out0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","  long_op_idx = long_obj[-1].astype(int)\n","  long_en_idx = long_obj[2].astype(int)\n","  long_en_tp1 = ffill_line(res_df['long_wave_1_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","  long_en_out0 = ffill_line(res_df['long_wave_0_{}'.format(config.selection_id)].to_numpy(), long_op_idx)\n","\n","  bias_info_tick = config.tr_set.bias_info_tick\n","\n","  # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","  # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","  # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","  len_df_range = np.arange(len_df)\n","  last_idx = len_df - 1\n","  shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","  short_en_tp1_touch_idx = pd.Series(np.where(low <= short_en_tp1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[short_en_idx]  \n","  short_en_out0_touch_idx = pd.Series(np.where(high >= short_en_out0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[short_en_idx]\n","\n","  long_en_tp1_touch_idx = pd.Series(np.where(high >= long_en_tp1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[long_en_idx]\n","  long_en_out0_touch_idx = pd.Series(np.where(low <= long_en_out0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()[long_en_idx]\n","\n","  short_true_bias_idx = short_en_tp1_touch_idx < short_en_out0_touch_idx  # true_bias 의 조건\n","  long_true_bias_idx = long_en_tp1_touch_idx < long_en_out0_touch_idx\n","\n","  short_false_bias_idx = short_en_tp1_touch_idx >= short_en_out0_touch_idx  # false_bias 의 조건\n","  long_false_bias_idx = long_en_tp1_touch_idx >= long_en_out0_touch_idx\n","\n","  # return short_true_bias_idx.ravel(), short_false_bias_idx.ravel(), long_true_bias_idx.ravel(), long_false_bias_idx.ravel()\n","  return short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1[short_en_idx], short_en_out0[short_en_idx], long_en_tp1[long_en_idx], long_en_out0[long_en_idx]\n","\n","  \n","def wave_bias(true_idx, false_idx):  # 정확하게 하려고, true & false 로 기준함\n","    true_sum = np.sum(true_idx)\n","    false_sum = np.sum(false_idx)\n","    return true_sum / (true_sum + false_sum)"],"metadata":{"id":"aFpEbTaECnGW"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_pr_v4(open_side, h, l, obj, tpout, lvrg, fee, p_ranges, p_qty_ratio, inversion=False):  # --> 여기서 사용하는 ex_p = ex_p\n","\n","    en_p = obj[0]\n","    # ex_p = obj[1]\n","    tp, out = np.split(tpout, 2, axis=1)\n","    len_p = len(p_ranges)\n","    en_ps, tps, outs, lvrgs, fees = [np.tile(arr_, (1, len_p)) for arr_ in [en_p, tp, out, lvrg, fee]]\n","\n","    np_obj = np.array(obj).T[0]\n","    assert len(np_obj.shape) == 2\n","\n","    # iin == iout 인 경우 분리\n","    en_idx = np_obj[:, 2]\n","    ex_idx = np_obj[:, 3]\n","    equal_idx = en_idx == ex_idx\n","\n","    min_low = np.full_like(en_p, np.nan)\n","    min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","    max_high = np.full_like(en_p, np.nan)\n","    max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","\n","    if open_side == \"SELL\":\n","        p_tps = en_ps - (en_ps - tps) * p_ranges\n","        # min_low = np.full_like(en_p, np.nan)\n","        # min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","        tp_idx = (np.tile(min_low, (1, len_p)) <= p_tps) * (np.tile(max_high, (1, len_p)) <= outs)  # entry_idx 포함해서 out touch 금지 (보수적 검증)\n","    else:\n","        p_tps = en_ps + (tps - en_ps) * p_ranges\n","        # max_high = np.full_like(en_p, np.nan)\n","        # max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","        tp_idx = (np.tile(max_high, (1, len_p)) >= p_tps) * (np.tile(min_low, (1, len_p)) >= outs)\n","\n","    ex_ps = outs.copy()\n","    ex_ps[tp_idx] = p_tps[tp_idx]\n","\n","    if open_side == \"SELL\":\n","        if not inversion:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","    else:\n","        if not inversion:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","\n","    return pr.reshape(-1, 1), liqd"],"metadata":{"id":"642Dt6urKfvF"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v13(res_df, len_df, config, high, low, open_idx, side_arr, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5), fontsize=15, signi=False):\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        fig = plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","    \n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","      sample_len = int(len_df * sample_ratio)\n","    else:\n","      sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","    point1_arr, valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res    \n","    assert len(valid_openi_arr) != 0, \"assert len(valid_openi_arr) != 0\"    \n","    short_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.SELL)[0]  # valid_openi_arr 에 대한 idx, # side_arr,\n","    long_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.BUY)[0]\n","\n","    valid_open_idx = open_idx[valid_openi_arr].reshape(-1, 1)\n","\n","    short_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[short_valid_openi_idx]\n","    long_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[long_valid_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_point1_arr, long_point1_arr = [point1_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)    \n","    # print(\"elapsed time :\", time.time() - start_0)\n","\n","    short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1, short_en_out0, long_en_tp1, long_en_out0 = \\\n","    get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj)\n","\n","    len_short, len_long = len(short_valid_openi_idx), len(long_valid_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","      # start_0 = time.time()      \n","      if len_short == 0:\n","        short_pr = []\n","        gs_idx += 1\n","      else:\n","        short_tr = short_tr_arr.mean()\n","        short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","        short_cum_pr = np.cumprod(short_total_pr)\n","        # short_liqd = liquidation_v2(OrderSide.SELL, h, short_obj[:4], short_lvrg_arr, short_fee_arr)\n","        short_prcn, short_rc = precision(short_pr, short_true_bias_idx), wave_bias(short_true_bias_idx, short_false_bias_idx)\n","        short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","        if signi:\n","          short_idep_res_obj = (short_prcn, short_rc) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, short_tr, short_prcn, short_rc, short_trade_ticks, short_pr, short_total_pr, short_cum_pr, short_liqd, short_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in short plot_data :\", e)\n","\n","    try:\n","      # start_0 = time.time()   \n","      if len_long == 0:\n","        long_pr = []\n","        gs_idx += 1\n","      else:\n","        long_tr = long_tr_arr.mean()\n","        long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","        long_cum_pr = np.cumprod(long_total_pr)\n","        # long_liqd = liquidation_v2(OrderSide.BUY, l, long_obj[:4], long_lvrg_arr, long_fee_arr)\n","        long_prcn, long_rc = precision(long_pr, long_true_bias_idx), wave_bias(long_true_bias_idx, long_false_bias_idx)\n","        long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","        if signi:\n","          long_idep_res_obj = (long_prcn, long_rc) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, long_tr, long_prcn, long_rc, long_trade_ticks, long_pr, long_total_pr, long_cum_pr, long_liqd, long_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in long plot_data :\", e)\n","\n","    \n","    try:\n","      # start_0 = time.time()\n","      if len_short * len_long == 0:\n","        both_pr = []\n","        gs_idx += 1\n","      else:\n","        both_tr = (short_tr + long_tr) / 2\n","        both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","        both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","        both_cum_pr = np.cumprod(both_total_pr)\n","        both_liqd = min(short_liqd, long_liqd)\n","        both_true_bias_idx = np.vstack((short_true_bias_idx, long_true_bias_idx))  # vstack for 2d arr\n","        both_false_bias_idx = np.vstack((short_false_bias_idx, long_false_bias_idx))\n","        both_prcn, both_rc = precision(both_pr, both_true_bias_idx), wave_bias(both_true_bias_idx, both_false_bias_idx)\n","        both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","        if signi:\n","          both_idep_res_obj = (both_prcn, both_rc) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, both_tr, both_prcn, both_rc, both_trade_ticks, both_pr, both_total_pr, both_cum_pr, both_liqd, lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","      if len_short * len_long > 0:\n","        for obj, cum_pr in zip([short_obj, long_obj, both_obj], [short_cum_pr, long_cum_pr, both_cum_pr]):\n","          try:\n","            # start_0 = time.time()\n","            gs_idx = frq_dev_plot_v3(gs, gs_idx, len_df, sample_len, obj[-2], cum_pr[-1], fontsize)\n","            # print(\"elapsed time :\", time.time() - start_0)          \n","          except Exception as e:\n","            gs_idx += 1\n","            print(\"error in frq_dev_plot_v3 :\", e)\n","        plt.show()\n","        plt.close()\n","\n","      return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_true_bias_idx, short_false_bias_idx, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_true_bias_idx, long_false_bias_idx, long_point1_arr, long_en_tp1, long_en_out0\n","        \n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v5(res_df, open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs):  # 이미 충분히 줄여놓은 idx 임\n","    side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","    id_idx_arr = id_idx_arr.astype(int)\n","\n","    ep_out, ep_loc_point2, lvrg_set = funcs\n","\n","    point1_list, valid_openi_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(8)]\n","    len_df = len(res_df)\n","    len_open_idx = len(open_idx)\n","    i, open_i = 0, -1  # i for total_res_df indexing\n","\n","    while 1:\n","        # ------------ entry phase ------------ #\n","        open_i += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i >= len_open_idx:\n","            break\n","\n","        # ------ ep_loc ------ #\n","        op_idx = open_idx[open_i]  # open_i 는 i 와 별개로 운영\n","        if op_idx < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ dynamic data by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        id_idx = id_idx_arr[open_i]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        open_side = side_arr[open_i]\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()  # => eptpout arr_list 만들어서 꺼내 사용하면 될 것\n","        point_idxgap_arr = res_df['{}_point_idxgap_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        ep_arr = res_df['{}_ep_{}'.format(side_pos, selection_id)].to_numpy()  # Todo - while loop 내에서 to_numpy() 반복하느니, pd_indexing 이 낫지 않을까\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","        # bias_info_arr = res_df['{}_bias_info_{}'.format(side_pos, selection_id)].to_numpy()  # ex. rolling(entry ~ end)'s high\n","        # bias_thresh_arr = res_df['{}_bias_thresh_{}'.format(side_pos, selection_id)].to_numpy()  # ex. close + dc_T20 * 0.5\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ ei_k & point2 ------ #\n","        i = op_idx + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        point_idxgap = point_idxgap_arr[op_idx]\n","        if np.isnan(point_idxgap):\n","            continue\n","        else:\n","            # ------ allow point2 only next to point1 ------ #\n","            open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","            tp_j = int(op_idx - point_idxgap)\n","            if np.sum(open_arr[tp_j:op_idx]) != 0:\n","                continue\n","\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side,\n","                                                                                 [*ohlc_list, ep_arr], ep_out, ep_loc_point2)\n","        i = exec_j\n","\n","        if not entry_done:\n","            continue\n","\n","        # ------ leverage ------ #\n","        out = out_arr[out_j]  # lvrg_set use out on out_j\n","        leverage = lvrg_set(res_df, config, open_side, en_p, out, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","        if leverage is None:\n","            continue\n","\n","        exit_done, cross_on = 0, 0\n","        # ------ check tpout_onexec ------ #\n","        # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","        if config.ep_set.entry_type == \"LIMIT\":\n","            if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                tp_j = exec_j\n","            if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                out_j = exec_j\n","\n","        while 1:\n","            # ------------ exit phase ------------ #\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ out ------------ #  # out 우선 (보수적 검증)\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_market_out_exec_v2(config, res_df, np_timeidx, open_i, i, len_df, fee, open_side, cross_on, exit_done)\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out != \"None\":\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_out(config, open_i, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","              if not exit_done:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                           [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                point1_list.append(tp_j)\n","                valid_openi_list.append(open_i)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                # bias_list.append([bias_info_arr[exec_j], bias_thresh_arr[exec_j]])  # backtest 에서만 가능한 future_data 사용\n","                # bias_list.append([bias_info_arr[exec_j], tp_arr[tp_j]])  # bias_info 는 entry_idx 부터 & tp = bias_thresh\n","                tr_list.append(tr_arr[op_idx])\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(point1_list), np.array(valid_openi_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side, np_datas, ep_out, ep_loc_point2):\n","    o, h, l, c, ep_arr = np_datas\n","    ep_j = op_idx\n","    # tp_j = op_idx\n","    out_j = op_idx\n","\n","    selection_id = config.selection_id    \n","    allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ ei_k ------ # - limit 사용하면 default 로 ei_k 가 존재해야함\n","            if ep_out(res_df, config, op_idx, e_j, tp_j, [h, l], open_side):\n","              break\n","\n","            # ------ point2 ------ #\n","            if not allow_ep_in:\n","                allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","                if allow_ep_in:\n","                  if config.ep_set.point2.entry_type == \"LIMIT\":\n","                    ep_j = e_j\n","                    # print(\"e_j in point2 :\", e_j)\n","                    continue\n","\n","            # ------ check ep_exec ------ #\n","            if allow_ep_in:\n","              if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","                entry_done = 1\n","                ep = c[e_j]\n","                break\n","              else:\n","                if open_side == OrderSide.SELL:\n","                    if h[e_j] >= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                            ep = o[e_j]\n","                        break\n","                else:\n","                    if l[e_j] <= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] <= ep_arr[ep_j]:\n","                            ep = o[e_j]\n","                        break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = c[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, j, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        try:\n","            if config.tr_set.decay_gap != \"None\":\n","                decay_share = (j - open_i) // config.tp_set.decay_term\n","                decay_remain = (j - open_i) % config.tp_set.decay_term\n","                if j != open_i and decay_remain == 0:\n","                    if open_side == OrderSide.SELL:\n","                        tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","                    else:\n","                        tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        except:\n","            pass\n","\n","        if open_side == OrderSide.SELL:\n","            if l[j] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if l[j] <= tp_arr[j] <= h[j]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[j]:\n","                        tp = o[j]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[j]\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if h[j] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    if o[j] > tp_arr[j]:\n","                        tp = o[j]\n","                    else:\n","                        tp = tp_arr[j]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if o[j] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_market_out_exec_v2(config, res_df, np_timeidx, open_i, j, len_df, fee, open_side, cross_on, exit_done):    \n","    close = res_df['close'].to_numpy()\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[j] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and j != open_i:\n","            exit_done = 1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[j - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[j] < 50 - config.loc_set.point.osc_band):\n","                exit_done = 1\n","        else:\n","            if (rsi_T[j - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[j] > 50 + config.loc_set.point.osc_band):\n","                exit_done = 1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[j] < ha_c[j]):# & (ha_o[j] == ha_l[j]):   # 양봉 출현\n","    #           exit_done = 1\n","    #     else:\n","    #       if (ha_o[j] > ha_c[j]):# & (ha_o[j] == ha_h[j]):  # 음봉 출현\n","    #           exit_done = 1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[j] < bb_lower_5T[j] < close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] > bb_upper_5T[j] > close[j - 1]:\n","                exit_done = 1\n","        else:\n","            if close[j] > bb_upper_5T[j] > close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] < bb_lower_5T[j] < close[j - 1]:\n","                exit_done = 1\n","\n","    if exit_done:\n","        ex_p = close[j]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_out(config, open_i, j, out_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if h[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if l[j] <= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if c[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if c[j] <= out_arr[out_j]:  # check out only once\n","                ex_p = c[j]\n","                exit_done = 1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = c[j]\n","\n","        if open_side == OrderSide.SELL:\n","            if o[j] >= out_arr[out_j]:\n","                ex_p = o[j]\n","        else:\n","            if o[j] <= out_arr[out_j]:\n","                ex_p = o[j]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_df\n","del np_plot_params"]},{"cell_type":"code","execution_count":37,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1652258670601,"user_tz":-540,"elapsed":2848,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","front_plot = 3    # 0 : whole, 1 : open, 2 : ep_tick, 3 : tp_tick, 4 : bias_tick\n","bias_plot = 1     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","pr_descend = 1    # 1 : 큰 pr 부터, 0 : 작은 pr 부터\n","position = 1      # -1 : short 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 50 #  150 100 20\n","# post_plotsize = 60\n","post_plotsize = config.tr_set.bias_info_tick\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_point1_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_en_tp1, short_en_out0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_point1_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_en_tp1, long_en_out0]\n","pr, obj, [point1_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, false_bias_arr, en_tp1, en_out0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","# ------------------ data chunknize ------------------ #\n","np_df = res_df.to_numpy()\n","\n","# left_end_idx = obj[2] - prev_plotsize  # left_margin 기준 - entry_idx\n","left_end_idx = obj[4] - prev_plotsize  # left_margin 기준 - open_idx\n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, point1_arr, lvrg_arr, fee_arr, tpout_arr, en_tp1, en_out0))[invalid_left_end:]  # all arr should have same dimension\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = false_bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":19,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1443,"status":"ok","timestamp":1652257620429,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"4aa29ff6-8116-4f0c-bd93-bb5ce5d214c6","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","data_window_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_tf1 = 'T'\n","wave_period1 = 5\n","wave_tf2 = '15T'\n","wave_period2 = 5\n","\n","step_col_list.append([['dc_base_{}{}'.format(wave_tf1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_tf2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 1\n","dc_tf2 = '15T'\n","dc_period2 = 1\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 60\n","\n","step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf1, wave_period1)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf1, wave_period1)], 1, '#00ff00', 7, '*'])\n","\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf2, wave_period2)], 1, '#e91e63', 10, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf2, wave_period2)], 1, '#2962ff', 10, '*'])\n","  \n","stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_tf1, wave_period1)], 1, '#00ff00', 5, 'o'])\n","stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_tf1, wave_period1)], 1, '#ff00ff', 5, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_{}{}'.format(wave_tf1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['cu_wrr_32_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['co_wrr_32_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_col_arr = strcol_tonumb(res_df, data_window_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_col_info\": data_window_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close'])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_tf2, wave_period2), 'wave_high_fill_{}{}'.format(wave_tf2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":38,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1zlzhJegT5GxsrS4Ao0oeagZXs1TaV-y3"},"outputId":"a721ad34-68a6-48b8-941f-0060c86a9276","executionInfo":{"status":"error","timestamp":1652258755343,"user_tz":-540,"elapsed":84744,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["_ = [plot_check_v6(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v6(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, lvrg, fee, tp_line, out_line, en_tp1, en_out0 = params\n","\n","    # if exit_idx - open_idx < 50:  # temporary\n","    #   break\n","\n","    ax = fig.add_subplot(gs[gs_idx])\n","\n","    # ------------ add_col section ------------ #\n","    a_data = data[int(iin):int(iout + 1)]\n","    # a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v5(config, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                    front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline_v3 :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *data[int(open_idx), params_[0]]) for params_ in col_idx_dict['data_window_col_info']]  # * for unsupported format for arr\n","    ps_msg_expand = pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    plt.title(ps_msg_expand)\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v5(config, en_p, ex_p, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  point1_tick = open_tick - int(open_idx - point1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if front_plot == 1:\n","    x_max = open_tick + 20\n","  elif front_plot == 2:\n","    x_max = entry_tick + 20 \n","  elif front_plot == 3:\n","    x_max = exit_tick + 20\n","  elif front_plot == 4:\n","    x_max = bias_info_tick + 20\n","\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  plt.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ wave_line ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  plt.axhline(en_tp1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_tp1, ' wave_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  plt.axhline(en_out0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_out0, ' wave_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  point1_ymax, open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [point1_tick, open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(point1_tick, 0, point1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff7722')\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","VdukVo5-Suzj","Bw5JibDKSuzj","Pe0QpnORSuzk","E0n53hflJbnp","MlFkpO1MSuzl","t1E_eAyPSuzm","nUs4fjVHSuzl","L7l5CTJfSuzn","x_XGJqBi8Jex","MSUY4nnku3s9","epgS5Dksu-HX","Iy76iO7gztne","x2yj2SwAXDLp","EOXQbXixiQcK","xpyP5t8Ht_pE","MuD_2vY7TI_8","mScdfR9hmjVu","xivLUsSGC4VF","sZAYhcdoXnm4","zmYbP-Gc1ojs","5rdQZm_71ojv","tApzvz_gK9lR","OJqkmkpsLCYC"],"name":"stem5_41_vec_backi2(0509_waverange_v11_2).ipynb","toc_visible":true,"provenance":[],"authorship_tag":"ABX9TyP3dLdCtVMK/JUhAHtwOur9"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}