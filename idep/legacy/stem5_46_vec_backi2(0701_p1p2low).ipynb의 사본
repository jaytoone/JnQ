{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1657549185716,"user_tz":-540,"elapsed":27021,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2787827a-3ed5-4f40-ff07-eb718aa6e619"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1657549216182,"user_tz":-540,"elapsed":30469,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    # --------------- ma --------------- #  \n","    # df = ma(df, 60)\n","    # print(\"ma phase done\")\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df, dc_period=10)\n","    # df = dc_line_v4(df, df, dc_period=20)\n","    df = dc_line_v4(df, df, dc_period=100)\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 100\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    \n","    # df = bb_line_v3(df, df_15T, 60)\n","    \n","    # df = bb_line_v3(df, df, bb_period)\n","    # df = bb_level_v2(df, 'T', bb_period)\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":620},"executionInfo":{"elapsed":2895,"status":"ok","timestamp":1657341694167,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"odqVwQHpYo1M","outputId":"333f7d19-3520-4b1a-8c27-bc6fb19c6412"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n","dc phase done\n"]},{"output_type":"execute_result","data":{"text/plain":["                         bb_base_T100  bb_upper2_T100  bb_lower2_T100  bb_upper3_T100  bb_lower3_T100       ma_T30       ma_T60  dc_upper_T100  dc_lower_T100  dc_base_T100\n","index                                                                                                                                                                      \n","2022-04-27 08:41:59.999     2818.1561     2856.318561     2779.993639     2875.399792     2760.912408  2792.450333  2806.733500        2844.49        2761.27       2802.88\n","2022-04-27 08:42:59.999     2817.8222     2856.020487     2779.623913     2875.119631     2760.524769  2792.417000  2806.293167        2844.49        2761.27       2802.88\n","2022-04-27 08:43:59.999     2817.5076     2855.655941     2779.359259     2874.730112     2760.285088  2792.547667  2805.914333        2844.49        2761.27       2802.88\n","2022-04-27 08:44:59.999     2817.1757     2855.226008     2779.125392     2874.251162     2760.100238  2792.546000  2805.607667        2844.49        2761.27       2802.88\n","2022-04-27 08:45:59.999     2816.8187     2854.820835     2778.816565     2873.821903     2759.815497  2792.391333  2805.184500        2844.49        2761.27       2802.88"],"text/html":["\n","  <div id=\"df-a192359a-9ecb-40c5-ba06-d6f85d8284ed\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>bb_base_T100</th>\n","      <th>bb_upper2_T100</th>\n","      <th>bb_lower2_T100</th>\n","      <th>bb_upper3_T100</th>\n","      <th>bb_lower3_T100</th>\n","      <th>ma_T30</th>\n","      <th>ma_T60</th>\n","      <th>dc_upper_T100</th>\n","      <th>dc_lower_T100</th>\n","      <th>dc_base_T100</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2818.1561</td>\n","      <td>2856.318561</td>\n","      <td>2779.993639</td>\n","      <td>2875.399792</td>\n","      <td>2760.912408</td>\n","      <td>2792.450333</td>\n","      <td>2806.733500</td>\n","      <td>2844.49</td>\n","      <td>2761.27</td>\n","      <td>2802.88</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2817.8222</td>\n","      <td>2856.020487</td>\n","      <td>2779.623913</td>\n","      <td>2875.119631</td>\n","      <td>2760.524769</td>\n","      <td>2792.417000</td>\n","      <td>2806.293167</td>\n","      <td>2844.49</td>\n","      <td>2761.27</td>\n","      <td>2802.88</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2817.5076</td>\n","      <td>2855.655941</td>\n","      <td>2779.359259</td>\n","      <td>2874.730112</td>\n","      <td>2760.285088</td>\n","      <td>2792.547667</td>\n","      <td>2805.914333</td>\n","      <td>2844.49</td>\n","      <td>2761.27</td>\n","      <td>2802.88</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2817.1757</td>\n","      <td>2855.226008</td>\n","      <td>2779.125392</td>\n","      <td>2874.251162</td>\n","      <td>2760.100238</td>\n","      <td>2792.546000</td>\n","      <td>2805.607667</td>\n","      <td>2844.49</td>\n","      <td>2761.27</td>\n","      <td>2802.88</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2816.8187</td>\n","      <td>2854.820835</td>\n","      <td>2778.816565</td>\n","      <td>2873.821903</td>\n","      <td>2759.815497</td>\n","      <td>2792.391333</td>\n","      <td>2805.184500</td>\n","      <td>2844.49</td>\n","      <td>2761.27</td>\n","      <td>2802.88</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-a192359a-9ecb-40c5-ba06-d6f85d8284ed')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-a192359a-9ecb-40c5-ba06-d6f85d8284ed button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-a192359a-9ecb-40c5-ba06-d6f85d8284ed');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":125}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gOQxwYqK0jCS"},"outputs":[],"source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmiB5VU5DN6B"},"outputs":[],"source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2427,"status":"ok","timestamp":1657332255334,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"5c7b94d3-7206-482b-90d7-011babe991dd"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":8,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1280,"status":"ok","timestamp":1657549243561,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"7FPBG5Qqg2jB","outputId":"edcaf45b-dc17-4455-c04f-b456316e3d0d"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 1.0436220169067383\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes\n","# res_df_.index[[0, -1]]"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if '3T' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["\n","def get_next_fibo_gap(x):\n","  if 0 < x < 0.214:\n","    return -0.786\n","  elif 0.214 < x < 0.382:\n","    return -0.618\n","  elif 0.382 < x < 0.5:\n","    return -0.5\n","  elif 0.5 < x < 0.618:\n","    return -0.382\n","  elif 0.618 < x < 0.764:\n","    return -0.236\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로.\n","\n","\n","def get_next_fibo_gap2(x):\n","  if 0 < x < 0.214:\n","    return -0.618\n","  elif 0.214 < x < 0.382:\n","    return -0.5\n","  elif 0.382 < x < 0.5:\n","    return -0.382\n","  elif 0.5 < x < 0.618:\n","    return -0.236\n","  elif 0.618 < x < 0.764:\n","    return 0\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로."],"metadata":{"id":"A7Yma0FQ81E_"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gWOmz--hNaSR"},"outputs":[],"source":["def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    # valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])   # 이곳은 cross_idx 가 아님, 단지 chunknized 된 filled_idx 일뿐\n","    # valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)  # --> Todo, unavailable : not cross_idx\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    # ------------------------------------ #\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #   cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_ratio_v4_2(res_df, wave_itv, wave_period, roll_hl_cnt=3):\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    roll_highs = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    cu_wave1_range = roll_highs[-1] - roll_lows[-2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_highs[-1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_highs[-2] - roll_lows[-1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_lows[-1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_roll_wave_data_v2(res_df, valid_prime_idx, roll_idx_arr, data_col, roll_hl_cnt):\n","\n","    data = res_df[data_col].to_numpy()\n","    len_res_df = len(res_df)\n","    roll_cols = [data_col + '_-{}'.format(cnt_ + 1) for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    roll_data = pd.DataFrame(index=res_df.index, data=np.full((len_res_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    res_df[roll_cols] = roll_data.ffill()\n","\n","    return res_df\n","\n","def roll_wave_hl_idx_v5(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_co_idx_arr = np.array([valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_cu_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    \n","    assert len(roll_co_idx_arr) > 0 and len(roll_cu_idx_arr) > 0\n","\n","    return valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr\n","    \n","def to_lower_tf_v3(ltf_df, htf_df, cols, backing_i=1, show_info=False):\n","    ltf_itv = pd.infer_freq(ltf_df.index)\n","    assert ltf_itv == 'T', \"currently only -> 'T' allowed..\"\n","    # assert type(column[0]) in [int, np.int64], \"column value should be integer\"\n","\n","    # cols = htf_df.columns[column]  # to_lower_tf_v1 의 int col 반영\n","\n","    if show_info:\n","        print(\"backing_i :\", backing_i)\n","\n","    renamed_last_index = htf_df.rename(index={htf_df.index[-1]: ltf_df.index[-1]}, inplace=False).iloc[[-1]]\n","    if htf_df.index[-1] != renamed_last_index.index[-1]:  # cannot reindex a non-unique index with a method or limit 방지\n","        htf_df = htf_df.append(renamed_last_index)\n","\n","    downsampled_df = htf_df[cols].shift(backing_i).resample(ltf_itv).ffill()\n","\n","    if len(downsampled_df) > len(ltf_df):\n","        downsampled_df = downsampled_df.iloc[-len(ltf_df):]\n","\n","    downsampled_df.index = ltf_df.index[-len(downsampled_df):]\n","    # assert len(ltf_df) <= len(downsampled_df), \"for join method, assert len(ltf_df) <= len(downsampled_df)\"\n","\n","    # ------ check last row's validity ------ #\n","    assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0, \"assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0\"\n","\n","    return downsampled_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"euA18M1uyc3s"},"outputs":[],"source":["\n","def wave_range_cci_v3(t_df, wave_period):\n","\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    band_width = 100\n","    upper_band = band_width\n","    lower_band = -band_width\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)\n","    # cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #   cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v5(cu_idx, co_idx, len_df, len_df_range)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ get post_idx ------ #\n","    paired_cu_post_idx = high_post_terms[:, 1]   # Todo, 여기는 cross_idx (위에서 vstack 으로 cross_idx 입력함)\n","    paired_co_post_idx = low_post_terms[:, 1]\n","    \n","    cu_post_idx = np.full(len_df, np.nan)  # --> Todo, unavailable : not cross_idx\n","    co_post_idx = np.full(len_df, np.nan)\n","\n","    cu_post_idx[paired_cu_post_idx] = paired_cu_post_idx\n","    co_post_idx[paired_co_post_idx] = paired_co_post_idx\n","\n","    cu_post_fill_idx = fill_arr(cu_post_idx)\n","    co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_cu_post_idx] = wave_highs\n","    wave_low_[paired_co_post_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_cu_post_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_post_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    # ------ term cnt ------ #\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_post_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_co_post_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    # b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    # b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    # wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    # wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","    #\n","    # high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    # low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","    t_df['wave_update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool  # temporary, for plot_check\n","    t_df['wave_update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool   # * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool   # * ~update_high_co_bool    \n","    \n","    t_df['wave_co_post_idx_{}{}'.format(itv, wave_period)] = co_post_idx    # paired_\n","    t_df['wave_cu_post_idx_{}{}'.format(itv, wave_period)] = cu_post_idx    # paired_\n","    t_df['wave_co_post_idx_fill_{}{}'.format(itv, wave_period)] = co_post_fill_idx\n","    t_df['wave_cu_post_idx_fill_{}{}'.format(itv, wave_period)] = cu_post_fill_idx\n","\n","    # Todo, idx 저장은 sync. 가 맞는 tf_df 에 대하여 적용하여야함\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력 = 뜻 : high_term's prime co_idx (high_prime_idx = wave_high 를 만들기 위한 가장 앞단의 co_idx)\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","    # ------ for plot_checking ------ #\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","\n","    return t_df"]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","metadata":{"id":"O1uu9vQnY5dn"},"source":["##### plot_check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 370940\n","# i = 185369\n","i = 186060\n","\n","plot_size = 300 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PgaNnempXRd_"},"outputs":[],"source":["wave_itv1, wave_period1 = 'T', 20\n","roll_hl_cnt = 3\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)  # to_htf 는 ohlc, 4개의 col 만 존재 (현재까지)\n","    htf_df = wave_range_cci_v3(htf_df, wave_period1)\n","    \n","    cols = list(htf_df.columns)  # 그냥 다 넣어버리기 (추후 혼란 방지)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])  # wrr 은 4개의 cols\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  t_df = wave_range_cci_v3(t_df, wave_period1)\n","  # t_df = wave_range_cci_v2(t_df, wave_period1)\n","\n","  valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","  t_df = wave_range_ratio_v4_2(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"elapsed":1850,"status":"ok","timestamp":1657413920179,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"-Dr_tTk9csFm","outputId":"38a95599-503a-4f7e-f69e-52d91698b969"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","\n","wave_cu_prime_idx_ = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_ = t_df['wave_co_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_prime_idx_fill_ = t_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_fill_ = t_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_post_idx_ = t_df['wave_cu_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_ = t_df['wave_co_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_post_idx_fill_ = t_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_fill_ = t_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# ------ data check in gs[0] ------ #\n","plt.axvline(wave_cu_post_idx_fill_[230], color='r')\n","plt.axvline(wave_cu_prime_idx_fill_[230])\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]   # long 이라서 초록색임\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"c2yVTn1tnxMn"},"source":["###### data_window"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":331,"status":"ok","timestamp":1657413924345,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"0DgdFydfB1f-","outputId":"6bee67ce-efa2-479c-f6e6-701f42f92bd1"},"outputs":[{"output_type":"stream","name":"stdout","text":["170.0\n","nan\n"]},{"output_type":"execute_result","data":{"text/plain":["300"]},"metadata":{},"execution_count":20}],"source":["# print(wave_cu_post_idx_fill_[210])\n","print(wave_co_prime_idx_fill_[210])\n","# print(wave_co_idx_[~np.isnan(wave_co_idx_)])\n","print(wave_co_idx_[249])\n","\n","# print(len(t_df))\n","len(wave_co_prime_idx_fill_)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zj_d5wsfDzf_"},"outputs":[],"source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Z-EokTzIqb-T"},"outputs":[],"source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"]},{"cell_type":"markdown","metadata":{"id":"Q_1wJTcRYpm8"},"source":["##### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVFfP9VcDG2_"},"outputs":[],"source":["\n","def get_roll_wave_data(valid_prime_idx, roll_idx_arr, len_df, data, roll_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_idx_v4(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array(\n","        [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","    \n","def wave_range_ratio_v4_1(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    cu_wave1_range = roll_high_[:, -1] - roll_low_[:, -2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_high_[:, -1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_high_[:, -2] - roll_low_[:, -1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_low_[:, -1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def wave_range_ratio_v4(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])\n","    valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #         cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_dcbase_v11_3(res_df, config, itv='T', over_period=2):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    # b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    over_base = close > dc_base_\n","    prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","    prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = prev_over_base & ~over_base\n","    co_bool = prev_under_base & over_base\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","def wave_range_v11_2(res_df, config, itv='T'):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"841i4oo2abh-"},"outputs":[],"source":["\n","\n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","\n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_, _, _ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","    for col_, itv_ in zip(future_cols, itv_list):\n","        back_col_ = 'b1_' + col_\n","        res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","    return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1) \n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)   \n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","    \n","    # ============ modules ============ #  \n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","    wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    \n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    wave_high_[paired_cu_idx] = wave_highs\n","    wave_low_[paired_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","    \n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    cu_prime_idx = wave_high_prime_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","    co_prime_idx = wave_low_prime_idx\n","    co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","    # ============ enlist to df_cols ============ #       \n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ # \n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","    # ------ for first_high ------ # \n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","      \n","    if itv != 'T':\n","      assert ltf_df is not None, \"assert ltf_df is not None\"\n","      join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","      ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","      try:\n","        ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","      except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","    else:\n","      ltf_df = t_df    \n","\n","    return ltf_df\n"]},{"cell_type":"markdown","metadata":{"id":"02DcTVB2cYuR"},"source":["##### dump"]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"fjGcs9ngkh5s"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"],"metadata":{"id":"CLYKs7ItkgIa"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Go7ARIUhfC1g"},"outputs":[],"source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pgA8QqyXZ66o"},"outputs":[],"source":["t_df[roll_cols].tail(100)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wF7fKJ3mOhaf"},"outputs":[],"source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3vHLGont-BFe"},"outputs":[],"source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Mh3w2s-j34Zs"},"outputs":[],"source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1651799326382,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eQ06-kWq4m6F","outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"outputs":[{"name":"stdout","output_type":"stream","text":["11\n","11\n"]}],"source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SUFmr9Z_kcCN"},"outputs":[],"source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_3pOQtt2ttfk"},"outputs":[],"source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1651756811396,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"kKaD1fK3WPRP","outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"outputs":[{"data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"execution_count":79,"metadata":{},"output_type":"execute_result"}],"source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YoZpr7lDn7z-"},"outputs":[],"source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","metadata":{"id":"RZJ6uIA_VcJs"},"source":["##### instant."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLWAP1Cl2Hvu"},"outputs":[],"source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"H_zPYIshbZgP"},"outputs":[],"source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"o3IUBc59VR5D"},"outputs":[],"source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u3yFd8Dcok5m"},"outputs":[],"source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JWj02LLGbnji"},"outputs":[],"source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":4,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1657549232580,"user_tz":-540,"elapsed":6919,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1657549233371,"user_tz":-540,"elapsed":795,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","      \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","\n","    # if config.tr_set.check_hlm == 2:  # 동일한 param 으로도 p2_hlm 시도를 충분히 할 수 있음 (csdbox 와 같은)\n","    #   assert not (wave_itv1 == wave_itv2 and wave_period1 == wave_period2)\n","\n","    roll_hl_cnt = 3\n","\n","    roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    \n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    res_df['short_tp_1_{}'.format(selection_id)] = wave_low_fill1_      # wave_low_fill_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = roll_highs1[-1]   # roll_high_[:, -2] wave_high_fill_\n","    res_df['long_tp_1_{}'.format(selection_id)] = wave_high_fill1_      # wave_high_fill_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = roll_lows1[-1]     # roll_low_[:, -2]  wave_low_fill_\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = wave_low_fill1_    # roll_low_[:, -2]\n","\n","    res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill2_   # wave_low_fill1_   # wave_low_fill2_   # b2_low_5T\n","    res_df['short_out_0_{}'.format(selection_id)] = roll_highs2[-1]   # roll_highs1[-1]   # roll_highs2[-1]  # roll_high_[:, -2]\n","    res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill2_   # wave_high_fill1_   # wave_high_fill2_   # b2_high_5T\n","    res_df['long_out_0_{}'.format(selection_id)] = roll_lows2[-1]     # roll_lows1[-1]   # roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill2_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill2_    # roll_low_[:, -2]\n","\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #     \n","    short_open_res1 = np.ones(len_df) #.astype(object)\n","    long_open_res1 = np.ones(len_df)  #.astype(object)\n","    short_open_res2 = np.ones(len_df) #.astype(object)\n","    long_open_res2 = np.ones(len_df)  #.astype(object)\n","    \n","    # ------------ wave_point ------------ #\n","    notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    short_open_res2 *= res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_cu\n","    long_open_res2 *= res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_co\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_point\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","    \n","    # ------ reject update_hl ------ #\n","    notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co\n","\n","    # short_open_res1 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # long_open_res1 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # short_open_res2 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # long_open_res2 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    if show_detail:\n","      sys_log.warning(\"reject update_hl\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","\n","    # ------ wave_itv ------ #    \n","    if wave_itv1 != 'T':      \n","      wave_itv1_num = to_itvnum(wave_itv1)\n","      short_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1)\n","      long_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"wave_itv1\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","    \n","    if wave_itv2 != 'T':\n","      wave_itv2_num = to_itvnum(wave_itv2)\n","      short_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1)\n","      long_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"wave_itv2\")\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    # ------ wave_mm ------ #\n","    wave_high_terms_cnt_fill1_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_terms_cnt_fill1_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    short_open_res1 *= (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","    long_open_res1 *= (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","\n","    wave_high_terms_cnt_fill2_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_terms_cnt_fill2_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    short_open_res2 *= (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","    long_open_res2 *= (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_mm\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_length ------ #\n","    if config.tr_set.wave_length1 != \"None\":      \n","      wave_cu_idx_ = get_index_bybool(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","      wave_co_idx_ = get_index_bybool(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","\n","      wave_cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      \n","      short_open_res1 *= wave_cu_idx_ - wave_cu_prime_idx_fill_ <= config.tr_set.wave_length1\n","      long_open_res1 *= wave_co_idx_ - wave_co_prime_idx_fill_ <= config.tr_set.wave_length1\n","\n","      print(\"wave_cu_idx_[short_open_res1 == 1] :\", wave_cu_idx_[short_open_res1 == 1])\n","      print(\"wave_cu_prime_idx_fill_[short_open_res1 == 1] :\", wave_cu_prime_idx_fill_[short_open_res1 == 1])\n","\n","      if show_detail:\n","        sys_log.warning(\"wave_length\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # ------------ 추세선 리스트 ------------ #\n","    # ------ dc_base ------ #\n","    # dc_base_ = res_df['dc_base_T100'].to_numpy()\n","    \n","    # short_open_res1 *= dc_base_ > roll_highs1[-1]  # Todo, index sync. 요망\n","    # long_open_res1 *= dc_base_ < roll_lows1[-1]\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"dc_base\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))     \n","\n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","        epg2 = config.tr_set.ep_gap2\n","\n","        # ------ epbox as epg ------ #\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1        \n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","\n","        # ------ tpbox as epg ------ #\n","        # p1_hlm 을 위해선, tp_0 를 기준할 수 없음 --> ep1 & ep2 를 기준으로 진행\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1      \n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","        \n","        # ------ fibo_ep ------ #\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1    \n","                \n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    if config.tr_set.check_hlm in [0, 2]:      # for p1_hhm, p2_hlm\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg   # p2's ep_box 를 out 으로 사용한다?\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg \n","    \n","    else:    # for p1_hlm      \n","      # ------ irregular - next_fibo ------ #\n","      # co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      # cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      # short_next_fibo_outg = np.vectorize(get_next_fibo_gap)(cu_wrr_32_)\n","      # long_next_fibo_outg = np.vectorize(get_next_fibo_gap)(co_wrr_32_)\n","\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * short_next_fibo_outg  # ep 와 마찬가지로, tpg 기준 가능\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * long_next_fibo_outg \n","\n","      # ------ epg1 as outg ------ #\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg \n","\n","      # ------ tpg as outg ------ #\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg \n","      \n","      # ------ fibo_out ------ #      \n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg \n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res1 *= (short_tp_ < short_ep1_) # (short_ep_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) # (long_ep_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation     \n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution    \n","    long_open_res1 *= close > res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution   \n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out can be vectorized\n","    long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban)\n","    # print(\"res_df['long_open1_{}'.format(selection_id)].to_numpy() :\", res_df['long_open1_{}'.format(selection_id)].to_numpy()) \n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","    \n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    \n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    if not config.tr_set.check_hlm:\n","      res_df['short_tr_{}'.format(selection_id)] = abs(\n","          (short_ep1_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep1_ / short_out_ - config.trader_set.market_fee - 1))\n","      res_df['long_tr_{}'.format(selection_id)] = abs(\n","          (long_tp_ / long_ep1_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep1_ - config.trader_set.market_fee - 1))\n","    else:      \n","      res_df['short_tr_{}'.format(selection_id)] = np.nan\n","      res_df['long_tr_{}'.format(selection_id)] = np.nan\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","metadata":{"id":"HuCb0phoPN83"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-DNPumVZi0xs"},"outputs":[],"source":["# ------------ csd ------------ #\n","    # ------ dc ------ #\n","    # dc_upper_ = res_df['dc_upper_T30'].to_numpy()    \n","    # dc_lower_ = res_df['dc_lower_T30'].to_numpy()    \n","\n","    # # Todo, post_cu ~ co 의 dc_lower == low (=touched) 여부 조사\n","    # short_open_idx1 = get_index_bybool(short_open_res1, len_df_range)\n","    # long_open_idx1 = get_index_bybool(long_open_res1, len_df_range)\n","    # wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()   # co_prime_idx (wave_high 정보를 지정하기 위한 front co_idx 지정)\n","\n","    # # 1. dc_lower == low 여부 조사, np.nan 덕분에 vectorize 불가하다고 봄\n","    # short_valid_idx_bool = ~(pd.isnull(wave_co_post_idx_fill_) | pd.isnull(short_open_idx1)) # get_index_bybool\n","    # dc_upper_touch = dc_upper_ <= high\n","    # dc_upper_touch_span = np.full(len_df, np.nan)\n","    # dc_upper_touch_span[short_valid_idx_bool] = [dc_upper_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_co_post_idx_fill_, short_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # long_valid_idx_bool = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1)) # get_index_bybool\n","    # dc_lower_touch = dc_lower_ >= low\n","    # dc_lower_touch_span = np.full(len_df, np.nan)\n","    # dc_lower_touch_span[long_valid_idx_bool] = [dc_lower_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # short_open_res1 *= dc_upper_touch_span == 0\n","    # long_open_res1 *= dc_lower_touch_span == 0\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"csd - dc\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","    #   # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","    #   # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))   \n","    \n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "]},{"cell_type":"markdown","metadata":{"id":"aTV4h3LjTZBp"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dc49JPmoTaPQ"},"outputs":[],"source":["\n","    \n","    csd_period = 40\n","    res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","    \n","    dc_upper_ = res_df['dc_upper_T{}'.format(csd_period)].to_numpy()    \n","    dc_lower_ = res_df['dc_lower_T{}'.format(csd_period)].to_numpy()  \n","\n","    short_open_res2 *= dc_upper_touch_span == 0\n","    long_open_res2 *= dc_lower_touch_span == 0\n","\n","    # ------ csdbox ------ # --> 결국 dc's upper & lower\n","    if show_detail:\n","      sys_log.warning(\"csdbox\")\n","      # sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","      \n","    # olds,\n","    # np.nan - np.nan = np.nan -> vectorize 가능할 것 => xx\n","    # 1. wave_high_prime_idx_ ~ long_open_idx1 의 valid(not_non) 한 idx 를 max_dc_lower 와 min_low 의 비교값으로 채워넣음\n","    # valid_idx = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1))\n","    # max_dc_lower_ = [dc_lower_[int(iin):int(iout)].max() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    # min_low = [low[int(iin):int(iout)].min() for iin, iout in zip(wave_high_prime_idx_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","        # ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":6,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1657549237355,"user_tz":-540,"elapsed":3987,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","# from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","  \n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and \n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2) \n","    \n","    # ------------ wave_period1 ------------ #\n","    if to_itvnum(wave_itv1) > 1: \n","      offset = '1h' if wave_itv1 != 'D' else '9h'\n","      htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","      htf_df = wave_range_cci_v3(htf_df, wave_period1)\n","      \n","      # cols = list(htf_df.columns[-15:-4])  # except idx col\n","      cols = list(htf_df.columns[4:])  # 15T_ohlc 를 제외한 wave_range_cci_v3 로 추가된 cols, 다 넣어버리기 (추후 혼란 방지)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      cols += list(htf_df.columns[-4:])\n","\n","      # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","      res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","      res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=1), how='inner')\n","    else:\n","      res_df = wave_range_cci_v3(res_df, wave_period1)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      \n","      # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'dc_base_T100{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)   # Todo, for index sync.\n","      # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    # ------------ wave_period2 ------------ #\n","    if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","      assert wave_itv2 == 'T'\n","      \n","      res_df = wave_range_cci_v3(res_df, wave_period2)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    # itv_list = ['15T', '15T', '15T', '15T']\n","    # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면, \n","            # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","            # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                  (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                  idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:                                  \n","            # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","            # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave2, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #  # vectorize allow only for p1_hhm\n","    if config.loc_set.point1.short_tr_thresh != \"None\" and not config.tr_set.check_hlm:\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point1\n","    if config.loc_set.point1.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point1.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point1.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point1.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point1.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point1.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point1.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point1.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point1.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point1.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point1.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point1.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point1.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point1.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point1.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point1.wrr_32 != \"None\":            \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point1.wrr_32 #+ 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point1.wrr_32 - 0.1\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point1.wrr_32 #+ 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point1.wrr_32 - 0.1\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point1.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point1.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point1.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point1.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point1.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point1.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point1.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point1.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point1.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point1.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point1.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point1.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point1.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point1.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point1.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point1.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point1.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point1.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point1.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point1.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point1.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point1.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point1.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point1.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point1.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point1.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point1.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point1.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point1.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone.use_zone:\n","\n","      # ------------ 추세선 리스트 ------------ #\n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1      \n","      \n","      wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # ------ ma ------ #          \n","      # ma_ = res_df['ma_T60'].to_numpy()\n","\n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= wave_high_fill1_ < ma_\n","      #   if show_detail:\n","      #     sys_log.warning(\"wave_high_fill1_ < ma_ : {:.5f} {:.5f} ({})\".format(wave_high_fill1_[c_i], ma_[c_i], mr_res[c_i]))\n","      # else:\n","      #   mr_res *= wave_low_fill1_ > ma_\n","      #   if show_detail:\n","      #     sys_log.warning(\"wave_low_fill1_ > ma_ : {:.5f} {:.5f} ({})\".format(wave_low_fill1_[c_i], ma_[c_i], mr_res[c_i]))\n","        \n","        # ------ dc_base ------ #      \n","      # dc_base_ = res_df['dc_base_T100'].to_numpy()\n","\n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= wave_high_fill1_ < dc_base_\n","      #   if show_detail:\n","      #     sys_log.warning(\"wave_high_fill1_ < dc_base_ : {:.5f} {:.5f} ({})\".format(wave_high_fill1_[c_i], dc_base_[c_i], mr_res[c_i]))\n","      # else:\n","      #   mr_res *= wave_low_fill1_ > dc_base_\n","      #   if show_detail:\n","      #     sys_log.warning(\"wave_low_fill1_ > dc_base_ : {:.5f} {:.5f} ({})\".format(wave_low_fill1_[c_i], dc_base_[c_i], mr_res[c_i]))    \n","\n","      # ------ bb_base uptrend ------ #\n","      # bb_base_T100 = res_df['bb_base_T100'].to_numpy()\n","      # b1_bb_base_T100 = res_df['bb_base_T100'].shift(1).to_numpy()\n","\n","      # lb_period = config.loc_set.zone.bb_trend_period\n","      # bb_base_downtrend = pd.Series(b1_bb_base_T100 < bb_base_T100).rolling(lb_period).sum().to_numpy() == 0\n","      # bb_base_uptrend = pd.Series(b1_bb_base_T100 > bb_base_T100).rolling(lb_period).sum().to_numpy() == 0\n","\n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= bb_base_downtrend\n","      #   if show_detail:\n","      #       sys_log.warning(\"bb_base_downtrend : {:.5f} ({})\".format(bb_base_downtrend[c_i], mr_res[c_i]))       \n","      # else:\n","      #   mr_res *= bb_base_uptrend\n","      #   if show_detail:\n","      #       sys_log.warning(\"bb_base_uptrend : {:.5f} ({})\".format(bb_base_uptrend[c_i], mr_res[c_i]))    \n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":            \n","      wave_itv2 = config.tr_set.wave_itv2\n","      wave_period2 = config.tr_set.wave_period2\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","\n","    if config.loc_set.point2.csd_period != \"None\":\n","      wave_itv2 = config.tr_set.wave_itv2\n","      csd_period = config.loc_set.point2.csd_period\n","      \n","      res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","      dc_upper_ = res_df['dc_upper_{}{}'.format(wave_itv2, csd_period)].to_numpy()    \n","      dc_lower_ = res_df['dc_lower_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        csdbox = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","        mr_res *= dc_upper_ <= csdbox\n","        if show_detail:\n","            sys_log.warning(\"dc_upper_ <= csdbox : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], csdbox[c_i], mr_res[c_i]))\n","      else:\n","        csdbox = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","        mr_res *= dc_lower_ >= csdbox\n","        if show_detail:\n","            sys_log.warning(\"dc_lower_ >= csdbox : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], csdbox[c_i], mr_res[c_i]))\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","metadata":{"id":"EQ63Jwpvr7qA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"csZwxsP5r_Pz"},"outputs":[],"source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1657549237355,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_46\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 1e-10,\n","    \"market_fee\": 1e-10,\n","    \"initial_asset\": 24500,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 50, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"cu_wrr_21\": \"None\",\n","      \"co_wrr_21\": \"None\",\n","      \"wrr_32\": 0.3,\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"wrr_32\": 0.3,\n","      \"csdbox_range\": 0.3,\n","      \"csd_period\": 40\n","    },\n","    \"zone\": {\n","      \"use_zone\": 1,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"check_hlm\": 0,\n","    \"wave_itv1\" : 'T',\n","    \"wave_period1\": 30,\n","    \"wave_length1\": 50,\n","    \"wave_itv2\" : 'T',    \n","    \"wave_period2\": 30,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\" : 0,\n","    \"p2_box_k2\" : 0,\n","    \"p1p2_low\": 0.5,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.12,\n","    \"ep_gap2\": -0.12,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 30000\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"static_lvrg\": 0,\n","    \"leverage\": 2,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","metadata":{"id":"MuD_2vY7TI_8"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"EKag94Y2TMCO"},"outputs":[],"source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":9,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":527,"status":"ok","timestamp":1657549332429,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"qBJfPsmJzVIr","outputId":"8eef0e5f-36eb-4cfb-9bf4-ff13411691c9"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_46\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"cu_wrr_21\": \"None\",\n","  \"co_wrr_21\": \"None\",\n","  \"wrr_32\": 0.3,\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"wrr_32\": 0.3,\n","  \"csdbox_range\": 0.3,\n","  \"csd_period\": 40\n"," },\n"," \"zone\": {\n","  \"use_zone\": 1,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"check_hlm\": 0,\n"," \"wave_itv1\": \"T\",\n"," \"wave_period1\": 30,\n"," \"wave_length1\": 50,\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 30,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"p1p2_low\": 0.5,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.12,\n"," \"ep_gap2\": -0.12,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 30000\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"static_lvrg\": 0,\n"," \"leverage\": 2,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":10,"metadata":{"id":"afUV2b1jaggN","executionInfo":{"status":"ok","timestamp":1657549343158,"user_tz":-540,"elapsed":533,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","# ------ p1_hhm 의 경우 out_box 를 위해 wave_itv 1 & 2 를 동일하게 설정해야함 ------ #\n","config_list[0].tr_set.wave_itv1 = 'T'\n","config_list[0].tr_set.wave_period1 = 20 \n","config_list[0].tr_set.wave_itv2 = 'T'\n","config_list[0].tr_set.wave_period2 = 20 "]},{"cell_type":"code","execution_count":11,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2342,"status":"ok","timestamp":1657549346058,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"6bdd6c91-8096-4874-d2cd-27535f40528c"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 1.0566973686218262\n","make data_list elapsed time : 0.00016617774963378906\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":14,"metadata":{"id":"_iYcJk8nK8Yq","executionInfo":{"status":"ok","timestamp":1657549399379,"user_tz":-540,"elapsed":535,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit utils config ------ #\n","config_list[0].tr_set.check_hlm = 1\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].pos_set.long_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","config_list[0].tr_set.wave_length1 = \"None\"\n","# config_list[0].tr_set.wave_greater1 = 0\n","# config_list[0].tr_set.wave_greater2 = 0\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap1 = -0.12 # -0.618 -0.23 -0.382 0.19 0.8 -0.12\n","# config_list[0].tr_set.ep_gap2 = -0.12 # -0.618 -0.23 -0.382 0.19 \n","config_list[0].tr_set.out_gap = -0.6  # 0 -0.35\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.0\n","# config_list[0].tr_set.bias_info_tick = 30000\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002  # utils 로 이곳에 배치\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004\n","\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":15,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":824,"status":"ok","timestamp":1657549402481,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"3896d0b6-165e-4556-bfb2-b0419d031c51"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 42048\n","np.sum(long_open_res1 == 1) : 42240\n","np.sum(short_open_res2 == 1) : 42048\n","np.sum(long_open_res2 == 1) : 42240\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 40427\n","np.sum(long_open_res1 == 1) : 40130\n","np.sum(short_open_res2 == 1) : 40427\n","np.sum(long_open_res2 == 1) : 40130\n","wave_mm\n","np.sum(short_open_res1 == 1) : 40425\n","np.sum(long_open_res1 == 1) : 40128\n","np.sum(short_open_res2 == 1) : 40425\n","np.sum(long_open_res2 == 1) : 40128\n","point validation\n","np.sum(short_open_res1 == 1) : 40401\n","np.sum(long_open_res1 == 1) : 40112\n","np.sum(short_open_res2 == 1) : 5108\n","np.sum(long_open_res2 == 1) : 6739\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.27518296241760254\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":37,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1657550071691,"user_tz":-540,"elapsed":531,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.wrr_32 = 0.3 # \"None\" 1 0.5 0.482 0.302\n","config_list[0].loc_set.point2.wrr_32 = 0.5 # \"None\" 1 0.5 0.382 0.302 0.25\n","config_list[0].loc_set.point2.csd_period = \"None\"  # \"None\" 100\n","config_list[0].loc_set.zone.use_zone = 0\n","config_list[0].loc_set.zone.bb_trend_period = 150\n","# config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = 2  #  \"None\" 2 0.8 ## 0.7\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":38,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":4657,"status":"ok","timestamp":1657550077070,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","outputId":"4e6b927a-fa66-44d6-bff6-9722a376ffc5"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 2.203974723815918\n"]},{"output_type":"stream","name":"stderr","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.50000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 2.4669034481048584\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":23,"metadata":{"id":"KqVkg236t_f2","executionInfo":{"status":"ok","timestamp":1657549461291,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","# config_list[0].tr_set.p2_box_k1 = 0\n","config_list[0].tr_set.p2_box_k2 = 0.5  # 0.5 0 --> \"None\" 불가, 0 ~ 1 사이 값 사용 tp_0 로부터 떨어지는 거리, 본디 p2_box 는 p1_box 내부에 존재해야, 정확한 hhm 이 측정가능해짐\n","config_list[0].tr_set.p1p2_low = 0.5  # 0.5 0  0 is equal to \"None\", 마찬가지로 tp_0 로부터 떨어지는 거리\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","config_list[0].lvrg_set.static_lvrg = 1\n","config_list[0].lvrg_set.leverage = 5\n","config_list[0].lvrg_set.target_pct = 0.03 # 0.1 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":39,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":664},"executionInfo":{"elapsed":3581,"status":"ok","timestamp":1657550080640,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"47354524-5ce8-4a9b-d884-5119b04ebf77"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.4055197238922119\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.5715625286102295\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_bias_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_bias_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8lYgsqH-rfAM"},"outputs":[],"source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ # --> 추후, outg 로 tp_gap / out_gap custom 여부를 위해, 본 cell 을 지우지 않음\n","short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","metadata":{"id":"tOFkzUX2imQu"},"source":["#### consecutive dur. value survey on bias"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CgvSrXaZEkMZ"},"outputs":[],"source":["res_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_itv1 = 'T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"elapsed":3342,"status":"ok","timestamp":1653807810574,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"Sahvc-R0jD1A","outputId":"6b83ac35-819d-487b-bf38-42144ad04c3b"},"outputs":[{"name":"stderr","output_type":"stream","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"data":{"image/png":"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a7311lu1vu7ChQtas2aN5syZo5YtW6p3796aNGmSS3MWFRXpuuuuq1O8gwYNUq9evdSsWTN17NhRf/zjH7V582adOnWq2te899576t69u/r376/+/fvr17/+tdLT09W/f39duHChTmMC3kDhg0ajV69eGj58uIKCgvTtt9/qm2++0YULF2p8zY4dO3TmzBnNmDFDAQEBio2N1dixY5WSklLta4qLi11OGO70vVLfvn3Vr18/+fn5qXXr1nrxxRdVUFCgrKysal+TmZmpiIgIZ3J5+OGHVVxcrP79+ysvL69OYwIAvOf555/XP//5T33xxRfKyMjQzp079fzzz7v02qlTp6p9+/YqKirS0qVLtWLFCpdOV5szZ46Sk5N14sQJ/fjHP3Yr3uuuu07vv/++ysrKlJmZqbNnz1Y6Pbwq586dU3FxsbOVlpbq/PnzKi4urvOYgLdYfqERjeZK+973vmd27NhhTp06ZY4dO2bWr19vunTpYmbPnm2WLl3q7HdpgYFLF4v27dvXfPzxx+bkyZNmz549Zty4cc6+VS1k0LNnT5Oenm5OnDhh1q5dW2NMd999t8nNzTUnTpwwTzzxxFVz19SGDx9u9u3bZ8rLy01xcbFZu3at6dmzp1v75MrFDTwxJo1Go9F8s82bN88sWbLE8jhotMbamv37fwAAAOBDevfuraCgIGVkZCg6OlobNmzQww8/rHXr1lkdGtAocaobAACAD2rbtq3WrFmj06dP6+2339aLL76odevW6bbbblNZWVmVzRVPPfVUla/dsGFDja+rbs7bbrvNE28X8DqO+AA1iIiI0N69e6t8rm/fvrWu3jZx4kS9/vrrVz2em5urm266qdrXZWZmVrlYwc9//nMtX768lqgBAABwJQofAAAAALYXYHUAklRSUlLp5l4AgIYXGRmpa6+91uowfBJ5CgCsV9885ROFT25urqKjo60OAwCaNIfDYXUIPos8BQDWq2+eYnEDAAAAALZH4QMAAADA9ih8AAAAANgehQ8AAAAA2/OJxQ2anHaSgi7bPifplEWxAAAaL/IJALiMwscKQZLeu2w7zqpAAACNGvkEAFzGqW4AAAAAbI/CBwAAAIDtcaqbr+P8bQAAAKDeKHx8HedvAwB8GV/QAWgkKHwAAEDd8QUdgEaCa3wAAAAA2B6FDwAAAADb41Q3AACaAneuxeG6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icIHHrdixQoNHTrUec3M/Pnza+xfWFioiIgINWvWzPlYt27dKn1g1vVDOi8vT926davyup36JpdLhY87ycWd2K8UGBhYKVGOGjVKSUlJGjt2rDIzM+s0Zk0uTy779+9XQEBApYtYSS4A7GLFihV69tlnFRISok6dOunXv/613nrrrVpfd+HCBa1Zs0Zz5sxRy5Yt1bt3b02aNKnW17377rvq0qWLHnvsMQUFBalNmzYaNGiQJGnXrl2666671KFDB3Xu3Nl5dkRttmzZouHDh6tly5YqKCjQ1q1bNXr0aHXq1Enp6ekujVGbkSNHqn///vLz81Pbtm310ksv6cSJE8rKypIkTZw4US+88ILuvPNO5eTkeGTOyZMn65prrpF0cTntp556ynk9VHZ2tnbt2qXZs2erefPmGjdunL7//e9r9erVHpkb9kPhA4/q1auXhg8frqCgIH377bf65ptvdOHChRpfs2PHDp05c0YzZsxQQECAYmNjNXbs2EpLZF6puLi42m/LLvf555/r8OHDmjdvnlq1aqXmzZs7l4XetWuXbr/9dkVERKhdu3bOFXVq8+mnn6p3794aNGiQPv/8c+3du1eRkZEaPHiw/vGPf7g0Rm0GDx6smJgYBQYGqkWLFpoxY4Y6d+6sHTt2SJKGDx+uZcuW6Z577pHD4fDInBMnTnR+U9mtWzf97//+rzO5nDlzRmvWrNFvfvMbtWrVSrfeeqvi4+O5NxMAW3j++ef1z3/+U1988YUyMjK0c+fOSqta1mTq1Klq3769ioqKtHTpUq1YsaLW08bKy8t15513auzYsSoqKlJ2draGDx8u6eKp4Lt379bXX3+tjRs36u2333YpjuzsbJWXlztXlCsrK9PBgwe1bdu2WvOwq4KDg7VixQqVlpbqq6++0vXXX6/Ro0c73+/zzz+vTp06yeFwOG+X8Nprr9VrzpiYGGVkZKi8vFwbNmzQhg0b9PTTTzufHz9+vG655RadOHFC8+bN07333qujR4/Wa07Ym+UXGtHs0773ve+ZHTt2mFOnTpljx46Z9evXmy5dutS6kEDfvn3Nxx9/bE6ePGn27Nljxo0b5+xb1UIGPXv2NOnp6ebEiRNm7dq1NcYUERFh1q5da44ePWqOHDliXnnlFedzf/7zn82JEydMdna2efjhh2td3OBS+/TTT01aWppz+5133jF7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YPr16+f1OLxVGjRocM20wMDAKuvfeuutpnnz5kaSadGihVm3bp156aWXjCTTrl0789JLL5nw8HATGBhokpOTzZEjR0zjxo0dimXUqFFm8+bN10zv3LmzPc6EhARz6tQpEx4ebiSZTp06mVOnTplevXqZxo0bm0WLFpklS5Z4vV0pvls444N6JzCw/m225d+I1TSt3Ndff62ePXsqNDRUt956q4KCgvTmm29KkoKCglRYWKjevXurefPmeu2117R06VJFR0dXOb/FixeradOmatq0qRITE1VSUmJ/3bRpU0nSX//6V8XExKh58+Z66KGH9Oabb+rOO++UJLVq1UqfffaZ/vznP6tly5b67rvv9Mknn9SlSQDAZ4SEhGj69OkqLi5WcXGxpk+frpCQEElS7969VVhYqJdfflmHDh1SSUmJnnrqKftnW7ZsqbS0NJ08eVLffvut3njjDW3evLnGZXbq1EmrV6/WsWPHdPDgQU2aNKnGWKqyceNGPfroo5KkX/3qVzLGaNCgQZKkvn37KjMzU5I0atQobdmyRR988IGOHj2q119/XXPnztVHH32kL7/8UmfOnNF9991X5XL27t2rkydPSpICAgJ06dIltW/fXtLlywanT5+ugwcP6tKlS0pJSVFISIg6duxYY1tUJycnR2VlZZIkY4yCg4MVFRUlSRoxYoQ+//xzbd68WWfPntWf//xnPfroo2rSpEmdlgn/Vf/+g4TPe+WVV1RUVKRTp04pPz9fffv2lXT5YD5//nydOnVKubm5uuuuu+yfuf3227VhwwYdP35cubm5Gjx4sP29qw/KY8aM0YgRI/TKK6/o9OnTSktLqzaeyMhIffrppzp8+LCOHj2qDz/8UNLlg/arr76qffv26dChQ5o/f76aNWtW7bzmzZunl19+WZJ0yy23yBijP/zhD5KkW2+9VceOHVNAQIC9o3zllVd04MABzZ07V1OmTNE///lPLVy4UCdPnqzQcV6tqKhIx44ds78uKyuzdy7nzp3T1KlTtX//fhlj9OWXX6qgoKBCe9bGzp07VVpaKuly52KM0W233SZJevTRR5WXl6dly5bp559/1uuvv64uXbrUuUMDAF/w6quv6u6771bXrl3VpUsXJSQk6LXXXrO/Hx4erubNmysiIkJjxozRrFmzFBoaKkmaNWuWzp49q/DwcI0aNUqjRo2qcXlNmjTR2rVr9e9//1u33HKL2rdvr3Xr1jkUS2U2bdqkPn36SLqcqO3Zs0e//vWv7a83bdpkr9ujRw/t3btXbdq00VtvvSVJGj58uN566y01bdpUW7ZsqXZZw4YN08mTJ3Xs2DF16dJFH3/8caX1unTpopCQENlsthrboyaff/65zp8/r2+//VYbN27Ud999J0m64447lJWVZa+3d+9elZaWqkOHDnVeJvyX1087UfyndOjQwfz444/m5ptvNpJMdHS0ufXWW82UKVPM+fPnTWJiogkMDDRvv/222bp1q5FkgoKCjNVqNZMmTTLBwcHmvvvuM6dOnTIdOnQw0uXL2k6cOGF+9atfmYCAANOwYUOHL3ULDAw0O3bsMB988IG58cYbTcOGDU3Pnj2NJDN69GhjtVpNu3btTOPGjc2nn35qFixYUO38Ro8ebdLS0owkM2zYMGOz2Uxqaqr9vX/9619Gkundu7e5cOGCmTZtmgkJCTGNGjUyU6ZMMaWlpSYpKckEBASYRo0aVbusnj17mhMnThhjjDlz5ox54IEHKq130003mfPnz5uOHTs69Dfq3bu3KSwsrPS9WbNmmbNnzxpjjPn+++/tlyjMmDHDfPTRRxXq5uTkmEcffdTr2xyFQqHUtpRf6maz2UxiYqJ9ev/+/U1BQYGRLh8zz507V+GysEOHDpkePXqYwMBAU1paau+vJJk33nij0ku2rixDhw4127dvr/S96mKpqvTt29dkZWUZSWblypVmzJgx9j5248aN5pFHHjHS5cvJ9u/fX+Gzc+fONfPnz3e67dq3b2/+8pe/mDZt2lzzXtOmTU12draZOHGiw/Or6lK38hIUFGQGDhxov7ROklm7dq0ZN25chXpFRUWmd+/eXt+2KL5ZOOMDlyorK1PDhg3VqVMnBQUFaf/+/dq7d68kacuWLVq5cqUuXbqkhQsXqkuXLpKku+++W02aNNG0adN04cIFbdiwQV988YWGDRtmn++KFSv0zTffyBijn3/+2eF4EhISdMstt+hPf/qTzp07p59//llff/21pMunyD/44AMVFBTo7NmzmjRpkoYOHVrtJWibNm3Svffeq4CAAP3617/Wu+++q549e0q69lu1S5cuacqUKSotLdV//vMfSdLWrVu1YsUKGWPs06ry9ddfKzQ0VBEREXrvvfe0b9++a+oEBQVp0aJFmj9/vn744QeH26Uqzz77rJo2bap7771Xn332mb2tmzRpYr+8odzJkyftl8kBQH12yy23aP/+/fbX+/fv1y233GJ/fezYMfvlVtLlM+9NmjRR69atFRwcrMLCQvt7V/5elaioKO3Zs6dWsVRm69at6tChg2666SZ17dpVCxYsUFRUlFq1aqWEhAR99dVX1cbnSMxXs9lsysvL00cffVRheqNGjfT5559r27ZtmjZtmtPzrcrFixf173//W/3797dfFXLmzJlrrtRo1qyZTp8+7bLlwr+Q+MCl9uzZoxdffFGvv/66Dh8+rCVLlujmm2+WJB08eNBe79y5c7rhhhvUoEED3XLLLSosLJQxxv7+/v37FRERYX9dm4OydLlz2b9/f4UOq1xlnUtwcLDatGlT5fz27t2rs2fPqmvXrurVq5e++OILlZSUqEOHDtckPkeOHLkmSavNepSUlOjf//63UlNTK0wPCAjQwoULVVpaqvHjxzs936pcunRJX3/9tSIjI/X73/9eEp0LAP9WUlJS4T7Jtm3bqqSkpMbPHTlyRBcuXFBkZKR9Wvn9J9UpLCzUrbfe6rJYzp8/r++//14vvPCCcnNzdeHCBX3zzTd6+eWXtWfPngqXTl/Z11Y3zRFBQUH2S6Kly5e0/+tf/1JRUZHGjRtXq3k6s8y8vDz7l6iS1K5dOzVs2FC7d+92y7JR/5H4wOWWLFmiXr16KTo6WsYYvfPOO9XWLykpUVRUlAICAuzT2rZtq+LiYvvrqw/Kjh6kCwsL1bZt20rP4lTWuVy4cEGHDh2qdp6bNm3SY489ppCQEJWUlGjTpk0aNWqUWrRooR07dlQbo6s6F0maM2eO2rRpoyFDhujixYu1mq+jy7y6c7nxxht12223KS8vz+XLBQBPW7JkiV577TWFhYWpVatW+u///m/94x//qPFzly5d0meffabXX39dN9xwgzp27KiRI0fW+LkvvvhCN998s1544QWFhISoSZMm9qGfaxvLpk2bNH78ePsXcBs3bqzw2hXGjBmj1q1bS5Li4uI0adIk+71JQUFBWrZsmc6fP69Ro0bVur+7UseOHTVw4EA1atRIQUFBGjFihH7961/b12nRokUaPHiw7r33Xt144436y1/+os8++0xnzpyp87Lhn0h84FIdOnTQfffdp5CQEP3nP//R+fPndenSpWo/k5GRoXPnzumVV15RUFCQevfurcGDB19zhuNKhw4dqvLbsit9++23OnDggKZNm6Ybb7xRDRs21K9+9StJlzuXl156STExMWrcuLHefvttffLJJ5WeHbpSeedSfulAeeeyZcuWGtfVUcOHD7d/a9i2bVu99dZb9s5FkmbPnq24uDgNHjy4xkvmHNG6dWs98cQTaty4sQIDA9W/f38NGzbMvszly5frF7/4hR599FE1bNhQ//3f/63s7GyXXF4HAN725ptv6rvvvlN2drZycnK0fft2+0iaNRk/fryaN2+ugwcPauHChVqyZEmNl2SfOXNGDzzwgAYPHqyDBw/KarXaR1OrbSybNm1Ss2bN7H3T1a9doWfPnsrJydGZM2eUnp6u9PR0TZ48WdLl0eQGDx6s/v3768SJE/bn8dx77721Xl5AQID9CpIjR47ohRde0BNPPGEfpW7nzp165plntGjRIh0+fFhNmza1DzgEVMXrNxpR/Kd07tzZZGRkmFOnTpljx46Zzz//3Nx8883XPMcnOjraGGPsN4t26tTJbNy40Zw4ccLk5eWZhx9+2F63soEM2rdvbzIzM83x48fN8uXLq40pKirKLF++3Bw9etQcOXLEzJw500gyAQEB5s9//rP58ccfzeHDh83ChQtNaGhojevYoUMHY4wxI0eONJJMs2bNzIULF8wrr7xir1PZAALOPMvozTffNIWFhebMmTOmsLDQfPzxx6Zly5ZGkmnbtq0xxpjz589XeBbP8OHDHZp3ZbGFhYWZjRs3muPHj5uTJ0+a7Oxs87vf/a5CnX79+pldu3aZc+fOmQ0bNpjo6Givb28UCoXia2XatGlm3rx5Xo+DQqFcWwL+9xcAAAA4qWPHjgoJCVFOTo7i4+OVnp6u3/3ud1qxYoW3QwNwFS51AwAAqKWmTZvqs88+09mzZ/XJJ5/o/fff14oVK3TvvffaL/e6utTGpEmTKp1Xenq6S9cnNze30uUMHz681vOcPXt2pfOcPXu2CyMHHOP1004USl1KVFRUhUu+rixRUVFOz2/48OGVzis3N9elcaenp1e6nEmTJtV6npMmTap0nunp6V7/O1EoFAqFQqF4s3CpGwAAAAC/F+TtACTp8OHDFZ6nAgDwvOjoaN10003eDsMn0U8BgPfVtZ/yicRn//79io+P93YYAHBds1gs3g7BZ9FPAYD31bWf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fCCv16v8/PygltlXJD5BSEtLU2trq/91W1ub0tLSOpUZM2aMxowZo3fffVcHDhxQYWFhtMOMuGDa4emnn9aDDz6o1tZWbd26VUuXLo12mLYKpo36k4ULF2rbtm12hxF1f/M3f6P7779fr7zyit2hIMrCtQ/Iy8tTUlKSjh075p/385//XLW1tXrhhReUlJQUlnil0GMePHiwXC6XDhw44P/jZOTIkTp//rwuXbrUp2VGOuYOs2bN0uuvv95pXqTaWbIe9+X70ECfTUtLU1tbW9DLjGbMl4vlPn1lzHb06XDE3SGa/TrYmH/84x/L6/Xqueee06OPPtrjZyP5txSJT5gMGjRI2dnZKigo0OzZs1VeXq7hw4fbHVbUzZ49W+vXr1dGRoamTZumTZs2acCAAXaHBRsUFBRo4cKFYb82Nx6sWrVKZWVl/qNagBWpqanatGmTFixY4O9DTz75pG6++Wbl5eXp2muvjantKjMzU3l5eZozZ45WrVqlb33rW3aHFJTU1FSNGzdO27dv98+LpXaeO3euJk6cqOeff962GKwKFHMs9+nuYo6HPt1TW8div3755Zc1evRolZWV6ac//WnU19+BxCcIPp9PGRkZ/tfp6eny+XydyrS1tamqqkoXL17UBx98oObmZmVnZ0c71IgKph0WLlyoyspKSV+fgh08eLBSUlKiGqedgmmj/mDcuHH6j//4D5WUlPR6SZgTTZw4URUVFWppadEDDzygl19+OWyn6RHbQt0HDB06VG+//baWL1/uv3RJkk6ePClJam9v17p165Sfnx8zMXdc0tzS0qJ9+/YpNzdXZ8+eVXJysgYOHNinZUY6ZkmaOXOm3nrrLV28eNE/L5LtLAUf9x133KHly5fr3nvvVXt7e4+f9fl8nS53squtu4tZiu0+HShmO/p0OOKWot+vrW6LFRUV/ksEe+rTkfxbKiI/dnLSNHDgQHPs2DGTlZXl/5HV2LFjO5UpLCw069evN5LMyJEjzZ/+9Cdz7bXX2h57tNth69atZv78+UaSufnmm43P57M97nBPmZmZAX/UPm3atE43N6ipqbE93mi3QUZGhvF4PGby5Mm2x2lXG1w+RfrH0kyxNQWznwzUNxITE82uXbvMY4891qVsamqq//8vvvii+cUvfhETMScnJ5ukpCQjfT32NTc3+3+EXFlZ2emH4D/60Y9i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\n","text/plain":["<Figure size 1008x1080 with 12 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_p1_idx]\n","  long_open_data = long_data[long_p1_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  # short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  short_false_data = short_open_data[~short_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  # long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  long_false_data = long_open_data[~long_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","source":["short_max_outg[short_bias_arr].mean()  # 0.6516201182674871 0.6614915628823353"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"iLi-agR41HJA","executionInfo":{"status":"ok","timestamp":1657335430544,"user_tz":-540,"elapsed":328,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"1ef2f4b7-a8e5-4690-f235-b5ddd5e581a4"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["0.6614915628823353"]},"metadata":{},"execution_count":71}]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":881},"executionInfo":{"elapsed":1957,"status":"ok","timestamp":1657335427143,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"jHh0uFkXC4VF","outputId":"7c3e0657-e0bd-4bf4-be0c-3bddb61452a0"},"outputs":[{"output_type":"stream","name":"stdout","text":["293\n","685\n","293\n","685\n","293\n","685\n","293\n","685\n","pkx : [0.05346088 0.14578409 0.37659213 0.48737999 0.77358195]\n","pkx : [0.08375248 0.15590148 0.29118087 0.78720528]\n","\n","56\n","115\n","56\n","115\n","56\n","115\n","56\n","115\n","pkx : [-0.22675861 -0.1793134  -0.1450474  -0.08178711 -0.03697774]\n","pkx : [-0.2594824  -0.17702805 -0.13854936 -0.08907675 -0.02586175]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(short_max_data))\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"mScdfR9hmjVu"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"983aUwM76s6X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p_e8PtFXa7mc"},"outputs":[],"source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLZDkNNxbZPO"},"outputs":[],"source":["p1_hlm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":261,"status":"ok","timestamp":1653452376525,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WhCPOi1qbkHS","outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"outputs":[{"data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"execution_count":161,"metadata":{},"output_type":"execute_result"}],"source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wgERZ65F5RBB"},"outputs":[],"source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rAao95SEnOY0"},"outputs":[],"source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":267,"status":"ok","timestamp":1653119592395,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"OEQ9KWXVnQ2J","outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"outputs":[{"name":"stdout","output_type":"stream","text":["153\n","163\n"]},{"data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"execution_count":220,"metadata":{},"output_type":"execute_result"}],"source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hOtCGUeBQ4hn"},"outputs":[],"source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QPhjkZQhRLqr"},"outputs":[],"source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cFd7Fz0Y6ucU"},"outputs":[],"source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v4"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":78277,"status":"ok","timestamp":1655562981508,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oVifICO4-Grk","outputId":"99e914ea-98d2-4c52-c01e-d4c18738154e"},"outputs":[{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9718692302703857\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.069481611251831\n","en_ex_pairing elapsed time : 0.48963069915771484\n","idep_plot elapsed time : 0.19661450386047363\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9608440399169922\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0421018600463867\n","en_ex_pairing elapsed time : 0.4900686740875244\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20415735244750977\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9762113094329834\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0472276210784912\n","en_ex_pairing elapsed time : 0.4884374141693115\n","idep_plot elapsed time : 0.1992168426513672\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9757428169250488\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.061593770980835\n","en_ex_pairing elapsed time : 0.4922516345977783\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20275139808654785\n","get_open_info_df elapsed time : 0.9718272686004639\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0611577033996582\n","en_ex_pairing elapsed time : 0.49936604499816895\n","idep_plot elapsed time : 0.1955404281616211\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9695820808410645\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0577938556671143\n","en_ex_pairing elapsed time : 0.482999324798584\n","idep_plot elapsed time : 0.19686579704284668\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9735269546508789\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0826354026794434\n","en_ex_pairing elapsed time : 0.48934102058410645\n","idep_plot elapsed time : 0.19826126098632812\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9531569480895996\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.055222511291504\n","en_ex_pairing elapsed time : 0.5082666873931885\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21497869491577148\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9643127918243408\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0502116680145264\n","en_ex_pairing elapsed time : 0.502924919128418\n","idep_plot elapsed time : 0.19685792922973633\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.008805513381958\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.051682949066162\n","en_ex_pairing elapsed time : 0.5109684467315674\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.2049274444580078\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9716737270355225\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0618155002593994\n","en_ex_pairing elapsed time : 0.5181412696838379\n","idep_plot elapsed time : 0.20029854774475098"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9584364891052246\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0500702857971191\n","en_ex_pairing elapsed time : 0.5167996883392334\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20274782180786133\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.973966121673584\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0631885528564453\n","en_ex_pairing elapsed time : 0.5297532081604004\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20432114601135254\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.961554765701294\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0457618236541748\n","en_ex_pairing elapsed time : 0.5284707546234131\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21644258499145508\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9707987308502197\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0691368579864502\n","en_ex_pairing elapsed time : 0.5354645252227783\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21542096138000488\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9668304920196533\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0549356937408447\n","en_ex_pairing elapsed time : 0.5420842170715332\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21134018898010254\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9731390476226807\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0800542831420898\n","en_ex_pairing elapsed time : 0.5430054664611816\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21756911277770996\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9662141799926758\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0587058067321777\n","en_ex_pairing elapsed time : 0.5436177253723145\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21967387199401855\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9630858898162842\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.084143877029419\n","en_ex_pairing elapsed time : 0.5587177276611328\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.2225339412689209\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9734728336334229\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0562217235565186\n","en_ex_pairing elapsed time : 0.683725118637085\n","idep_plot elapsed time : 0.19470643997192383\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9524209499359131\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0482914447784424\n","en_ex_pairing elapsed time : 0.5747659206390381\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.20411157608032227\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9617624282836914\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0563850402832031\n","en_ex_pairing elapsed time : 0.5843932628631592\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.2063751220703125\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9615845680236816\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.0422992706298828\n","en_ex_pairing elapsed time : 0.5829193592071533\n"]},{"name":"stderr","output_type":"stream","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"name":"stdout","output_type":"stream","text":["idep_plot elapsed time : 0.21132826805114746\n"]},{"name":"stderr","output_type":"stream","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 20150\n","np.sum(long_open_res2 == 1) : 20410\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 1.00000 (1.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 0.9458277225494385\n"]},{"name":"stderr","output_type":"stream","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 1.00000 (0.0)\n"]},{"name":"stdout","output_type":"stream","text":["get_open_info_df elapsed time : 1.072371244430542\n","en_ex_pairing elapsed time : 0.5856218338012695\n","idep_plot elapsed time : 0.21661949157714844\n"]},{"data":{"image/png":"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ERFVDbt27cI///yD8+fPY+/evQgICAAA/PrrrwgKCsKxY8cQHx+PBw8e4MMPPwTwcBqHhQsX4uTJk0hPT0f79u1l7gKRTjHAw8l+iYiIiIjoMYsXL4a9vT3GjBkjOwoRERERUbnwF79ERERERP/j5uaGli1bAgC8vLwwbtw4nplDRERERDpJITsAEREREZG2sLS0xKZNm+Dg4IDU1FQsXboUu3btkh2LiIiIiKjcONUDERERERERERERkZ7hVA9EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0RERERERERERER6hgO/RERERERERERERHqGA79EREREREREREREeoYDv0Skdq6urggPD0dWVhY+/PBD2XGoDGvWrIGfn98zl6tWrRp2796NjIwMbNmyRQPJiIioLKyxuoE1lohIt7C+6gbW1/LjwO8j4uPj4e3t/cT9Xbt2hVKplJCIHsc+0g3Tp0/HkSNHYGVlhZUrV1badmrUqIEdO3bg/v37uH79OkaMGFHmsvv27cO9e/dULS8vDxcuXFA93rFjR5w+fRpZWVmIiIhAp06dKi23rhkyZAjs7Oxga2uLYcOGleu5zs7OCAkJQXZ2NmJiYkp9//5r6NChOHnyJLKzs3HkyJEnHvfw8MDZs2eRnZ2Ns2fPwsPDo9z7QvLw81v7sY90A2usfmGNJXXg57f2Yx9pP9ZX/cL6+v848KvlpkyZgps3byIzMxMBAQEwMTEpdbmRI0eW+EDIzs6GEAJt2rQBAFhb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\n","text/plain":["<Figure size 1728x576 with 36 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","# val_list = np.arange(-0.0, -0.5, -0.03)  # prcn 2\n","val_list = np.arange(-0.1, -0.8, -0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point1.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point1.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap1 = set_val \n","  # config_list_copy[0].tr_set.ep_gap2 = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","  open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","  open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=2)\n","  open_info_df_list = [open_info_df1, open_info_df2]\n","\n","  try:\n","    result.append(get_res_v9(res_df, open_info_df_list, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'frq', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oE5zkT75Beiy"},"outputs":[],"source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if config_list[0].tr_set.check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v9(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","source":["def plot_info_v9(gs, gs_idx, len_df, sample_len, tr, hhm, p2_hhm, out_hhm, mean_low, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n tpbox_mean_low : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhm, p2_hhm, out_hhm, mean_low, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"],"metadata":{"id":"8hdpN7S8JJF-"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v17(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"short_net_p1_frq :\", short_net_p1_frq)\n","    # print(\"long_net_p1_frq :\", long_net_p1_frq)\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    # print(\"short_obj.shape :\", short_obj.shape)\n","    # print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ get hhm ------ #    \n","    # start_0 = time.time()\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ mean_low ------ #    \n","    # start_0 = time.time()\n","    selection_id = config.selection_id\n","\n","    short_p1_idx = short_obj[-1].astype(int)\n","    long_p1_idx = long_obj[-1].astype(int)    \n","\n","    short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx] # != short_tp_1\n","    long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","    long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","    long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","    long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","    short_mean_low = short_max_outg[short_p2_true_bias_bool].mean()\n","    long_mean_low = long_max_outg[long_p2_true_bias_bool].mean()\n","    both_mean_low = (short_mean_low + long_mean_low) / 2\n","    # print(\"short_mean_low :\", short_mean_low)\n","    # print(\"long_mean_low :\", long_mean_low)\n","    # print(\"both_mean_low :\", both_mean_low)\n","    # print(\"mean_low elapsed time :\", time.time() - start_0)\n","\n","    # ------ plot_data ------ #\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_mean_low, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_mean_low, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_mean_low, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v9(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    open, high, low, close = ohlc_list\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        if show_detail:\n","            print(\"open_i1 :\", open_i1, side_arr1[open_i1])\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm   \n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ============\".format(op_idx1, open_side))\n","     \n","        # if show_detail:\n","        #   print(\"check_hlm :\", check_hlm)\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry by expiry_p2 function in p1's loop : continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        if check_hlm in [0, 1]:\n","          i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","          if open_i2 >= len_open_idx2:  # open_i2 소진\n","              break\n","\n","          if show_detail:\n","            print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","          # ------ check side sync. ------ #\n","          if open_side != side_arr2[open_i2]:\n","            continue\n","\n","          op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","          if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","            continue\n","          \n","          if show_detail:\n","            print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","          \n","          i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          tp_ = tp_arr[op_idx1]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          \n","          # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","          # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","          if check_hlm:  # p1_hlm, p2_hlm\n","            if op_idx1 < op_idx2:\n","              expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","              if expire:   # p1's expiry\n","                  if show_detail:\n","                    print(\"expiry_p1, touch_idx = {} : break\".format(touch_idx))\n","                  i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                  open_i2 = prev_open_i2\n","                  break   # change op_idx1\n","          \n","          # ------ point validation ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","          if open_side == OrderSide.SELL:\n","            if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","              break  # change op_idx1\n","            elif not (ep2_ < out_ and close[op_idx2] < out_):\n","              continue  # change op_idx2\n","          else:\n","            if not (tp_ > ep2_):              \n","              break\n","            elif not (ep2_ > out_ and close[op_idx2] > out_):\n","              continue\n","\n","          if check_hlm == 2:\n","            # ------ p2_box location ------ #\n","            if open_side == OrderSide.SELL:\n","              if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                if show_detail:\n","                    print(\"p2_box rejection : continue\")\n","                continue\n","              else:                \n","                # ------ p1p2_low ------ #\n","                if not high[op_idx1:op_idx2 + 1].max() < tp_0_ - tp_gap_ * config.tr_set.p1p2_low:\n","                  if show_detail:\n","                    print(\"p1p2_low rejection : continue\")\n","                  continue\n","            else:\n","              if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                if show_detail:\n","                    print(\"p2_box rejection : continue\")\n","                continue\n","              else:\n","                # ------ p1p2_low ------ #\n","                if not low[op_idx1:op_idx2 + 1].min() > tp_0_ + tp_gap_ * config.tr_set.p1p2_low:\n","                  if show_detail:\n","                    print(\"p1p2_low rejection : continue\")\n","                  continue\n","\n","            # ------ check p2's expiry ------ #\n","            exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx2, out_1_, out_gap_, len_df, open_side,\n","                                                                                    [*ohlc_list, ep2_arr], expiry_p2)   # tp_j 는 op_idx1 사용\n","            i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","            if not entry_done:   # p2's expiry\n","                if show_detail:\n","                    print(\"expiry_p2, i = {} : continue\".format(i))\n","                continue  # change op_idx2            \n","            \n","          # ------ tr_threshold ------ #   # en_p 에 대해 하는게 맞을 것으로봄\n","          if check_hlm:\n","            if open_side == OrderSide.SELL:\n","              tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))              \n","              if config.loc_set.point1.short_tr_thresh != \"None\":\n","                if tr_ < config.loc_set.point1.short_tr_thresh:\n","                  continue\n","            else:\n","              tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))\n","              if config.loc_set.point1.short_tr_thresh != \"None\":  # thresh 여부는 short 기준 공통\n","                if tr_ < config.loc_set.point1.long_tr_thresh:\n","                  continue\n","          else:\n","            tr_ = tr_arr[op_idx1]\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None : continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ # --> p1_hlm 의 경우, 1번만 실행\n","          if not allow_exit:\n","            continue\n","\n","          while 1:\n","              if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                  tp_j = i\n","              if not config.out_set.static_out:\n","                  out_j = i\n","\n","              # ------------ out ------------ #  # out 우선 (보수적 검증)\n","              # ------ signal_out ------ #\n","              if not exit_done:\n","                  exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","              # ------ hl_out ------ #\n","              if config.out_set.hl_out != \"None\":\n","                  if not exit_done:  # and i != len_df - 1:\n","                      exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","              # ------------ tp ------------ #\n","              if not config.tp_set.non_tp and i != exec_j:\n","                if not exit_done:\n","                  exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                            [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                  # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                  # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","              if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                  # ------ append dynamic vars. ------ #\n","                  p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                  p2_idx_list.append(op_idx2)\n","                  pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                  pair_price_list.append([en_p, ex_p])\n","                  lvrg_list.append(leverage)\n","                  fee_list.append(fee)\n","                  tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                  tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                  # open_i += 1  # 다음 open_idx 조사 진행\n","                  break\n","\n","              # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","              # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","              i += 1\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done\n","            if show_detail:\n","                    print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:\n","            if check_hlm:\n","              if check_hlm == 1:   # exit only once in p1_hlm mode\n","                allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : continue\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_entry_v5(res_df, config, op_idx, wave1, wave0, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave0, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[i] < ha_c[i]):# & (ha_o[i] == ha_l[i]):   # 양봉 출현\n","    #           exit_done = -1\n","    #     else:\n","    #       if (ha_o[i] > ha_c[i]):# & (ha_o[i] == ha_h[i]):  # 음봉 출현\n","    #           exit_done = -1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[i] < bb_lower_5T[i] < close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] > bb_upper_5T[i] > close[i - 1]:\n","                exit_done = -1\n","        else:\n","            if close[i] > bb_upper_5T[i] > close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] < bb_lower_5T[i] < close[i - 1]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"qM6H6fmrKtsA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":260,"status":"ok","timestamp":1653436951068,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oLDZobRcgg6E","outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"outputs":[{"data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":["res_df.low.rolling(100) #> 1000"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"uB-I09hKKvmu"},"outputs":[],"source":["def get_touch_idx_fill(tp_1_touch_idxs, net_p1_pair, net_p1_idx, len_df):\n","\n","    tp_1_touch_idx = np.full(len_df, np.nan)\n","    tp_1_touch_idx[net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair]\n","    \n","    return fill_arr(tp_1_touch_idx)\n","    \n","def get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    # print(\"np.sum(long_p2_false_bias_bool != ~long_p2_true_bias_bool) :\", np.sum(long_p2_false_bias_bool != ~long_p2_true_bias_bool))\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_tpbox_p2exec_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_tpbox_p2exec_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FuIwazc3P5d1"},"outputs":[],"source":["def get_wave_bias_v4(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)  # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ------------------ touch idx ------------------ #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    short_tp_1_touch_idx = pd.Series(np.where(low <= short_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_tp_0_touch_idx = pd.Series(np.where(high >= short_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_1_touch_idx = pd.Series(np.where(high >= long_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_0_touch_idx = pd.Series(np.where(low <= long_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_out_1_touch_idx = pd.Series(np.where(low <= short_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_out_0_touch_idx = pd.Series(np.where(high >= short_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_1_touch_idx = pd.Series(np.where(high >= long_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_0_touch_idx = pd.Series(np.where(low <= long_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    # print(np.sum(np.isnan(short_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(short_tp_0_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_0_unq_p1_touch_idx)))\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","    \n","    # print(\"np.sum(short_net_p1_true_bias_bool) :\", np.sum(short_net_p1_true_bias_bool))\n","    # print(\"np.sum(long_net_p1_true_bias_bool) :\", np.sum(long_net_p1_true_bias_bool))\n","\n","    # print(\"np.sum(short_unq_p1_true_bias_bool) :\", np.sum(short_unq_p1_true_bias_bool))\n","    # print(\"np.sum(short_unq_p1_false_bias_bool) :\", np.sum(short_unq_p1_false_bias_bool))\n","    # print(\"np.sum(long_unq_p1_true_bias_bool) :\", np.sum(long_unq_p1_true_bias_bool))\n","    # print(\"np.sum(long_unq_p1_false_bias_bool) :\", np.sum(long_unq_p1_false_bias_bool))\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6YcqQQzsl6Ys"},"outputs":[],"source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"t7a5Hyyyd5Lk"},"outputs":[],"source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dsI-R8Zz7ls1"},"outputs":[],"source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":350,"status":"ok","timestamp":1652751452213,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"gMur2u8WeQ2K","outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"outputs":[{"data":{"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":872,"status":"ok","timestamp":1652756329304,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eoXMxRm3qdz2","outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"outputs":[{"data":{"image/png":"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\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dm7ZqzS9vqhm"},"outputs":[],"source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qOE2YSzntx8v"},"outputs":[],"source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_plot_params"]},{"cell_type":"code","execution_count":40,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1657550105186,"user_tz":-540,"elapsed":586,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 4     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick, 5 : bias_tick (사용 금지)  \n","x_max = 500       # back_plot : 0 사용시, custom x_max 반영됨\n","\n","bias_plot = 1     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = 1   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 100 #  150 100 20 500 1000\n","post_plotsize = 160 # config.tr_set.bias_info_tick -> excessive bit 는 감당 못함\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","    if pr_descend == -1:\n","      pr_descend = 0\n","    pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","try:   # wave_range 단독 실행의 경우 tr_arr 이 존재하지 않기 때문에 try 처리함\n","  res_df['short_tr_{}'.format(selection_id)].iloc[short_obj[-1].astype(int).ravel()] = short_tr_arr\n","  res_df['long_tr_{}'.format(selection_id)].iloc[long_obj[-1].astype(int).ravel()] = long_tr_arr\n","except:\n","  pass\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":41,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1319,"status":"ok","timestamp":1657550108619,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"2bjxKCIh1ojZ","outputId":"c53b022f-299d-4adb-b92a-48fd4e65955b"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","# hc_tf1 = '5T'\n","# hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period1 = config.tr_set.wave_period1\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = 'T'\n","dc_period1 = 100\n","dc_tf2 = 'T'\n","dc_period2 = config.loc_set.point2.csd_period if config.loc_set.point2.csd_period != \"None\" else wave_period2 \n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ff00ff', 1]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 2]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 100\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ma / ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ma_period = 60\n","# step_col_list.append([['ma_T{}'.format(ma_period)], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","data_window_p1_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_p1_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  # \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"XfvH5ngyieS9"},"source":["#### session_plot main"]},{"cell_type":"code","execution_count":42,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1scc6gGuxEDKG2ibFaIgRHVcxpvfjYeTi"},"executionInfo":{"status":"error","timestamp":1657550194622,"user_tz":-540,"elapsed":86006,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"46e7207d-2fc4-405c-d1b0-32e78b6a26a2"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["# p2_hlm 의 경우, tr 확인을 우해 session_plot 우선 실행 필요함\n","_ = [plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","metadata":{"id":"sZAYhcdoXnm4"},"source":["### whole_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jjFziVVIhgSr"},"outputs":[],"source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"50HXDIdJij28"},"source":["#### whole_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-tbLsXN9eN2p"},"outputs":[],"source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FtILHO-4kVlO"},"outputs":[],"source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    # print(\"p1_idx :\", p1_idx)\n","    # if p1_idx != 370259:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    if back_plot == 0:\n","      iout = iin + x_max\n","      # print(\"iin, iout :\", iin, iout)\n","\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v8(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v8(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","  elif back_plot == 5:\n","    x_max = bias_info_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg2 {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------------ ax2 ------------ #\n","  # ------ band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  if back_plot == 5:\n","    ax1.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"ddL_BC24buq0"},"source":["### dump"]},{"cell_type":"markdown","metadata":{"id":"zgTrEWWqbwsT"},"source":["#### whole_plot thing"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M4zn8wxibzAR"},"outputs":[],"source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"4IhBjPMobzAS"},"outputs":[],"source":["cf.go_offline()\n","init_notebook_mode()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"n9WZkE9wbzAS"},"outputs":[],"source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","x2yj2SwAXDLp","Q_1wJTcRYpm8","02DcTVB2cYuR","xpyP5t8Ht_pE","MuD_2vY7TI_8","983aUwM76s6X","_blyFhQJUd5X"],"name":"stem5_46_vec_backi2(0701_p1p2low).ipynb","provenance":[],"toc_visible":true,"authorship_tag":"ABX9TyMHeAxIPzI1r+0KLTw0gso5"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}