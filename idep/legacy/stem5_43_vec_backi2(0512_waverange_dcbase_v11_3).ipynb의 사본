{"cells":[{"cell_type":"code","execution_count":null,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1652401346623,"user_tz":-540,"elapsed":20429,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"28380d0b-a186-4f94-f944-725189856725"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"9qGt60DKTZmf"},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","import IPython\n","import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","source":["\n","def bb_level_v2(res_df, itv, period):\n","\n","    bb_base = res_df['bb_base_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_upper2 = 'bb_upper2_{}{}'.format(itv, period)\n","    bb_lower2 = 'bb_lower2_{}{}'.format(itv, period)\n","    bb_upper3 = 'bb_upper3_{}{}'.format(itv, period)\n","    bb_lower3 = 'bb_lower3_{}{}'.format(itv, period)\n","\n","    level_gap = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy() - bb_base\n","\n","    res_df[bb_upper2] = bb_base + level_gap * 2\n","    res_df[bb_lower2] = bb_base - level_gap * 2\n","\n","    res_df[bb_upper3] = bb_base + level_gap * 3\n","    res_df[bb_lower3] = bb_base - level_gap * 3\n","\n","    return res_df"],"metadata":{"id":"kuf6ZhccgRj9"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    # df = bb_line_v3(df, df_15T, 60)\n","\n","    # df = bb_level_v2(df, 'T', 60)\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":602},"executionInfo":{"status":"ok","timestamp":1652066331412,"user_tz":-540,"elapsed":2108,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"90cf9151-9050-4f0c-fa54-9f9a9a9e38bb"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n"]},{"output_type":"execute_result","data":{"text/plain":["                         bb_upper_T60  bb_lower_T60  bb_base_T60  bb_upper2_T60  bb_lower2_T60  bb_upper3_T60  bb_lower3_T60  upper_wick_ratio_5T  lower_wick_ratio_5T  candle_updown_5T\n","index                                                                                                                                                                                   \n","2022-04-27 08:41:59.999   2823.126867   2790.340133  2806.733500    2839.520235    2773.946765    2855.913602    2757.553398             0.354545             0.640260                 0\n","2022-04-27 08:42:59.999   2822.498326   2790.088008  2806.293167    2838.703485    2773.882848    2854.908644    2757.677689             0.354545             0.640260                 0\n","2022-04-27 08:43:59.999   2821.914551   2789.914116  2805.914333    2837.914768    2773.913898    2853.914986    2757.913681             0.354545             0.640260                 0\n","2022-04-27 08:44:59.999   2821.473171   2789.742162  2805.607667    2837.338676    2773.876657    2853.204181    2758.011153             0.354545             0.640260                 0\n","2022-04-27 08:45:59.999   2820.842501   2789.526499  2805.184500    2836.500502    2773.868498    2852.158503    2758.210497             0.089172             0.248408                 0"],"text/html":["\n","  <div id=\"df-882399d2-6441-4f90-a90e-e91ecbb1b52a\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>bb_upper_T60</th>\n","      <th>bb_lower_T60</th>\n","      <th>bb_base_T60</th>\n","      <th>bb_upper2_T60</th>\n","      <th>bb_lower2_T60</th>\n","      <th>bb_upper3_T60</th>\n","      <th>bb_lower3_T60</th>\n","      <th>upper_wick_ratio_5T</th>\n","      <th>lower_wick_ratio_5T</th>\n","      <th>candle_updown_5T</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2823.126867</td>\n","      <td>2790.340133</td>\n","      <td>2806.733500</td>\n","      <td>2839.520235</td>\n","      <td>2773.946765</td>\n","      <td>2855.913602</td>\n","      <td>2757.553398</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2822.498326</td>\n","      <td>2790.088008</td>\n","      <td>2806.293167</td>\n","      <td>2838.703485</td>\n","      <td>2773.882848</td>\n","      <td>2854.908644</td>\n","      <td>2757.677689</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2821.914551</td>\n","      <td>2789.914116</td>\n","      <td>2805.914333</td>\n","      <td>2837.914768</td>\n","      <td>2773.913898</td>\n","      <td>2853.914986</td>\n","      <td>2757.913681</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2821.473171</td>\n","      <td>2789.742162</td>\n","      <td>2805.607667</td>\n","      <td>2837.338676</td>\n","      <td>2773.876657</td>\n","      <td>2853.204181</td>\n","      <td>2758.011153</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2820.842501</td>\n","      <td>2789.526499</td>\n","      <td>2805.184500</td>\n","      <td>2836.500502</td>\n","      <td>2773.868498</td>\n","      <td>2852.158503</td>\n","      <td>2758.210497</td>\n","      <td>0.089172</td>\n","      <td>0.248408</td>\n","      <td>0</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-882399d2-6441-4f90-a90e-e91ecbb1b52a')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-882399d2-6441-4f90-a90e-e91ecbb1b52a button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-882399d2-6441-4f90-a90e-e91ecbb1b52a');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":94}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1071,"status":"ok","timestamp":1652066337627,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"c3a01224-f5a8-442f-8300-805b0988100d"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1652401400871,"user_tz":-540,"elapsed":6816,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"cdbc8576-09c8-4cc9-8b14-a2226038887b"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 5.865435600280762\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["def cci_v2(df, period=20):\n","\n","    itv = pd.infer_freq(df.index)\n","    high, low, close = [df[col_].to_numpy() for col_ in ['high', 'low', 'close']]\n","\n","    df['cci_{}{}'.format(itv, period)] = talib.CCI(high, low, close, timeperiod=period)\n","\n","    return df\n","\n","def wave_range_cci_v1(res_df, config, itv='T'):\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    wave_period = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = cci_v2(t_df, wave_period)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(itv_num).to_numpy()\n","\n","    upper_band = 100\n","    lower_band = -100\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df"],"metadata":{"id":"euA18M1uyc3s"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 370940\n","i = 185369\n","i = 186060\n","\n","plot_size = 200\n","t_df = res_df.iloc[i - plot_size:i + plot_size]\n","# t_df = res_df.iloc[i - plot_size:i - 22]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-Dr_tTk9csFm","colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"status":"ok","timestamp":1652404704338,"user_tz":-540,"elapsed":4114,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5da874f6-0416-4d21-ada4-ae6aaa0d3a38"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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mLt+3QnZPB31lnLDD1YkKTMGfypLhVy7lcupSUHbrk0rHjXTpsZNGXVqmpRdw/9N+cGKJGXG4E9lI98banuTX5rCvbHkO+69J0mSKo3Bn8pGJW+oPdZIoKOE8eZteyzusdPHJElSpTD4U9mptKyNw7cqSEWlj1wGQaDTxyRJUqVIOvi77777CIfD7NmzZ6hu+vTpbN++nb1797J9+3amTZs29Ny3vvUtXnzxRZ599lkuuOCCofovfOEL7N27l7179/KFL3whS6chVY6R01vdqiBz2drIPtHU42y1LUmSlKmkg7/777+fyy+PH1lYuXIlTzzxBM3NzTzxxBOsXLkSgCuuuIKzzjqLs846ixtuuIF/+Id/AGLB4le/+lUuvvhiLrroIr761a/GBYySxpft6a0jp4VWwv5+wTmme66hhoaE9cHPxqmkkiSpGCUd/O3cuZO33norru7qq69m8+bNAGzevJklS5YM1T/wwAMA/OIXv2DatGk0NTXxiU98gp/85CccOnSIw4cP85Of/OSEgFJKVqkEKZ966r1MYQpEJjH5x//IOwv+e1badaSveARJZIKgz6mkhdHZdJArd9wE84EdJF82Ak0pviabbU7qhvNfyknb4cb4/7clSZUtozV/jY2NdHZ2AtDZ2UljYyMAp59+Ovv37x867ne/+x2nn376qPWJrFixgl27drFr1y5mzJiRSTelgvnUU+/l6/deQogQVUB1z6k0/LqVFloybntkwDFSpa/py8Ro127D330QpsBAbTd0QNesXwCuHywW61Y/wNML98AWYCHJl2uA1Sm+JpttnrMPph7NSdvfWLM58wsrSSobWU34Eo1Gs9bWxo0bWbBgAQsWLODAgQNZa1fKp7/43gLq+ybE1VUdq2MtazNue6yAI90kMBpDC9z0pWeO/9acDeGLvjMUAI7kWr886gaisKl1KwPV0dioVzXJl62DX6m8JpttnvQuVOWm7U2tW5keXRS7RmUi+LdVKrM/JKmYZBT8hcNhmpqaAGhqauKNN94A4LXXXuPMM88cOu6MM87gtddeG7VeKld/cOCkhPWzmJnT9x0vCczI4NAgMQlroafuWFxVtKaPA+f9sEAdqkwJR2XnAlugrrs29jj4HDLZMjL4lc5r89lmGm3Xddfy2QcXwxwkScos+Nu6dSvLly8HYPny5TzyyCND9UEmz4sv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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","config.tr_set.wave_period = 20\n","wave_itv, wave_period = 'T', config.tr_set.wave_period\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","t_df = wave_range_cci_v1(t_df, config)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# wave_high_fill2_ = t_df['wave_high_fill2_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# wave_low_fill2_ = t_df['wave_low_fill2_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv, wave_period)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=6)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=6)\n","\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in paired_cu_idx if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_fill_, alpha=1.0, color='yellow', linewidth=2)\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","# plt.step(len_df_range, wave_high_fill2_, \"*\", alpha=1.0, color='#0000ff', markersize=6)\n","# plt.step(len_df_range, wave_low_fill2_, \"*\", alpha=1.0, color='#ff0000', markersize=6)\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","cci_T20 = t_df['cci_T20'].to_numpy()\n","plt.step(len_df_range, cci_T20, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"markdown","source":["###### data_window"],"metadata":{"id":"c2yVTn1tnxMn"}},{"cell_type":"code","source":["idx_ = 55\n","\n","roll_cnt = 3\n","valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_v4(t_df, config, roll_hl_cnt=roll_cnt)\n","roll_high = get_roll_wave_data(valid_high_prime_idx, roll_prev_high_idx_arr, len_df, wave_high_fill_, roll_cnt)\n","roll_low = get_roll_wave_data(valid_low_prime_idx, roll_prev_low_idx_arr, len_df, wave_low_fill_, roll_cnt)\n","\n","print(roll_high[idx_])\n","print(roll_low[idx_])\n","# roll_prev_high_idx_arr\n","# valid_high_prime_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"I_ZNM9n7hFOf","executionInfo":{"status":"ok","timestamp":1652336726344,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"9adbcf9a-c09b-49f1-d93a-d5286fcc3050"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["[   nan 977.51 999.24]\n","[963.05 944.76 981.55]\n"]}]},{"cell_type":"code","source":["# wave_co_bool_idx_[~np.isnan(wave_co_bool_idx_)]\n","wave_cu_bool_idx_[~np.isnan(wave_cu_bool_idx_)]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"BvF0CoLn7bF3","executionInfo":{"status":"ok","timestamp":1652336711486,"user_tz":-540,"elapsed":305,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"f66d504b-83d3-46cf-9996-4fe886e434be"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([  6.,  22.,  49.,  55.,  73.,  82.,  96., 113.])"]},"metadata":{},"execution_count":41}]},{"cell_type":"code","source":["# print(co_idx[~np.isnan(co_idx)])\n","# high_terms_list\n","print(valid_high_prime_idx)   # valid_cu_post_idx\n","roll_high_idx_arr"],"metadata":{"id":"mzDW9PNuyQLx"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# roll_wave_hl_v2(t_df, config, roll_hl_cnt=4)[0][-1]\n","# roll_wave_hl_v2(t_df, config, roll_hl_cnt=4)[1][50]\n","# roll_list = roll_wave_hl_v3(t_df, config, roll_hl_cnt=4) # [0][60]\n","\n","\n","# valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3)\n","# roll_high = get_roll_wave_data_v2(valid_high_prime_idx, roll_prev_high_idx_arr, len_df, wave_high_fill_, 3)\n","\n","# roll_wave_hl(t_df, itv, period1)[0][150]"],"metadata":{"id":"G5jpriueRpxH"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["term_thresh1=1\n","term_thresh2=1\n","\n","itv = 'T'  # '15T'\n","\n","over_period = 2\n","\n","period1 = config.tr_set.wave_period\n","itv_num = to_itvnum(itv)\n","\n","\n","t_df = donchian_channel_v4(t_df, period1)\n","\n","dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","# b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","# short_open_res = np.ones(len_df)\n","# long_open_res = np.ones(len_df)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","over_base = close > dc_base_\n","prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","cu_bool = prev_over_base & ~over_base\n","co_bool = prev_under_base & over_base\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","# cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","# # ------ get post_terms ------ #\n","# high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","# low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","# paired_post_cu_idx = high_post_terms[:, 1]\n","# paired_post_co_idx = low_post_terms[:, 1]\n","\n","# # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# # paired_prime_cu_idx = high_prime_terms[:, 1]\n","# # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# # ====== get wave_hl & terms ====== #\n","# wave_high_ = np.full(len_df, np.nan)\n","# wave_low_ = np.full(len_df, np.nan)\n","\n","# wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","# wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# wave_high_[paired_post_cu_idx] = wave_highs\n","# wave_low_[paired_post_co_idx] = wave_lows\n","\n","# wave_high_fill_ = fill_arr(wave_high_)\n","# wave_low_fill_ = fill_arr(wave_low_)\n","\n","# # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","# wave_high_terms_low_ = np.full(len_df, np.nan)\n","# wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","# wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","# wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","# wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","# wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","# update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","# update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# wave_high_fill_ = fill_arr(wave_high_)\n","# wave_low_fill_ = fill_arr(wave_low_)\n","\n","# wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","# wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","# wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","# wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","# wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","# wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)"],"metadata":{"id":"TqMmmSAGuChM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"50ucQUF-Jixd"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"code","source":["\n","def wave_range_ratio_v4_1(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    cu_wave1_range = roll_high_[:, -1] - roll_low_[:, -2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_high_[:, -1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_high_[:, -2] - roll_low_[:, -1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_low_[:, -1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def wave_range_ratio_v4(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])\n","    valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #         cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_dcbase_v11_3(res_df, config, itv='T', over_period=2):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    # b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    over_base = close > dc_base_\n","    prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","    prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = prev_over_base & ~over_base\n","    co_bool = prev_under_base & over_base\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","def wave_range_v11_2(res_df, config, itv='T'):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n"],"metadata":{"id":"RVFfP9VcDG2_"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_roll_wave_data(valid_prime_idx, roll_idx_arr, len_df, data, roll_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v4(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","\n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","\n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_, _, _ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","    for col_, itv_ in zip(future_cols, itv_list):\n","        back_col_ = 'b1_' + col_\n","        res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","    return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1) \n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)   \n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","    \n","    # ============ modules ============ #  \n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","    wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    \n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    wave_high_[paired_cu_idx] = wave_highs\n","    wave_low_[paired_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","    \n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    cu_prime_idx = wave_high_prime_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","    co_prime_idx = wave_low_prime_idx\n","    co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","    # ============ enlist to df_cols ============ #       \n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ # \n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","    # ------ for first_high ------ # \n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","      \n","    if itv != 'T':\n","      assert ltf_df is not None, \"assert ltf_df is not None\"\n","      join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","      ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","      try:\n","        ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","      except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","    else:\n","      ltf_df = t_df    \n","\n","    return ltf_df\n"],"metadata":{"id":"841i4oo2abh-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"code","source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"],"metadata":{"id":"Go7ARIUhfC1g"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"],"metadata":{"id":"3vHLGont-BFe"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"],"metadata":{"id":"Mh3w2s-j34Zs"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"eQ06-kWq4m6F","executionInfo":{"status":"ok","timestamp":1651799326382,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["11\n","11\n"]}]},{"cell_type":"code","source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"],"metadata":{"id":"SUFmr9Z_kcCN"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"],"metadata":{"id":"_3pOQtt2ttfk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"kKaD1fK3WPRP","executionInfo":{"status":"ok","timestamp":1651756811396,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"metadata":{},"execution_count":79}]},{"cell_type":"code","source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"],"metadata":{"id":"YoZpr7lDn7z-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"code","source":[""],"metadata":{"id":"1eZov-szzNuB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"],"metadata":{"id":"nLWAP1Cl2Hvu"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SeJan_0t95yL"},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CB2yZdQ95Cdg"},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","# def get_line(touch_idx, rtc_):\n","#     touch_idx_copy = touch_idx.copy()\n","\n","#     nan_idx = np.isnan(touch_idx_copy)\n","#     touch_idx_copy[nan_idx] = 0  # for indexing array\n","#     touch_line = rtc_[touch_idx_copy.astype(int)].copy()\n","#     touch_line[nan_idx] = np.nan  # for true comp.\n","\n","#     return touch_line\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","\n","    p1_itv1 = config.tr_set.p1_itv1\n","    p1_period1 = config.tr_set.p1_period1\n","    p1_period2 = config.tr_set.p1_period2\n","    p2_itv1 = config.tr_set.p2_itv1\n","    p2_period1 = config.tr_set.p2_period1\n","    p2_period2 = config.tr_set.p2_period2\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","      \n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","\n","    wave_itv = 'T'\n","    wave_period = config.tr_set.wave_period\n","    roll_hl_cnt = 4\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)   # Todo, df 저장할 방법 고민\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","    \n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    res_df[short_tp_1_] = wave_low_fill_      # wave_low_fill_ b2_low_5T\n","    res_df[short_tp_0_] = roll_high_[:, -1]   # roll_high_[:, -2] wave_high_fill_\n","    res_df[long_tp_1_] = wave_high_fill_      # wave_high_fill_ b2_high_5T\n","    res_df[long_tp_0_] = roll_low_[:, -1]     # roll_low_[:, -2]  wave_low_fill_\n","\n","    if config.tr_set.p2_itv1 != \"None\":\n","        p2_period1 = config.tr_set.p2_period1\n","        p2_period2 = config.tr_set.p2_period2\n","        res_df[short_epout_1_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[short_epout_0_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","        res_df[long_epout_1_] = res_df['dc_upper_{}{}'.format(config.tr_set.p2_itv1, p2_period1)]\n","        res_df[long_epout_0_] = res_df['dc_lower_{}{}'.format(config.tr_set.p2_itv0, p2_period2)]\n","    else:\n","        res_df[short_epout_1_] = wave_low_fill_   # b2_low_5T\n","        res_df[short_epout_0_] = wave_high_fill_  # roll_high_[:, -2]\n","        res_df[long_epout_1_] = wave_high_fill_   # b2_high_5T\n","        res_df[long_epout_0_] = wave_low_fill_    # roll_low_[:, -2]\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df[short_tp_gap_] = abs(res_df[short_tp_1_] - res_df[short_tp_0_])\n","    res_df[long_tp_gap_] = abs(res_df[long_tp_1_] - res_df[long_tp_0_])\n","    res_df[short_epout_gap_] = abs(res_df[short_epout_1_] - res_df[short_epout_0_])\n","    res_df[long_epout_gap_] = abs(res_df[long_epout_1_] - res_df[long_epout_0_])\n","\n","    # ================== enlist tr_set ================== #    \n","    short_open_res = np.ones(len_df)\n","    long_open_res = np.ones(len_df)\n","\n","    tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","\n","    short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ---------------- point ---------------- #\n","    if p2_itv1 != \"None\":\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","    else:  \n","        # ------ p1 only ------ #\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = 0  # default\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = 0 \n","        \n","        # ============ wave_point ============ #\n","        short_open_res *= res_df['wave_cu_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        long_open_res *= res_df['wave_co_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        if show_detail:\n","          sys_log.warning(\"wave_point\")\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ wave_mm ------ #\n","        wave_high_terms_cnt_fill_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        wave_low_terms_cnt_fill_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        short_open_res *= (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater1)\n","        long_open_res *= (wave_low_terms_cnt_fill_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill_ > config.tr_set.wave_greater1)\n","\n","        if show_detail:\n","          sys_log.warning(\"wave_mm\")\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ================== pattern depiction ================== #  \n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","        \n","        # # ------ even_break, hhhl (long) ------ #        \n","        # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","        # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","        # short_open_res *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","        # long_open_res *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"even_break\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # # ------ roll_high < bb_upper2 (long) ------ #\n","        # short_open_res *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","        # short_open_res *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","        # short_open_res *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","        # long_open_res *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","        # long_open_res *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        \n","        # if show_detail:\n","        #   sys_log.warning(\"roll_high < bb_upper2\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ base_15T < wave_base ------ #\n","        # dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # short_open_res *= (dc_base_ > wave_base_) & (dc_base_ > close)\n","        # long_open_res *= (dc_base_ < wave_base_) & (dc_base_ < close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))     \n","        \n","\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res\n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_tp_gap * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_tp_gap * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg = config.tr_set.ep_gap\n","        res_df['short_ep_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * epg\n","        res_df['long_ep_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * epg\n","        \n","        # res_df['short_ep_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * epg\n","        \n","        # wave_cu_marker_ = res_df['wave_cu_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        # wave_co_marker_ = res_df['wave_co_marker_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","        # res_df['short_ep_{}'.format(selection_id)] = wave_cu_marker_ + short_epout_gap * epg\n","        # res_df['long_ep_{}'.format(selection_id)] = wave_co_marker_ - long_epout_gap * epg\n","\n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep_{}'.format(selection_id)] = close\n","        res_df['long_ep_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    res_df['short_out_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * outg    # for hlm check\n","    res_df['long_out_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * outg \n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg        # for hhm check\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    # ------------ point validation ------------ #\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","    short_open_res *= (short_tp_ < short_ep_) & (short_ep_ < short_out_)\n","    # short_open_res *= close < short_ep_   # reject open_execution\n","    short_open_res *= close < short_out_    # reject open_execution\n","    res_df['short_open_{}'.format(selection_id)] = short_open_res * (not config.pos_set.short_ban)\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","    long_open_res *= (long_tp_ > long_ep_) & (long_ep_ > long_out_)\n","    # long_open_res *= close > long_ep_   # reject open_execution\n","    long_open_res *= close > long_out_    # reject open_execution\n","    res_df['long_open_{}'.format(selection_id)] = long_open_res * (not config.pos_set.long_ban)\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","      sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","    \n","    # ------------ wave_bias ------------ #\n","    wb_tpg = config.tr_set.wb_tp_gap\n","    wb_outg = config.tr_set.wb_out_gap\n","    res_df['short_wave_1_{}'.format(selection_id)] = short_tp_1 - short_tp_gap * wb_tpg\n","    res_df['long_wave_1_{}'.format(selection_id)] = long_tp_1 + long_tp_gap * wb_tpg\n","    \n","    res_df['short_wave_0_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * wb_outg   # hhc\n","    res_df['long_wave_0_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg    # hlc\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    res_df['short_tr_{}'.format(selection_id)] = abs(\n","        (short_ep_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep_ / short_out_ - config.trader_set.market_fee - 1))\n","    res_df['long_tr_{}'.format(selection_id)] = abs(\n","        (long_tp_ / long_ep_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    if config.tr_set.c_ep_gap != \"None\":\n","        # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","        # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","        res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","        res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # ------ zoned_out ------ #\n","    if config.tr_set.t_out_gap != \"None\":\n","        # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","        # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","        res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","        res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["\n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"aTV4h3LjTZBp"}},{"cell_type":"code","source":["\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","# ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"],"metadata":{"id":"dc49JPmoTaPQ"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":75,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1652409926346,"user_tz":-540,"elapsed":4722,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","import logging\n","from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    # ====== public ====== #\n","    res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2) \n","    # res_df = wave_range_v15(res_df, config, term_thresh1=2, term_thresh2=3)\n","    # res_df = wave_range_v15(res_df, config, itv='15T', term_thresh1=2, term_thresh2=3)\n","\n","    # ------ wrr ------ #\n","    # res_df = wave_range_ratio(res_df, config, 'T', 60)\n","    # res_df = wave_range_ratio_v2(res_df, config)\n","    # res_df = wave_range_ratio_v3(res_df, config)\n","    # res_df = wave_range_ratio_v4(res_df, config)\n","    res_df = wave_range_ratio_v4_1(res_df, config)\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    # itv_list = ['15T', '15T', '15T', '15T']\n","    # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expire_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expire(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expire_v2(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    h, l = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.ei_k != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_0_ = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if l[e_j] <= short_tp_1_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.ei_k or h[e_j] >= short_tp_0_[tp_j] - short_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()\n","            long_tp_0_ = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if h[e_j] >= long_tp_1_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.ei_k or l[e_j] <= long_tp_0_[tp_j] + long_tp_gap_[\n","                tp_j] * config.tr_set.ei_k:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","    allow_ep_in = 1\n","    if config.selection_id in ['v5_2']:\n","        if side == OrderSide.SELL:\n","            dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","            dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","            allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","                           (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","        else:\n","            dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","            dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","            allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","                           (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","    if config.selection_id in ['v3_4']:\n","        wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","        wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","        close = res_df['close'].to_numpy()\n","        if side == OrderSide.SELL:\n","            sup_T = res_df['sup_T'].to_numpy()\n","            allow_ep_in *= close[i] < sup_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","        else:\n","            resi_T = res_df['resi_T'].to_numpy()\n","            allow_ep_in *= close[i] > resi_T[i - 1]\n","            if len(wick_score_list) != 0:\n","                allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","    if allow_ep_in:\n","        out_j = i\n","    return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #\n","    if config.loc_set.point.short_tr_thresh != \"None\":\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point\n","    if config.loc_set.point.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point.wrr_32 != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point.wrr_32 + 0.1\n","        mr_res *= cu_wrr_32_ >= config.loc_set.point.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point.wrr_32 + 0.1\n","        mr_res *= co_wrr_32_ >= config.loc_set.point.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone.use_zone:\n","\n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["      \n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q_4E-zH02WJy"},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_43\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2022-01-14 16:34:59.999000\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 1e-10,\n","    \"market_fee\": 1e-10,\n","    \"initial_asset\": 24500,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 50, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"5T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"wave_period\": 5,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"p1_itv1\": \"15T\",\n","    \"p1_itv0\": \"T\",\n","    \"p1_period1\": 1,\n","    \"p1_period2\": 5,\n","    \"p2_itv1\": \"None\",\n","    \"p2_itv0\": \"T\",\n","    \"p2_period1\": 20,\n","    \"p2_period2\": 40,\n","    \"ei_k\": 0.0,\n","    \"expire_tick\": 10,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap\": -0.0,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 240\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1652404835686,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"9652f427-f812-463e-c204-5f9701e2a044"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_43\" {\n"," \"point\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"5T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"wave_period\": 5,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"p1_itv1\": \"15T\",\n"," \"p1_itv0\": \"T\",\n"," \"p1_period1\": 1,\n"," \"p1_period2\": 5,\n"," \"p2_itv1\": \"None\",\n"," \"p2_itv0\": \"T\",\n"," \"p2_period1\": 20,\n"," \"p2_period2\": 40,\n"," \"ei_k\": 0.0,\n"," \"expire_tick\": 10,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap\": -0.0,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 240\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expire, ep_loc_point2_v2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","# config_list[0].tr_set.wave_period = 5"]},{"cell_type":"code","execution_count":76,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3675,"status":"ok","timestamp":1652409930018,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"948f52f7-2af2-4e8d-e84b-17b7e2158504"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 2.1249747276306152\n","make data_list elapsed time : 0.00018596649169921875\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_iYcJk8nK8Yq"},"outputs":[],"source":["# ------ edit utils config ------ #\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_greater1 = 0\n","# config_list[0].tr_set.wave_greater2 = 0\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","config_list[0].tr_set.ep_gap = -0.12 # -0.618 -0.23 -0.382 0.19 \n","# config_list[0].tr_set.out_gap = 0\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 500\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004\n","\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":77,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":772,"status":"ok","timestamp":1652409940509,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"d6ef618e-bcf4-4475-c8d2-9401f3804597"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.33467650413513184\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfDSOGMd91rE"},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point.wrr_32 = 0.25 # \"None\" 1 0.5 0.382 0.302\n","config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","config_list[0].loc_set.point.cu_es = \"None\" # \"None\" # -2\n","config_list[0].loc_set.point.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point.short_tr_thresh = \"None\"  #  \"None\" 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point.long_tr_thresh = 1  #  \"None\" 2 0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":78,"metadata":{"executionInfo":{"elapsed":1297,"status":"ok","timestamp":1652409943793,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"baed7964-dd7c-4c57-ffe3-c0b2163c267e"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9831373691558838\n"]}],"source":["open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.ei_k = -0.5\n","# config_list[0].tr_set.expire_tick = 10\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","config_list[0].tp_set.p_ranges = \"[1]\"\n","config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","config_list[0].lvrg_set.leverage = 1\n","config_list[0].lvrg_set.static_lvrg = 1\n","config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":79,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":642},"executionInfo":{"elapsed":3708,"status":"ok","timestamp":1652409948607,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"42438bf9-0489-45e2-aef6-b96bd425ccd6"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.3978855609893799\n","short_obj.shape : (915, 5)\n","long_obj.shape : (1225, 5)\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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9y7Wr18Pb29v6OnpITY2FnPnzkVERAQ2btxY2reBqFh4ApZIhwwMDKCvr19gn6ysLPTp0wc+Pj74/fffkZ6ejq1bt2LGjBka/fIbx83NDaGhofneZyc4OBiTJ0/GCy+8gJSUFNy4cQOjR4/Gpk2bij0WERFRRVERamzv3r0BAJs3b9ZapqenBwCIioqCpaUlvL29UadOHcTFxWH//v2YNWsWEhMTC91PIiKi560i1NiiHsdOnjwZycnJWLZsGUxMTHDs2DEMGzYM6enpxdhjotLTA8CbSxERERERERERERGVA94DloiIiIiIiIiIiKic8AQsERERERERERERUTnhCVgiIiIiIiIiIiKicsITsERERERERERERETlhCdgqVpRKpXw8vIqsI+9vT1EBG3btn1Os8pf//79cfnyZaSmpiIkJARDhgwpdB0bGxusXbsWly5dQlZWFgIDA/Psp1QqISIauXfvnkafwMBArT656dq1a5nsIxERVQ2ssZratWuH3bt3Q6VS4fHjxzh37hw6duyo0WfAgAG4dOkS0tLScOvWLUydOrXU+0VERFUL66umotTXXE2aNEFiYiJEBKampiXeJ6KyYKDrCRBR3rp164YdO3Zg9erVmDx5MpydnbFlyxYkJCTg4MGD+a7Xtm1bODs74+zZszA0NCxwG5s2bcLKlSvVrzMyMjSWf/zxx6hdu7ZG27x58/Daa68hKCioBHtFRESke+VdY1999VWcOHECu3btwtChQwEAnTt3hrGxsbrPW2+9BT8/P2zYsAGfffYZunTpgkWLFiEnJwcrVqwou50lIiJ6TipCfX2al5cXkpKSUKtWrdLtGFEZEYapLlEqleLl5VVgH3t7exERadu2rU7nun//fjl8+LBG2549e+TEiRMFrqenp6f+e9u2bRIYGFji9+LZGBoaSlxcnKxevVrnnyXDMAxTscIa+2/OnDkjmzZtKnQOx48f12hbsmSJxMXFiaGhoc4/T4ZhGKZihPX13xSlvuame/fuEhcXJ9OnTxcREVNTU51/lkz1Dm9BQNXSlClTEBUVhfj4eGzZsgXm5uYF9hcRTJkyBUuWLMHDhw8RGxuL6dOnAwDef/99hIeHIyEhAevXr0eNGjVKPT8jIyO8/fbb+P333zXat27dijfffFPrqtRn51pe+vTpg7p162LLli3ltg0iIqrcqnuNbd26Nbp27arxC5O8dOjQQetqoICAANStWxdvvvlmodshIqLqhfW1aPUVABQKBVauXIl58+bh4cOHhU+e6DngCViqdoYMGQIHBwd8+OGH+OKLL9CvXz988803ha43ffp01KpVC8OGDcPmzZuxZMkSLFq0CKNGjcLkyZMxa9YsDB8+HFOmTClwnNz789jb2+fbx8bGBkZGRggLC9NoDw0Nhb6+Pl5++eWi7Wwhxo4di/T0dKhUKmzbtg1WVlYF9ndzc0NUVBROnDhRJtsnIqKqhTUW6NKlCwDAwsICwcHByMzMxM2bNzFmzBiNfjVr1tS69U/u69atW5dqDkREVLWwvha9vgLARx99hBo1amDVqlWl2iZRWeI9YKnayczMxMCBA5GdnQ0AaNOmDdzc3DBx4sQC17tx4wY++ugjAMChQ4cwePBgjBs3DtbW1khMTAQA9OzZEy4uLli0aFG+44gIsrKyCvyWz8LCAgCgUqk02hMSEjSWl8auXbtw9uxZ3LlzB61bt4anpydOnDiB9u3b4/Hjx1r9jY2N0b9/f6xbt67U2yYioqqJNRZo1KgRAOCXX37B4sWLERQUBFdXV6xfvx737t3Dvn37AAA3b95E586dNdZ94403AAB169Yt1RyIiKhqYX0ten2tW7cu5s+fjxEjRiArK6tU2yQqSzwBS9VOYGCgunABwNWrV2FpaQkDA4MC/wN9+PBh9d8iAqVSiZSUFHXhAp4cTL311lsFbv/48eOFPhzreXj6W86TJ0/i9OnTCA4OxujRo/N8+Me7776LWrVq8fYDRESUL9ZYQE9PDwDw448/qp9affToUbRu3Rpffvml+gBx7dq1WLt2LT744ANs374db7zxBqZNmwYAyMnJ0c3kiYioQmJ9LXp9XbhwIc6ePat+TVRR8BYEVO08+41cRkYGFApFofe9yWu9vNpq1qxZ6jnmfkv47H19cr81zF1elkJCQnDt2jV07Ngxz+Vubm64ceMGLly4UObbJiKiqoE19t/1AwMDNdqPHDmCNm3aqF9v2LABa9aswZo1a5CQkAA/Pz/Mnz8fAHD//v1SzYGIiKoW1tei1dc2bdpgzJgxmDdvHszNzWFubg4TExP1vMpiP4lKiidgiSqg8PBwZGRkwNbWVqPd1tYW2dnZuH79erlsV0Ty/FlJ7dq14eTkxKtfiYio0ivvGhsaGgrg3yt1cunp6Wlc2ZqTk4NPPvkEDRo0QPv27dGwYUOcPXsWANT/JCIiqiwqQn196aWXYGRkhLNnz0KlUkGlUmH16tUAgLt37xbpAV5E5YUnYIkqoIyMDAQGBmLw4MEa7UOHDsWZM2fyvEdrabVt2xa2trZ5XuHq4uKCmjVr8gQsERFVeuVdY0+fPo34+Hj85z//0Wh3cHDApUuXtPqrVCpcuXIFycnJ+Pjjj3Hq1Clcu3atVHMgIiJ63ipCfT158iR69uypke+++w4A4OTkpL51AZEu8B6wRM9Zjx49cPjwYTg4OOD48eP59ps/fz6OHj2K5cuX448//oCzszOcnZ3Rp08fdR8rKyuEh4djzJgx+PXXXwE8eViWs7MzAKBp06aoXbs2Bg0aBADYu3cvUlNT4ezsjBEjRsDf3x/R0dGwtbXF7NmzERkZiZ9++klrLm5ubggODtZ6oiUREVFFUhFqbGZmJubNm4fFixdDpVIhKCgIgwYNQo8ePTSeHt2lSxfY2dkhODgYtWvXxrBhw/DOO+/Azs6uPN4aIiKiEqss9TUuLg7Hjh3TmFPz5s0BACdOnEBycnKZvSdExcUTsETPmZ6eHgwMDLR+OvGsU6dOwdXVFQsWLMCECROgVCrx3//+FwcPHtQaS6H492J2S0tLbN++XWOs3NfNmzdHREQEoqKiYGlpCW9vb9SpUwdxcXHYv38/Zs2apXFDdgCoV68eHBwcMGfOnNLuOhERUbmqCDUWAFasWAGFQoFPPvkEc+fOxbVr1+Dq6oqTJ0+q18vMzMTQoUMxd+5c5OTk4MSJE+jWrRuuXLlS6veBiIioLFWm+kpUUekB0L7hIxERERERERERERGVGu8BS0RERERERERERFROeAKWiIiIiIiIiIiIqJzwBCwRERERERERERFROeEJWCIiIiIiIiIiIqJywhOwREREREREREREROWEJ2Cp0lIqlfDy8tL1NPLl7u4OEYGpqelz2+aaNWsQGhqKxMRExMfH49ixY3BwcCjSusbGxvjuu+8QERGB1NRUhIeHY8aMGerlufuTV9auXavu16lTJ/j6+iIsLAzZ2dnw9fUt8/0kIqLyxRpbsMmTJ0NEsG3btkL7FqUuNmzYEH/88Ye6BkdHR+P3339Hy5Yt8x23Q4cOyMrKQmxsbKn2hYiInh/WV22lOYb94IMPcO3aNaSlpeHq1asYPny4xvLi1NfCjoeJSstA1xMgqqr27NmDrl27IiUl5blt09jYGD4+Prh27RqMjIwwduxY7Nu3D927d8e5c+fyXU+hUGDv3r1o1KgRPDw8EBUVBRsbG9SrV0/dJ3d/ntalSxesWLEC+/btU7d169YNdnZ2OHv2LMzMzMp+J4mIqNrTRY3N1aBBA8ydOxcxMTFF6l+UumhiYoKEhATMmTMHERERaNSoEWbNmoUjR46gffv2ePTokdY6Pj4+iI2NhYEB/3eeiIjKRmU6hnVzc8O6deuwePFiHDlyBE5OTvjll1+QlJSEXbt2ASh6fS3K8TBRWRCGqYxRKpXi5eVVLmPXrFlT5/tXFlEoFBIRESErVqwosN/48eMlPj5eGjRoUKzxfXx8JCEhQYyMjNRtenp66r+DgoLE19dX5+8DwzAMU7ywxuafH3/8UX755RcJDAyUbdu2Fdq/pHWxZcuWIiLi4uKitWzEiBFy48YNWbhwocTGxur8PWEYhmGKFtbXwlPUY9iwsDD55ZdfNNq2b98u//zzT4Hr5VVfS3o8zDDFCW9BQJXe7Nmzce/ePSQmJmLjxo2oXbu2epmJiQlWrlyJsLAwJCcn49atW/Dx8dG6AkVEMHXqVCxfvhwxMTH4559/ADy5auX48eN49OgRHj16hIsXL8LV1bVI83r25xvW1tYQEQwePBhr166FSqVCVFQU5s6dCz09vTJ6NzTl5ORApVLByMiowH5jxozB77//XqyfMSoUCgwePBh+fn7IyMhQt4tIiedLREQVC2usps6dO2PIkCGYOXNmkdcpaV2Mi4sDAK0aXqtWLSxatAifffaZRv0lIqLKg/U1f0U5hjU2NsZLL72EgwcParQHBASgXbt2sLKyynfdvOprSY6HiYqLJ2CpUhs2bBh69eqFcePGYdq0aejbty9+/PFH9XITExPo6+vDw8MDTk5OmDNnDv7zn//kec+2GTNmoHHjxhg5ciQmT54MMzMz+Pv749atWxg0aBBcXV3x66+/ok6dOqWa8+LFi5GUlARXV1ds3LgRnp6ehRbE3EJobW1dpG3o6+ujbt26mDJlCl566SVs2LAh376GhoZ47bXXcOfOHWzcuBEpKSlQqVTYsGFDgbcQcHBwgKWlJbZs2VKkORERUeXCGqtt5cqVWLx4MaKjo0s1z/zo6enBwMAAVlZWWLFiBW7fvo09e/Zo9Pnqq68QGhqq/nklERFVLqyveSvOMWyNGjWgUCi0vojMfd26dWuN9oLqa0mPh4lKQueX4TJMSaJUKiUuLk5MTU3Vbf/9738lOztbbG1t81xHX19f3nrrLRERadasmbpdROTChQsafTt16iQiIrVq1SrR/Nzd3UVE1POztrYWEZGff/5Zo9/Fixdly5YtBY41cuRIyczMFCsrq0K3O3ToUMmVmJgo7777boH9GzVqJCIijx8/lp07d0qvXr1kzJgxEhcXJ7/99lu+661fv17u378vCoUi3z68BQHDMEzlDGusdkaPHi1KpXSHSnAAACAASURBVFL9E8+i3oLg6RRWF9esWaOu4Tdv3pSWLVtqLH/55ZclOTlZ2rVrJwDE09OTtyBgGIapRGF9zTvFPYYFIA8fPpQlS5ZotK1evVpERIYNG6bRXlB9LenxMMMUN7wCliq1gwcPIjk5Wf16586dUCgU6Ny5s7ptxIgR+Pvvv5GYmIisrCycOnUKAPDyyy9rjLV3716N1+Hh4UhMTMTmzZvRv39/mJubl8mcAwICNF5fvXoVL7zwQoHr/PrrrzA0NERkZGSh4x84cACvv/46+vTpg507d2Lr1q2wt7fPt3/uT0cSEhIwePBgHDp0CBs2bMCUKVMwZMgQtGjRQmsdQ0NDuLi4YNu2bcjJySl0TkREVPmwxv6rdu3a+Pbbb/H5558jLS2tTOaal2+++QadO3eGq6srYmNjERAQAEtLS/XyFStW4KeffsKVK1fKbQ5ERFS+WF+1FfcYFgDWrl2L8ePHw8XFBXXq1IGbmxtGjhwJAFrHqAXV15IcDxOVBE/AUqX27BOIU1NTkZiYiMaNGwMABg4ciF9//RVnzpzB4MGD0aVLFwwcOBAAULNmTY11Hzx4oPFapVLB0dERhoaG6vvB+Pv748UXXyzVnFUqlcbrjIwMrbmUdvwLFy7gwIEDeP/993HmzBnMmzev0PmcOnUKWVlZ6vYjR44AANq0aaO1jpOTEywsLHj7ASKiKow19l+zZs1CZGQkAgICYG5uDnNzcxgYGMDQ0BDm5uZQKMrmf6mjoqJw/vx57NixA71790adOnUwceJEAECfPn3QrVs3LFu2TD2HmjVrQk9PD+bm5oXe752IiCoG1te8xy/OMSwALFy4EHv37oWfnx8SEhLg4+ODuXPnAgDu37+v0beg+lqS42GikuAJWKrUnr4qBHhyM24zMzPcu3cPADB48GCcPXsWEydOxP79+/HXX38hISEhz7HyekjGuXPn4OTkhDp16uC9997Dyy+/jM2bN5f9jpSjixcvFvitXWpqKm7fvq11E/Xc13ld4erm5oaIiAicPn26bCdLREQVBmvsv1q1aoXOnTtDpVKpY2dnhwEDBkClUuHNN98s820mJiYiPDxcXcNbtWoFMzMz3Lx5Uz2HmTNnol69elCpVJgxY0aZz4GIiMoe62vhCjuGBZ4cxw4dOhQNGzZEu3bt0LRpU9y+fRvp6en4+++/813v2fpakuNhopIw0PUEiErD0dERpqam6p9wuLi4ICcnB+fPnwfwpJilp6drrDN8+PBibyctLQ3+/v5o164dvvzyy9JP/Dl68803oVQqC+zj7++PAQMGwNDQEJmZmQCePGQrOztb/TTNXCYmJujfvz98fHzKbc5ERKR7rLH/mj17Nry9vTXavL298ejRI3h6emrVyrJQr149tGrVCvv27QMAbN++HcHBwRp9Ro0aBRcXFwwYMKDQWk9ERBUD62vhinIMmysmJgYxMTHQ09PDRx99hO3btyMxMTHf/s/WV6B4x8NEJcUTsFSppaamYs+ePfDy8kLjxo3h5eWFnTt3IjQ0FMCT++usXr0as2bNwrlz5+Ds7AwHB4cije3s7IwxY8bgjz/+QGRkJJo2bYrx48erf4rwPI0cORIbNmyAjY1NvvfQsbOzw7Rp07Bz505ERkaiXr16cHd3R9euXfHuu++q+/Xo0QOHDx+Gg4MDjh8/DgDw8vLCiBEjsGPHDqxevRrNmjXDokWLsGHDBkRFRWls591334WpqWm+tx+oX7+++n49FhYWsLa2xqBBgwAAO3bsKPV7QUREzwdr7L9CQkK02lQqFR4+fIhjx46p2/KqsUWpi9OmTcOLL76I48ePIyYmBi+++CKmTp2K9PR0rFu3DgBw9+5d3L17V2MOPXv2RGZmpsYciIioYmN9/VdpjmH79u0La2trhIaGwtLSEuPGjYOtrS3c3d3V6xWlvgLFOx4mKimegKVKbevWrUhMTMT69etRq1Yt/Pnnn5gwYYJ6+bp169CiRQt8+umnqFmzJg4ePIj//ve/OHfuXKFj37x5EyKCb775BpaWlur758yaNas8dylPCoUCBgYGWj+LeFpUVBSys7PxzTffoEGDBoiNjUVwcDDs7Oxw9uxZdT89PT2tsSIjI9GrVy8sX74cfn5+ePz4MX7++WfMnDlTaztubm4IDQ3FpUuX8pxH27ZtsX37dvVrGxsbvP322+ptExFR5cAaW3x51dii1MVLly7B2dkZQ4cOhZmZGe7cuYOjR49i3rx5WiddiYiocmN9/VdpjmGzsrIwfvx4tGzZEmlpaThw4ABGjx6N6OhodZ+i1tfiHA8TlZQeAO2bhhARERERERERERFRqfEhXERERERERERERETlhLcgICohfX39fJdlZ2c/x5kQERFVLayxREREZY/1lUh3eAUsUQm4u7sjKysr3zx9428iIiIqOtZYIiKissf6SqRbvAcsUQnUrVsXL774Yr7LlUol4uPjn+OMiIiIqgbWWCIiorLH+kqkWzwBS0RERERERERERFROeAsCqhaUSiW8vLx0PY3nbtasWYiIiEBqaiouXLiA3r17ayw3NDTE4sWLcfz4caSkpEAk7+9jfH19ISJaadWq1fPYDSIiqiCqYz3t1asXNm/eDKVSCRGBp6enVp/XX38dGzZswI0bN5CcnIywsDB89dVXqFGjhka/Dz/8EAEBAbh//z5UKhVOnjwJR0dHrfFyt/V07t27V277SEREulfdaqxCocDnn3+O48eP4+HDh3j48CEOHDiA119/Xavv7NmzcfDgQTx69AgiAmtr6wLH7tChA7KyshAbG6u1zMjICEuWLMGDBw+QlJQEf3//QscjKgs8AUtURc2cORNfffUVVq1ahQEDBiAkJAS7d+/WKGgmJib44IMPkJKSgtOnTxc4XmhoKLp27aqR27dvl/NeEBER6VafPn3wyiuv4PDhw0hOTs6zz9ChQ2FjY4NFixbB2dkZq1atwrRp07Bp0yaNfh4eHlAqlRg/fjxcXV1x8+ZN7N+/H++++67WmJs2bdKouc7OzuWyf0RERLpgbGyMmTNnIigoCCNHjsSIESOQmZmJkydPomPHjhp9x48fDwMDAwQGBhZpbB8fnzxPvgLA999/j1GjRuGzzz6Dq6sr6tevj4MHD2p9aUpUHoRhqnqUSqV4eXnpfB5FjUKhEENDwxKvb2hoKI8ePZJ58+ZptJ8/f152796d5zoTJ04UeXIJrFZ8fX0lKChI5+8LwzAMo9tUt3oKQPT09NR/x8bGiqenp1afevXqabWNGzdORESsrKwK7Hfq1Ck5cuRIpX6fGYZhmNKnsv23v7Q1VqFQSJ06dTTaDA0NRalUyoYNGzTac2tx3759RUTE2to633FHjBghN27ckIULF0psbKzGsqZNm0pmZqaMHDlS3dakSRNJT0+XsWPH6vw9Zap2eAUsVVt2dnY4evQokpOT8fDhQ/zwww+oVauWerm7uztEBO3atUNAQACSkpIQGhoKFxeXIm/D3t4eIgJHR0fs3r0bSUlJiIiIwPjx4zX6+fr6IigoCAMGDMCVK1eQlpaGLl26lHjfbGxsULt2bRw8eFCjPSAgAI6OjjA0NCzx2ERERE+ryvUUQL6353laXFycVtvFixcBAE2aNCm039N9iIiIclXlGpuTkwOVSqXRlpmZiZCQEK26WJRaDAC1atXCokWL8NlnnyEjI0Nree4t+fz8/NRt0dHROHnyJJycnIq7C0TFwhOwVC299dZbOHToEO7fvw9XV1dMmTIFzs7O8PX11eq7efNm/Pnnn3BxccGNGzewdetWNG3atFjbW79+PS5fvoz33nsPe/fuxdq1a9G3b1+NPs2bN8fixYvx7bffwsnJCUqlMs+xcgukvb19vturWbMmAGgVnYyMDNSoUQMtWrQo1vwBoE2bNnj06BHS0tJw4sQJ9OjRo9hjEBFR1VLV62lpvPnmm8jOzkZ4eHih/a5fv67VPnbsWKSnp0OlUmHbtm2wsrIql3kSEVHFVB1rrJGRETp27JhnXSyKr776CqGhodi1a1eey21tbXHnzh2tWwqFhobC1ta2RNskKioDXU+ASBe+++47nD59Gm5ubuq2u3fv4siRI2jbti1CQkLU7cuXL1cXuQsXLuDBgwfo168f1q1bV+Tt7du3Dx4eHgCeXIVqY2OD2bNnY8+ePeo+9evXR69evXDp0qUCxxIRZGVlFfgt4K1bt5CTk4POnTvj3Llz6vY33ngDAFC3bt0izx14cnXOuXPncPXqVTRo0ADTp0/HwYMHYWdnh6CgoGKNRUREVUdVr6cl1bBhQ8yePRu//vprvvegA4DRo0ejY8eOmD59ukb7rl27cPbsWdy5cwetW7eGp6cnTpw4gfbt2+Px48dlPl8iIqp4qmON9fDwQN26deHj41Os9QDg5ZdfxsSJEwu8KtfCwkLrqlsASEhIgIWFRbG3SVQcPAFL1Y6xsTHefPNNfPLJJ9DX11e3nzx5EhkZGejUqZNGMQsICFD/HR8fj5iYGLzwwgvF2ubOnTs1Xvv5+eH777+HQqFATk4OAODOnTuFFjIAOH78eKG3EHj8+DG2bNkCDw8PXLlyBZcuXcLw4cPRq1cvAFBvs6i+//57jdd79+5FSEgIZs2aVayftxARUdVRHeppSRgaGuL3339HUlISpk6dmm+/jh07YuXKlfD29sbRo0c1lk2ZMkX998mTJ3H69GkEBwdj9OjRWLFiRZnPmYiIKpbqWGOdnZ3h4eGB6dOnl+gK2BUrVuCnn37ClStXir0u0fPAWxBQtWNhYQEDAwOsWbMGWVlZ6mRkZMDIyAjNmjXT6P/sN2QZGRnqn/gXVUxMjNZrQ0ND1K9fX9324MGDYu5JwaZMmYKrV68iMDAQ8fHxmDFjBhYsWAAAuH//fqnGTk1Nxd69e7WeTklERNVHdamnxfXLL7+gbdu2cHZ2zvMqGwB48cUXsWfPHhw+fFjr6te8hISE4Nq1a6y7RETVRHWrsa+//jp+++03rF27tkRfNPbp0wfdunXDsmXLYG5uDnNzc9SsWRN6enowNzeHkZERgCdXupqbm2utb2FhgYSEhFLvB1FBeAUsVTsqlQo5OTmYO3cu9u7dq7U8Ojq6zLdpaWmp9TozMxMPHz5Ut5X1TyAfPnwIBwcHNG3aFObm5rh27RqmTJmCe/fuISIiotTji0i5/GyTiIgqh+pST4vD29sbAwYMgKOjI65du5ZnnwYNGuDAgQOIiIiAm5tbkX+VwrpLRFR9VKca+9JLL6m/lJw8eXKJxmjVqhXMzMxw8+ZNrWUqlQqzZ8/GwoULERYWhmbNmsHExAQpKSnqPra2tggLCyvxPhAVBU/AUrWTkpKCs2fPolWrVpg/f/5z2aaLiwv279+v8frChQvFvhVASdy9exd3795FjRo1MGbMGGzYsKHUY9asWRN9+/bFhQsXymCGRERUGVW3elqYmTNnYtKkSRgyZAhOnTqVZx9TU1P1gXS/fv2QmppapLHbtm0LW1tb/PDDD2U2XyIiqriqS41t1KgRDhw4gPDwcAwbNqzE29q+fTuCg4M12kaNGgUXFxcMGDBA/bCw3Fs1uLi4YNOmTQCAxo0bo3v37vj4449LsSdEheMJWKqWPv/8cxw+fBg5OTnYvn07EhMTYWVlhb59+8LDwwM3btwo0+05OTlhwYIFOHbsGN577z307t0b/fv3L9FYPXr0wOHDh+Hg4IDjx4/n22/EiBEwNDTErVu3YGVlhalTpyI7OxvffvutRr8+ffrA1NQUHTp0AAAMGjQIABAUFITIyEjUrl0b/v7+2LhxI27evIn69etj6tSpaNKkCQYPHlyifSAioqqhOtRTKysrdO7cGcCTpzO3adMGgwYNQnJysvpAddiwYfj222/h6+uLu3fvajwAJDw8XH31kJ+fH1555RWMGjUKNjY2sLGxUffLfWims7MzRowYAX9/f0RHR8PW1hazZ89GZGQkfvrppxLtKxERVT5VvcbWrFkT+/btg4WFBSZNmoRXXnlFvSw9PV3jhGqPHj3QoEEDdOrUST3X2NhYXL16FaGhoeqLjp7Ws2dPZGZm4tixY+q2u3fvYv369fD29oaenh5iY2Mxd+5cREREYOPGjSXaV6LiEIap6lEqleLl5aXR9sYbb8i+ffvk0aNHkpSUJCEhIbJ06VKpXbu2ABB3d3cRETE1NS10rPxib28vIiK9e/eWvXv3SnJyskRFRcmECRM0+vn6+kpQUFCxxrS3ty+w3/vvvy9hYWGSmpoq9+/fl7Vr10rdunXzfG/y4u7uLgCkRo0asmPHDomMjJS0tDRRqVSyb98+6dKli84/V4ZhGOb5pjrW09z5P0upVGpsNz+59RRAvn3kyW86BYC0b99eDh06JDExMZKRkSH37t0TX19fady4sc4/f4ZhGKb8Ut1qrLW1db418ekaC0ACAwPz7Ofp6Znv+J6enhIbG6vVbmRkJEuXLpWYmBhJSkqSPXv2SPPmzXX++TNVP3r//wcRlQN7e3scPXoU7dq103hKJRERERUd6ykREVH5YI0lej4Uup4AERERERERERERUVXFe8ASlYK+vn6+yyrCA0GIiIgqA9ZTIiKi8sEaS1Qx8ApYohKyt7dHVlZWvvnqq69w7Ngx6Onp8accRERE+WA9JSIiKh+ssUQVB+8BS1RCtWrVQqtWrfJdHh0djXv37j3HGREREVU+rKdERETlgzWWqOLgCVgiIiIiIiIiIiKicsJbEBARERERERERERGVE509hCsmJgYRERG62jyRlgYNGsDa2hrnz58v9rqNGzdGgwYNYGhoiLi4ONy+fbtUc6lVqxZeeOEFmJiYIDMzEw8ePEBMTEyR1q1fvz4aNmyIGjVqIDs7G4mJibh165Z6eatWrWBmZqa13oULFyDy5IJ4MzOzPH+qcu/ePdy9e7eEe0XVQauWxgCAazdTSz2WtbU1LC0tSz1OdcQaSxVJVamvAKBQKNCuXTsYGRnhypUrSEtL01jWtGlT1KlTBwYGBsjIyEBsbKzW+E/PISsrC3FxcaytVCSsseVDqVQiMTER2dnZyMrKQufOnQvszxpLFUllr7FmZmZo0KABTE1N1bUzJiYGsbGxGv309PTQqFEj1KtXD0ZGRsjIyEB8fDzu3bunPoYFnjxwrFmzZqhTpw4A4NGjR4iMjER2dnap9o2qtudZX0UXCQoK0sl2GSa/TJw4UeTJf72LlU6dOomIyMyZM6Vr167SokWLUs3DxsZGEhMTZcuWLfL222/LF198IZmZmTJ27NhC150/f74kJCTI9OnTpUePHjJ48GDx8fHR6BMYGCiHDx+WLl26aOTpPvb29iIiMmzYMI0+L7zwgs4/J6Zi59V2pvJqO9MyGYt1gu8dUzVSFeprbhYuXCj37t0TEZG2bdtqLNuxY4fExsbKuHHj5O2335Z58+ZJdna2TJkyRd2nefPmkpKSIjt37pQ+ffrIpEmTJDExUZYvX67zz4mp+GGNLZ8olUqpV68e3zumUqay19jffvtNdu/eLSNGjBB7e3vx8PCQtLQ0WbJkiUa/pUuXSnJyskydOlV69uwp06ZNk5SUFPH29tbot3//frl165a89957MnDgQLl27ZocP35c558TU7HzHOurbnaQhYupaClp8Ro+fLiIiJiZmZXJPNauXSvXrl0TfX19dduqVaskMjKywPXatGkjWVlZ0qtXrwL7BQYGyrZt2wrsk3sC9tmDS4Z5nmGd4HvHVI1U9vqam9yDy/Hjx2vVSGNjY8nKypJJkyZprLNjxw45e/asxhzCw8M15jBp0iTJyMiQRo0a6fyzYqpPWCf+DU/AMpU5lb3G5vXv3sKFCyUlJUWMjIzUbffu3cvzpOz9+/fVr7t27SoiIt27d1e3de7cWUREHBwcdP5ZMdUjBdUI3gOWqiUjIyOsXLkSCQkJiIuLw7Jly2BoaKjRx97eHiICR0dH7N69G0lJSYiIiMD48ePVfXx9fbFx40YAwOPHjyEisLe3L9XcnJyc4Ofnp/Ezia1bt6JZs2Zo165dvuu5u7vj5s2bOHToUKm2T1QaDj3M4dDDXNfTICIdqYr1NZe3tzd+/PFHhIWFaS3T19eHvr4+Hj16pNGuUqmgp6enft2hQwccPXpUYw4BAQEwNDRE7969S7JbVI2wxpYPEUFAQADOnz+PcePG6Xo6RPmqijU2Li5Oq+3ixYswNjZG3bp11W2GhoaF1lgnJyfcv38fJ06cULcFBQXh1q1bcHJyKtF+UfXwPOtrhTsrzDDlnWXLlklqaqpMmzZN+vTpIzt27JCoqCiNbw9zrwKNjIyUhQsXSu/evWXNmjUiItK3b18BIC1atJB58+aJiEjPnj2lS5cu+X6LaG1tLSIi7u7u+c7LxMQkzz7169cXERFXV9d81z169Khs375dPD09JTY2VtLS0uTgwYNia2ur0S8wMFAePXokycnJkpycLPv375f27dtr9Mnd9wcPHkhWVpYolUrx8PAQhUKh88+OqdgJ/KOdBP7RrkzGYp3ge8dUvlTF+gpAnJ2dJTY2VurUqZPvr0S2bt0q//zzj7z66qtSq1Yt6du3ryQmJsr777+v7hMcHCxr1qzRWK958+YiIvLtt9/q/PNjKnZYY8snTZo0EQDSoEEDCQ4O1rh6Ljfjxo2ToKAgCQoKEqVSqfM5M9UzVbXGPpulS5dKfHy8xrHnd999J3fu3JG33npLTE1Nxc7OTqKjo2XOnDnqPr/99psEBgZqjefv7y/+/v46//yYipvnWF91s4Ms+oyuUrduXUlJSZHPP/9c3aanpyehoaF5Fq9169ZprB8QECBnzpxRv3Z3dxcREVPTgu8ZYmVlJZmZmTJy5Mh8+zRp0kRERAYMGKDRrq+vLyIi48aNy3fdsLAwefz4sYSEhMjAgQOlX79+EhwcLLdv35YaNWqo+82dO1dGjRoldnZ2Mnz4cLl69aqoVCqxtrZW9+nQoYN888034uTkJA4ODrJ8+XLJysrSuscOwzwbHhxWjPC9Y3SRqlpfDQ0N5fr16zJhwgSN+T97AtbIyEi2bdsmubKzszXeCwCyfft2rX8/hwwZkuf7wTDPhjW2/OPp6SnTp0/ne8dUuFTVGvtsWrduLSkpKeLp6am1bMWKFfK0Z591EhAQIDt37tRa79dff5VTp07p/DNkKm6eV301AFE10759exgbG2PXrl3qNhHBrl27YGtrq9V/586dGq/9/Pzw/fffQ6FQICcnp8jbjYyM1PqJSFnS09ODqakpBg0apP55ZEhICK5fv47hw4djw4YNAIC5c+eq1zl58iQOHTqEsLAwTJkyBVOnTgUABAcHIzg4WN3v8OHDSE9Px7Rp0zB//vw8fypCRETVW1Wtr9OmTUNaWhrWrVtXYL/ly5ejS5cuGDVqFG7dugU7OzvMnTsXDx8+VNfgtWvX4uDBg5g9ezbWrFmDli1b4rvvvkNWVlax9pmIyoaJiQkUCgWSkpJgYmKC3r17Y968ebqeFpGWqlpjn1anTh3s2LEDly9fxjfffKOxbMaMGRgxYgQmTZqEy5cv49VXX1Ufl3p6ej6X+RGVFk/AUrXTqFEjAEBMTIxG+7Ov82uPiYmBoaEh6tevn+86JaVSqQAA5uaa9x+xsLAAACQkJOS7bkJCAh48eKBxbzqlUonbt2+jTZs2+a734MEDnDp1Ch07dixwbtu3b8cXX3yBV155BYGBgYXuCxERVS9Vsb7Wr18fHh4eGDVqFMzMzAAAtWrVAgCYmZnBxMQEKSkpaN++PT7++GM4Ojqq78V+4sQJmJmZYcmSJfD19YWI4NChQ/Dw8MCcOXMwf/58ZGRkYN68eZg8eTLu379fpvtMRIVr2LCh+kSVgYEBNm/ejAMHDuh4VkTaqmKNfVqNGjWwa9cu1KhRA/3790dmZqZ6Wb169bBgwQJMnDgRP/74I4AnNTYjIwM+Pj7w8fFBbGwsEhIS0KBBA62xLSwsijQHovLGE7BU7eQe4FhaWmr8h9jS0jLP/s+2W1paIjMzEw8fPizzuaWkpCAyMlLrW8zc13k9+CNXaGgorK2ttdr19PQK/ZZTRPDklysF93n6n0RERE+rivW1adOmMDMzw44dO7SWnTlzBocOHYKjo6N6nKd/PQI8eZCIhYUF6tWrp96vb775BitWrMCLL76IO3fuQF9fHwsWLMDZs2dLvZ9EVDxKpRIdOnTQ9TSIClUVa2wuhUKBzZs3o02bNujWrZvWCeIWLVrAyMgozxpraGgIa2trxMbGIiwsDN27d9ca39bWFn/88UdJdo2oTCl0PQGi5+2ff/5BamoqBgwYoG7T09PTeP00FxcXrdcXLlwot58K7tu3Dy4uLlAo/v3Xc+jQoYiMjMSVK1fyXc/f3x+NGjVC69at1W0tWrSAtbU1Ll26lO96DRs2hJ2dHS5cuFDgvFxdXZGZmYnLly8XY2+ouhk/PRzjp4frehpEpANVsb7evHkTPXv21MiUKVMAAKNHj8b06dMBABEREQCg9WuSTp06ISkpSeuANzk5GVeuXIFKpcLEiRNx+/Zt9ZWzRPlhjSWqvqpijc21evVq9OnTB/3798f169e1lhdUYwHg9u3b6jk0btwY3bp10+hjY2ODffv2lWi/qHp4nvVVJze55c3LGV3G29tb/QTJd955R7Zv317gEyQXLFggjo6O6idIvvvuu+p+ZXkDcwBiY2MjiYmJsmnTJunZs6fMmDFDMjIyZOzYsRr9MjMzNZ76qFAo5Pz58xIaGiqDBg2SgQMHyuXLlyUkJEQMDAwEgLRv3178/f3F3d1devbsKe+//76EhoZKXFycNGvWTD3W6tWr5euvv5Z+/fpJ7969xdvbW7KysmTJkiU6/+yY6hPWCb53TOVLVayvzyavh3ApFAr566+/5M6dOzJmzBh5++23Zc6cOZKWliaLzisM7AAAIABJREFUFi3SmMOcOXPknXfekb59+8qaNWskPT1devXqpfPPjqleYZ3ge8dUvlTFGvvll1+KiMjChQulS5cuGjEzM1P38/Pzk4SEBJk8ebL07NlTpkyZIiqVSn777TeN8ffv3y/h4eHi4uIiAwYMkLCwMDl+/LjOPzum+qSQGlEhJ8Uw5RojIyNZtWqVqFQqiY+Pl++//16mTp2aZ/Hq3bu37N27V5KTkyUqKkr9FOTcFLV4WVtbi4iIu7t7ofPr1q2bnDt3TlJTU0WpVMonn3yi1UdEtJ4OaWlpKZs3bxaVSiWPHz8WPz8/jROrTZo0kT179kh0dLSkp6fLw4cPZfv27dKqVSuNcT755BO5dOmSPH78WNLS0uTKlSvy6aef6vxzYyp++vW2kH69LcpkLNYJvndM5UtVra9PJ68TsACkYcOG8r///U9u374tycnJcvXqVZk5c6YYGhqq+zRr1kyOHTsmKpVKkpKSJDAwUOzs7HT+uTGVI6yxFSN87xhdpSrW2MDAQMmPvb29up+ZmZl4eXnJzZs3JSUlRW7cuCGLFi2SWrVqaYxvbm4uGzZskISEBHn06JFs2rRJ6tWrp/PPjqnYeY71VTc7yMLFVPTkd4DFMEz+CfyjnQT+0a5MxmKd4HvHVM2wvjJMycIaWzHC946pyGGNZZji53nVV94DloiIiIiIiIiIiKic8AQsERERERERERERUTkx0PUEiCqqY8eOQU9PT9fTqBbWfQ0kPAZmLtX1TIiIqLyxvlJ11Ost4MZtICJa1zMhoqqMNfb5GuoM7DkKJKXoeiZUGfAKWCLSqUYNgA+HADPGAq1tdD0bIiIiorJ3cD1w+7CuZ0FERGXl5ebA1qXAL4t0PROqLHgClqiC6N+/Py5fvozU1FSEhIRgyJAhha5jY2ODtWvX4tKlS8jKykJgYGCe/SZMmAB/f388fPgQIgJ7e/s8++nr6+OLL77A9evXkZaWhqioKCxbtqxU+1UYM9Mn/1ToAe++Xa6boudg5MfXMfLj67qeBhGRWnnV10aNGmHx4sUIDg5GYmIiIiMj8dNPP6Fx48Ya/RwcHLB161bcvn0bycnJ+OeffzBx4kQoFPzfcMpb5/bAO3ba7ayxRFTR6LrGAkCTJk3+j70zD4/x+uL4dyZ7gojEEpFFCLHHErEmliKhpGoLFVFrVX+UohSVtvZSlGqrJWqrImhriS0poUGoJUjEkoQIWSeRfb2/P95Z8mYmySSZJcv5PM957vvefV4xZ+55zz0Xx48fx9u3b5GYmIjt27fDyMhIJZ+vLJg47dJW7UMRakZT+pV++RFENaBv377w9/dHUFAQPDw8cPr0afz+++8YMmRIme06dOiA4cOH4/Hjx4iMLP0LY8qUKWjUqBHOnTtXZn979+7FvHnzsGnTJgwdOhRLly5FdnZ2pT6TstQ35tIkEdDRQa1DERogNi4PsXF52p4GQRAEAPXq1+7du2P06NH4/fffMXLkSCxevBguLi74999/YWJiIq03a9YsmJiYYMWKFRg+fDgOHz6MzZs3Y+PGjSr9rETNx6Y5sPwj4OYRIOAXoG1LfjnpWIIgqhPVQcfq6uri3LlzsLW1hZeXF+bPn49x48Zh165dKv2sihCKIz2YNVD7UISa0aR+ZdqQ0NBQrYxLQqJqEQqFTE9Pr0p9BAQEsEuXLvHyTp8+zYKDg8tsJxAIpNdHjx5lQUFBZdbr0KEDY4wxNzc3uTrDhg1jeXl5rF27dhp9fq7OYCwc7PofYP/5a//fk6RqMv49Czb+PQuV9EV6gp4dSd2W6q5fTU1NmY6ODi/PwcGBMcbYlClTpHnm5uZybdesWcOysrKYvr6+1p8ziWaEhXNSVp0/vpPVY+FgU0fzy0nHVg+hZ0dSG6S26FgvLy9WUFDA7OzspHnjxo1jhYWFrHXr1mp9hh0dlPtuJ6n+oin9Sh6wRJ3G19cXjx8/lt4bGxsjLy8Pt2/fluaZm5ujsLAQ77zzDgDAz88PoaGh8PT0xIMHD5CTkwMXF5dKz0FfXx8DBw7EkSNHePmHDx9G79690aBB6a/UGGNKjaFMvWnTpiEwMBDh4eFK9akqJCEIIqO5GLA6OhodnlAxc6Y2w5ypzbQ9DYIgtExd0K9paWkoLCzk5T158gSZmZlo3ry5NC85OVmu7Z07d2BkZIRGjRqVOw5Ru2hqXnrZ60T+vUtn2fVAF2D/1mb4ZDrpWIKo65COlelYDw8PhIaGIjo6Wpp38uRJ5OXlwd3dXclPUzn+/lGt3RMaRFNrWDLAEnWa4OBgtGnTBk2aNAEA9OnTBwUFBejSpQvq168PAOjfvz+KiooQEhIibWdnZ4eNGzdi3bp18PDwQFRUlML+3dzcyoy5CnAxcPT19REREcHLDw8Ph46ODtq0aVPVj6kULi4uiIyMxPbt25GWlobMzEz4+/srjLOjSiQhCB5EAoYGQCtrtQ5HEARBaIC6ql87deoEExOTMsMCAUDv3r0hEomQkJCg8jkQ1ZuVH5delprOv+/VRXa9fDagrw+Y1lPPvAiCqDmQjpXpWEdHR7k55Ofn49mzZ3B0dFT5HIpTwj5MEOVCBliiThMSEoL8/Hz0798fAKeozpw5g/j4ePTp00ead+fOHWRmZkrbWVhYYPz48Th48CAuXbqEV69eKeyfMYaCgoIy3/KZmZkBAFJTU3n5IpGIV65umjVrhqlTp8LJyQleXl748MMP0b17d5w4cUKt40o8YO+K9eYnH6h1OIIgCEID1EX9KhAIsG3bNkRGRuKvv/4qtV67du0wZ84cbNu2DUVFRSqdA1F9SU0DsrIBN+fS6xgZ8u+d2gG/b+auo8T/FQwN1DM/giBqDqRjZTrWzMxMbg6Seah7HW1sBIRFAm8z1DoMUYsgAyxRp8nKysJ///0nVV6urq64cuUKgoODeXnBwcG8drGxsbh37165/V+5cgV6enq4cuWK6ievYgQCAQQCATw9PXH27FkcOXIE3t7ecHFxwaBBg9Q2rsQAe/0ekJIK9OmqtqEIgiAIDVEX9eu6devQu3dveHt7o6CgQGGdhg0bwt/fH/fv38fatWs1PENCmxQxIPQBd+Cog53iOob6gCgNmL8W8P6cy3unN5dGxYrrkAGWIOo8pGMV61hNY9EQSE4FGtSj72ZCOcgAS9R5JIpKT08PLi4uCA4OlubVq1cPTk5OcsorPj5eZeNL3hKampry8iVv7CTl6kYkEiEsLAwpKSnSvKtXryI3Nxft27dX27gSA2x6JrB5L9C9A2ChGadfgiAIQo3UJf06Z84cLF68GD4+Prh586bCOgYGBvjzzz9hYGCAUaNGIT8/X2XjEzWDZy+4dNIIxeVGhkB2LvD9fuDAX8DG3UA9caimzGwupUU+QRAA6dji8yg5B8k81LmOblAP0NMD4pO4+yZlxPcmCAlkgCXqPMHBwejSpQsGDx6MvLw83L17F8HBwejZsycGDhwIXV1dXL16lddG2cOvlOHZs2fIy8uTi1Hj6OiIwsLCcuPIqYrw8HAIBAK5fIFAoPItkl0cgaNbAX09zgCbkQkwBpwTP2aJtwdR8xg7LQJjp0WUX5EgiFpPXdGv77//PrZv344lS5bIHUYiQSgU4tChQ2jfvj08PDwo9msdJSMLOH8NmOChuNzQAMjJld2/SeTyTOsDQgGAtxEYPpF0LEEQpGMlREREyM1BT08P9vb2crFhVYnEYeiV+PBEx5ZqG4rQAJpaw5ZrgDUwMMCNGzdw9+5dPHjwAL6+vnJ19PX1cfjwYTx58gTXr1+Hra2tOuZKEGohODgYAoEAS5cuxbVr18AYQ1hYGLKzs/HZZ58hPDwcSUlJahs/Ly8PQUFBGDduHC9/woQJCAkJwdu3b9U2dnFOnTqFTp06wdxc9vrO1dUV+vr6Sm1VqQhrFwBjhwHv9OEMsOlZXP6dcG6xsWwWYGKs0iEJDZGcUoDklOqxLYggCO1SF/Srm5sbDh48iO3bt2Pz5s2l1tu5cyfc3d0xatQojb1YJaon/z3iDhwVKliFGepzHrAS3oj/ezSzENdnBYh4RjqWIAjSsRLOnj0LZ2dn2NjYSPNGjRoFAwMDBAQEVHkOijAyBCwbc9dPo7l09Xy1DEVoCE2tYcs1wObm5mLQoEFwcnKCk5MT3N3d4eLiwqszffp0iEQiODg4YMuWLdiwYYPaJkwQqkYkEuHRo0dwc3OTxrlhjOHatWtwc3OT27pREVxdXZGfnw9XV9cy633zzTcYMGAAtmzZAjc3N2zYsAHDhw/H119/La1jY2OD/Px8eHt7S/OMjIwwZswYjBkzBlZWVmjcuLH03sjISFqve/fuGDNmDIYMGQKAU2ZjxoxB9+7dpXV27dqF5ORk/P3333j33XcxceJE7N+/HxcuXMC1a9cq/QwUcf8xlzp3FBtgxbHhi4qAaSuAzm2B8e4qHZLQED5eTeDj1UTb0yAIohpQ2/Wro6MjTp48iYiICPzxxx9wcXGRir29vbSvZcuWYfbs2di6dSuKiop49SSnVRN1h2cvAX19oEUz+TIjwxIesCUNsAZNMGkM6ViCIEjHSjh27BgiIiJw/PhxeHh4wMvLCzt27MChQ4fw9OnTSj+Dssi6A1w9yF3feghcDAEc7RW/WCNqBppcwzJlxcjIiN2+fZv17NmTlx8QEMB69erFADAdHR2WmJhYbl+hoaFKj0tCom7ZuXMnY4yx3r17S/OWLFnCGGPM29ubV9fPz0/pv183NzfGGGNubm7l1vX09GRhYWEsJyeHhYeHswkTJvDKbW1tGWOM+fj4yOUpwtbWljdnRfj5+fHGaNWqFTt9+jTLyMhgKSkpzM/PjzVs2FDlz3vuJDAWDvb3j5zcOiYrEwjA0m+BbV2m/b8LkopL0MmOLOhkR5X0RXqCnh1JzZfarF99fHxKrVNcvwYFBZVaT5n5k9QOSQ4B2/YF2EAX7jfQQBf5Ohf2gF09KLtv14qrO2E42OczwFhcR3b5T9Kx2hZ6diTVRUjHcmJlZcVOnDjB0tPTWVJSEtuxYwczMjJS23Nn4TKxswKbPIq77uig/b8JksqJBtew5XcgFArZnTt3WHp6Olu/fr1ceVhYGLOyspLeP336lJmbm1dlUiQkJLVYPp4kU1ohh8GCfuOXx10Bi7+q/XmSVFzIAFs9hJ4dCQkJSfUSiQHWpjn3+2fGOH65QAB2/0+wi36yPDNTru78KWDLZnEG2H/IAKt1oWdHQlK3pbgBtp4xWCsbxd/rJDVHNLWGVcpJuqioCF27dkWLFi3Qs2dPdOjQQZlmcsycOROhoaEIDQ2FhYVFpfogCKJ20auLLASBhNg3FAOWIAiCIIjawXgPoFFD7jr2DZCXB9i34NeZNxno1AYwayDLE6VxdZua09ZWgiCI6khGFvDsBZAkAlZ9rO3ZENWdCqnytLQ0BAUFwd2dH5zx1atXsLa2BgDo6OjA1NQUycnJcu1/+eUXODs7w9nZWa0BoQmCqFmUNMD6nwdMjIB6JYywH74PfD1Pc/MiCIIgCIKoKn98J7suKgKi47iDuIpj0YhLV//Iz3+TVCwGLAAVHmJOEARBqIh7EVxsbwszbc+EqM6Ua4C1sLCAqakpAMDQ0BBDhgxBREQEr85ff/0FHx8fAMDYsWMRGBiohqkSBFHbuPOIS0saYJ++4NLWtvz8PWuAlXMAgUD9cyMIgiAIglAH0a84r1gHO1lefj6XnrjIr/smiTttW0i/fQiCILSOvp7i/O9+41IHW8XlBAEoYYC1tLREUFAQ7t27h9DQUFy4cAGnT5/GV199hZEjRwIAdu/eDXNzczx58gQLFy7E0qVL1T5xgiBqPvcjuTQrh5//JIZLW9sobtfGTm1TIqrI8ImPMHziI21PgyAIgiC0gnlDoJX494tVU8D3E1lZY7GX6+EzXNqhtaystBADcQnAQBdu0V8kIh1LEAShTSaPkl1HPJddR0ZzKRlgayaaWsOWa4ANCwtDt27d0KVLF3Tq1AnffPMNAGDVqlX4+++/AQC5ubkYP348HBwc4OLigqioKPXOmiBqCfr6+ti0aRPi4+ORkZGBU6dOwdZWuW/tGTNmIDIyEtnZ2bh16xYGDRokV6d58+Y4fvw43r59i8TERGzfvh1GRka8OvXr18eWLVsQFRWFzMxMPHr0CPPnz1fJ5yuPh0+5tFmJkNDPXnJpSQNsVCyX9uys3nkRlSc7uwjZ2UXangZBEIRadayrqysCAwMRHx+PnJwcPHv2DJs2bUL9+vUr3BdRu3jwF/D0HHf9ky+waq6srKk5l56/xqXFt6rq6ACFhfL9+V8ADPS5MExFRaRjCYLQPurUr4MHD8bhw4cRHR2NzMxMhIWFYe7cuRCWeEv1zjvv4NChQ4iKigJjDKtWrVLZ5ysL03qya5cJsuvoV0BBATkK1VQ0tYalcO4EoUW+//57TJ06FYsWLcLYsWNhYWGBCxcuwMDAoMx2Xl5e+Omnn7Bv3z54eHjg4cOHOHXqFO+APF1dXZw7dw62trbw8vLC/PnzMW7cOOzatYvX1969ezF58mSsXbsW7777Lo4dO4bvvvsOn376qVo+c3EkoQZ0SnwTZWZxHh8l3yA+Fr/bWb+QW6gQ1Y85HzbDnA+baXsaBEEQatWxjRo1wp07dzB37lwMGzYMmzdvho+PDw4dOlThvojaRbPGXCoQANkldvhIPGCTU7nU3FRWJhQoNsAe+AsIDePCEMCQdCxBENpHnfp11qxZMDExwYoVKzB8+HAcPnwYmzdvxsaNG3l9ubu7o3Pnzrh06RIyMzNLDqU2cvNl128zZNcFBcDzWPKAralocg3LtCGhoaFaGZeERFViaGhYpfZWVlYsPz+feXt7S/OaN2/OcnNz2fTp08tsGxERwXbv3i29FwgE7P79+2z//v3SPC8vL1ZQUMDs7OykeePGjWOFhYWsdevWDAAzMjJiBQUF7JNPPuH17+/vz65fv662Z/fxJDAWDmbZGOzARrDObeXrXN7PSfG8Mz9z7Vg42PKPwIwMtf93QMKXoJMdWdDJjirpi/QEPTuSuivVXccqkhkzZjDGGDMzM6tyXyQ1VyS/Uywbg21dJrtn4WBxV2T1Mm6DfbtYdr9uIVj2XcV9bv6ca18YSzq2Ogg9O5KaLNVdv5qbm8u1W7NmDcvKymL6+vq8tpLrxMREtmrVKo08v4VTue/jwb3ly079BHbnuPb/jUkqLppaw5IHLEGIGTlyJG7duoWMjAykpKTg+vXrcHV1lZYzxrBgwQJs2bIFCQkJCAsLq9J4Q4cOBQAcP35cmhcXF4erV6/Cw8Oj1HYtW7ZE27ZtceTIEd7cjh49ymvn4eGB0NBQREdHS/NOnjyJvLw8uLu7AwB0dHSgo6ODtLQ03hipqakQaOCkq/wCYMoyHXj+8Cf+d4DvmfskBnDtATRvIssTCmXeJKvnA8e/V/sUCYIgCBVQ23SsIpKTkwFwWzOr2hdR87G3Bl4l8PMsGsquk1O5eLESdIRAUSm7H18ncmlpcWIJgqi71Db9KtGlxblz5w6MjIzQqFEjXlttYCh28r1yS76siAFO7YB2rTQ7J6LmQGqcIADY29vj2LFjCAwMxMiRI/HBBx/g1KlTvC95AFi8eDEsLS3h7e2NefPmldqfn59fubGQHR0dERsbK7dlIjw8HI6OjmW2A4CIiAi5dubm5rCwsJDWK1knPz8fz549k/aRkZGBP/74A0uWLEGXLl1Qr149jBgxAuPHj8cPP/xQ5vxVhUlDUzRs2gRWjm15+X5inf7JB7I8gQB48Vp2796fv3ghCIIgqh+1UcdKEAqF0NfXR5cuXbBixQr4+/sjPj6+Un0RtYN08Z9cK2v+9lQA0Ct2enZSKj8GrFAIFJZigI1LUJxPEETdpjbr1+L07t0bIpEICQna/zI0MuTCxeTny5f9HcilxQ9YJIji6Gp7AgRRHejatSvS09OxZMkSad7Zs2fl6r1+/RpeXl7l9ldYWIiCgoIy65iZmSE1NVUuXyQSwczMTEELWTsAcm1FIpG0PCkpSen+p0yZgoMHD+Lu3bsAuAMeli1bhn379pU5/6rgVEw36+hyX0P5OfxAadf+A/zPA8tmAfceA3+c4RYnSSLAzoo7kAIAft8MDJ2utqkSBEEQVaQ26lgJDx8+lC4qAwIC4O3tXem+iNpBcipQ34TzgJV4rv5yFJg5Dgi8zq9X/CWyUAkPWIIgiOLUZv0qoV27dpgzZw42bNiAotK+JDWIoT6Qk6u47K8gYBdkBy4SREnIA5YgAISFhcHU1BR79+7FkCFDYGxsrLDemTNnlOpvxowZcHBwUOUU1caWLVvg4uKCqVOnwtXVFStWrICvry+mTZumkv7dnIG/dnLeqwC32Jg5TlYu1OMMsLriLZvFWf0Tl66cw6UCAIwBb4otRCjQOUEQRPWmNuvYMWPGoE+fPpg9ezY6deqEo0ePantKhJYR/6yBvbUsb+X3QNN+wIiPZHnJJTxglQlBQBAEUZzarF8BoGHDhvD398f9+/exdu1abU8HAOcBm12KATY+CUhL50IQmNaXL2/ZgnMuIuouZIAlCACRkZHw9PSEvb09zpw5g6SkJBw8eFBuK4RkW6EqEIlEMDU1lcs3MzOTvgksrR0AubaSt4qScmX679SpEz7++GNMmzYNv/32G4KDg7Fu3Tps3boVmzZtUkkc2D++A0YOFJ/eCy42jgQDfZkHrJ6BvAH2bjiwYhu3jcO0PmfELWJAvDg00JMYoEVTQEcHcHUGurWv8nSJKjLwvQcY+N4DbU+jxmBgYIAbN27g7t27ePDgAXx9feXq6Ovr4/Dhw3jy5AmuX78OW1t660DULGqjjpXw6NEjhISEYNeuXZg4cSJGjBiBgQMHVqovonZgYsSl9i34+QnJfK+pJJG8B2y5IQjSSMcSBCGjNutXAwMD/PnnnzAwMMCoUaOQr2jPvxYwNCjdAxYAIp4DcycBqTeB9iVCEZzcAaxdQCEKqiOaWsOSAZYgxJw5cwaurq4wNzfH9OnT8c4772D79u28OqoM9h0REQFra2u5N5WKYreWbCepV7JdcnKydOtGRESEXB09PT3Y29vL9SEJPyDhzp07MDMzg7l51fdPPI/l0uKeIBJS02UGWIFQCH0jI7k61+9xqXMnbnHCGPBGvDslKhbQ1QWsmwGX9wG3/as8XYLQKLm5uRg0aBCcnJzg5OQEd3d3uLi48OpMnz4dIpEIDg4O2LJlCzZs2KCl2RJE5altOlYR//33HwAuJl9V+yJqLhIDbN9ugJFB6fWSUwGzBrKDtcoKQVAylixBEISE2qhfhUIhDh06hPbt28PDw6NaxH6VYGRQugcsADyOll1PH8Mvk+yQuEmbZeosZIAliBK8ffsWv//+O06cOIH27dXnUnn+/HkAwOjRo6V5lpaW6N+/v8LYPRKioqLw+PFjjBsn28cvEAgwbtw4XruzZ8/C2dkZNjY20rxRo0bBwMAAAQEBAICYmBgAQLdu3XhjdO/eHRkZGSpZHEaJDbDTxwCtZFPBvDVAZpbMAAsABiby22ZCw7gFiZeHbHuesXhxI9mSZ2clq28m/0KW0CCffdwcn33cXNvTqFFIDjHQ09ODnp6e3I9kT09P/PbbbwCAY8eOYfDgwRqfI0GoitqiYxXRt29faR9V7YuomejrcQdtJaZw96PK+LpOEnFGV7MG3H1ZIQikGJGOJQhCMbVJv+7cuRPu7u4YNWoUIiMjVfwJqoaRIZCdU3p5xHPZ9cKp3I7Pft2B9FtAQSGXb2woC89HVA80tYalQ7gIAsCsWbPQu3dvBAQEIC4uDg4ODhg3blylD6L69ddf4ebmVmYMnVevXmH37t3YunUrBAIBEhMT4evri5iYGBw4cEBab+XKlfjyyy+hV+zoXF9fXxw4cADR0dG4du0afHx84ODggEmTJknrHDt2DMuXL8fx48excuVKmJqaYsuWLTh06BCePn0KALh16xZCQ0OxZ88efPnll4iKikK/fv3w6aefYtu2bZX67CV5+ZpLp47mttr5LOOXC4sZYA3rmSA9KZlX/jYDSEkDpo/l7gOvy8IZtGjGpS2LbfMbO5Q77ILQDu8O5U5d3bwzTsszqTkIhULcvn0brVu3xg8//ICbN2/yyq2srPDy5UsA3OEIaWlpMDc3R3Iy///KzJkzMWsWF1iKTlcnqhO1Ucfu27cPkZGRuHv3LrKystCtWzcsWbIE//77L4KCgirUF1F7kLxH3vAr8PX/gEYNSq+bLD6HxsKMuy4rBIEU/UZ4dyjpWIIgOGqjfl22bBlmz56NtWvXoqioiLcz7NGjR0hPTwcA2NjYwNnZGQAXrqt9+/YYM2YMMjMzpc5G6qCsQ7gA4HEU/97BFvh4IlDPBHBsKctv1wp49FQ9cyQqjibXsEwbEhoaqpVxSUgUSa9evdipU6fYq1evWHZ2Nnv+/Dlbv34909fXl9ZhjLG5c+cq1Z+fnx+Liooqt56+vj7bvHkzS0hIYBkZGez06dPMzs6OV2fVqlWMcS5xPJkxYwZ78uQJy8nJYbdv32aDBg2Sq2NlZcVOnDjB0tPTWVJSEtuxYwczMjLi1WnatCn75ZdfWHR0NMvMzGSPHj1iS5cuZXp6eip5tivmgLFwMP/vwaIugpmZcvf/m8yV2zl1ZpvDQtjmsBBm3aGdwj583gMrfMi1u7gHzNGeu/5gJFh+GNhX/wMLP83l7Vip/b+nuixBJzuyoJMdVdJXXdMTpqamLDAwkHXo0IGXHxYWxqysrKT3T58+Zebm5vTsSGqM1EYd+8knn7Bbt26x1NRUlp6ezu7fv89WrFjBTExMKtwXSe2RFs243yLTx4Kd+xXs+QXuvqmFfN153lzZrPHc/e7VYC8CS++bhYOxONKx1UHo2ZFUF6mN+jUoKIiVhpubm7Sej4+PwjrKzL8iUt8qU7SAAAAgAElEQVQEzMS42Px+A/tnX+n1LczE39diGTMUzPcTfh4LBzuxXft/PyTF/l01t4bVzgckxUVCUjdEYoD9YjaX2jTnG2Bb9egqNcC27tm91H42LeHaXfLj7g0NuDTqIljgXrCHf3PlIYfBpo4G+2un9j97XRQywFZNVq5cyT777DNeXkBAAOvVqxcDwHR0dFhiYiI9OxISEpJqKG1bcr9FvIaD7dsAlvRv6QbY0UO4sg2LuHu/tWDRl0rve1g/sKc3SMdWB6FnR0JSN0RHByz9FljGbTCBgMsLOQwW8EvZ7dJvyQytX8zmXrSVNMDeOqb9z0ciE02tYSkGLEEQGuGheItF+1b8fB09fgiC0ggTh/+RHOYl2fqRJAK6tJUdYtGlLeC3Fhg5UBWzJgj1YmFhIT0N1tDQEEOGDJE7wOCvv/6Cj48PAGDs2LEIDAzU+DwJgiCI8qknDkGQmc3F/WvUsPS6Jy8ChYVAbh53LxRy96Vx7qosrBNBEAShfvR0udABJsZcyABAfAhXGTFgAaD7WMDvOPAmEWhjpzjea4umKp8uUQMgAyxBEBpBYoDtWCKkkJB3CFf5BtjiB24BwB9nuQWOxI5rZCgrkxzWRWiO7JwiZOeUF8SOkGBpaYmgoCDcu3cPoaGhuHDhAk6fPo2vvvoKI0eOBADs3r0b5ubmePLkCRYuXIilS5dqedYEQRCEIkyKGWCNDMo+ZIUxIC0daFifu1fmEC7SsQRBEJpBVxfY8JnsvnMbLjU0AHLyym4bGQ1MW86tf9u25A5oLM6Bv4CmFvL5hPbQlH6lQ7gIgtAIUbFAVjZ3GBcA1BfbWnWKH8IlWbko4NEzxfnBt7nUyBC49QDo0VFWZmEGvMiuyqyJijLc65G2p1CjCAsLQ7du3eTyV61aJb3Ozc3F+PHjNTktgiAIohKYiF/8ZmQBoz4GWHjZ9dMyAFOxAVaZQ7hIxxIEQWgGl87APG/Zfee2wOEzynnASngczR3A1asLPz/wBjB5FGDVlFsjE9pHU/qVPGAJgtAIjAEBV4EOrbn7Yf24VEdJD9icXODOI2DXEX7+3XAgP58zwEY855fZNlfFzAmCIAiCIMqneAgCAMjI5FJhKZ6wqW9lHrBCJTxgCYIgCM2Qms6/79yWS5XxgJUgSlOc/0IcTqZFs8rNjai5kAGWIAiNMWYe0FPsyGdkwKUSA2xhfkGZMWABoMc4YPYqfl5uHnDvMedRW8S4GGkSti5T1cwJZVmxsAVWLGyh7WkQBEEQhMaReMBmZnHpyu3i+1J246SmAw0bcNc6Qu53TFmQjiUIgtAOncRh9IwMlfeAffZScX7sGy61JgNstUFT+pUMsARRC9DX18emTZsQHx+PjIwMnDp1Cra2thXqY968eWCM4ejRo7x8CwsLbNu2DTdu3EBubi6ioqJK7WPGjBmIjIxEdnY2bt26hUGDBsnVkRw2YaDPpZIYsLlZWTAoIwQBULpnSHwyoKsDCCB7owgAjUzL7I5QA4NdG2KwaxmnjhAEQdQgVqxYgQsXLiAtLQ2MMaV0a/369eHr64sbN24gNTUVr1+/xvHjx+Hg4CBXt0GDBtizZw9SUlKQmpqKAwcOoFGjRrw6enp6WLlyJZ48eYKsrCw8efIEvr6+0NfXV9nnJFSD5JCWDLEBdutvgE4H4G2G4voZWYBrD+D75eUfwgWQjiUIonahzjUsAPTt2xf//vsvsrOz8erVK6xevRo6Ojq8OkFBQWCMyYm+vgGvnk1zLmSAob7sMOjyaFBPcX5sPJeSB2z1QVP6lQywBFEL+P777zF16lQsWrQIY8eOhYWFBS5cuAADA4PyGwNo3LgxfH19kZCQIFdmZWWFCRMm4M2bN7h7926pfXh5eeGnn37Cvn374OHhgYcPH+LUqVNoYtmBV0/iBZIlfnOoU8wAa1hGCIKykHi9CnVkBtiMLMCc1igEQRBEFZg9ezZ0dXURFBSkdBsbGxvMnDkT586dw9ixYzF79mxYWlrixo0baNGC711x5MgRDBgwADNmzMDUqVPh7OyMkydP8uqsX78eS5cuxc6dOzF8+HD8+OOPWLJkCTZu3KiSz0iohvatgSXTueviHq9lhRXQFdsB/jcZaGpOIQgIgqhbqHMNa2dnhwsXLiA+Ph6jR4/GunXrMH/+fGzatEmubmBgIHr16sWTvDyZlVUSTsalC6CnB2QraYD99Shw66F8fmYWF56APGDrHnQIF0FoGUNDQ+TkKLmPQQFWVlaYPn06pk2bhv379wMA7t+/j6ioKEyePBm7d+8ut49169bh1KlTsLa2liu7f/8+mjXjtMO3336LsWPHKuzD19cXv/32G1avXg0AuHz5Mrp27QrXYUsByCKYP3sBLFgPHA3g7mUG2GwY1ivbA7Y89HSBF3HctaQrQwPl31ISBEEQtYeq6leAM6YyxjBixAh4enoq1SYqKgqtWrXijR0cHIwXL15g2rRp+PrrrwEAvXr1wrBhw+Dq6org4GAAwKtXr3Dz5k0MHjwYly5dAgBMmjQJP/74I7Zs2QIA+Oeff2BlZYUPPvgAn376aZU+H6E6JLFcAeW3p6YV84zt2w34j87YIgiihlDd17BLly7F69evMXbsWBQW217w3XffYcOGDXjz5o00LyUlBTdu3OC171Bs00psPOBoD3y7iLtXdm2ZmQ08fAL06CBf9vINYGOpXD9E7YE8YIlagbe3N4KDg5GcnIyUlBQEBgaie/fucvX69++PwMBApKenIzU1FUFBQXBycpKW29jY4NChQ0hMTERmZibu3buHiRMnKjUHPz8/hIaGwtPTE+Hh4cjOzkZwcDDatWvHq8cYw4IFC7BlyxYkJCQgLCysSp996NChAIDjx49L8+Li4nD16lV4eHiU297Z2Rnjx4/H0qVLFZYzVk5AMgAtW7ZE27ZtceSI7IQsyVYQh/byc9j6G/BKvPVCR49z/8jNyIS5deXirrSx49L3BvNDEADApiXA5zMq1S1BEESdpy7rV0mfFSUrK0tuUSoSiRATE4PmzWWnQ3p4eODNmzdS4ysAhIaG4vnz5zz9raenh7Q0/kkeqampEAhKOdmJ0AqSf475a5Vvk1bikJfyQhAQBFG7qMs6Vt1rWCcnJ/zzzz884+v58+ehp6cnHVtZdHQ4r1V7sZ3XtYfybUVvFedHRnNGXaJuQQZYolZgZ2eHffv2Ydy4cZg0aRJevnyJ4OBgtGzZUlrHzc0Nly5dQn5+Pnx8fDBhwgQEBwfDysoKALeFISQkBM7Ozli0aBFGjhyJ3bt3K3yjVhq2trb47rvv8M0332DSpEkwNTXFuXPn5LZRLF68GJaWlvD29sa8efNK7c/Pz6/MmKsA4OjoiNjYWGRmZvLyw8PD4ejoWO6ct2/fjo0bNyIuLq7cumXNAQAiIiJ4+W9ehcO4njmgY1FqW0kM2MzUNFg6tMLQj6ZVePzd/lyaXyBvgJ07CVj/WYW7JCpJsigfyaJ8bU+DIAgVUZf1qyqxsLBA69atERkZKc1zdHSU05uAvP7+9ddfMXv2bPTp0wcmJibo168f5syZgx07dmhk7oRyCMWrqgdPlG9TMjZs8yZl1ycdSxC1i7qsY9W9hjU0NEReXh4vT3Jf0rg8dOhQZGZmIjMzEwEBAejUqZO07OwVYMJCIFo8TH4BsG1/udOTIhK/P/33Dj8//Dlg3wLQ11O+L0J9aEq/UggColbwzTffSK8FAgEuXLiAnj17YvLkydKydevW4d69exg2bJi07rlz56TXCxYsgKmpKbp37y7dkhAYGFiheTRu3Bienp4ICQkBANy+fRvPnj3D1KlT8fPPP0vrvX79Gl5eXuX2V1hYiIKCgjLrmJmZITU1VS5fJBLBzMyszLYffvghmjZtqjAWTkWQjFNyHj07iLgLoRmAJIVtJSEITm/difZufdHMoVWFx78bDoz4iAtvEPtGcR0dHfIs0QRjP3ys7SkQBKFC6rJ+VSWbN29GRkYG9u7dK80rS3/b28vcYpYuXQojIyNcu3ZNmvfDDz/w/m0I7SPxgK1IHFdJCIKsbMDYiDvgpSxIxxJE7aIu61h1r2GfPn2KHj34rqo9e/YEAN5hl5cvX8Zvv/2Gp0+fwtbWFsuXL0dwcDDGvdcFQAx2+wN3HgExcUCH1sC1/4BLIWVOj/95xB6wtx8CfbrK8iOeA7q6nBdsYgrwOlH5PgnVoyn9Sh6wRK3A0dERx48fx5s3b1BUVISCggI4OjqiTZs2AABjY2O4uLjgt99+K7WPQYMGISAggBcPpqLEx8dLFRcAvHjxArdv35Z+2Us4c+aMUv3NmDFD4anJqqBBgwZYt24dlixZUuUYeaXxNrP8OhIDbEJ0DJ5cv4UGjUv3li2LM5eBx1FAXj6QnAqEP+OXt6xcdAOCIIg6DenXqvPRRx9h8uTJmDFjBlJSUircfvHixZg8eTI++eQTuLq64n//+x8++OADfPXVV2qYLVFZhGIDbEWiVkhCEPidUP18CIKo/pCOrTjKrmF/+ukn9OjRAytWrIC5uTlcXFywfv16FBQUoKjYmzJfX1/s3bsXV69excGDBzFw4EAwxuDtw4+xHlPJzaLPY7k0hR9JCBHPufTbxUDcFe7cEqL2QwZYosZTr149nD9/HtbW1li4cCH69euHHj164O7duzA0NATAvWETCoV4/fp1qf2Ym5uXWa4Mik5gTEhIgKUlP8J2fHx8lcYpjkgkgqmpqVy+mZkZRCJRqe2++OILvHjxAufPn4epqSlMTU2hq6sLPT09mJqaQihU/utBMk7JeRRB/PayqPR5SAywRQWFeJuUVGkDbHFavgMMnMrP69a+yt0SSrB2hS3WrrDV9jQIglABdV2/qoKRI0di+/bt+Pzzz3Hy5ElemTL629zcHKtXr8bnn3+OH374AcHBwdixYwc+//xzLFu2DI0bN9bI5yDKR+oBWwEDrCQEQYN6ytUnHUsQtYe6rmPVvYa9ePEili9fjuXLlyMpKQlXrlzB7t27kZKSUqaxOj4+HteuXYNLz268/JhXXFrRM6NP/wOMmQes+Zmf/ziaS7uKoyG0tqlYv4Rq0ZR+pRAERI2nd+/esLa2xpAhQ/D4scx1vPgXukgkQmFhoZwSKU5ycnKZ5crQpIl88K4mTZrg4cOHvLzKHOpRGhEREbC2toaxsTGysrKk+aXFlpPQtm1bODs7K9z6kZqain79+vG2O5Y3B8mYL168kOY3b+EIFCYDhYrDDwBcDNjCfG6LytuEJDRobK7UmGWRnslJbh5goM/l/fglcPoyF0CdUB+9e9QvvxJBEDWCuq5fq0qfPn1w+PBh/PTTTwq3SUZERKB///5y+Y6OjlJjrb29PfT19XH37l1enTt37kBPTw+2trZITKR9i+rAzBSY4gl8v185r1bJe+vKhCAwFRtgM8rZOUQ6liBqD3Vdx2piDbt27Vps27YNLVu2RGxsLHR0dLB69Wpcv369zLkxxtDGjgGyZa00Bqxtc8VtyuL4BS6dtwb44F3uOjMLeBEHCMS6o23LisUQr6s4tQOiXwGpxQ43s2kOXN4HDJoKRMVWrl9N6VfygCVqPEZGRgCA3NxcaV7v3r15wcuzsrJw48YNTJkypdR+Ll26hGHDhilUQMrStGlT9O7dW3pvbW2Nbt264ebNm5XuszzOnz8PABg9erQ0z9LSEv3798fZs2dLbbdixQoMGDCAJ3fv3sXly5cxYMCACp1sGRUVhcePH2PcuHHSPIFAgL5u44AMxXPQ0eMijuvo6qJQHCMoLTEJegYGMGrQQOmxyyKx2E7PRg2BJo1Kr0sQBEHwqev6tSq0b98ef//9NwICAko9qOTs2bOwtLRE3759pXndu3dHq1atpPo7JiYGANCtG98TR3JKdnR0tBpmTwDA8tnA1mXAGCUPy65MCAJJ3Po3SYBxV6BJv4rNkSCImktd17GaWsNmZmbiwYMHSE1Nxdy5cxEdHY2LFy+W2n/Tpk3Rr18/IOc2L/+h2DjauArrye0HgF7FQuhGRAHWzbhrR3vFbQg+d44DV0ocgjZmCGBnBSycqpUpVQjygCVqPNevX0d6ejp++eUXbNy4ES1atICvry9iY/mvP5YuXYqLFy/i7Nmz2LVrFzIzM9G7d2/cunULp0+fxpYtWzBlyhQEBwdjzZo1ePnyJdq1awcTExN8++23Ss0lMTERBw4cwIoVK5CdnY2vvvoKCQkJvEM3KsKvv/4KNze3MmPovHr1Crt378bWrVshEAiQmJgIX19fxMTE4MCBA9J6K1euxJdffgk9seGz5BtNgHtrmJSUhMuXL/Pyx4wZAwBo06YNjI2NpfeXL19GUhLn3err64sDBw4gOjoa165dg4+PDyytHIBXk+TGcfX2gueS+fjS1YNngE1P5Ppq0Ngc2W/fyrWrKAkpQItmsnuJNyxBEARRPnVdvwKAq6srGjduLDV4enh4IDExEY8ePUJ4eDgAef3auHFjBAQEICMjA99//z0vht7bt2+l7a5fv45z585h3759WLRoEYqKirBhwwYEBwfj0qVLALgtoCdOnMCGDRtgaGiI+/fvw8nJCb6+vjhy5IhUBxOqJ1nsXNWrC3DsXNl1gcqFILj9EPCcC1wMAbLVE46fIIhqSl3Xsepew7Zq1QqTJk3CzZs3oauri3fffRfTpk3DiBEjUCg+mblTp05Yt24djh49ipiYGNjY2GDZsmVcjNiUrQBksVnV4Z16/howVPwO1rFl2XUJ7rBKAOjUhp8vCefQpa1Gp1NpmDYkNDRUK+OS1E4ZNmwYCwsLY1lZWezevXvMw8ODBQUFsaNHj/Lqubq6ssuXL7PMzEwmEolYYGAg69Kli7TcxsaGHT58mKWkpLDMzEx29+5dNmHCBKXm4Ofnx0JDQ9no0aPZ48ePWU5ODrt69Srr0KEDrx5jjM2dO1fpPqOiosqtp6+vzzZv3swSEhJYRkYGO336NLOzs+PVWbVqFWPcvpFSRdEzk8xZEW5ubrx6M2bMYE+ePGE5OTns9u3bbM0XgxgLB2PhYEKhrN7cvT+yzWEhzL5HV/b+8kXs6ytnGQDWslsXtjkshLXp7aySv4uAXyAdn4WDObXT/t9qbZegkx1Z0MmOKumL9AQ9OxLtS13Xr0FBQQr136pVq6R1SupXNze3UvVmUFAQr39TU1O2Z88eJhKJWFpaGjt48CAzNzfn1alfvz779ttv2dOnT1lWVhZ78uQJ27BhA6tXr57W/z5qs0wexf12CNyrXH33/lz9np3VNyfSsdVD6NmRqErquo5V5xrW2tqaXb58maWmprKMjAwWFBTE+vXrx6vTvHlzdvr0aRYXF8dyc3NZUlISO3bsGGvbtq10/bhuYbFnIM5T1b+/taWsz9v+2v97rO7Sohl/bR/2F1j4abAhfbj7jNuV71uD+lU7D48UF0ltE4ny0vY8qpNM8YRCA+yUzWvY5rAQ1mXYYDZ21edsVeDfDAAzt27BNoeFsB6jhqtk/FY2/C/pXk7afya1XfbvdGD7dzqopC/6/0TPjqRmirERmP/33MJCFf2RfiXRhnwwkvvtkPmfcvWHu3H1nTupb06kY6uH0LMjqU1COlaxSNaPv66W5TnYgbW2Vd0YjRvJxlFW19Rl6dSGv7aXiMQAW/Cg8n1rSr9SCAKCINSGbinfMBkp3MmW9c3N+CEIxFspm7VSzR6M6Ff8+yXTgff/p5KuiVLw/piixxNEXWe4K/D+EKCwEBi/QNuzIYjyaWIOvAwC9v8JzFjJLzM2AkYM4E6yLgtpCIIKHMJVUUjHEgRBqJfhbsDZK7L7TXtk10+iVTtWcX1hbASYGNOB0WXRyLScCgJATw/Iz69435rSr3QIF0EogUAggI6OTqlCKEZX/GiWbOIrmPRk7nSseuaNeAbYvOwc5OfkYuC0ybBz6lzl8cXhfaSMfqfKXRIEQRDlEJ/Mpc0syq9L+pWoDugIAX09oHtHxeUOtuX3IaxEDFiCIAh1Qjq2Ygx3A07/BCydCeTkAut/ASKeq3FAAf+WDowuG7NSDLDrFnKpjhBo0VRz86kMZIAlCCXYs2cPCgoKShVbW1t8+OGHcHZ21vZUqwU6OkCDejIPWL/j/HLJAVvt+vWBjq4uigpkllL/1RsBAI1aWKplbqV55RKqYcvqltiymqLIE0RdJkPsvdGxTdn1ANKvRPUgT+wtY2youNzEqPw+hOJVFVOjAZZ0LEEQFYF0bMUQ+wTh/SHc4Vu5eeodL1nEv29irt7xajpmDRTnd+8gu7ZtXrm+NaVfyRRBEErg6+uLHTt2lFoeFxenwdlUf7Z9AcydBHy+mbsvKOGJysTuIS3at0XqmzdSD1gACL8aAgAwNDFRy9wcbIHwZ2rpmgDg1FE9/24EQdQcJAaohOTy65J+JaoDEkcwI7EBtuQiuDTDbHE0EYKAdCxBEBWBdGzFkKxZe4h3Q+Tkqn/MnuOBqaOBjyeSB2xx5k8B/M8DsW9keeYNy29XWQOspvQrGWAJQgliYmIQExOj7WnUGAb25NLpY7i0ZCiA4hjWr4/CfJkBNkfsOmVgYqyWuXV0IAMsQRCEJkhOLb8O6VeiOiDxXjUxAqyaArH/AEcCZOVKecCKDbDq9IAlCIKoCKRjK4ZOif3hOWr2gAWA0DDgdSJngG1MBlgAQBs7YOsywOc9oNv7XF781fI9hIuKADsrtU+vSlAIAoIgVM6l61zaxo5LS3rAFsfYtAHPA7YgNxeF+QUq84D9+Q/gwF+y+1++lnm6EARBEOpDTe/RCELl6BQzwNYX//xw7SErN1bCACugGLAEQRA1GmEJ65i6QxBISOSORyEPWDESQ3Qra1mexPgqeVaKSBJV3gNWU5ABliBqEePHj4e/vz/i4uLAGIOPj0+F+3ByckJBQQESExN5+U2bNsXJkycRExOD7OxsxMXF4ciRI2jdurVcH0xgBDReD7SKAdpk48HDZ1i8eLHC8Ywb1EdRMQMsAORkZsKwnmoMsB/5At6fy+5N6wPOnVTSNUEQBFEGyngN1iR+/PFHhIeHIz09HSkpKbh8+TIGDx5cbrvu3bvDz88PERERKCwshJ+fX6l1+/fvj3/++QcZGRkQiUT4559/YG1tzaszY8YMPH78GDk5OXj06BE++OCDKn+2uo7kxayBvuwA0Yb1ZeUViQGrzhAEBEEQtZXK6lgAMDIywvr166Xr1GfP5Nee+vr62LRpE+Lj45GRkYFTp07B1pZ/wqL39FWAI5PKzkMMjDEMGzZMZZ9TEbl5wNsMigErQeK8lZktX5aTC4ydD6z+Ub7sTZJyh2ZqEzLAEkQtYuzYsbCzs8OpU6cq3ceOHTvkjK8AYGxsDJFIhJUrV8Ld3R0LFixA27ZtERgYCFNT2ZGEQqEQoz88A9TzBBKXA7HuWLt2TanjGTXge8ACQE5GJgzUFAO2sBBw76eWrgkAkc+yEflMgbYkCKLOUdsMsEZGRtixYwdGjx6NyZMnIykpCWfPnoWLi0uZ7fr27Yt+/fohNDQUb968KbXesGHDcPHiRdy7dw+jRo3C5MmTERISAkNDWQBSLy8v/Pzzzzh+/DhGjhyJgIAA7Nu3D56enir7nHWR4ttOLcy41NCASzMy5WPANjGXxQiUoIlDuEjHEgRRW6msjhUKhThz5gw8PT2xfPlyuLu7Y80a+bXn999/j6lTp2LRokUYO3YsLCwscOHCBRgYGMj6EgAoTAWiewHRvbBqUS/06tULISEhqv64ciQkkweshHriHVSKDt2ytuRiw365XZb38CmXPnoG9OsODO5d8TE1qV+ZNiQ0NFQr45KQVFfR1dVlQqGwSn0IBAIGgJmYmDDGGPPx8alQ+8mTJ7MnT56wNWvWsMTExHLrt27dmjHG2OjRo6V5s2fPZtlZKYxFNmYsHIyFy7fr6zWGbQ4Lkcqsn7fyyj/z38+mbl2v0uc7tC+YSxewa4fA/vMHa2Wj/X9zkrKF9AQ9O5KaKU7tuO/+tFCwlR+DfTxJ+3NShY4tKUKhkMXExLBt27aVWU+imwHu/6afn5/C+b148YKtXr26zL4iIiLYvn37eHnHjh1jYWFhWn/GNVla20L6m2Wcu+yahYPFXwU7v5tfP+aS/O8br+FcXhs77X8eZYT0BD07EhJViTZ17OzZs1lKSgpr3LhxqXWsrKxYfn4+8/b2luY1b96c5ebmsunTp0vzfv9tFWP5idLv//eHaO4ZXjsEdu5X7f9baksG9wbb9gV3PWaoTAc3bMDlZd2BnG1Bcn9xD5eOHAhW+BDsm/na/Sxl6QjygCVqJCNHjsStW7eQkZGBlJQUXL9+Ha6urgAAW1tbMMYwYsQIXhs/Pz+EhoZK71etWoXExET07NkToaGhyMrKQnBwMOzs7NC4cWOcOHEC6enpePToEQYOHKj03Hx8fMAYQ48ePXDlyhVkZWXh8ePHeO+993j1goKCcPToUcycORNPnz5FTk4OmjevWtASVgW3i3r16mHDhg1YtGgR8vKUC3iTnMwdca2vrw/T+sDSmcC0adMQef8IUCjvRVsaJT1gczMyVX4I1/lrwI17wOnLQNf2wOMztM2DIAhCEarQsbBYhfpOifh6cU/88Gvt0LEAF+dz2xeAoz1QVFSE1NRU6Ovrl9lGGd08ZMgQWFtb44cffii1jpGRERwcHHDhwgVe/vnz59GxY0fY2Ngo9yEIOYp7wJY8BCUzW94D1kb8p7RyjixPGoKg8j/FCC0iFArx33//4e+//9b2VIhaDq1jlUNZHTtt2jQcOXJE4Q5OCUOHDgUAHD9+XJoXFxeHq1evwsPDQ5onieUtQROHcElITKnbHrAX9wDzvAF9PS5koIQWTbn0pXgD0R5/+bZvkrjUtD7w7GX1DkNABliixmFvb49jx44hMDAQI0eOxAcffIBTp06hUaOKf2MZGxtj165d2LJlCyZOnAgbG/Fqhd4AACAASURBVBvs378fv//+O65evYr3338fr169wtGjR2FkVLG9lH/88Qf+/PNPvP/++wgLC8PRo0fRuXNnXp2+fftizpw5+PzzzzFy5EikpaUp7EuiDEvGqVElX375JcLDw/Hnn3+WWU8gEEBXVxc2NjbYtm0boqOjcfr0aayaC6xbqIdu3boiPS0WsDwAtMkCHFKxZ88e1K9fv9Q+S8aAbdisKSxb26vkc5Vksx+wdDMX7626n5JYE/l5cyv8vLmVtqdBEEQlUaWOFQiNgWa7ANEWTJ5cO3RsUwtgnrcOws82wqeffgoHBwfs2bOnQnNXhIuLC5KSktCrVy9ERkYiPz8fYWFhePfdd6V1DAwMIBQK5V6SSu7btWtX5XnUVYofztnYjF+WlSMfTiM9k0u/nicz2GoiBAHpWPUxf/58hIeHa3saRC2H1rHlo6Ojg0aNlNOxenp66Nq1K2JjY3HgwAFkZWUhNVV+7eno6IjY2FhkZmby2oeHh8PR0VF6LxQA0GkItE4E2uZh267/MHr0aKXmXVUSUgCnOqzGs3O41LIxPwa7VVPZ9ZkrwGxf2X1zV04CrnL3sW+AyGigTSVMJprSr7pqH4EgVEzXrl2Rnp6OJUuWSPPOnj1bqb6MjY0xb948XLlyBQDQvHlz7Ny5E19++SU2b94MAIiNjcWjR4/g5uaGgIAApfv+9ddfpX2cO3cOjx49wrJlyzBx4kRpnYYNG8LJyQkJCQll9lVUVISCgoIqebiWRZs2bTB37txyY+wAwM6dO/HRRx8BAJ49e4YhQ4YgIyMDWdkAdMyhq6sHZ7clQN4lIHYUoGcDT89vYWJiggkTJijss1ASaVuMsWkDMKjns+bmAeeuAes/A5o3UcsQdZo2rWpZ0EeCqGOoUsdCaAzEzwOyr2CiK7B+fc3UsQIBoKcL5OUDozwnAI6HAQBr12RgwoQJfM/fStKsWTOYmJhg165dWL58OZ49e4ZZs2bhxIkT6Nq1Kx48eIDU1FQkJyfD2dkZf/zxh7Rtz549AaDUBfxAF+5Ai+BbVZ5mrUVYzOtJzgM2C2hYIg6d33HOUwcAWttwnksSzyl1HsJFOlY9WFlZYcSIEVizZg0WLlyo7ekQtRhax5bNhAkTcPgwp2MzMsrXsebm5tDT08OSJUtw6dIljBo1CjY2Nvj2W/7a08zMDKmpqXLtRSIRzMxkb90S3jwFEpYAuXcAYX0kJMzG8ePH8f777+PEiRPlzr8q5OVzaVMLID5JrUNVSxJTuN0lVk2BFs04XSoU8g2wqW+B4n5br8VOzwf+Av69Azx/CYwaBAxwrvj4mtKv5AFL1DjCwsJgamqKvXv3YsiQITA2rvxW9dzcXAQHB0vvnz7lIjgHBgbK5VlZVcxdsviXNGMMf/75p3SRJOH27dvlKi0A2L9/P/T09PDixYsKzUFZtm3bhr179+LBgwfl1l27di2cnZ0xduxYJCYm4vz582jSpAlevIZ09ZGTLQJejQOyLgJpe/Dpp59i/PjxsLdX7NVaMgTBzZOnwArVt4KRfFm79wO6OJZdlyAIoi6hSh2Lolwgm9OxfbvVXB37x3dA7n3uR/0/QeeA6B7AS3c8fXQChw8fhpubW4XmrgiBQAAjIyOsWLECu3btwqVLlzBx4kRERUXxFuo//fQTZs+ejdGjR6Nhw4bw8vKCtzdnCSwqxfIXuBe4sr/KU6zVVNQDljEgLZ27biWO/CDUgAGWUA9bt27FkiVLSv0/BAAzZ85EaGgoQkNDYWFhocHZEbUJWseWzblz59CjRw+4u7vjxInydaxAvPYUiUQYN24cLl68iD17yl97lkbIlYOAaAsiHvwDZPyNpQveRUhICL788ssK9VMZzom9OGeNV/tQ1ZKEFC6dPApY4CPbVdKiaeltivP8JZdGRgMmxtXX0YoMsESNIzIyEp6enrC3t8eZM2eQlJSEgwcPVurHUHp6Ou9tnGQbX/E3ZPn53Ouo4qcQK0NJhZSQkABLS0teXnx8fIX6VAfu7u7o27cvvvvuO5iamsLU1BSGhoYQCAQwNTWVi7vz8uVL3Lp1C/7+/hg6dCgaNmyIuXPnIjUd3KmRAOKiryEzS2ZUlfwQaN++vcI5FOaXiAGbmaXyGLDFSUzhFk+zJwAhv/MXXgRBEHUZVepYFKUD4t0Mlo0BY8OaqWMlBjb/bUBbm1Qg5zaQeQ7/np6CkJAQfP3111UeQyQSAeDi6kkoKirC5cuXebpzzZo1OHPmDI4fPw6RSIQdO3bA19cXAPDmzZsqz6OuIokBm58v7wGblcPFgJ3nDXwxW5ZfVMSJfQvuXhqCQP3TJVTIiBEjkJCQgP/++6/Mer/88gucnZ3h7OyMpKQ66J5GqARax5ZNamoqbt++jXPnzmHKlPJ1rOSzXrt2DQUFpa89RSIRTE1N5dqbmZlJ9S8g+x7/bCPnVXn7IRc3tnPnzhAK1Ws6eyV+nF//D5g+Vq1DVUtSxBEsPpBFXkJ8Et8DVhkio7m0UxuVTEvlkAGWqJGcOXMGrq6uMDc3x/Tp0/HOO+9g+/btAICcHC6ASEnDYfHtBZqgSZMmcvevX7/m5akrpEBFaNu2LerXr4+nT58iNTUVqampWLp0KczNzZGamorFixeX2jY9PR3Pnj2Dvb09F/OMZQP50YBAgOIOrJK3k6V5FpSMAZublQWhjg70DA2q+vEUj1cETF4CfLcXMDKs2wHPCYIgSqJqHSsS/6iWGKpUgSZ1LGNAWCSgqwt8+L4s38IMuHPnToU9bBQhiT0pKHECiEAg4OnO7OxsTJgwAU2bNkXHjh1hZWWF6Oho5ObmlmtAIkpH8iI2I5sL2VCc7BzA2Ig7fG3Np7IFOsDFm5MY6DURgoBQPX379sWoUaMQFRWFw4cPY9CgQdi/n1zGCfVB61jlKU/HZmdnIzo6WqHuBGRrz4iICFhbW8t5HDs6OiIiIkJ6L3kZ9/AJ4P05kJXNfU5NfNZXxWzezh3VPpxGcbQH/Nby9WdJMrO5tEE9Wd7LN0C7Cv7EinjOpRsXVaydpiADLFGjefv2LX7//XecOHFC+oYrISEBeXl5vMMoTExM0KdPH43OrXjAboFAAE9PT9y8eVOjc1CGY8eOYcCAATzZu3cv0tLSMGDAgDJ/hJqbm6Nt27aIioqSZWacgpVtX0CgJ80aPHgwCgsLERYWprCfkiEIcjOzAECtXrCHTgGXxSGFLBvzy5qYA/bWahu6VnP3QSbuPsgsvyJBENUeVenY+5FcKjFUqQJN69joV9z2QPd+sjzzhkDv3r35OrCSnDt3Dvn5+Rg0aJA0TygUws3NDffu3ZOrn5CQgIcPHyIvLw8fffQRjh07hvT0dN7cOrfltzEo+yDpOo3EAJv6Vr6ssJD/7LoWOyTleSzQSvx7QROHcJGOVT1ffPEFrK2t0bJlS3h5eSEwMFAa1oMg1AmtY8tHGR176tQp9O3bF3p6pa89z58/D4D/uSwtLdG/f39eDF6JLijuSDRmzBjcu3evzBAlqiAhWXZdXb03K8uJ7cDU0UBHh9LrCBTk/RUE9O8BNGusoLAU4hKAJzHczpWKoCn9SodwETWOWbNmoXfv3ggICEBcXBwcHBwwbtw47Nu3D4AsTs2CBQsQExOD1NRUfPbZZ8jOztboPGfMmIG8vDw8ePAAM2bMQOvWrXmByyuCt7c39uzZg1atWpUZP6ddu3Zo3769dJtJjx49kJGRgcTERGmAdldXV1y6dAmDBw/GlStX8OrVK7x69YrXz4ABA5Cfn4/Lly9L8xYuXIiWLVviypUrSEhIQMuWLbFgwQLk5ubi559/Rp9O4orJ30K/xWQIW/nj9fOdsGhijS1bNmDPnj14+fIlb5ycjEwY1jORM8DmSAywxibISBZBXUhiwTZvAvz3SJYf9idnhBXU4ZMoK8uCFVU3RBAEoT3UoWMTU4CcXGDiCNXNU9M6tpFlP9h3XggjwxNAwQtAxxzdhvrApHEvjBw5UlqvpI4FAAsLC2kMOzMzM9ja2mLMmDEAAH9/fwBc+IAffvgB69evh0AgwNOnTzFr1iy0aNEC69atk/Y/YsQI2NraIjw8HE2aNMHMmTPh6Ph/9s47PIqq7cP3phfSSCD0CKEjXZSioqIioALSFQWlWECs+NoQFF4LSFFfUVRAmvJJFwQpggIKEnoLvSdAQnqv8/1xdjKzLZuymwLnvq65ZmfmzMzZDcxvznOe0pRhw4aZ9PfHT+DR+yCkk7avWlXhsSmxRPV6+isC6hs9tU9fhEZhWmGUE+eEF8/I/qKgJ8DZy9DzXvFZHTw6c4wuNVYiqdzIcax1jR06+G5GP/86389bxaVLlwgODmbYsGF07GhfY6dNm8bQoUNZsWIFs2fPpm7dunz2menYMyoqirlz5zJr1iwMBgOxsbFMmjSJixcvsnjx4oLrv/XhnxC0grvvOUFmji+jRo3irrvuok+fPiX67sVBP3l3sxlgg4yFLFs3hcMnTY89eh/sOggeViaJ1fF5vZpalElRWP+XMPjq8fGGTT/Am9Ng90HLc8pKX6UBVlLpOHz4MI8//jgzZsygatWqXL16le+//94kOfbYsWP57rvvmD17NgkJCfz3v/+lc+fO3H572fnzDx48mJkzZzJlyhQuX77MoEGDOHjQyv/2IuDi4oKbm5tFeIU5AwcOLMgFB+J3GDt2LH/++Sf3338/IGYxi3Itcw4dOkTPnj0ZNGgQfn5+XLlyhT///JOPPvpIGHBVA2zuJXauepCuj84kqNlKktKSWbxgAW+//bbFNbPS060aYFUPWC8nesCCmCED6x6wIB7U6WX7viORSCTlirM0NikFQh3oAVvWGpuRepn9x/Po1f1jcK0GebF4JB/kqYF3c2+z3agONNY0tkWLFixfvrxgOzw83ESTVcaPH09aWhrvv/8+VatW5cCBA3Tv3p1z584VtMnNzeX555+nYcOGZGZmsnHjRp599lmio6NN+uttzOAzUpdHrro0wNpE9XpKStX2qa8mqgE2zphWcXBPWLhGfD53WbxDNL5N84DNL//sUpIS8tdff5k4H0gkjkaOY62zaMplqJZH/YYfU61aNWJjYzl48CB33303u3fvLmhnTWMvXbrEgw8+yMyZM1m5ciXJyckssDL2HDduHGlpacyYMQMfHx/++usvhgwZQlZWVkGb2OtnaNzwVeYtqEl+fj779++nV69e/P777yX67iVFP5HXuikcPS2iMSor67eLFE6e7qb7vb1g7TfC0KrmgNWjvrOoeWCLGmESEw8BfiJ6RZ0wDaslCsJu/gH8Ozg3WsUeSmFLnTp1lK1btyrHjh1Tjh49qowbN86iTdeuXZXExETlwIEDyoEDB5QJEyYUek1AiYiIsNtGLnKpjMuwYcMURVEUX1/fcu9LWS4DHkFRIsWy8QeUpAjbbbsM7qdMP7JLeXvt/ynTj+xSer36osnxRh07KNOP7FLqt2vt1D67uaHkHUOZOMZ0f/Zh8T0u/IFyW+3y/20r07JodiNl0exGDrmW1An528mlci5tmolnaO5RsV42C6VTG/H5kXtKd+3y0Ni9y1F+nS0+qzqX8C9K1iGUyN/EdkXTipnviH7F/K31uce95d+virrcd6f4jSaN1X6vw2vEevZEsd71s3ZsyTSU+N0o93YQ28/0RnlxiPhcPdh5/ZQaWzEW+dvJ5WZdSqOxtaqLZ2Gt6sW/r/ps9fIs3+8/5knRj5Cg8rl/zhHtt3BzQ2kYJj5//lb5/9sozfLBGPE9Xh9uut/HW/u+fy7UPqttgwPF55eHopz6HWXx1KLdb+QAcV6dGtq+14Zr1848hPL2KNNzykpf7eaAzc3N5Y033qBFixZ07NiRMWPGmOQkUdmxYwdt27albdu2TJ482d5lJRLJTYw+eXZhZKYLT9e8XNMpvax06zlguwzux6Ovjy19B43k5orQWHMP2B37xDqsFjz+gOV5EtvUqeVJnVrOKZ4mkUgqF2pBBV9vLeWL+fO2snHIWKsjLlGEy6l54pwcsFFiquqKPsuCk7Yp8IDV0ugWeBsZi4jj4qoda1JfrP/eD9nZ0Cy8bIpwSY2VSCQVlYljYMGnolhhSTm4ynH9KQnWcsCWJdduaJ+rV4VAP/H5nvbl0x9HkWP0Qg0xqyWnd4r20HnHxieKYtlxiSKFVZ0axbufmk9X/97z8lPaZ08P+OR103PKSl/tGmCvXbvGgQMHAEhNTSUyMpLatWs7vWMSSUXF1dXV5iIRBBTRAJuTISp92kxBYFap8on33uT+Z5/CkUTHiBywemLiRa631DS4TT7uJBKJpFh07yLWi9eKdYCfNqioEVL4uRVdYw8aDbCqcVkNbatSAQ2wicnwwVdglNqC9DoSS9QcsAm6Ilzq3LCagsDVBS4bi4A3NRpg8/Lg9CVRpdlFNcAqzu+vRCKRlARnaqyX0XZVXGMZiDEXiMmt0QNL3ZUS88W7Yl1e4f7b92qfQ0O0dwyvSj7vpk5gVg003a9PSuHuBpFnxeccnWkg6jrUNhur2yMmXqz17z0XoizbFTMjo0Owa4DVExYWRtu2bfn3338tjnXq1ImDBw+yfv36gip+EsnNxrBhw8jNzbW5DBs2jAULFmAwGEhLuzWr1F6/UXQP2FyjW0lejnUDrLkHrDO4ekN4ZD3URSu8oXIhWhpgJRKJpLh8+oZYGx/lBPgJD4bE5MI9YCuSxgb6izzg5pwwpmNt1USsVe/IimiABfh4Dvi0Fb//3e3KuzcVF9X2oDfAnr4o1leuG9u4wMVo8VvqX08izwoPWDUHbHnmlZNIJBJbOFtj1UkoexOt1sjOEYWYAOZ8KAoelifOjGQojNc+henzxedQnfGwqGPrioqbUWNDzA2wZh6wpy/CH7tg3Mfa/ivXHeMBm2alrou5E1ZZUOQiXL6+vqxYsYJXX32VlJQUk2P79+8nLCyMtLQ0evTowerVq2nc2LJ026hRoxg9ejQgKsJKJJWNtWvXcscdd9g8fv78+TLsTcXk8jW4o4g54nOzxbRevrkHbEEKAl+r57l5eBScW1qiY0QF49+/EzNj4Q9rx85fgfrSACuRSCQlQjVEqSF0V2MLH5iVhcYaDKIIw7EzkGCl4AOI6sOH14jQ8ipm3VFT1KioXpIV1QCrcu2GSKkTGiImSiWmqBWn9f8mZi2E75dBsrEwl4uLCEs9fdG0QnXkOej7oPDegfIbuEskEklhOFtjDSU0wBoMYtJTTVUE0KCuNuFZHpRXCoKYOPj6J3jjWWGAvW40JN5WWxgo1YiMyoarq3gnrGaWCsnbS/vs4Q4ZWdB7jGmbqOtwV6viTW4WGGB1RmzVq3nxr3DoJEwbL5yvoq4X/bqOoEgGWDc3N1asWMGSJUtYtcoyMYfeILthwwZmz55NcHAwcXFxJu2+//57vv/+ewAiIiJK02+JpFyIj48nPj6+vLtRoTl6uhgGWGNcha0UBLY8YKsEBZJ4PabkndRxxujh4uICwWazcheiKn/OnbJm194U+40kEsktQahxEKYaYK/dKNwDtiw09t474M+F8Ntf8OgL1tuoL+weHtCwnukxdfCTlCI8e9Vw84pugB0zGX77Fh65GxasLu/eVCwGPAKfGb22r+uGLlnZsOew5omlesmeOCcMsOp25Fnxua7RQ8eZBlipsRKJpKQ4W2NVA2xIELi7Q5C/0Px5/4XRH8C+Y+L4fXfCmCdh4RpYuw38fMU47FK0dq2wWk7rZpEorxQEoOlQaAi464zQNaqZ/kaVCTdXoY3muejn6zxd3d2sG5ivXIcnQuHKtaIbYVPTRfolvcFXfV/z8YZVW4QBtkEd2GmcWC8rfS1SCoK5c+cSGRnJzJkzrR4PDQ0t+NyhQwdcXFwsjK8SSUVBURTGjBljv2ElwcPDg88//5zr16+TmprKunXrCAsLK9J506dP5+rVq6Snp7N9+3batze1Ns6fPx9FUawugwcPNmnb7ZGR0OAUQ17PgNv2go/96lX71m3k1K49nInYb7I/Py+PnMwsPH1sGGCDg6zuLwnTf9Q++1URSblVLkSJGdkAP4fd7qbn3SkXeXfKxfLuhkQiKQfM9VXNq6nOpdnzgC0L1AIQD3UqQmODB59++jmtel2nx0ihryHVhb6q+cW8jJqhN8A6Wl9HjhzJqVOnyMjIYO/evTzwQPGrQ67/S3h59Ly32Kfe9AT5i/WQN+CkzgFMNaSmG3PoqhMJkcYBsRoSeuaSWKuvJs5MQSA1ViK5danoY1gXnWWpelX4e4koqtWuOfxvgnbsqcegf3cY94wYw549fx0ap/LQoHXgLjS2MAOsMzVWHcOWlwcsQHqGyIkbGqxFVkD5vz+VBldXYQCtVhWefQLefV7s79xGa+PhoaV10nP5qsiB61bk2H1BbLypwfdqjNDn6fPh0lVhZG9QVzteVvpq1wDbpUsXnnnmGR544AEOHDjAgQMH6NGjB88//zzPPy9+uf79+3P06FEOHjzIl19+afGPWiKpSHTs2JFly5aVdzccxpdffsnw4cN588036d+/PyEhIWzevBlPz8KzdX/55ZeMGDGCSZMm8cQTT5CamsqWLVuoV09z95k8eTIdO3Y0WRYsWEBOTg6bN28uaDd48GBGjf0Wkhby/IgekHUM6qyjRYsWhfbh/IFDzBn9CldPnbE4lpmWZuEBm54kkrP5BjnOAJubC1t3i88uBq2yMWjJumUeWIlEItG4/y7r+831dfdh0+P2PGDLAjWvq4dH4e0AqP4lDz4ynCtH3mTfJqGvX3yzmanzPHl4hGiiGun0BlhH6+u3337LwoUL6dGjB8eOHWPdOvv6ao0NO2BgD2h8W7FPvSX40yw4Tx2A30gQ6xrGf7srNpm2U4uGqIZcWYRLIpE4g4o+htXn8wwNhoY6fyC98VDNFdv+fjGGjdz9JkT1x90rBOpuBoNnoQZYZ2qsOoZt1qz4GutIrsdZGmDL+/2pNKgesMGBwiP6v6+K/fq8rJ42Uiys+1Oc62c9M6FNYuJN0wVl54ropX8OCEPvlevwUOfiG3YdgVIeS0RERLncVy5yqUiLl5dXqc6vXbu2kpOTozz99NMF+2rVqqVkZWUpI0aMKPS83Nxc5bnnnivY5+HhoVy5ckX56quvCr3n0aNHlfXr15vsO3vmhKIkzFWUSJRm4ShKpEFRMg4rixYtsnqNLoP7KdOP7FJ8gwJt3ued9cuUpz6dZLLvP78uVaYf2aW0f6yHQ/8Oc6egKJFiGdIL5efpKJG/obRrLva9NbL8/61UlmX5/CbK8vlNHHItqRPyt5NLxVv6PCieiy89abvN9Z0oq/+H4u2lPVsB5c3nxGc/X+f305a+Pj9I61Ot6tbP7dYJRTldW1Hyc5Qda59W9i5H+XW2pb5e34kSsUxca+IYca6j9fXEiRPK3LlzC7YNBoNy+LBtfVWXme+gJPxruu++O0VfXx5q+zyDAWXWOygN6pb/v7WyWkYPFL9LjWpiW/330bSB1ubloWLfnl9Q3N1N/10DSvxulL9/Evu8vZzXV6mxFWORv51cbvXFmsb+3wzt2dizK8rOJdp25iGt3fyPhcbm5+cor7/ydEGbJ/vUUpT8LEWJHqH8/ZP1+zpbYzMOFj6GLavl759Qjq1F+fET7Td8YXD5/91Lusx6ByVtv/ZdlEjxvnFyg7aduAfly/esn3/xD5SkvSiLPiv6PQ+uQjm9Udv+6n2U2H+07SO/mv6uZaWvRUpBIJFUNObPn09ERAQ9e/bk2LFjpKWlsW7dOoKCgggPD2fr1q2kpqYSERFBy5YtTc41D9/Ytm0by5YtY8iQIZw+fZqkpCTWr19P7dpFd3tU+9O7d28iIyPJyMhgx44dNGvWzOLer732GjNnziQmJoYjR46U6nd4+GFRMWrlypUF+6Kjo9m5c6eYxbNBy5YtcXV1NZkBzM7OZvv27fTq1avQ81q0aMHPP/9csK9+/fo0CG8CKb/oWiqQsqzQPtgjKy3dIgVBWqKojlElKNDaKSXmvNHTNT9f5AdUOWZ0zG1lWVNQYoPgIHeCg9zLuxsSiaSE2NPXj2dshcapfPi5bX11dRUFGddv2Aa1loG/0NePvkqCOuvp2qn89NVHV/ChUE9Q34dRgCq5tvU1NkFLW6N6wDpaX5s0acIvv2j6qigKy5bZ19dXnxEpdPT8uQdS0iC8rvVzQITjvfKMyBd7q6MPQf19p1j7V7ERInlNS1HgzBywUmMlksrNzTyGdXERofMgPF7PX9GO6VO8ubgAvg9jAHbt0DR2/dZoSN8JVXrY9IB1tsampCns31O6MawjuB4HzRvCsD5iOz+/8nrA1g4V0aS5Znl1Q4LAWPYFEHmDbRUZO30RPIrpqerjLXK8qoW+3FxF5KvKm1PFupbxdy0rfZUGWEmlpV69enz00Ue8//77jB49ms6dO/Pdd9+xdOlSli5dSv/+/XFzc2Pp0qV2r3XXXXcxduxY3njjDUaPHk27du347rvvitWfsLAwZsyYweTJk3nyyScJCAhg48aNFqkAxo8fT82aNXn66acZN26czevNnz/fbjXKpk2bcuXKFdLS0kz2R0ZG0rRpU5vneXmJJ1F2drbJ/uzsbMLCwgqOmzN48GAyMjJYvVqr4FFwn+wTBfuOnwGyIwkODiYkpGQJa7LS0i1SEGQav6cjc8CClmogIwteGAyNwox9yIZlv0Pntg69nUQikVRoCtPXzRuXQlR/PDxs66uLQVfAwvsuCBT6+slHo8GrHRM+Kj999fUBas6H8PMmKWcs8GhKftYVWjdJK8gbC6b6GhuvpTR48zl4prdz9PXEiRMmbSMjS66vZy9BuDFK84t3IeZv0+OZWWLdoE6xL33TcOC4WOv/hKcviLWtfzOXr0GATEEgkUiKwM06hjUY4OoNoOZ8Pp9jewzrYgA8mkLuFQJ8xdjuqfGQmAzZaZHgmtziVgAAIABJREFU0ZTaodbPdbbGurrA9ajSjWEdQbRZremE5MprgL3yJ/TuZmr8BKGnqXoDrKttA+yZS6bpGIrCqQvC2K8W4nJzMzUCb9wp3uOqVbV6utMoh4wHEoljqFq1Kp06deLcOVENoVWrVrz11ls888wzLFq0CACDwcD69etp2rSpxQBGj7+/P7169SIxMRGAGjVqMGvWLLy8vMjMzCxSf6pVq0bv3r3ZtWsXAPv27ePs2bMMHz6cOXPmFLS7evVqkfIk5+XlkWv+pDIjKCiooM96EhISCCokT+qZM8K1s0OHDqxbt65gv1pELygoiKtXr1qcN2jQINavX09KilYlsOA+eVo/Og2Bvr0T+HGxOH7jxo1Cv4c1stLT8bXh6Vq9flixr1cYqgE2KQV8vaF9C1HlGODvA6JCcs1qooCMRCKR3OwUpq/njy9i3KMQe9lA887W9VUttgCAiz9c6cWvvyZy4jB89FoN7uxUfvrq4wX5+XmQn0v3u2HO/9lo6BpESkoigQZRDOTwSbFbr6+x8dCsgdgflwgvDoFRUxyvr+Y6n5CQUHC8uPp69jI0Dxefxz0t1t5eolowaDn8ipQj9yZl0BvQtQNcLKTa9G3dTD2oL18Vlb0BpxbhkkgklZ+bdQxrMIhJvOzsPDw8LMewU16Byd8YPWBdgyAvkdBg0zZZmQl4GLWvWbiWY1vFGWNYvca6ukJ6esk11lGcumC6HZtQuYtwgWWu1QZ1THPAurtDjg3Tx+mL4m/jXgwH1fkroVdX8DfmjnVztfTCvXIN6tYs+jUdgfSAlVRaLly4UCBcoD2Qt27darHPXihGRESEycP3+PHjRTpPz/Xr1wuEC+DSpUvs27ePO++806Td+vXri3S9kSNH0qhRoyLfvzgcPXqUnTt38vnnn9OuXTtCQkL4+OOPadxYxNrnW4mfu/POOwkPDzcJ3bBFcqp4oAEE1QilY//exe5jVlo69W5vjre/FkNpQIwMb7//XgJr2JgaLQFqiEzVADh32fTYPwfE+rM3yydJt0QikZQ1hemralzy87Ctr3oP2EOHIug8SOhrXCKQVb766uMFyadHcmlnI2pXL7xtbIKYmCvsuBqo8d0v0LE1JMc7V1+Lw6JfLfedvQz165gWS1ENsqDtzzJ1LrqlOH0BfrBS52bQ62IBYZzd/I927PI1MYELzk1BIJFIKj836xjWYBDPv4STI9m10nIM+94L8OowYYBV3xFqmHl1XozSPjeshwXOHsO6ulSMZ7i54Tnquu0IjIpGWC04txnqmaWR8K9iut2tEzxyj+m+wjxgoXiFuJJSxTrAmB7IPAUBCO2uW6Po13QE0gArqbSYe4SooQj6/eo+W+EI9q5l7zw9MTExVvfVrGk6rXL9+vUiX9MeCQkJBAQEWOwPCgoq8JCxxfDhw0lPT2ffvn3Exsby2GOP8cUXX5CdnU1cXJxF+8GDB5OcnMxvv/1m0QcAXEQ/1MGbOqv4+MT/MGDi27h7aWEsD73wnN3vdm7fQQDCWluvQhkQ6rg4jKuxQmy/WAR/7Bb71DCHA5EiP83Tj8PARxx2S5v4+RZvdq+i8cf2RP7YbumVLZFIKg9F0deQANs6qfeAPX0ukV3icU5CMkD56quPN6Rnwqot0KKh0RPHGnkJ+PoGsO1f0916fY2N13LKLtso1qMHOF5fzXVe1Vf1eP06MLwvVDULGjGfUASRgsDLU+Rku2aM6vh6gnZc1XBPD8uB8a3OLxvEYo1LOocrZw7epcZKJJWfm3UM62IQEQB/7NbS2Jy9JNILNHhIbD/1qGiXnJwALgEWHrA7DwVxMUpoW4iNYE5naqyrK3h4mWpseXBcZ4D1v0O8bzS+Teh9YbRvAfG7oXpw4e2cyfC+op8j+oltNa2POc/o/LPU95U8G/p5+qJY1yrGe4k6ga4afs1TEIAwwNYx+nSVlb5KA6xE4iCqV7d0palevbpFGITiwNi0EydOULduXXzMilXZC1cBOHv2LO3ataNBgwY0adKEli1b4unpyf79+y1SHxgMBgYOHMjq1astwlkK7uMp8uh4eWh9iIuLI8dVjOa8fMWUlVcVX/yC7Sdb2febGM3WatxQ1w/tuKeaeM8B5OdD4J3wzgz4e7/Yp+bIy82Fug+Iz/ff5bBb2uTQaljzP+ffx1lMmXGFKTOu2G8okUgqNTYNl5h6t+jJz4eU1OLfy5H66uMF6RkipYCvjyg6ZZXsE1QPrcvx80JfmxpTDej1NTZe+x3OGAcHIUGO11fznO6qvqqhkVPfhPkfw7uj7X79gqKTX0/Qcq/d1VrTV53M0rSSeNtUBC5ZRrw6BamxEonE0ThKYw1GA+zZy8IL0sVFbP+0TkQbLv4VWjYWtTbSkk6guNel70OmY9hGjZpy8KDQPlsGWGdqrKsLBIWYamx5EKWzdefkwuo/xGe1OJmnBwTp5mY/GgdfvgdjnhT7H7u/7PpqToqxNI3qrZpoNITeSICEJOvnzF8l1t06Wj+uGmjbNLN+3BrJqgesaoC1koLg8lUxee3jXXb6Kg2wEomDCA0NpVOnTgXbdevWpV27duzZs8dp99y0aRMAffv2LdhXs2ZN7rnnHjZssOGmYcb58+c5deoUwcHBDBw4kLlz51q0uffee6ldu7bV0I3z588Tdfkk+A0AoIqvELsBAwawYcMGsozlMD2riKewwcW1SP3KTEklPuqqiQEWg4EcY4WQLkMGFMmQW1RS0sRLwsrNlscSkkQy9KGPiRm9R+4R+eEKM0CUlPp1oMe9psbmklCjGkz/j5jJlUgkEkfg5gbd7zbdV9UyCKPQEL5kMwPsv/8ncqcWhiP1VfWAPXJKbLdqbKNhmtDXfF+hr3VCLfW1ptmY9dxlrSgXOEZfT548yYABAwr26fVVxcMYNXFP+8K+ueC4iGrl8QegoS6duhqip9eeyhLuWBHYbfTylvlfJRJJZcNRGmswiOiXs5fE+MOsljKfzxfrts0h5brQ2NuaWo5h167bQGYWBFsvBVKAMzTW1dVAk9YDijyOLivU2iSq0fXYWuHp2qmN2J7wIrw8VBi4oXwLdiUbDbABupQD12Lh/mFwQ+dgqtfLiCNi7WUj/7xaILQ4FCUFwRWjobss0xBIA6xE4iBiY2NZvHgxQ4YMoU+fPqxbt46YmBh+/PHHEl3vhx9+4PTp04W2iYqKYu7cucyaNYuhQ4fSvXt3Vq5cycWLF1m8eHFBuwkTJpCTY5pU5eWXX+bJJ5+ka9eujBw5kj179nDkyBGr4jV48GBiY2PZvHkzgf6WIfLLf5oEAc9C8Ht06nwf8+bNo1GjRnz66adkpomnsHeVKhbXtcfVU2eoqTfAQsH1br//Hp767MNiX9Me6qydOWrY5q6fYcN38OdCYSh1Fm2LMcNnjblT4PXhcO8dDulOkVm/tDnrlzYv25tWYurUqcPWrVs5duwYR48etVpVtmvXriQmJnLgwAEOHDjAhAkTrFxJInE+bz4nXvL1jB9h2c7NzXYYWZKZAfbOVjD7g8Lv60h99fGCGi1/4P/WnCY/Hx7oKAaNFhNquVH8tmYuY16dBf5D8Q621NfDJ4DgCdBE6GtahsgDWlJ9tcakSZN49tlnee+997jvPlN9Naddc1MDsDWiroN/B4gxRmmqg5pLW+HvnzQDbGaW5vUrsU92jghldLb9VWqsRCJxNI7SWNXjtf/wH6DBafzMDLDHzmiak5Uexd9b50J1obGt2plqbFyi8IB15BjWGuYa61pnHlVDrGtseSJSOEGg0ZioRmrqi0EC3HG7WJerAdb4nqf3wj15AY6eNtYCMKKPlNq+F4a9DX3GOr4f+hQE5u+ml401a8JqlZ2+SgOsROIgLl68yJtvvsmkSZNYunQpKSkpdO/enaysEkzZAK6urrgVoerTuHHjWLhwITNmzGDFihXEx8fz8MMPm9zXxcXF4lre3t5MmTKFjRs38sEHH7Bs2TIee+wxi/ASV1dX+vXrx4oVK8jLy+PsRlg63bQPe3YuhWsvQMBwPvzsd1q1asWjjz7KsWPHyDR6wHpVscyabXAp3M0z+tQZajRsQJ3mIjTEYDCQnaGVS6zdzJbrUumwVnxkojEtQGiIyBkLIoTGWTxd/LplJqheaVt/LHVXioW3lwveXlJaikpubi5vvPEGLVq0oGPHjowZM4ZmzSyt7zt27KBt27a0bduWyZMnl0NPJRJMilYtWSvWATbm1mx6wNqY5CoMR+qrjxfk5bvi6upGVjaM7A/JEXB8nWXbWdPGseSnhVB9BtS21NdffgcMLmAQ+ppuNMCWVF+tsXTpUl544QWGDx/O77+b6qs5bm5wVyv7v0FKqlZASg2d9/OFzm01A+zVWHj1GedEetys+HqL3IbORGqsRCJxNI7SWDUFQVqGKxjcMB/65ebCIWPmunwFXh43DpKFxr7yjqnG3kiAkEDHjmGtYa6xeLZi8TfWNba8cHGBRKMBdt5/4Z+fNU9ONU2DGt2i8th9Zda9Alo2ht7dRMoEEI5L5tzQpdU1N3MsXGNqoDXn3qehSY+i9yc9Q/xOJikIzDxg1dQG990Jd7d3oXnDstFXpTyWiIiIcrmvXOTijGX+/Pm3zL9pJVIs+n1P9xb7GtS1bD981qfK9CO7lNsf6KoAire/vzL9yC5l+pFdipdflULv1ahjB2X6kV3Ki3P/pwDK899/qbyxfGHB+dOP7HLKdwzwQ6lRzXKf+t3nf4ySvBdl5juOv/eNXeIeEctKd53Da7T+urqW3b+PbatvV7atvt0h17pV/k/pl9WrVysPPvigyb6uXbsqa9eulb+dXMp9mfmO9lzp1gnlx09QLvxh2sbVVRx//0Xr11j0GcrZTdq2NU3RL47W173LUX6dLT5PfVO7v74P3TqJ7S7t7PdRPeZfBeWP+SjbF5X932XN1+I3VfVJ7deksbbPGT1QtLnwh+lvEF5PrLctEOvGt5X/vztnL+pvYa77xV0OrkJJP+DcvkqNrRiL/O3kcrMsjtTY9XNQdi8Vn9MPoOQfR0nbb9rmfxPE83bfChSDQdOeJx81bbdlHsqOxSjNwoUulcVv4eEu+vLO6KKf4xsUqEw/skvp0KeXw/szbbzoj4e76W+lRIpxqBKJ8vFrou2ZjabHC3uvctai3rd/d9M+bP0R5c+F4vOPn1j2U4lE8fZyTp9u7EL58j3xedNclJ1LrPf7m4koSvTtihLtfH2VU6gSiaTI2HLIdTU+ScwTWwM2PWDXzvgfmXaqsZzeHcGJnbupUlXLwp5tlkDdGSSlaNWh9ftOXdC2L13VEqE7g9ZNrM8cFhVfXRjq5+NL3x+J8wkLC6Nt27b8+++/Fsc6derEwYMHWb9+Pc2bWw+PGTVqFBEREURERBASEuLs7kpuQdLSTbdT002fNaB5TNpwNiEu0Xpet1qWNUCcgo+XyAELMG1e6a834Uuxzso2piDwgWbhoiiWeboeZ5KYAqlpUMXHfluATX+L9U9mnr+qB+zW3WLd3DQLkKQQ2vQFn7bl3QuJRCIpH1xchIUJRM5Sg8EyLY46lrq9ISiK5tlpzg1jCoLj6+DMRmf12BS1boatFErWCK5bG4BOA/raaVl83vocvFqLFDfm+cVVrVY9YL08rUdwlgf69Adq/lUV1QNW7wnrTJJTzXLAWnk3/fdQIQVZnYA0wEokdjAYDLi6utpcbiW8dQbBCS9pn1XDrLUBd1a6GLE36ngHgTVCC/bnFlElbly+gl9IMAAGDCh5+WRnaEbYsNa3F7H3pUdNED68L1yMFgbYerWgz4OOvc/FaDFwb9+i5NfQD8Lval36Pkmci6+vLytWrODVV18lJSXF5Nj+/fsJCwujTZs2fPXVV6xevdrqNb7//ns6dOhAhw4dyrVyq+TmJS3DctvcAKtOyNlKQRCXJF6GG98GU141AK6AK1UDy0ZffbxFWBpAbLyozGyPUxfg163Wj035BgzNxMAnPVMYeGf8R+hE1w4O63YBfr6weyl0aaftUwdi+yPtFy1RuRAFHq3gy8Wm+9WqxVExYt1M5oGVSCSSSklZjGHd3bXCUGoKAhDh4hmZlmPDLbvE2sNYbGmjcTLQvDtqDtiyxNXOBLI1lHzxhe2l1SsJimJqVE1Lh13Ggo/q7VTN9/SAfw+bnl/WKYRi48W6VRNtX+8H4P67tG01xYBauNLZBPrBM73Fb2EtBQHAuSvQoE7Z9AekAVYiscu8efPIzc21uYSFhfHss8/SoYMTRloVDG8v7fNbI7RZzQLBsjLgzjaOdO94rAePvVH8zNopcfH4Bgbg6u4OBlAUhRydF2yv114q5GzHMn6aWCcmg5+PyHVz8Q9Y9ZVjRW73IbHuWEzDqYuL6M/wvqbes7fVdlzf7LFuUzzrNsWX3Q1vAtzc3FixYgVLlixh1apVFsdTUlJIMxaf27BhA+7u7gQHB5d1NyUSSwNsutAF/fPPpRA9AO3le/FUeG/SPGiaC01zOXKybPRV7wELsOeI9tnWeLRJD+g9xv6104weweejxHbT+iXvpy1uqy0m1XYugSceAiVSFLq4vVHxB6w5OZCQZLqvhdHjNSMTLkULb96bndBKFDAgNVYikRSVshjDzv8vxO8W+mkwaJOvqekQ0hlq3GPa/vRF02014jDEbPLwRoJWz6KsKIkHrGL8woYysHb6d4C7nxLjUPV2quZ7emj5dVUe7OT0Lplw8rxYt9KVaFlgrGWmTkirnq++ZtE65h6+jkKdHOjaQTiMWfOAPXfZGNWaHQ/Z8UWOJCop9iv8SCS3OJMmTeJ///ufzePR0dFO74OLixC14szIOQMfowH2k+/gndHQp5sIX3QzCpa1WSU1ZcClo8cLPFmLQ8oNUarZz5iGQEEhOysLNaGBp7eTn5I6rsbCnQPhehxMfAma1Ifqxq8U6A/xhSQOLw4xcXD2Ejw/CKbPL/p5nh7CI3f+x/DPAVFQBUQoiN7ry5lMn+38/w83G3PnziUyMpKZM2daPR4aGsr169cB6NChAy4uLsTFxZVlFyUSQBjl9KgGWV9vSDEW17LrAWt8Tvp4AzcmQYLQ15enaJ4dKs7QV1+zZ+GewzDIWNShaoDmwVES0jPF9U9fENtNneA9qh88DNdFPHq4i4FNcSfusrKFIVZNl7DoM7FWFIg8B81vcgNsr/vgo5fLuxdFR2qsRCIpKmUxhu3WUazvaiW8MvWGtPQMy7FHTo7p9jVjwFaNaqb7bySUvQdngQG2OB6winjZcTE4v7Pqe9Wlq9r7RYEHrLsweuspq9ROKrFG42pLnQE2NQ2TYmw3jO+A/roCrvcPg8yS1SwvMi0b205BcO6K8R0oQ/x/qB2qGZOdgTTASiR2uHjxIhcvXrTf0IkcXgN1a0DtrpYP17JE9YA9dBKuXBODlp/WFT5jqFakTLwWQ7Ww4idYSbkhRsNVgqtiMMZZ5hitAHm5uXj5+do81xmoaQhGvC/WSqRYhwQ6zgALIg1Bh5bFO0f/0uPjZXqsQR04err0/ZI4li5duvDMM89w+PBhDhw4AMC7775LvXr1AJgzZw79+/fnxRdfJDc3l4yMDAYPHlyeXZZIClD1yNdHM8Da84BVw85cXYCci2IBYqJh3z7n9RW0fHR6D1h9bu9hfcQE2NVYi1OLRFqGuH6GcSDhDA9YPY/db7qtVo0uLrbGjZHn4NVnhMaX9wSws6heVfvsdmtllZJIJDc5ZTGG3bwLnn4c3nzONAVBYTz7rvauoOptDbNIBPMcoe7ulsZbR1NYTRNbqGNTZ6QgsEX1YDHpCkLzDQaR0sE8u595/l1no/5++ohZ1fiq9k19V9RHZ/65x/l9ax4uxtVr/rA8du6y6XbdmtIAK5Hc0hgMWkjgg51h9Zby64tq1EtLh+17YXBPIQAFgmXFA1YlPTEJ3xLkay3wgA0JNio75BinybLS0vHyLVsDrC2KmnfPGm5u4jfUC+f67fBARzFDmFx4rTKr1K1put0wrGwMsNtWi7/x/X2OOv9mNwF///13wcubLb7++mu+/vrrMuqRRGIbc28UvQesijohZ8sD9mK0mKzKMdOLgCrW2zsSNTWL3gB78oL2eZqxYOHxMyW7flqGuIc6DnOGB6zK/JXw7BOm+24kiEFqcecl2z0hJnr1KIi/FQjPkYORJe5qhUbv1R3oJyaXKzJSYyUSSUUiyVi2oO+DwpCWXwQD7I+6bFs7jBOv67ebtokzc2oJDrQskOxo3ErgAeuiFkKx8y7vSPTjxeBAEQEJwotUrVECZfNepcdWsW6AAGMKAtXgXtYTnvfdKdbWClyfU2sBBNzO9Rvwxy7n6qvMASu5pTh//jzTpk0r2J4/fz4REREOuXavXr1QFIWwsDCHXK9Zs2Zs2bKF1NQ0CI+CkA/pea/9/7LNmzdn48aNpKWlERsby+zZs/E1M1IqimJ1ycw0jS/19/dn3rx5xMfHk5iYyMfTFoNLVTKy4NdtYjDepL6uCFchOXPSk5PxCQwotj6lxAkPWP+QqgV9z84Uo/7M1DS8qlRuA2zdmpD4L2QeEjkRVS5d1Y47oj/hZVjdUSKR3JyY50hVDbBVfMTL7ZUr5/lostDYvHzbGpuWYakX5pVyzXGExqqTiOkZmsYePKZp7MgPXPhjNzRvaPsahWmsGmr59U8KNFWo3dW2xrq7uzN16lS2b99Oenp6QbRIUfl9p+U+dcBa3MIlqkeKHkWBP4zFUpo42ZO3vBj7FPw8Xdu+xeqqSiSSSkZFH8f6eGkesKrGpqWlERUVxYcffoiLlZwC5y6Dawv4v/ViW9XYVZvSoGEshM4Gg2+BURFKPo7dsG4xS7+oajO1QUlywKrFzOw5UziSb5dqn93ctEiOrByRux0gO1ukxytLCjOqqkZj9T3F3jufo1C9ptX3mFVWHNmuXNP6l53rvHy0KtIDVnJLM3nyZLy9y9g/vwgEBgayZcsWjh8/zrCne7Ps63CoPp0nh7tw9tIEps2z7l3k7+/P1q1bOXXqFIMGDSI4OJipU6dSs2ZN+vbVksV17NjR4ty1a9fy999/m+z75ZdfaNy4MSNHjiQ/P5+vvvgMQlaTkXkvx4zelC0aFq1qZHpiMm7u7nj6FC9nq2qA9QsJxmAwCAOsMb4zMzWVqrVr4uruTp6z41Ls0Cwc1v1Z/PNqVtMSketz96kG2Ho1KfitS8qNBJEPtjj5ZCUSicQc8wi7NDUFgTdsWwBU19rk59vW2LQMMB+qOPNl/KHOIjyvwLPVVdPY3r17s3mR0NjbWrnQ6/kJZB6yfh17GqsapL/+pCNjhojPr30qctuaa6yPjw8jR45kz549/PPPP3Tr1q1Y38naAOFGCQ2wyTYMsKcvir9jk9uKd73KQJ0a8NX7pvvOXCqfvkgkEklJqAjjWL3d0ctT6Lt+HNu7d2/Cw8OZPn06Li4uTJgwweIa6pjWXGPnfxZMSOOp4FaTWtVLP45duugzPO9fzaQv7uXEOcvvUpTxrDmqB2xZFOFSiTHLVa8WkszKhjemwtLpYmK8zD1gXWHHXrjnDtttzAt/Opvte6GbnWJk+fliIqBZtcLbOQppgJXc0pw7Z+XpW84EBcCbb7yAt7c3TzzxBCEBKZC4hSNn/bm90yQ+HT+VdX+lWDXKvfTSS3h7e/PYY4+RlCSecHFxcaxdu5b27duzz5hg799//zU574477qBatWr8/PPPBfs6duxI9+7duffee9mxYwcADWtFMe3rPbRs2435i/4gNxdaNNISZxeWMyfN2B+fgOJNx+Xl5JCelIxfcFUxYs9XyMkSM5yZqWLU6O1XhdT4hEKu4jxa9Rahm3cWM1+rOYdOQLMGkGI0aFzWGWBLyvhpMHMBfPwavDVCFE775LvS9VMikdx6NKgHLw2xLKaRqjPAqqiDsbw82xqr5krV46yBQrvmsGmu+PzODLHucr+msSkpQmNx8ef11ycxdepUDp9MoVUTy4hCexqbliE09trlf8HoiJOfDnl5lhqblJRE1arCbWXMmDHFNsBaQ82ZV9yIDFsesJlZYjLwZvSAvbxNDLrUMXOTHtqEgkQikVQGKto41stTaMcLL5hq7JYtW/D392fSJKGxKSkpVs8319jzz0AVzzi8wtfSpVN7Vm0u3Th23+YoOvfdw8B+3fhommUy0KGPi3WxPGCNbp/WvHudRYxZHd5QY0HorGxRqyT8YTi5QUxsVw2EL9+FsVMgMdm5/XJzs0wvZY55nlpn0/dlGNEfZr5deLsLUdCsXdn0SaYgkNzSWAvduOeeezh48CAZGRns3buXTp06ERsby8SJE03aTZw4kevXr5OcnMyCBQvw9y+9n7+fL8Tvhndf78H+iI2kpKRQxegd+dXspRhcfMCnKxNetH5+mzZt2Lt3b8HAEGDz5s3k5+fTq1cvm/cdMmQIqamprF27tmBfjx49uHbtWoFoAVy5EAHZ57irUw+yc4R3TNtmUN+YSLtwD1ijATYwwM6vYElOVjZ3PzmA8PZtURSloAhXZpoYNXr6+tKoYwfqtWxe7GuXliOnYNu/IiF6abh0VXhoqQP+azdE2ERpDLAJyeJv8p/PhQdWz3tL10eJRHJr8vZIeGM4DDGTkYIcsLrABrWgU75iW2ObPHCQJt0z4La94N0JGsZy7yPO0Vi9ofdBoxdEy3Y92Lhxo8kgMPnqUnx8fOjatWtBBEJVM7myp7GqgVotjgHQ+DbrGusMSpqCwFoAiephe/K8+A43I2VdYVsikUgcSUUZxyYkiTog3p5C+3v0sNTYpUs1jbWFNY31yt0MSj6d7i79OPZkpBjHDhnYw+p1prwi1iXygC3DFATmHrDD+oi16hAFIjdvaDA80xueegybtgNH4uYqnLHMc8a/N8t0+8UPoX0/5/cHxATzrAX2PW8vRJdNf0AaYCUSE2rWrMmGDRuIj4+nf//+zJkzhyVLluBjFjY/btyLeorbAAAgAElEQVQ4PvjgA7777jv69+9PRkYGU6dOtXFVUxRFsRBBlYLCGR5NSU04AVBggL1w4TKZmWng0ZSuHWDLPLj/LtPzvby8yM42nVrKzc0lPz+fZs2a2ezTwIEDWbNmDRkZmntT06ZNOXHihEk7H28gO5J6tzUFhPGxV1cxs2SPtCQx7eZbTA9YgJhzpqUIs9UiXEYPWK8qPrzw/Ze88tPcYl/bEcTEm1ZSLgnqgF8Nf8nPFy8xg22/b9hFP9O59yi0bur8HPG/rLnBL2tuOPcmEomkTFELE5kbJPU5YFWqGA2e1gYwqsZmZcQTf7w/JMyBmkvAxaegiARYaqwLGXwxs3Qae/aSlualVl1TfQvpBHXvvkxaWhpNmzYtqH5r/n3taaz6e6jf5UKUMF5a01hHsvoP+OeA5gFbXAOsNfQG2GZOLCYmKR5SYyUSiS3KaxybmweXr2kesNbGkJcvaxprC3ONrR0KKLlAPnXDSj+OPXkeyI6kWg3bfYDiesCWfRGuWKMBVp30rVNDrPXepf5VhJ1g4CNiuywiWVQD7P3D4VGdwffjOabtvl0K+4/DlG/h65+c3y+AY3aKq16IArJucPG88/VVpiCQSHS8+uqrZGZm0qtXr4KHeFpaGkuWLClo4+Liwn/+8x/mzJlTkMdm06ZNbNq0iTp16ti9hzpYKxTXIFwRrizqwDYtA27cSOD8sSDuCYMaIdCmmRg4qpw5c4Ynn3wSNzc3cnNFDED79u1xc3MrCHU055577qFOnTosXbrUZH9QUBCJiaYlKL09gbwE/PzFaOw/0+HQKfjvK3a/NhlGA2xJPGC/HTWOl+bPJvyOtqCAh7eopJJlVB4v3/ItxBUTp4V/FIfhfbUCZqoBVu+Rk5cHwcX/uQrQp4Q4eEIY+BvUFYYIZ/HN/ApeQloikRSbdGM4vd4g6epimgNWRS36YE3mVI3dvqoXXdpkgDugpEGtJQWVaa1p7JevbqJalU1AyTX2t79g3NPis18VU31TPUcTEhIICgrigylCc39aZ3oNexqr/k7exu9y6gK0bnsPoVY01hGoIfRD3hCeL+r4724HhNGpKWYjzwkP53n/hefeK/11Kyr6CYCKjNRYiURii/IYx6q6cyEK2rcQBlhrY0jQNNYW5hr7wHA4sbU9GNzw9y/9ODZfAfIS8PAqfFYxqBi+Qi5qES7zJPlORPWA9fGGRb/CQ0ZbgN4Aq76HdGoj1s7I5f6/CfDcEyLv7Dc/izFtbq5wAPrtT9GmsLQHE75wfJ9scfws3N3ettZfiAIyr5FeBhkNpQesRKLjzjvvZPPmzSYzaKtWrTJpU7duXWrVqsWaNWtM9q9cubJI93B3d2fy5Ml221Ux2hTV0E41116iLm2Oec6877//nmrVqvHVV18RGhpK8+bNmT17dqFG3yFDhhAfH8/GjRvt9kkN5VQvdSEKPv7W7mkApJUiBQFAWoImonWaNQEguK54UfDy036IsgwBUYmJF7l73d3tt9Uz/2P4/iPxWa1a6aezJU+dK7bdijlV9uUikft1yy5tnxoO0qbwSd9S4+3tgre3lBaJ5Ganbk1dCgKdAbaqceBizYNE1djklAwtTD9FaKz6UmxNY+vWAFJKp7G/74Q9h2HjTs24aIv0DJj4FWSbhebb09jbjOl42rcQ65PnIbR+0TW2KMz/WKz9fKH7KPh1qzboUhThGdPv4eJf9/0vhCFX9aJVPWB//k2s69sfl1dq/Mu4WElJkRorkUhsUV7jWEWB63HiOVqaCAxzjXX1bg41ZoOSi5dn6cexBd/BzrjKmOmuSLgWpCAou+eyOvmdY0wHWMNYPEpvgDUvrtkwzPH9GPMkeHvB7A/g6w80D1iV2x+HJj0df9+SEGlMl2wrpdKFKAAX6td1/t9RKrhEoqNGjRrExMSY7MvIyDDJYVOjhvDzN29nvl0q8hKoGiQMlVV0BtigoCAuR2lTM+aGuZMnTzJ69GiGDBnCtWvXOHz4MHv27OHgwYNcu2bpNeHq6kq/fv1YsWIFOWZJ4BISEggIMDWWensCrkHExRV/eig9WU1BUEIDrNGAq6Cw77dNALgYZxv1HrC+VYtZfcQBXDdGK1QrxUtHUqrlvqgY4d1UI6R414qKgdc/NS0ocuyMMJw7Ow/s+p+bs/7nss/FK5FIypbYeNMcsOLlVfO2sJaCQNXYtAzdhJWSAXkpeHlobcBUUy9dBfLEdrPwkvU3KxvuGgSPjLKubyA0NiHBtr7Z09gde4X3R2sxR8jZy67g149dOyw1tqTUqi7WdUJhyz/Qe4xmLAUY9o5mRDU65hSJ/34LS9eLQTRo10xKgU1/Vx4P0ZKiemBXdKTGSiQSW5TnOPaycZjZrrljNXb+T3u4FnUQT5drFs/p4o5jxUlBuBus9yEpRUQJqhOPRaHAAFuGHrAAA1+D1n3hzEVtX5buJ0i1UlSyuOPJ4vDSEDEZn6srwnXstGXBsPLiuDEFga3aKheigIDmhLdwvr5KA6xEouPatWtUr17dZJ+3tzd+fn4mbQCLdubbpSL7BNVrCldF1QDrH1gHX19fIvadsHqKmxvc3ggWL55PaGgoLVu2pFatWowdO5aGDRuye/dui3O6detG9erVTapGqpw4ccIiT4+PN+S7W+bUeXcmBTnzbJGfm0dGSio+gSVL8q73gL1xUcTQq169XlU0A2yQ8cWiLFFDQcwLcU1+BaaNL9o1FAVizd4Hoo3vQrUc8E8rK1uE2aoeWhKJRFJSbn9ceF7m5YnQd19vzRirkm/FzVTV2LR08FAnEA3e4OqHp6fWBkw19WI04Cq2N3xX+v5b07c6dYTGmuubOfPn29bY81dE2gE1ciWwRjdwq87+3ZYaW1JOGbXWlkF0w3Z4/TPxuWkJcr6pnsl6o25osBi0lEOAidMwr8RcUQaJEolEUlLKcxz77kzxXN2ww7EaO3LUWPwCG0LGbtqapYEt7jgWAI+muOadMIk4VFEUWPunZfSLLdr2eIj+H/wHEKkdypJlv0PkWeEBq6IvwpWSZnnOc/1EXtj77nROn3y8TT1gKxJ/7IavFmvvR+ao7wDm77LOQBpgJRIdERERPPTQQ3h7a/GUffv2NWlz+fJlrl69Su/evU32P/HEE47rSOoGQup0p0qVKgWhnT0eHUR6ejqrfv3L6imTx8GRX+GT1yArK4ujR48SExPD0KFDcXFx4ZdffrE4Z8iQIURHR/Pnn39aHNuwYQM1a9akS5cuBfvCGrTHxTOcDRs2mLT95DtoWoQQg/SkJNp07wZAUK3iGUpVD1ivKr6c2h1BVno6m7+dB4CnzgO2Tgsnx9hbQX1omxfiev8FePO5ol9nw3bT7ajrYl07tOR907N2GzQvofeYRCKRqBw7rX1Oy9AmCvX1qax5wKoam53rrXnA+gmNVT1grWns5WuAX8k01prRcMOGDXTvLjRWZdAgobF//WVdY/UUprFROieiOzoPgZxozp/6s0R9t4Y6uCnMIzXiiFh3aFn860eeFWv971Y7VCxqaoWbjZaPi6KiEolEUpkpz3Fsbi74tIWeox2vseACyb8w50PTdsUdx9YJaw8e4ZC6oSBsvzTUb9e6oC5JSgmiQx3BGV1djxyd96m5B2xSinDo+flz2LbAOVEf3l4V1wCblwfj/mvqMWxOxFE4dNL5fZEGWIlEx6xZs/D29mbdunX06tWLUaNGMWXKFNLTtadYfn4+U6dOZfTo0Xz00Uc89NBDfPvttzRrZrs6o56cnJyCpOcgwjA7tTHLH5r4LQayWLlyJa3adoOAUbz77iRmzJhBUlIK12KN7Rqc5ocffgCMCcNd/Bj76qf079+Thx9+mE8++YQffviBcePGWYR8eHh40KdPH3755RcUxdJVaffu3WzcuJGFCxfSt29fevfuzSODlpCVtIM//vijSN/VnF3LVpMUIzof1rJ4I7lUY/99AwNJS0jk3bu6cXbvAXJzcvD28yU+WlSx8vEvmYdtaVA9YENthHYU1WtIFVFVFAs8YB3wkgBw8oLIE1QOWRokEkklpXVTGPuUtm1uWE1LFy/1zRqYer1akZUCjR00eh349oKAURAyBfLTcXERz1BrGtux+7fgUTKNtdafb7/9lqwsobHdunVj1KhRTJokNFYfqnn6tKaxAH5+fnz66af07GlbY9WJMwwedH2gD6T8QtMG1rPOPvLII/Tr1482bUTehn79+tGvXz/q1atn8/upv39hg6eT5+H8FRg/zXYbWyQb0+HovYPuHCjWbYr2J6gU6KNFj5623U4ikUgqC+UxjtWPcdQaIY7W2DFjxxF5OgEfL+1eJRnHDhm1BNJ3QPofDgnHNxgMpMTFc3TrX7i4lo9ZzVaRK3MP2FMXoUl9bazazgmR9oF+pikIKhtp6WXTf2mAlUh0REdH07NnT0JCQlixYgUvvfQSQ4cONREuEAL38ccf88ILL7BixQqqVKnCW2+9VaR7uLm5mYQpjB4A//wMLw7W2lyPSUS52A1XV1eGvLCW/JAPmTlzJhMnTgTg3BVjQ4Mbd9yuS/Km5OHp35alSxaxevVqunXrxoABA1iwYIFFP3r06EFgYGChlZkHDRrEX3/9xbx581i4cCGJ1/cRta+vzfb22DZvMT+9LaYvDcUUqrQE4QHra1bEKzMlFU9fX7LTRcxAleBSJGItIWoO2OpVxYvIg51Nj9sSeXNxPGs0wKrFTm4kCI8yex6wVQPhtzlQ087LhOox1bdb4e0kEolE5eAqCKulbZvnFU1Nh7taiXzVHu6QZHyuNbJS8EHVWG/fEKi9AoJegqtDIV9obO8HRDtzjfXwqAKxmsYWFulnrrHWSExMpFs3obFr167lww9NNVZ/LVfdF87Ly6Nt27YsWmRbY6+oBljfHvj5BULyUqu/BcA333zD8uXLGTlyJADLly9n+fLl3H///Tb7XhQPWEWBBg+JEMXiouYj1xf5vBAlvGecXcSxLCnjaFGJRCJxOuUxjgXLCVdnaOyWXUZnIyMlGcdeubgPosQ41iH5UI3W59ycXNw8yj9Run5i0cIAex4ah4FxOM3tjUp3L1vORRXVA7YiUcza2hJJ5aZ+fdOEaM8++6xFm7/++ovWrVvbvdYHH3zABx98YLLPWg4acwxmTyxj5AIdboflxgKOMfEQGhLJgH7d+O8r0PdB0N9q3Z/QuS1wtj5Rh7T912LS8c/oTk4OBNrJ77JmzRqLvpiTlJTEc889x3PPiTj6lV9BeF27X7FQ8vPFk9nFpRjVQdBywOrzvQJkpqWJfcbv4hdc1eJcZ5OaLipmVg+Gkf3hu4/g5Sna8Y5tYNVmbXvzPPDx0maKVVQP2IZG5ydFgas37OeAHdRDFNd6+/nC2x2KFGsTb2sH8+NSBxajk0gkFZ60DK2CvMv5+sz6GiaOEQZCWxr77rjWLPhU25eXD3k5pgW29Br79QfQeAiQLDS2bg1jXlgr2NM1lcjISLp1K3w2yvydIT09ne7duxd6ToEHbOoaQkMM7F5qWhCxsOsXBXVw4+WksZ7qAeuvM8AqigjLu5kMsJU1n63UWInk1qUijmNt4WiNTUiGQH/x7FaUko1jx4+Atm+KY+YG2C/eFdcvDgaDAUVRyM3OxtW9/M1q+hRIs3+G4X3gpY+E16uHOzz1mMgZGxRQegOseSHwbf+K/LKV2QBbVvoq538lkgqCfuCpzynq62OZx2WOLp2rPu+oAkz8CgL8TAdPjsLbUxgaS0N+nrA6FtsDNjHR6v6s1HRCG9QvEGG/kGCr7ZxNeia8NQIGG3PhfvW+dmzll5qhHeDBTkYDuhmqAVZfKCvquvW2ei6J7AvUt1Nga9sesfb1LrxdaViwNIYFcoAokdwypGVAHV1Kb/Xlu7CJHvMiBwYDxCXYNvCZj7HesBxzVhgKDLC6bUfl8QbhiQqmed8ciXp983eIA8ehdZPKa7g0p7J6wEqNlUgktyLxSeK5HeBnv609cnJg6GOaDri7w7inS3AhAyj5+eRVEA/YghSFwPEzUKU9LFwD0+aKAqGgRSe1aFi6e7np/KiiY2Drv6W7XkWgrPS1kr5+SCQ3H/pqxWpO0UZhoriJuQE2PhEMzWD+SlGdWM+FKLF2RrV7H29haCwN+cYEdq7mcax2UFMQmOPi5kpAqJYktTw8YEEzijfQeQjrcyWqaQX06AeABoP4uwJs3Kntvxor/h3Uq4VNVKO4tXvoSUmD1DTNGGAwmBqGHUFwVTeCq5b/LLBEInEM5tXizVELcKnkGKsHuxXyiLdmgPX0hHvaW7bt9zA8Z1YbxFq7isIVcwNsjGMNsOqE25RvHXdNPWu2ivWqLab79x2HKr5wdwX+7YtKZTYiS42VSCQVibJ6nKrDwKoBhbcrjKlG71d3d7izFXz6uti2lrO+KLgYXEBBeMCau4SWIY+/BO/NKryNaoBVsecB++h9cF8h0bT6d7zgQGEgB9P88ZWNstJXaYCVSIpAtWrV+PDDD+03LAW+PiIkAETxDBCh6NYMsCrX40TYux71XEcYYM21xNsTMrJKd818Y9y9oZjuJ9kZGVb3n/53L15VfDUP2OCq1L29OR0H9CldR4vJ+7OE4cFD5/Xl6gqb/hafG9gxwKqJ5UPvhj5jtf2TvxHrJx4SBtZgKwW01OvY84AFYQyoEyr+tv83A9IPiCJwjmL5vKYsn3cTxalKJLc46dYfvQX8ZlbQeLWxRuOav2zP7qgGWHWSynCmGpH/foirq9EY6wFPGws0L//CNN/pkVOiGJS91CzlhVUPWCf01bwYmqM4cU5M8O45bLp/+UaIS4QR/Zxz37JE1czKGCopNVYikRQXZ49jS2rALA6qgS/IgbWWx4+wjIbwLqTApQUGAwpKuXvArt0GH88pvM3pi6ap76oHW9oQVBrUhbXfwDbLEjIF6G0Enh6aE5F/JTbAlpW+SgOsRFKBUHN/no+CS9Fids7X29JbSCUmTjz09OEYqgesPW9IeyydATlHTK/j421/MG4PxThqdCmmB6xKRkqqyXbC1Wu4e3oWGHR9Avx59ee5DPjgP6XraDFRFIhNsCyMcvmaWOt/RzUfoF70VeN7TBxk6ozch07AwUh45Wk4txku/mF5bzXpelF+0ugYGPCI+Nve10Hs01c4l0gkEj079hV+PCnFdPvkeajdpxEDftxG2x4PWT1HfQbm5glD4tvT4ddtYp+nB7z3Aiz8VEw8maNGCPw6u2iejGXt7Rgbb3rv6BgxweqotEDl5b2ZkSkmeEPKvs6lw1F/w5k/wiOjyrUrEolEIikCCcliXRoPWJWrulD9ZuGikKjKI/cU/ToGY0LavJwc3JxZYMMBpGfA7kOm+yaPs972/ru0zw1tFBE1j3JSDeSOSBFxsyMNsBJJGTFt2jTOnz9faJvvPwIaxvLYgIn8cxA6t7HvAQumM1hxiSLMvDAP2M6dO7N7924yMjI4d+4cL7/8skWbLsa8o0N6afuq1nyQe/vtJDExkWvXrrFy5UoaN25scW69evX46aefiIuLY+2X3/B0eMuCpOp5RgNsgLcPK1euJDk5mdjYWL766iu8vQtPTvrDmDf57vlXTPalxIofoTxDP1Ri4sDPLBz3epwwNugNsGqVaX0a3MJeKJZt1P6evj6Wx4vjTBytS22TYvx3FV6v6OdLJJJbC/0EYK/n4bVPTY+n6PRJTVcQ2uA2AFrcd7fda7rdDp/9oOmcn68WEdDAStHHE+fFs7Z9C6hbU+wrir4qCsTGxlpUYXY0nTp1hrDd0DiDvfvPcfudQl/tpSF48MEH2bmzcH0dOHAgA0asQAmPRlEUhg0bZvVatWrVKra+FoWkFAi8CQZX6qRlfJJpyh+JRCKRWFIUjQXnaqxq4OvYyf4Y1hqP9noQ6u2ERokEd7gGtVeCR2PC68LOJcZGBg/qtJrO1atXSU9PZ/v27bRvbzvvjqeHO2/c/RBrZ/yPUD8HWIadzBtTxfr6DTh8EkYPhL9/Mm1jMEDbZtp2Hxt11PQG2Oxs7e/jjBo0NxvSACuRVBAuX4VquvSlf+8XeT9bNbFdQTk7V6zDapruPx8ljLfWCA8PZ+PGjZw/f56ePXsyZ84cZsyYwYgRI0zaqbODQx8TBt4undtRo+1vpCRFMWDAAF566SUaNGjAli1b8PPTRmR16tRh165dBAYG8vxLL7Iu6izHE28UDP7iLl3h7yXLeKJeE8LCwhg8eDCvvPIKAwYM4Lvvviv0N4rc/jeXjhw32ZccewMQuWAz09JMjhW1UqejiIkH8wiUqzHi72EtPYDeAFtYSM30+aK6pC2KY4DVV8j0ryIMGQFSLCUSiQ3cXIVXa7XOsH47zDILSUvRPXZf/USsszNFYmoPG0Y/a1Ed6nWq+MCNBPHZmrdlXh6MNo7vPn8Lhj5e1G/ifFR9TYo/D1d68svSOQwdOQMCRhRqgG3Xrh2//fYbUVGF62v//v0JrHobpK6zeS03Nzc2btxYbH0tCokpldu7xctTGPhVzcwvg7BZiUQikZSehGTAPZx3p9gfw4IoYKzqVbt27fj1198gN4pF3wzgwLaXwL0B1N1C80Y6Uav+Ja5BI5g0aRJPPPEEqampbNmyhXr1rHuq9L37fpEHFjC4GEoc3VlW7D4IPZ+HR1+E+avEvs5tIVA3Bh3WB8Y8qW2/+axldCdoUZc/roImPcX7AVTuFARlRfm7jEkktxghQVAjBI6eNt0/cwHMeFvb3rlf+1yjGlZxNz78nn3CdBB8I0GEDzQMgzMXTc8ZP3480dHRDB06lLy8PLZt20a9evWYOHEic+fOtbhHs3C4vhOoNgDy41mz+Ek2bxZerKdPn+bw4cN06dKF33//HRCzpGfPnqVXr148+PyzXEpL5lJaMqtXrwZAURQ8LkTTqGFDGjZsyIULFwDIyclh6dKlfPjhh5w5c6bQ31BP8g2jB6yrKyk34vHy1Z78bp4e5GSWMmltMYiJM91u8JAomPJwF+ueXK6usHQ9hNWCr3+yPK6SlS2qWOpDQvSo3jzRMSIvYt0a1tupbVRCgkT/6jiwQIxEIrm5cHMTaVFUo6g5eu1RDas5RgOsu40qf2o7fd44vQfsDWMuMXMDrKKISSS18OCA7mL53LY9skxR9TX71FACGuYx7/ttVA+tx9AhE2lQx1JfVQYMGEB8fDxPPvlkQZSINX0dNGgQk8YqvP+iL4Yg67Hz/fv3p1mzZg7RV3Mquwfs7qXQuin4thPbZZG3UCKRSG5mysrXJSEJqDqe1CT7Y1gPd+HZ+X8bYPDrQmMN+fEQ/SRnT+SRegPuanoa6h+mc5cuwO/gVhsCRzJz6mjmzJkHwNatWzl37hzjx4+38LQNDw/nkQ53sfH0cXq3EGGjbh7uZGdU7OTiG7aLdWiItq9+HThg9G8yj8gMDREOYacvmO5XPWC3/SvSH6pOZHJi0z7SA1ZSIXn66afZsWMHcXFxxMfHs3XrVqshAPfccw9bt24lJSWFxMREtm3bRps2muunGgofGxtLWloahw4dYsiQIUXqw/z584mIiKBnz54cO3aMtLQ01q1bR1BQEOHh4WzdupXU1FQiIiJo2bKlybkBAQEsWbKElJQUoqOjeffddwuORSyDI7/CO6NF/1+bdBAaZzD2vb3g3amg3cFIeNZ4mj5XjZ7lm0Q+l46tTb0gv/0/4/f/f/bOOyyK6/vD7+6CCKggoqIUu2JJwVhTbIlGNOrXRA2aqMnPkm6qqRo1MaZZU4wllphYYo29xRaTGCXGhmJUBCyAFAHpsDC/P+7O9l1YXIpk3ueZZ3bv3Llzd8X57Dlz7jkNLM8JDQ1l48aNeiMPYM2aNQQGBtKuXTuTvgePwezlIrn3ob9dSbmZzdwfDOelpQkrWY40rVWrFo8//jjz589HkiS0+dbLZ4eGhhIeHq43DgF++eUX8vPz6du3r/UPa4MMnQNWrdGQmXLT5Fi16raLwJQFiaaXJ/qaiNaKviYima2RkQX3D4drCY6NbYz8b//b32J/l2VWCD3GDliAvDxR2drbSUntv1uewHfLi/kwCgoKFYaj+jrguQza9betryt/SYKWWdD4FF27CX3Nz9ZFwNq4B8/9ahk0CsfV26Cv70zdBuraBLdqxmuT9kPLTJ4YFw5uQl+LikDdBo5FePHOhyuhZQY0j4M671sUjJTnf/LkSfYczoHGf9P2rq6WnZyMrK/LNgidjE+C5SvWgGsgTw1pZ/M8V1dXsrOzTXTZXF9BPMAszth1pr6ac6dFwLZoDBNGGhwE9+hqa8gGpnFBkjsFRWMVFCo3lcWGPRcRzqsvlM6GXbPGug1rPv+TJ08y5oMc6tz7N127lq3G5uVDkWcoUeeKt2Gr6wppPRkq9q6urlCUDRRS3Q0SkoBCobEN6uoEwu0uUGmY8+1e/Tj5+fn89ttv9O9vlI9Px9y5czlw6h+Ssm7p2zSVPA+sMcYOVeO0ham3LLrSwEogmPy7Sy5mmXRT5PN/7AWnTbHcKS99VRywCpWSxo0bs2LFCoYOHcqIESO4evUqhw8fpkmTJvo+3bt3Z9++fRQUFDB69GiefPJJDh8+jL+/uIvUrVuXI0eO0LFjR9566y0GDBjAkiVLCAy0Eopog6CgID766CMmTZrE+PHjuf/++1m0aBFr1qxhzZo1DBkyBBcXF9asWWNy3rJlywgNDeX1119n/Pjx9OnTh7CwMPHZdDe5GRMbsHv3TrKzbsL1IaxdsxAarAS1Icnn8k3QKhRe/hiL8aOjoykogHkrRHTluKEg22XnL4u9+bJ2Dw8PgoKCOH/+vEl7ZGQkAMHBppX/snLgzc9h4Ivw2rs/4VmrIcNHvo23tzcBAQHMnj2byMhI9u0TlaHat29PtWrVkCSJ33//nT0LlzGuVQgdfRuajBscHGwxh4KCAqKioizmUBy5mVnk5+SidtGQdsPUu+jq5kgpy9vHOALWOOdh/ZwAACAASURBVG2EHCFmXLVbLlxjbVmHNW4kG16bpxyQ3y/ZIPa2cgYDnDULfsrV+cjtRc06wtpfkln7S3LxHRUUFCoER/X19MHRXPzTtr7O+fItuDYA0pfgU0foa0G+WHlQzUYEbFERSK5BqOsZ9LV1u/vBbxEff76GI4fWwPUhuLi6QEOhr/J9btmyZTzYLRRuvA4J48GzD6NHhpmM36BBA3bu3MnNmzeZ8t4QSF3IBx+txMPDShJtM2R9dRRjfZ29XOS2vZkGp04JffWpa1vbfvrpJxo2bMjbb9vWV2PsBZg4U1/NSc8QEcqlWWWpVsOuxbDp69uagkN8MwnmvW9wvKbpDMteutUkd6IDVtFYBYXKTWWxYVu3CmLu7NLZsE8OCSX1oqUNK2OssXvXDiErYSErV5a9xqqrBZGXWbwN62r2UPann34Cl4bg8zbBzb25fCMA6s2GvEi81TqNVYnfK/lmwUP5+fk0atSI6kYPlPv160eXLl3Y+Pshk5UUGvMLV2KirxteG6fJk3+2FRTAuSjx2s8oWlZGjoDVGgX8fv69ZaTsnUR56qtUEVt4eHiFXFfZ7rxNpVJJGo1GioyMlCZPnqxv//PPP+3+Hc2YMUPKzMyU/Pz8SnXdZcuWSQUFBVLTpk31bZ9//rkkSZI0cuRIfVtoaKgkSZIUHBwsAVKbNm0kSZKkYcOG6ft4enpKKSkpUnR0tCRFIrbkz6Vb6cnSe8+7S1Ikkn99JOn6CEmSJGnz2il25/b9999LFy9elADJ1RXpz9XoxwWkwAbi9Zghpuc1bNhQkiRJGjRokEm7RqORJEmSxo0bp287thZp2wLT8x9++GHp5s2bksy5c+ekwMBA/fGwsDBJkiQpLS1N+vTTT6UXPnxfOnLjqlRYVCS9+OKL+n4XLlyQ5syZY/G5Dh8+LK1cudLhf6v3dqyTZhzdJw2f8aE0cdNKadaZI9KsM0ck30aBDo91O9uzjxv+HR7qYGgf3Fu0zX4Xqb4v0vVDSLH7RNvqWSUbO8DPMHZQQ9Njj+vGb9cC6bEeSL617Y/l6YH03nhxzrltYt+vu3O+g4CG1aSAhtWcMpaiE8p3p2xlu5VEX/cuRfp9pel5xvravJHh3jRykDjuH9xSmnXmiDTlwHar1122bJmkLSiQRg016OuSRUJfv/pipDS8vxjvarjQVykqWJIiDfo6fPgwSYpEKohAks57SgV5Ql/lsT7//HMpOTlZcnd3l7p1FGNNnyz0dcqUkuurI1tx+poQMc7u+cXpq7x9NAFJe85TkiRJGj16tMVxZ+ur8TZhpPgua3s5fm5tL8PfSWnOL812YqO43qMPive7Fov3h34U+1dHVez/v9JsisZWjk357pStJFtF2rBSUYEkXRIa27Mz0lfzSm7DSteG6W1KYxtWPs9YYxdMRYr7DWnEiPLR2CPbirdhG9Q1tYsBSYp9WJK0Bo29HHVO+vajQINdfrmdJEmS9Nhjj5mMf/bsWUmSJKlBgwYSILm6ukoXLlyQXnjhBempz6ZKC/88IEmSJC2/cFKq37Rxhf/NObLJn/2rDwxtE8eINg93g25PGGl5brsW4tjjvSv+czhrKy99VSJgFSolwcHBbNy4kYSEBIqKitBqtQQHB+srAnt4eNC5c2d++OEHm2P06tWLXbt2kZBQ+lDymJgYLl++rH8v507bv3+/RZv81LJjx44AbN68Wd8nKyuLvXvFkga5SjTunYg6v5eCfJEMLy0DshM3lWheY8eOpUWLFoB4QjXALNw/NR1ATR1vDRqN2G6XNm3asGrVKjZu3MjDDz/MwIEDSU1NZceOHfoiIfJSyZ07d/Lee+9x9Pjf/Jl4jXNpSbz77rv2hr8tMpJSROJzCZNCXOUeAWuUJqBAa3idostn+PpomKT7t0rPFPtqJVytkmQ0dtMA02NyZJgEbDtoO1ejTFa2IRK2sS442Vl5YH+c35If59vJgaCgoFChOKqvLhrTCAcw1deMLPMrGLC3XD46JoYV6wz6euGiuCnFXNivP6+Gi+5G5WKqrxs3biY9A7RaQMpCyjQsGQTo1KkTe/fuJSfHUO3r8EHH9dUWarVar60l1Vd7hRZLoq+VAXnlRmkKN1Y3Wu1hrmFlhZxLuF4dsZdzB8vXvxNzwCoaq6BQualoG/b+EN2LghgouEzTQNi/HJ7oUXIblkzrNqyMNY3dtKl8NLaGBwzsBYN72z7fOBNANVehsTRcBRkbOX9QaGx8QioDRu4AtU5j8yK4Gf87M2fOpH379vj6+jJjxgz9v1uRbsnEG2+8QW5uLgsXLtTZvQYhcatxZ1WgemKC2Dcx0mQPXQRsTq7wJ+TllywFQVWgvPRVccAqVDpq1KjBnj17CAwM5I033uDBBx+kQ4cOnDx5Uh/+X7t2bdRqNfHx8TbHqVOnjt3jJUHOwSYjL0swbpfb5Ln5+flx69Yt8vJMiz8lJorl8fISODR+qAoNS+YlCeJu5EBhhsPzTDGdJpnZIDWN4vPFWrRasTVq1Eg/by8v0wzbtWuLSiepqbY9dx9//DEXL15k7Nix7N+/n61bt9K/f3+aNGnC2LFjTc4/cOAAAAU6b/PVzFsEBgbqDcnU1FSLOcjzsDcHW+RkZOqcrRK5Rt4A1+oVl4LAGON/n+a61UO3dA7YkqYgyDNaEWNe0Et2VjiynFJ2wLq7CydGoJV8wQoKClWL0uiri8b0gRKY6qs9B2z8BdsFn8z1NTNT3ORUUpr+nuZdU3fjU1nqa0qa4d7nqko0Sc3i5+en11zZB5yXl0NGhuP6ao2oqCi9tpZUX6upU/Hxtj5eSfRVprgcsM7WV2PkKselyRlurHVNyssBq/u49XxM2wN0KXfuxBQECgoKlZeKtmG73CuKT90TjD7HadQecaxh3ZLbsEjWbVgZE43VaVJOTvlobHBzLzZ/Cxu/En2t2bDGwS2N/GH69I8h/yInD4zlkTCDxvrUbQJeBo29cOQZsrOzOX78OElJSQwYMIB58+aRn59PSkoKvr6+fPDBB0ydOpWaNWviUb061dTCQVxNraFOPRtVsyspG/fCL7+a5oD1cBfOV/kBZUKy/RQEhYqOOsydk6hC4T9D165dCQwMpHfv3vz777/6dmODIjU1lcLCQho0sO01SklJsXu8rEhISKBWrVq4ubmZOGHr1RMJQNMzdZUHCxPw9a1ncu6NVHeaa0oX7dK6PzQLMrxPPTeA/cfc+GyReB8XF0dBQQFXrlyxyAMnvzfPG2feR3asyqSlpREbG0uzZs0AQx4eORJWkq0bvYOwSH8d8zm4urrStGlTFixYUMJPbDSPhBu666hMImCbd7qPK6fPOjxeaYmNs95u7IBtrDM8M3R5Wv3qODZ+oJ/tCFhHjMnoa4bXN1Lgka4weV7Jz1dQULjzKI2+uriA1iyvtLG+ZudgE7W16lg2yNHJZU1PuGHDyWisrylpeQT4wfUb4N+wnt4YkPvJmitTrZq706JJBwwYgJvRCouS6Cv55wn0E3lhzSmJvhpjL3LT2fpqzO1EwBo7YM0fIpYV8t9mfRs6q1RrVlBQcCblZcO2aQ4PhMDidabtap12lraug6yxxLuZOGHN9VTWWJUKxg8Tbe7uZa+xWbeu4OkRDDpTL6ghBDW1tGGNU7E28Yc2rYMh7wBLNojfDGDQ2Fb1miH/fNAURtG+fXuaNGmCq6srFy5c4Ouvv+aff/5Bq9Xi7+9PzZo12bBhg8WchzdrR9MvZtGlvWXBtcrM5WvQ5wHhtM4vEBGwujqqgChYZs0BKwcma7WWxxTso0TAKlQ63N3dAUycl127djVJXp6dnc3Ro0cZNWqUzXH27dvHo48+aiEaZU14eDgAgwYN0rd5enrSu7dYK6GPgM0Jp36j3rhWc9f3a9ZmMABupSiieP4ybD9oeJ+cEIE28zjHj4utoKAAEOkBBg8ejNooXOjJJ5/kypUrRERE2Bw/NjaWkJAQkzYfHx8aN26sr7YcGxtLREQEvXr1AgyO2CBPLy5dukSWzjm6c+dOOnbsSFCQwWM8cOBA3Nzc2LVrl8OfPfnKNf31cjMy9e0dB/ZzeKzbITFFV1kTcDcKvjVxwPqDRm0wDO+zXRjbgsYPC8epefSQ/IPLEWPS2FmbdNN0eaiCgkLVpDT6ai0FQUn11ZGCFHJR4xoetqM8jfU1JU3c+64meoJnbxMHbHh4OL1799Z/XoCHegwu8VyKIyIiQq+tJdHXhPgrkBehj7w0x1hf+zwgViSY62tJcba+GuO0CFh/2/2cifx3VM+WA1aJ3FFQUHAi5WXDHlkNiz6y1ErZcVaah2Rg0FhqWLdhjfv17t2bNi0MGjt4cNlrbPhfO6HGYGQXVveO1m1Y4wjYrz6AGwmx4Bai1zAwaGxqSoy+rYauhlh0dDQXLlygTp06DBs2jCVLlgAiZUOPHj3024yff2RrxD8A7L4WxfzVPzntOygvDoWLqNcH7xPfm0d10wfrCck2UhBYKcKlUDIUB6xCpeOvv/4iIyODxYsX07t3b5599lnWrFnDtWvXTPq9++673HPPPXqDp0+fPkyZMoX+/fsDMGfOHNLS0jh8+DCjRo2iZ8+evPjii0ycOLFM53/u3Dk2b97Md999x9ixY+nfvz/bt28nO1uEEOlv/qlzcXFxZ/qX28CzP8/+3zhqNZ4ORdn4FbOC4fvvv+fixYt2+6SmW8859+WXXxIQEMCPP/5Ijx49mDhxIs899xwfffSRSb8OTxTQvP1k/fsFCxZw//33s2zZMvr06cPgwYPZsWMH+fn5rFy5Ut9v8uTJDBkyhC+++IKuHTryQL1AWnv7MnXaNH2f9evXc/78eTZu3EhoaChhYWF88803rFq1Sp+PyBEKdY/fVCq1PgI2LycHqQISvE3XBRgZpwzQ/W4AhKOzvq9l2oiSEn0dWjY2bStNBCxAcD9oFSrEt7wikhQUFCqO0uirb+BgfBra11c8eoL3i/QbbKqvGgciYGVqeBjSBphjrK/eQWNR1exP0y7boSgb4zRxc+fOxd3dnW3bttH1wf7gNY4xL0zX67A9SqKvtrClrzO/EPoq59ouKChg8mTr+rp7dR8u/G5dX1u3bk3re55AVfN/AHTo0IEnnniCbt266fs4W1+NudMiYGVtNE5BEBlleK04YBUUFJyJM2zY3vfD+0PncCvdtg0rOxhtPQxzLUUgDxg0Fr/vwGssjz9uasPKyBr7/TJhw+I1junTy15jV6/4ElwD0Nb7ETx68OnH1m3Yv88UQB2hsa2awOUzC8Djfp55wdKGvXLeoLH1W7zCiBEj6N69O2PHjuXYsWOcOXNG74DNysri0KFD+u3f61e5niaKdCTkZHI99SZ3Gv9Gi/2+ZXBxl3DGZpk5YO2lIFAiYB1HccAqVDoSExMZOnQofn5+bN68mddee43nn3/ewnA4fPgwvXv3xsPDg59++omff/6Z7t2760UuOTmZBx54gBMnTjB37ly2bdvG+PHjuXLlSpl/hmeeeYY9e/Ywd+5clixZwr59+1izZg1gFAGrjYNr/VC7+IL/BsaPf5Gnnn4airK5fNX++BqNBpdiDNvUW9YdsFFRUfTt25fmzZuzc+dOXnzxRd588029uMio1C6oVIZbxJYtWxg2bBht27Zl3bp1LFiwgJSUFHr06GGSp+iXX35h1KhRPPbYY3zz8QxaedVhf1w0q1at0vfRarX07duXq1evsnbtWr755hs2bNjA+PHj7X9wGxgcsJCXWXE5YAG+XQVtB8CfJ+z3K61v+Go8dGgnlt3IlNYB+280XIgRy09q1YA6NvITOsKs+deZNf/67Q+koKDgdEqjr0EdfqLDo/b1VQrYBt7jSUky1ddSO2B1HtirVlLgyfp6X8+5qP2XcPnCPgpursH4UnFxcfTr1w9fX1+mfbYBar/IJx8+XSLjsCT6agtb+jrnqyUUFsLdrUQ/FxcXkyhZY32l4TqqB1nX12HDhvHEs+vRBIoom5dffpn169czzegBp7P11RhnRMAmp8L99972VEqE3gFrFAGbl28oxlWaz1HRKBqroFB5cYYN+3wYUJjM9Pdt27ByEIc1x9jt8swzz0DWHqg/l3Wrl3DqH4MNKyNrbG0fYcNS+0WefrrsNfb02Si42hcX9+YQsJOGrV7krbcsbVgXFxdQqZmxUPeZem+B68NoGGhpwybcMGhs9eruTJ8+nd27d/Phhx+ybt06BgwYYDWgR+2iQePqoj+mzcvHvWYpQ48rEDklAwjb0tPdNAVBfJIIHDKvN1oVi3CVp75KFbGFh4dXyHWVTdkqels2A0mKFFujhobXHu7iuEbjnOusmol0YVfpzz+2FmnbgtubQ0hob2nWmSPSrDNHJJVaXWbfaefHB0izzhyRnv7iI+mhp5+UZp05In1+/JD00W87K/zfW97kf2d5WzjN8NqRcYb3F+f0ecDQNvp/hr+n0sztsR7i/I53Vfz3ZLwpOqF8d8pW8dv5HUJP7PVJPiLuISMHiff+wS2lWWeOSBM3rXToWme2IK2fh/TMYDHekTWm903jvtNfFW2LP0Y6tw1p09fWx+zeUfTr3rFiv8drB8U8anvZ71ecLpRGN5y1aTTi2pNfdPzch7uKc//S/Zv27Fz28/3pC3GtK/vF+01fI53YiNS/h2if8lLF/k1U9KbohPLdKVvl2z59Q9yfZr9ru8/lvaLPmCGm7fe2NmhE9glL26Ok913jc8z137uW4XVwU9Fn0gvl8900C7L8TP71LfvJut+jE1K/7oa+bVtY9v3xc8PxJ/uVfC6f/PWrNOvMEemtjT9JgPThvi3S0CnvVvjfT2m2tGOG7+DXpUiHfzIce+v/RHtjf9NzHn1QtHe+p+LnXxk3exqhRMAqKJQzxvl6jJ8wyRQ66UmSrQjY8kSlLqZcs5Mo1D1+U6lU+ghYjasr1Yzy/1U08hKNvX/e3jhHT4v9is/gd92qGX0ErFS6MS/rVkY5Y1loy2butGxWeb53BQUFx2kSYMg1bS0HrDkZWdbbHY2AzcgSRbjke1pCsu2+cjTG/z0uIjT+94hDlyp3Zi8X+5DWFTqN26KwUPwbmacgmDgG3nzW/rnygpR5P4p9cNPbm8ujD8KwUPt9rEXAgsiX/+hY+HLp7c2hIlA0VkGhanNFF5D5+mj4/mPrfc5fFvv8fOvHAW5Z0WXjYs0lpWcnw+teXSD1KDxyv3gv27QXYhwftzQkp1q2tWhk2SanaMgvgB2HDO2p6ZZ95WjiNz6Dn3eUfC7VPT0B9BGwORmZuNdyThGy8uaaURSsh1kE7Dld2h7zPLD6CNgqlIKgvPRVccAq/CdRqVRoNBqbW9leu0yH15OaDt6l1AEXF4OxdDsYpzAoSwLaiHWdQXe3JSczU3dtFa7V3VCpK8dtTl66maRLD6RSwTcrod9zjo1zI0Xs6/vCA+3F64e7iH1p89lFyw7YAPv9SsLCWc1YOMuyareCgsKdw+W9YgOhB8X9wDZ2wMr6qgJcXF0d0tfMbOGAlXXyhpED9vmppn3nrRB7tRou6TIfWNOt8tLc4vhxi9jLaQjuVG5lQphZfcsv3oKZb8OM122fJxcXPRclnAalrdIts2sx/Dzbfh9Z/t2qwV8/Cyd9fd2S3T1/mBYauVNQNFZB4b+DNb1QqVRcSdAAGtR2bNgCK7rdv3vx1zQ3m/zqGnRUns9j3eW5iH155dNOzzDU1ZBtl+ZmDth6dWD5p+J1foHpMeMiXDJ7j4j9uSjLYyVCdsDeyrhzHbAJhtfmRbjkVFANzerBVcUiXOWlr5XDM6GgUM4sXboUrVZrc2vUyMrjNCfw1QfQq3OZDG1B6i1hOMsVHR3htx/hrpa3P4fycn5eO/cvAD4NG5CXZfrI19Wt/PPAWkPO/Ss7YL1qwCvTYedvjo2TlS02mVo14KkB4nVpfwDl5EJCErwQVrrzFRQUKjdtW4AUKfaO4mgE7NKlS4mNOMfr7brw8aODHdLXjCzTHLDxSWJ/6jws/Nm0r3F0rLwyoK4PNinlAgGnkXRTfJ67S6Ct9u7lCUmw9YDz5uUoiSngX9+6s/u98abFtoyR23Ny4XoiBDUouznKGC/C6Xy32Fur5qygoKBQWZDvW0s3QDMrK9OWLl3Kcx9qIVjL8o2m+vr3GS24Co3VWDHBbOWMbdQQpr0inJcuVp6Tjh8m9gk6TZbvo/Jcy7PmcbIuYvVagsjpLUfANvYX25x3Dc5C2Qm95w+xt/bQbftBCOgBu38v3XykIjkCNuOOzAELphGwtWuZFuGKSxR7Ywesq6vh78RZK3f/SxTrHQkICGD//v2cPXuWiIgIJkyYYLXfvHnzuHjxIqdOnSIkJMTpE1VQcCZTp06lQ4cONre4uDinX7NeHXjlaQi4zaiPkpKqc/jV9nL83K5OKpChLicH7N9bDGtGcjNNHbDVPKqXyxyKQx8Bq1s+Y/4k0RGMHQ9PDzS8zskr/ZgxcRDYADrdXfoxFBQUKifdOoj91JccO++t/wNXl5I7YFUIfe035AlWXjrDouN/OKSvcgoC2W8mR8AWd7+UH2zVs+OArQyc/rf4CFjZkLUVuSthcExXBFO/Fft7gg1tJyPFZwPx72cN2QGbly+W2AaWhwNWCTNRUFC4w5Dv/VHXwMfb0o6bOnUqy+d0QIruwJJZpvp68VAHKBAaa+6AvZECN60swQd4YTh8+CL88o1h+b4xXe+F5kHCUQsi/UtdH8Ncy9MBK+t9YRFEXTE4YKN/FZuxBskRsINfgSZ20hQZF6JyFDkFQW5GJu4178wIWPNCXMYpCFLSxKoV+XfY22Mh/7R4EAtVKwK2vCg2OZdWq+XNN9/kxIkT1KhRg+PHj7N3714iIyP1fUJDQ2nRogUtWrSgc+fOfPfdd3Tp0qVMJ66gcDvExsYSGxtbrte09kSxLJHz5AzpA3N+KN0Y7rcZPFpeOWBlwjfvsHTAursDVpIGlTPnL0OHdpAuMiTclgP2Roohj9OAHhB+RlRzlqNsS8OQV+HaQfEj69jp0o+joKBQ+ZCXlw151LHzvpxouuTPFrKRc19bWLE5Fq27G4/kZpGdm8Xx48dLfL3MbBHBMm6oeC87Gu1FtgIkyg7YOvb7VTSn/xX5Uqu7iRy7nu7wd4RpH5VKbDU9xXJ/c1w01peWlhfHz4p9h7Zw9JR4rdEIxyqIVRnW8vTpHbAFwgH70H3OmY+PN9xMs35MrRbpmErzIFpBQUGhIpAfHF3WpdZpHiR+58vExsaScC0WciHvFhhLbIv6htfmGX+Kigy1Qcwdp7K51vVekXLAmPQMkbt8wVR4uKuhfct8eG6KbhyHPuHtYawvl65Y5oC9arScXtbK7ByIKaPi9pLu02dXkRQEYPmdxiUZ7Nbeuvy/rXV53BUHrOMU+2w4ISGBEydOAJCZmUlkZCT+/v4mfQYNGsSKFSIZ19GjR/H29sbPr5zC/BQU7mA0GkNuPWfnqdvzh1g28HxY6aNAbrdYSHnmX33zrq6smfSxDQdsxfPeHPh0EfyqK8J1uw5YGffqQvwuX729+V2/AbFxzot+VlBQqJysnlV8nwNHDUU1vGoW/wNbzm/qX9+03dEiXKu2iX3Hu8Q+3k4RLpk/T4hl8QB1azt0uXInRhf8e08wnNsG4etMjxv/DvC2UUTTRVOxRS+u3xDLUDu0M7Rp1AYnfEkiYK/Gg38950SoTn/V9jG1SqQ7UFBQULhT0Dtg5RynNgpnSRLU8S5+HGPqeAudTvzDkOcdRDSpjLmOnoiENs0sHbptm5d/DlgwrCQE4YA1r19hbF8V9/DYKUh3fgoC8+JkOw+bvo9LNHyvUboHA3I0dFUqwlVeOPTTp1GjRoSEhHD06FGTdn9/f65eNVj/165ds3DSAowbN47w8HDCw8Px9bWRhERB4b+AZ38IlmjZohGvfCKa8qxUsly3bh0HDpQu2VtuHkz4BFo2hpyTsH+59X4NGzZk48aN3Lp1i6SkJL7++mvyC4TT0lbUyOjRo5Ekyeq2YMECfT+VSs1dtevxbIt7yMnO5ty5czz11FOlGqvEnzvTNGSo48B+tO72gMPjOJtrCfD+HEN109spcmacb/F2o5SNOXISut5ze2NMn32V6bNv0xusoKBQZjzYvmT9jDXJp5gIwl+PiGVqs5ebtqsddMD+eQIWGzkl4xLFj/25K6z3r/8gPPysaQRs//79kSSp2Fzut6OvJcVcX7v1/xpU7tS3EamrUgGa+uD/C3+Fx5KTk0NcXBxr166lefPmgK4oWiFER0fb1E7jIIhJkyaxd+9e0tPTS/S9lITEm/DMYMN74whY2QEb2g0OroCxumhmWfPkFASurrbzERbH15PEPi5R5C43TodgjFpt/bfVnYyisQoKVRv5Odzlq8KxaV5kyhh7DtjaZg/x1GphE147CL61xWoTGVcjqZZXksiOtSvxQnf0qQl0NmxN70Z6J6+1FARlpbFyCgIA/4YN8Wi+kYyMW9A8Cep/TfPGhsAb8yJcxjz00EMcPHiQzMxMUlNTOXjwIIGBpkl3X3rpJSIiIsjKyiImJoavvvoKLy/TH0Re7h6sX7+eDZ/P5ZV2nfl53Vrq1r2zko1fM3tQuelX0/dxidBQ95HkB/JyHveqFAFbXvpa4l/Gnp6ebNiwgddee42MDCsl5ErA4sWLWbx4MQDh4eGlGkNB4U7Awx02fQ0vT4eLMbb7JSTDb3/CgjVlM4+Ne+HAMfE0s2dnIZ7GYuTi4sLu3bvJz88nLCwMb29vZs+eDS7ekDTS5rjbt2+3SDPSuXNn5s2bx86dO2nRuQPBD3UlJLAJjzRsQnhyHJNHjqHvo4+yYsUKMjMz2bx5c4nGcpT8nFyT9z2eGUGPZ0bw5l1dbZxRvjij6rLxv6GHu6lD9nY4elpUt/55Djxpp5q1Pfb9ZiPBlIKCQoUhR6kcPAbt25TsHGPHlbVCIMakMdXcuQAAIABJREFUpoOvlVusxtUxByzARaPsQPkF0NxO2oREo9UA2TkiB2zkbeRycybW9HXu3NlQzRs/X+v6qlYDag8oSuWHxZPZdSAWPz8/3n//ffbv389dd92Fq0s62kIYPHgwbmZFJhcvXkxhYSEJCYb1hM899xyXLl3iwIEDDBo0yCmf7eR5kcvWv76IiNWoTVMQAAzoCd07it8d36+zzAELIoIqLhH+9wicu2SIui6Ol3XPcU9GiqicZoGiUJs5anX5RmaVB4rGKihUbWSnZk6eSMMT+hB8PN+ynyRBHQfSq9hLhWcs1fKDsQPHxHJz2ca430qJH9lZXK5FuHQRsD06uZBSeze45vPea2FMf8Mbr6azadHZG5KFxtpK1/Poo4+yZcsWFixYwEcffYS7uzsPPvgg1asb6oa88sorzJ07l48//piDBw/SsmVLZsyYQVBQEP/73/8A8fmf69aH1Lh4Pvp6Lg+EPUGHDh3YuXMnnTp1ougOEaDcYmqIxCWKFFa/rxK6C4aaNlXJAVte+lqiX8YuLi5s2LCBlStXsmnTJovj169fN3liEBAQwPXrZZRoQ0HhDqBHJ+jzAHz1PoSOt90v7zaKJpUESYJeo2HMEPj+Y5HX54pR/ZMhQ4bQunVrmjdvTkxMDACFhQWsWb2GiL+n8dLkS1bHTU5OJjnZdG3oyJEjSUtLY+fOnXxybD9qjYahvo2ITE/m6QH/4+LRv9mzezdBQUFMnz5d74AtbqyqyOMT7Dvmi8PYAVvDw3kO2J+2iuqht1O37J52IvzpVISTJqWgoOA00m4JB1lJHFPGDlhble2LQ61Wo9ZoKHKgTK6xE84Roy4p1XoOWGen9ykp1vS1qKiA1avWMPGFaYDQV43GUEVYrQIKoiH+WY7+DocOifbjx49z8eJFevXqhYtmEwVaOHnypMn16tevT+vWrfnggw9M2oOCgpAkif79+zvNAbtgDYwaJCJPr9/QRcDaSEEgG/NuriKiqrDQEMEkR29t+lrsVSVIe2T87ymfb56zUEatqnoOWEVjFRSqNsZRpbYiOOXl4D7ehnOs3esOHhM2KdjXcVejwlvyPVuOgLWXO7UiinDt/ROmvgzUHIK3b2uIac7xozHEXQQvzwKqNVwD6dOg4JLV78/FxYXFixfz5ZdfMmnSJH379u3bTfqNGDGCTZs2MXXqVAAOHjyIm5sbc+bMwcPDA4CWXnWoX8uLbh07UbNFE+r168l3n8xhx+qfGTx4MBs2bCirr8Gp1PCwfzxOFyHb5W5DwU0vXbrbqpSCoLz0tUQpCJYsWUJkZCRz5syxenzLli2MGjUKEJFr6enpJk/fFRRKwoABA/j777/JzMzk5s2b/PXXX3Tr1g0Q6S9kA8KYZcuWmURTT5kyhaSkJDp16kR4eDjZ2dkcPnyYxo0bU7duXTZt2kRGRgbnzp2jZ8+eJZ6bvEw+JCSEAwcOkJWVxYkTJwgJCcHDw4OlS5eSlpZGVFQUYWFh+srN8tOhKVOmcOrsDWhxCxr8ABrL5G4BAQFs376d7OxsoqOjGTNmjIPfoG3kG2cDMyMlNDSU8PBwvXEIsP/XX0DK59/EvvxWwkB1tVrN0KFD2bhxI/n5+aRci8NFpca/vh+xmelci7yg77tnzx7atWtHUJD1pEbmY5WGtVNmsGXmV6U6tzzYtBciLpb+fDnSJy9fLAGxVrG0NCTfFGPfjsE6d3oT5k5v4pwJKSgoOIVOXQdA47/pPz4TWtzk6NHi9bVZ52XQSIiAWzXH9PX+zoZVDS7F3KDM9XX11ixofALcQqhe3VJfzZkyZQo3btwg4KFbPPL4D9SqZSV5qksAn88pG321hTV93bDhFyQpn8BmffVtxtHFxs5F4+WjKSki1LdatWoiBYEVg2fYsGGo1WrWrDFdUiOVgWUcpVuhJ89dozZE0Nh0wFYzOPXlStyl0S7jc7JzhUPXVioDtRqKyrM6TDmgaKzzcXNz4+jRo5w8eZKIiAi9w0VBoaQ404YNatoJGoWTnJJNzTaH8fE11dhLF88xanhPNBoRAetVEwrPwgQrCyvSMwCv0RAscSU1BIIOQEuDxso27Jh306BpFNQM099P/9IV5G167xTyG1u3YWXN8vEtOxvWnD9P6F7UCCXiTDgUxNCooS6KN+MXVFI+1BAaay0Ctnfv3gQGBvLtt9/avY6rqyvp6aYRkWlpaahUKlS6D16vuic3s7O4dOkScRfEQ9X41BTi4+Mt/r0rM5euwIlzto/n6rRboxEFOI2pShGw5aWvxTpgH3jgAUaNGkWvXr04ceIEJ06cIDQ0lOeee47nnnsOgB07dnD58mUuXbrE4sWLefHFF8t84gpVi6ZNm7J+/Xr279/PgAEDeOqpp9i2bRs+PsWUPraCh4cHixYtYs6cOQwfPpygoCB+/PFHVq9eze+//87jjz/O9evXWbduHe4OFmj64YcfWL16NU888QQqlYr169ezZMkS4uLiGDJkCEePHmXFihXUqy8S6wTUhwkTJvDhhx+y8sdFEDcEinKg7hcWY2/evJl27doxZswY3njjDV599VW6di1+2bxsvNrL6yZXkjYv/BQcHMz586br9jyrF0BBFN6+NpKqWeHhhx+mXr16rF69GoCES5fRqFSoVSqKJAmpyHB3lp2qrVtbD3UxH6s0HN24lVO795u0lWdBsLJm6Ubo/zz8sk8YmLbyCZaG64mWhXQUFBTuXJo2bcrbU9ZD1n62rBgAcU/x2wHH9FXO31lSfV04dy4uKnHPHTb1PXr+39PFXkPW1yeffAJQgf965n5tqa/GNQZkfV20aBF/7xlCNZccvvjCUl8J2EyTZmWjr7awpq8FBQWci4zi7FWDvrZrIb7fpZ9AYANDXx8vFS4uLgQFBTFv3jxiYmLYtUtE6FgzeMLCwjhy5AhXrlxxeK6OkpgCmVnQVHbAagwOWPMCLu7VRdS1sQO2ls5JO+Ixx68t/y2u3w0jJopoWlsaKEeF3TUQ3voCHnoaBrzg+DUVqjZ5eXn06tWLe++9l3vvvZe+ffvSuXPnip6Wwh2Cs23YJ0YugtQ5jBo5nOqeQTTqYKqxN1Oug/86ULlTwxOa6IpQzXvfdKzEFNhvVLanRrMf4NZquG7Q2BU/CI09tHkI5B6Fhit4/mmhsf9Gw6vfTeC5lz7k8hnrNqwcOTn5k7KzYa0xcynEpwdzJkJobGN/kacWhA179WYwMdetL63v3LkzycnJdOnShQsXLlBQUMCZM2d47DFTQfr+++8ZNmwYoaGh1KhRg3vvvZd3332X5cuXk5UlIiQ1KpU+zUB6ojC2verXIz8/36adWxlJSIL2T9g+fv6y2EuSoUiqjAMLnBR0FJuC4I8//tB7+e3x8ssvO2VCCv9NQkJCyMjI4O2339a3lXb5uYeHBxMmTOC3334DRBGM+fPn8+GHHzJrlij/fO3aNc6dO0f37t3ZtWtXiceeOXMmK1aIaiAqlYodO3Zw8OBB/RKGY8eOMWTIELr3HAAswLuWmnfeeYeFCxfyxWeTeTUUyNoD1faAq6FsY2hoKO3bt6dz584cO3YMEEsOo6KiuHjRfqhkUVERWq3WbpSL7IA1j4CtXbs2aWlpJm3etYDCVFzdSl5OOiwsjBs3brB/v3B6psYlkFdUSI62gPrunkhGISidOom1MLZ+mJiPVVryc0yTrXp41SIrNc1G7zsLrRZ2HBLLK58MFcbnWevZIhzm+g1of+f8ZlBQUCiGkJAQcnIycE16m4hT8MSDsGLpTqs5M21h7IAtqb4GpNUiJjONkH59COnXhwNLf7J7DWN9JUkFgTvIzrLU1wEDBrBgwQLUaoO+Tp48maDPoHOzPZy5tYeAAIO+du4aCtXb8+G7nVm92vn6agtr+gqQmpqKh8agr+1aiKJWzz5uyM9bVATDx8xn5tLnAYiKiqJ3797k5Yoik+YRsEFBQXTp0oVXX33V4XmWlqirphGwsnN1xuvwj1kkTYO6OgesbjnoVd0iOfMUwcZOWlvIy2j3HxVGY0KynQhYXQqCiIu3t+pEoeojO1RcXV1xdXUtk8hxhaqJs23Yld9NYFz/39i8BY4dbEivQfM5dMigsfVqXeOn9efAoztk7aLz3Ybzb6TAtoMw7VuRniztFnj4wadfwOofZ/LOULmipdBYNxehsatmAgnHoOYQqDEA0hZQVGTQWJfkyQQPxcKG7XQ34BlK88Cys2GtMfFLGDSuNsnJaSSnoo+ALdCCa2Eq15Nr0/UR6+f6+fnh6enJokWL+OCDD4iKimL8+PFs2rSJkJAQIiIiAFiwYAE1a9Zk69ataDQige6mTZv0AYgAafm53F27Hj4+Pty8eZO87GyatGiOv78/eWWdZ7AcSdfVty4ogGpmqSyqUgRseVF1QsIU7mjOnDmDl5cXy5cvp3fv3vrcKqUhLy+Pw4cP699fuiQ8U8YOPbnNOJKmJOzbtw8QER3WxpUrHdfXRcDiGkjDhg31+U71ZGw0edupUycSEhL0wgVw5coVjh8/XuycfvzxR1xdXe1GvSSnqigs1OBfX6MXEVt463K62KscaYyrqyuDBw9m3bp1+qeAkiT2p28mcnft+gwcOABvb2/CwsIYOVKskbGWmNzaWKUl3+yxZ43adkqF3qHc0BWgcXVSCgIQDth6deQnyQoKCnc6Z86cwdPTCxosp35Qb1B56O/zJeXJN8TeEX2t4eCNSdZXgGcmijF27bbUV1m3AwNN9TVBl/rnLj9TfQ1u2wm0CUSeLRt9ValUaDQa/VYSco2cjO1awC2dcXOPLjA2Jw/uqz+DNfM7MmTIEJKSktizZw8NGohlLOYGT1hYGEVFRaxdu7ZE13cGl6+ZRsAaz2nsENO+fr6mztWUNDgUbpmft3EJfpLJDwNkiU9ILiYCVvGjKZQAtVrNiRMnSExMZO/evSa/xxUU7OFsG/ZKlNDYoiKIu26psTfidREXLuKGuWCq4Xz5Xng1XjhfAeJ1aegOHDBoLPlijIQrYtxqrhDx7y1u3EjSj+vtY9BYOW83YGLDvjoScO/EzZSys2GL09jYOOGAddGIZfQZ2YZCXbbGc3d3Z9KkSSxatIh9+/YxfPhwoqOjTZzoYWFhTJ48mUmTJtGtWzeeffZZOnbsyJIlS/R9zqenoC0qZMmSJQQGBqK+lcUbT48GrNu5dyry39LNW5bHFAes4ygOWIVKwYULFxg0aBBNmzZlx44dJCcns3LlSnx9bYQ12CEjI8PkSZq85N04EqWgQHgXjasdloS0tDSGPArZJ6BpgOW48vXc5HE1IglsYmKi6UCFpu/9/Pws+1g7r5R8//1SNG21vD9bi1arZfRoIQ6pqal4eRlKaA7oCa+OAjS1SUmxo15GhIaGUrt2baspA44mXSc6M421q9eQmprKN998o8+tZS1PtL2xHEWbl2cifp5V2AHrTK4nCqPVVkSRgoLCncXFixfQxA0C16aMe2MHtEhm2qcl09fz0fDOLDh6Srx3RF/lFAQlxXiMg3/Z1ldZt/38TPX1w6/hzAUs9LW2jx9oy05fly5dilar1W+29FU/n9q1STKyDvt1s6xOnZ0LaK8S1utv/vp9A3369MHb25vnn38JsMxrFxYWxoEDB5z2mUpC1BVoGiCcqBq16TLEIY+aFnzxqyscp8bRrbcyRe5CYyes+RJaa8jjyg7YGyl2inCVoNicggIIZ0lISAgBAQF06tSJtm3bWvQZN24c4eHhhIeHl8o+UaiaONOGLdRm8GSo0NiiIsjIEDfN/DxjLRQa++NWx2zYq9eMxxDjtm0q2lxdRHRjTm4+qMS4Nb0MGmvi0DTS2DpegMaPtNSK09iY6zoHrAscPQ1XbtQm9qptGzY1VRw7cOCAvq2oqIhDhw7Rpo1YhqJSqfj666/56quv+Oyzzzh8+DDLly9nzJgxjBo1ipCQEAByC7WsPfM3Xbp04cqVK7zzyACK1Bp27NhxR9ZDsuW4Ts8Qe2Ndl/W8KhXhKi8UB6xCpWHHjh1069aNOnXqMGbMGB555BG+/lqUxs3NzQVEAQpjatcu+TJ5Z9H3IbG/x06KVL1BUShuvvXqmSVf1Zi+T0hIsOxj7bxSMnXqVM7t68AfGzvQoUMHtm7dCsD58+cJDjZ8kC3z4X8Pu4JrU86dK9n61LCwMGJjY/nzzz8tjmmlIrZfvUjDgADatWuHv78/MTEx5OXl8c8//zg0VmkwTkMQdJflj+k7HbnYmzORC7aVNg/s+5/E8v4nsc6bkIKCwm3hXh3I2gFXujH6iTqQMIaQ+4rXV5dqtcnMhi++L+8ZlwzZuJF1Mi8PNuxBr69yFH/qzQRwKVt97dChg36zpa8gVnk0bdqUiLMGffX0gKcGmI6Zk2t43SRAOL6joqJo0qQpYBpx0rJlS0JCQpzy4NIRoq6Kv637Q0QEbKGZo/PulsKgB10ErKtpPr5bmSLlQv/uhragBtChHexcBHe3sn7d6ro/U9n4sxsBq6p6DlhFY8uW9PR0Dhw4QN++fS2OLV68mI4dO9KxY0eSk8vgB5jCHYuzbFgPN7EqAkS+zWydFngalSyRU7ckmAVhzNVlF9DY8O6kZVi2db1HPByTl+8bk5xk0NikVMOcZI3NywM3N6AwAe/aFaexsXFi9YSrCxQhNNY8/7oxkZGRABYpNlVG+Vx9fX3x9fXl5MmTJn1OnBAVwJo1a6ZvS66mJiAggDZt2vDSVzNZd/4ETZs25a+//rr9D1/OpOh89OYPheW/HU8jn39+gfh7qErZWspLXxUHrEKl49atW6xevZpNmzbpn0QlJiZaJLT29PTk/vvvL/f5yT/63eysrlTL9/SCq2RnxDNo0CD9sfgkyKn2uEn/8PBw/Pz89PlRQSyvbN++vVPmHBsbS9SF49RQH+f48ePcvCnWkuzcuZOOHTsSFBRk6FxzIKjc2Lq9+Ny4Hh4eDBw4kDVr1hD8UFdmnTmCj38Di343EhI4e/Ys+fn5PP/886xfv56MjAybYzmLfCMrtnnn+5w2bmUhL9/wVNJZXL8h9v6l/N10JDyDI+FOnpSCgkKp8TD6wRx/4xbcWs2Zf6zr69ihIEWCXz1PatV1rr66mCcOu02uXr1KfLypvl6MBWoKfZULPf0bGQ4ufrRuW3b6evz4cf1mT18HDhyIm5sbv2w21dcO7UzHzDZKYd40AOrUqUOrVq24djUaMI04GT58OHl5eWzcaJp6oayR87xOeckyAhZEcZbUW5Cfb5mCAAw55bZ+J/aHjwsHbL9u4kH3cBsFpPURsLqxbiQLB4KXlbQaVTEFgaKxzsfX11cfrV69enV69+5t14GjoGALZ9uwWTotqGGU1UB2jpk/XPpXVyjJvN6Hfm6Z1tu3zIe2zQ2p5zJ114yPN2isHBmpUqHX2J+26gbICcenTtnasPY09lZeEB7uothjo5ZCY+3Vd9m9ezcFBQX06tVL36ZWq+nevTunTonlPklJSWRlZVl8hvvuE7ZkTEyMSXthYSGRkZFEX7pE2ybNCA4OZvny5U749OWL7ID1MVu8k5Mrjk2caWjLy69azlcoP31VsvwpVArGjx9P165d2bVrF3FxcbRo0YKhQ4fqC3JIksTmzZt5/fXXiY2NJS0tjTfffJMcs0JL5YEcwVHNjgPW8FCtiOuRXzB+/EzycpLB4zAxhU/QOLc1Rg8z2bFjBydPnmTdunW888475OXlMW3atBIt3xg5ciRLly6lWbNmdnPoxCWKFAMPd4V9R0Tb+vXr+eCDD9i4cSOTJ0+Gml5Qfw5S+ipOnjJUdfr1118BeOQR04zmAwYMwNPTk9WrV3PvUBHC06xDiP54k5re1HJ1o0f37tStW5dx48YRHBysXz5iayxnUZBrcMCWNDffncaNFOuGZ2nRO2BLGQHbtaOYjGIgKihUDsaOHQ8NukLmLvybxIFXC0ICh7JosaW+xp+NBc80Wnd7k9xC5+rrU59P44fX33PaeEVFRXzxxRfMnDmT5ORkDh8+zBOjnoBqwsiV74tH/9wBuSf56LN13MorG321hrm+enl5MWfOHFatWsXxEwZ9LQr4lW6BwFWdvvq8gY9rE6j+GxQmMnhIE9786HXy8vJYvWohr/c3jYB98skn2blzJ+np6Vbn0a1bN+rWras3HENDQ0lKSuLcuXP6SKDScOw0rNsFvbqIaGPjCNjDf0OzIGGc3UiBVk0sHbDmzoC4G/DQfRAgVr3Strn168o5YI0jYEE4HcwfSFbFFASKxjqfBg0a8MMPP6DRaFCr1axdu5bt27dX9LQU7hDKwoaVH2hZi4CVV3cUFkJmFtTwhCGviqJbYDuXti1nWW+dHzjqqtin3YIaakAyaKyrStiw1DRo7KeLYcwgIGsHly6UrQ1rDVljn3p+I3hMBrUXj/xPaKycix4sbdiEhAS+/fZbPvvsM1QqFZcuXWL8+PEEBATw6aef6s9btGgRr7/+OtnZ2fzxxx80a9aMadOmceTIEY4fP87gzCyq1/CkW/0gBg0aRGZmJgO7PsSQZm2ZOXs2//77r0OfpzKwdKNY1XLNSvYE365iL6cK8i3/RchlTnnpq+KAVagUnD59moEDBzJ79mx8fHyIj49n8eLFfPjhh/o+L7/8MosWLWL+/PmkpqbyySefcP/999OuXTs7Izsf2QHr5ma7j/Gqhha15rLhZx9Gjnoear+GOnYLb771NqtWrTI5Z+DAgSxatIilS5eSmJjIjBkz6N27d7E5hNRqNS4uLhZLKcxZtgmeexKeDDU4YLVaLX379uWbb75h7dq15LvkUS1jDUXxE03OteW8DAsLIzIyklOnTtH40Z4AVK9p8AZKksTdPvXYunUrubm57N69m2effZa4uDi7YzkL4whYVwfz/d4pJCRDy8bOGy85VVSWnvoSxFyHrQeKP8eYGR80AqDn/yKcNykFBYVSEx11GjQDyfWezaKlPhSp4ok4sph33rHU19C+80GdCsmfkJZ9P+A8fa3bKNBpY8nMnTsXHx8fnn/+eV577TV27twCSW9Dw1V41zLqeG0gMYllp6/WMNfXvLw81qxZw8SJE00M4RORGu4zzpCTe4rqNfuBz5Ogrkmv/tdYu+EgH330ES7SdcCwVPSee+6hdevWTJs2zeY8pk2bRo8ePfTvv/tOhJxOnTrV7nklYdfvMFS3Uts4AjYmDu5tLSJ5k1Nh8CPwxz+iuJiMuQNWfvgnO17bNMMqU0UaXP1vsZs6v3PLxnD+smnfqpiCQNFY53PmzBmnResp/Pdwhg37fBj0MASQIptdcgSsp4d4yBSfZEhBUCSJpeE1dKs9YoQ8lKiYoTVkXbl2AwIaiAK/ssa++OLz4P0aZG5hxfdvM+qFVWi1YoVDtWowaeJAnnmhYjR26fff0KLPWpDyiPxjDePHF2/DTpw4kaysLCZNmoSPjw8nTpzg0Ucf5fJlg4i8++67JCcnM3LkSN577z2SkpLYtm0bkyZNQpIkVGqxkLxmNTcWLVqEl5cXsdevcTA+lu0n7swifkvWw8qtpumC/kuUp75KFbGFh4dXyHWVTdlud5v8IpIUiTTtFdt9QruJPs8+jpTyF9L2hUgN64m2sUMrbu57liCFr7N9fPtCMcdVM5FcXR0bu88LY6RZZ45IfV4YIw2cOEGadeaIfquozzvhp8X6Obyx9ocK/9spi23tHPFvtmux88Zs1QQpYivSpd2On3vgl3bSgV/aOWUeik4o352y3f52b2txjxj0sHh/9QDS99Ot9/38LdFXikQ6uKL01/QPbmmiAbPOHJGmHtxeLp9Xnn/fh8T7Xl3E+wfvq/h/C2vzBKT43wzvpUikHz4zvP7tR8M5LRqLtuH9K37+gNS6mWGeH79qeD3tFaTCs0gJvyN98ppoO/UL0rYFhnNfGmH6mV8fLfbp4YY2898harXhWId2oq1BXfH+xRGW8zu21vSaVWFTNLZybMp3p2zO3OIPm94PZW24u5V4/fLTuv1TSCMeE6+bN0I6vVm8fqIPUnU303OtbebXMN62fif61PAQ91Pj+6+Hu/WxE3Tz7t6x4r47tRqp4IyYx6QXyu+6n4UflF7+YYEUdHdbfVs1d3dp1pkjUs9nn6rwv6my2qz9nVaVrbz0VckBq6BQAjreBVIkhLQxLHurbicCVk6Afvpf+HYVPPoA7F1S9vMsjhORcFdLw/IVc9xc4ffjMOItQ/GMkpKTIcJZ3Gs6cT38bWIaAWvnH+wO5kZK8X0c5d9osbS0SYBpxUsF5xMQEMD+/fs5e/YsERERTJgwwWq/efPmcfHiRU6dOqWvvqqgUBLcdbc+Oa9oeiZ41bDetywK+8l4envpI0bKksgosa9dy36/yoRcPEXGeCl9U6PAYTn3n9Ys32pFcf6yWK4KpnlpfbzE8v/6dUSULIj8fNZywMpkZsOVONFPpkUj29eWl8vGJ0FWNjQPsuxTFVMQKCgoVD2uxltvl1cK1PcR+5EDjXRAK/Jsy8hRi1F2VvLLOT6tIUfAZmbD/FWmdmC2jWwJ8vUl28OWOUVFcEX3/Wm19vs6E5VGzeV/TnHl9Fl9W35ODkVFRVRzd7dzpsJ/HcUBq6CAWJ5gawNDgYx3xhoEyV4RLnm1Q2ERLPwZDh6DNjbymZUn/5wTDjVbS/vMc7Q5Qq6uqJZ7rcrjgL38j6F6ZVV1wMqGureTv/Z/o4Xx2tyOAaxw+2i1Wt58803atm1Lly5deOmll0wKNYDI2diiRQtatGjB+PHj9UuIFRRKgofODpCXf6fdwnR5vhGZ2c6/vkq3aTQaavn6WOirs+k+Suxr64pIdL23TC5z2/g9BI0eFq/zzB54yrn8QOTjlp2S8tLTyuKAlSQYPwXm/CAKspzS1S0y/jv6N1rsPdxNlzWapyDQFkLEJdO2fcvEw+8BPaGuj3A+AEz+ClKNUt5eumLdWVsVUxAoKChUPYzv+cbc0rVqzaaqAAAgAElEQVTLzy6bBIjUACDumeI+aNDUVv00dB1hW2PNH7Ia23zFBd7k5olUMsbctJ56vNyJvib2BeXogFWr1RQVWYpxfk4O1TyqrgP23sHw1MTi+ynYRnHAKvznGT16NFqt1uY2evRofW6yAT0M+V3tRQbKEbCFhSKv2SP/Bzt+K9OPUSJO6KoWD+hp/bhbNUtDsKQU6Cwr91o2QqsqgMMr1+lfV6uiOWDlKKDABs4d998YsW/V2LnjKpiSkJDAiRMnAMjMzCQyMhJ/f9MEXoMGDdIXczh69Cje3t74+fmV+1wV7kzkCFh5QUB6JtzXpvTjqVQq2vfvU6Jo1jbedXm9XRf9lnYjyUJfnY0ckSNX8Z3+qtg3rOf0S90WN5JFxCdYPvg0X6US3FTXrrOnHV2hUpas2wVvfCairrqPgrsHwZodhuOJKcLp7+5mvwhXYSFcjDG812rBT5c+8NnH4fuPYfmnWOXSFTsRsBUZmqWgoPCfoEM7eLx36c+39VBNdsx6eoh9XR8jHdBCnUajIVjLzzuEpv57WUtism2N/cjs+X18kuF1fjG60jIUBr5k2ibrbS1P++eWNdG6/Lfl+cBNrdEgFVpeMD87BzcPj/KbSDlz6jys2lbRs7izUYpwKfzn2bp1Kx06dLB5PDo6mgd1ETQe7oaoGnsBlbJdanxfTk4Ve8fTjDuPi7Fi37MzfLLA8ng1V5FQvTTINk5lSkFQWGD4MFW1CJf8b+pnP8+9w1yIEftWTRw777VJ0c6dyH+IRo0aERISwtGjR03a/f39uXr1qv79tWvX8Pf3JyHBSplSBQUz3HW3vmxDRhZqe4kKtrIuWaOujQq37R/ry4gZH1LL15eDP6yy3knH5YxUVl46Q1b6LTy9arHhk5lcOWNYrhcd7fz7hVYrjFbzFAT1fJx+Kadh7oA11+FWTeDYaYNjtrJEwJqTngFnMkSUljHnoyGktX0HbNRViEuCV3URzGFvwPqvxGuvGvYjmy7GigfkGo1pMbCqmIJA0VgFhcrH0Z/F/cbt7uIdmdawdU8vKBCRpzWM/Hn6lRBaiDixlQfbdWD2cutOMXON/XmH2ELaiPMXTDUU7SouetRamgR5JYJsG1cUcgRsfSfbQraQi4ZJVgQmLzsHtyocASvzyvTKu8KotJSXvioOWIX/PDdv3uTmzZsW7fV9refDk404uzlgdU8nje/Lct6dGhX4UEySRBSUrbxqtxMBK+Nes/JEwGqNwoSquVdNB2yC7m/U2akVs7LhWoLjDthTETbWUSnYxdPTkw0bNvDaa6+RkZFR/AlWGDduHOPHjwcotvKswn8HD92tT46A/XEz9OsmKirbc8DaSptTXReK4xPQsNhr5xZqyS3UEn8lhgYtmhGTmMCJ48cdmX6pSE23dMDuPFzmly0163bB8P7w6gwI6ydyx096QRzTaqFlY/G6suWAtYX5ctp/o6HLPaaOCTkHbGYWeHUSv5eM893KDxcBvGqKFEq2uHRFVOJu0UjkpZWpig5YRWMVFCofGVniPtWtI/z6p+Pna9TiXm+tRsetTFPbUV6BWaCF+ISbkHuTrFRwRFrlFZHGEbClsU9jdKs4KjK4COCcLvd7eeWAVemWuhZZEZj87KqdgkDmm5Viq0qUl74qKQgUqhTR0dF8+eWXtz3OXS0h4TCMGWJ5TBZHeykI7m4p9oVWHLC+NqKKypLu3bsjSRKSJOHSOpVEXeGm+vXr88svvxAbG0tOTg7NH46jc+hamje3tLzd3d357LPP9H2joqKYONGQBKZh/fq80a4LM58YyeYv5uFaDsVWiqPIzEp1cat6eWATkorvU1ouxMDo/0G7FiU/5+FuXjzcrYIfhd9huLi4sGHDBlauXMmmTZssjl+/fp3AQINnIiAggOvXr1v0W7x4MR07dqRjx44kJ5dhNSWFOwr52ZOcA/aaLqVOvTqOjxUdHc3zw0YAOLTELjNFeHpr1imfMNTUW4YUBDfT4Ksf7RcmuV2MNTY11dSrLbcbb0eOHDHpk5EFU76/n6U//cXEz3M4cuwy1H6FS7FiaWXLRiJC/o9/JAiW2PuHhKdnBa/5tIN5dKv8m8OjumWfGp4GJ+kVowiry9cMr71rmjoKzDlzQeyfGWzarlZVvRQEisYqKFQ+DugWLg3oUbrzq7naDoCp3T6aJ0cZbNvXdKsEtIWGFAClrQNhbCaVJoPcx/PhtU9hZQUsSXd1deXnn38mKiqKVVuyyWyYSJfHdtC+fXuLvhqNhnfeeYcLFy6Qm5vL1atXmT17dqmvrVLpHLBWUhDkZWfj5l51UxBUZcpLXyveQ6KgUAmRnaSjB1keC6gv9p52Hm7Jhl98oqFNjjSq43378ystI0aMYPtPj+Cv+wweHh6kpqYyefJk+vbty62o16lVuxX79+/Hy8twA1Kr1ezYsYNBgwbxwQcf0LdvXz755BOTsZNu3mR1VAR/JV6jslIVl4SURdEcmeW/iH17B/JFTnojkElvBBbfUUHPkiVLiIyMZM6cOVaPb9myhVGjxC/uzp07k56erqQfUCgxstNLrmIsO8PmfwjPhzk+XqFWWIl2VxWYhcPkZGSgLSigZp3yeQKZegvua1sulzJhxIgRPPLIIxbtM2fOpEuXLvptzJgxJsebNWvG7t27iY6Opl+/fixcuBBtndnM2TyGnFzo3hHi4+N5ZVwXSP64vD5OqTFfgvu7rnCLsS/U3EkLptFLxmN41TTk37fGsdNi1UYjs6DsqhgBq2isgkLlQ07xM7x/6c7v2VmsUrSG+T0sQFcCQKs1PLTKyinddU//a3hdsxTP9PILYN4K09Qv5YVGo0GSJD799FP69+/P06PG4eLqwf79+2nSxHT53vLly5kwYQIzZ86kT58+vPvuu+TklPJLA9S6CFhJshIBm5NbZVddVnXKS1+VFAQKClaQnyjKS/WNf/j3ecCwb1DXelRGkSSMXG1RdUCockVGwMqcPn2aVnXOMrCriOSNjo7m2Wef1R8vSodde47z9GsX6dWrlz4ab9y4cdxzzz20atWKpCTxgQ8dOmQydkFBAfE5mdR2E07OvOxc1NXthAlXAK+sWMhnA56s6GncMWzaC3xWukg5hZLxwAMPMGrUKE6fPq0vxvX+++8TFCQqyixcuJAdO3bQr18/Ll26RHZ2tsn/WQWF4jCPgE3SPQxs2Ri+mwIL1jg2XqEuZMbeA6031v6g66tF4+KCJEnkZWfT6O67HLtYMVSvXp3c3FyL9owsYaQ+YBkIU6acPn2as2fPWrTHxMRY5HY2ZuLEicTFxfH0009TWFjIgQMHCAoK4t33pqC+vIT6vuDuls/F80ehILgsP0KZIAcJGTsYzPPe2sOrhiHvoS1+/wfuaiGK1CTpskpVRQesgoJC5aJpoCFNjHnqm5IgF9iylQLA1sOnAi1s3gfPvm9a+NARZNsUSu6AtaW75c3/s3fe8VFU6///bE02yaaTBiGUICX0IuUiKCBNEVEERLki9yJX7OLX7r0C/lBE7IqIFDugFClSBEQpoRdDkxoIpJG+yWY3W+b3x5nZndmd3exutibn/Xrta3ZnzsyehDDPnOd8zufR6XSYNEk4i7xjxw6Ulpbi3nvvtYgaRowYgYkTJ6Jbt244e/asV75bKiV+QGJFuPRaLWKSm3nleyiNE6qApTR6Bg4ciN27d6OmpgYlJSX48ssvERVF1lm0atUKDMNg9OjRgnOkUimQWYCUjnOtVS2VWahN3AS0qyKvtNV4ZHyy5RxuCeLw4cMx6sFfkNhPg08//RQA8Pzzz2Pu+4eAdhW4e3ohNmzYgLZt29r1dc6cOSgqKkJlZSWWLl2KiRMngmEYZGRYTVvDwsIwf/58XLt2DTqdDidOnMCoUaNc/n1cLyKDklSR2BCmBKoqiTxKqbQmT6dNm4bVq1dbkq+uIGZMHmiatRIpk9wIMBiAi1frb+cu1VrygDe4j/evTSHs27cPEokE3bp1Q48ePdCjRw9s2bIFixcvxuLFiy3tnnzySWRmZqJr16446gcPTUrjISKcKGU4dWFFFblnOKPvRCBjqPgxM3shJWtBIBZjOQsatUyJ5zv3Q/c2mYiIjkbbPj0Ql5YCqVSKgoICzJ1rVXNmZWVh06ZNqKqqQlVVFVavXo3kZPEY+8svv0CjEcbYQ4cOoaKiAoWFhYjpuAFQtEVHmzDrjxjrCaNGjcLatWth4smIVq5cifT0dHy+tjMAsnpGzB8wFGjJKrZsHwtybwCvOFkFyrVXKKz+t46IVQNZ7YDifcRHF2icFgQUCiW42PA50JvcpiGXu7+Unyt4yfm0b9oNtLnTelynt763FMJSDcTvv5O4+96SEnz8iWtjW9u4GxGTBbQgY9us0Q2Lu4Ec23LU1NRAp9PZjWF37drlteQrAEikJCsu6gFbW+uWRROl6UETsJRGzYABA7Bjxw4UFhZi/PjxePbZZzF69GgsX74cgFWVMmHCBMF5vfoMBuQpQNVKDP8HkJLWFsjYB01tOFDwMGquTIVZkYVnXt1o951Lly5FadFJVJ69B0uXLgVAPBvnL/gU678Zi6eenA6ZTIb9+/cjOto6Vfrss8/i1VdfxRdffIHx48ejtrYW7777rt31f/75Z0ydOhXz5s3DmDFjcPjwYWzYsAHdunVz6Xdyg/X/a26Nr5BIJJDL5VBGtMSguz5Cbm4uNm/eDIB47PTo0QPXr1/Hd999B61Wi4qKCixbtgxqtYemQxSvEtkL6ODhsqf6UMiBO271zbUpFIpv+c8k4NUZQj9yhrGqYB1xrQC4li9+jGFljEpVuMMYO6I5GYQVFBehQFuNvh2y8PMcEs8ioqMxePBgpKSkYOVKIr9t27Yt9u3bh/DwcDz88MOYOnUqsrKysHGjeIw9efIk7rlHGGM//fRTjB07FtOnT0dNrQxMxn50aOv/GCvGm2++CYPBgJs3b2Lp0qWIi7MuhYmIiEDLli1x7tw5wTncYDEqliheE2LrV4EGK38eJQqtz38U7m89DHhniXDfmu1ka2aAfces+1umWt+LJWM//xFYuobYPY0YSPZRBSyFQvE1tpZ0rzxmnQSqj7QkYBnr6DZ3EdnefTtwhefmxo/ffx4BoBoApLs/thWLu3MW7gMk7Nj2csPibiDHtjKZDMnJyXj33XdhMpnw44/WYNO3b1+cP38en3zyCSorK1FTU4M1a9YgNTXVyRWdI+EUsCIBRq+tbZSWdxTvwgTidfjw4YB8L3017teVK1eYBQsWWD7/+eefzK5duwRt7rjjDoZhGCYrK4sBwDz77LNMeXk5o1QqLW1+WvUFw+hymCs7wGz4HMzv279hGN055qu3FAxzFkxpNpjTWzMZs8nIjB49mgHADB48mGEYhnn//feZz/4LpmiveB+lUikTHh7OVFVVMVOmTLHsy8/PZz799FNB282bNzMMwzAZGRkMAGbIkCEMwzDMoEGDBO3++OMPZvXq1Q5/L1zfsrKymC63gGHOghk/wnp80aJFDEdp8UUmMzPTciwlJYVhGIapqqpi1q1bxwwbNoyZNm0aU1payqxatcrSrtuIoczCnGxmS95FhmEY5t2DvzMLc7KZhTnZAf2b4PoQDH0Jxdc7s8DUnrB+/nUxmKVvOW7/+/rOzO/rO3vlu2mcoL87+mrY69gacr9nzgr3n1gnvv+xCWRfSjPx6125coX58usVzMKcbOaVzT85jbErzp9gJr31BvN7/hWmRqdjOg3szyzMyWba9OrOfPHFF0xOTo7lnG+++YY5d+4co1AoLPsyMzMZo1E8xjr7mbkYazJUMfs3T2FKs8F8/Jr/YqztseXLlzP33Xcfc9tttzHPPfccU1ZWxhw5coSRSqUMACYtLY1hGIYZO3as4DyZTMYwDMPMmz2dYc6CGTWIxG0m/xGGYRgmMjIy4H9fzl5if1+uvBQKMBlp5H1cDJj7h4O5uR/M2V+t11z4kuPz130C5vxW8j53J5hl/y/wvwtvvmiMDY4X/d3RF/c6ud56b+K/XDn318XW9n27iZ9bUnyFYUoWMMxZMBnNwTA1fzJMtftjW7G4e+HCOYY5S8a2j01oeNz159iWe7300kuWMWxRURHTt29fwXGdTsdUVVUxe/bsYUaNGsVMmDCByc3NZQ4cOODxv3lkXCyzMCeb+ceD4+2O3fXs48w7R3YH/O+Svtx/+Su+UgUsJSiRShvu3aZSqdC/f3+sXr0aMpnM8tq7dy/q6urQq1cvAMDq1asRHR2NkSNHAiCzaEOH3QdUrUJ+MfH16dpzGFC9DsVlZgAyxMfKcPrsFRh0uejdu7fgeznlKJ++ffti+/btKCkpgclkQm1tLdRqNW655RYAQHp6OlJTU7FhwwbBebafhw0bhoKCAuzbt0/wM+3cudOuH464wRYG4ytg582bhwH9+wA3xqNacxPbt29HUlISAKKOBYDy8nI88MAD2LFjB5YtW4Znn30WEyZMQJs2bVz63mBBFU1Vu+5QVgmEhxEfyegoYNQg4JFxjtvPmHUJM2Zd8l8HKZQQQB0JvDyd2Lz4kx3ZZLt8rXA/3/ctLgZQRxHPc2eFjmyJjIxwGGNNZjOSVZGIjIvF+cpShCuV6NeDBPUItRr33XcfVq1aZbnWsGHDsG7dOpjNZst1rly5gtxcz2OsVK5Gi5YkxkbF+C/G2vLoo49i7dq12LNnDz744ANMnjwZvXr1wpgxY1w6nyu0mBhX/zL8xoDBAFxl1dfllUQRu+8YkMLzIo9xEsb3HSd/y0kJjdOCgMZYCiW4qGlAMVwpLxNTUg4sXgWMe0rYhi+yNJlVgKo/oHF/bCsWd3/+eR2UXc2Qd5Zh6ZqGx91AjG1XrFiB3r17Y8yYMTh69Cg2bdqEjh07Wo5LJBJIJBKMHTsWW7ZswerVqzFlyhT07dsXQ4YMqff6YlgsCESqj+lrdVCEhUEqawIBu5Hhr/hKE7CUoGTuM8De70lVSE+Ji4uDXC7HokWLYDQaLa+6ujoolUqkp5Mqd/n5+di7dy8mTiTFmYYOHYq4+GZA1UrkFwNtWgDRMYlAwst4ZaER6EBeDzxrhDKiLTIyhNXyioqKBJ/T09Oxfft2SCQSzJgxAwMGDEDv3r1RVFSE8HBSHSUlhRik2Xqs2n5OTExEamqq4OcxGo2YPXu25eepj7IK4jPUgpeAzcvLw6mcI4BmDb5YMByxsbF44oknAAAVFWSkvm/fPhh5JYp37doFAOjUqZNL3xssRCfSilLuUFZJtvExvOQM4zhRc/5SLc5f8ryyKIXSGJk4Gnj7eWDO0/79XjND7vfTXhPub8MLF+kpwLE1wPmtwOf/df3aanW0wxgrk0qhVoQBYFBtNOBKSTHuGkZM7W4b8A80a9bMsgwSILHt5Zdftottbdu2tYttrsbY2uoixMWQGBup9l+MrY+tW7dCo9GgZ0+SkOZibExMjKAdZ1NwPZ/4RSSGsAdsQzn4FxDLK24T7aRYDGdbsGRO47QgoDGWQgkuqmrI9tsNztuJwS9GWFIO/OdNYP0OYRv+PSw6Jg6QyIEU98e2juJuXZ334m4gxrZFRUWWxOuYMWNQWlqKl19+2XK8vLwcOTk5KCsrs+zbu3cv9Hq9x2NYSxEuxn6Gr05L7s9KrgIqJWTwV3xtoo9ylGBnYA+ynTER+N1x4WCnVFRUwGw2480338Svv9qXh8zPtxrcrVq1Cu+88w7Cw8MxceJEnD1zDB2lF5FfTIo/aGrKoDavwxtzv8JcdgD9v0+A2U8B3y4rAUAq7wKAUiG8GY8cORIREREYO3YstFoyTSqTyRAfH29pU1hYSK7RTFgZy/ZzWVkZrl+/jnvvvdeD34iV60VAz05EzZh7Azh7CVAqyDGNRoNLly5ZlK21tbXIzc21KGE5uM9iBuQclcU3EZMU2EqQ13LOICI2GonpLQAA0c0SUXQ5N6B9CiXKWKVcfIxViSWTkb/34lL79ncPJ0mDTdvrMZmkUJoQXFX2F/8FvPahtSBWoPhhE/GGBYCHxhClICBU44gikSCtfTv8DYBRyB3G2OdWLke10Tqy/KsgD3cOGYrlV09j1JChOHbsGC5evGg5XlZWhnXr1uGrr76y+8qSkhLBZ9sBj6MYq1TFQ6YHyiRAjca/MdYVuJ9Dq9Xi2rVr6NChg+A49/nY8XMwGokCtkLj8255jfJKoq72Bgf/En52VuTm8ClSaG7kQKC0svElYGmMpVCCj+wTwIz/AVPuse6LUAFaB7mcIf2A/ceFCdhKB/d3vgdsQ8a2/oi7gRzbAoDJZEJOTo5gdebZs2ctSWE+EonE6RjWGVL2YYkRUcDGphKFU0RcLHTVNR5dnxIY/BVfaQKWEpTsPQYM6mOtDOkJWq0WBw4cQPv27QUVH8X46aef8NFHH2HcuHEYN24cjv75Njq2ty7XL7q2E+q2WTh06CjAVqk8egyADnhuMrB7H/DG42T/BJuijSqVCmazWaAenTBhAhQKheVzXl4eCgoKMHbsWGzfvt2y/5577hFca+fOnZg1axaqq6vx999/u/cL4XE+F7hrMHkAqKoG4vtZl8YqwhLQvn17bNmyxdJ+06ZNGDt2LBQKBQxs+eyhQ4daAp0jPps6Eyq1E6mKH/ho8r+QntURz65cBgBQJ8bXcwaFD18Be63Aur95sngCdtbM5gDo4JBC4cMfu+z/Abh1guO2/mDuImsC9sV/AUUlwIWrZOm2M1RqNZIjW+HvwmswSeAwxhbpyKBDApLZPVtShDGduiMzOh63tcrC3NlzBO137tyJrKwsHD161O2fxVGMlclIjI2PAaor/RtjnTFixAio1WrBz7plyxaMGzcOr7/+umVAOHHiRFy7dg2nTp1CSTkpwpV7wydd8gntRwPJXlpwcuSU8LMzCwKjEfj3G8DPH5GJ5cZmQUBjLIUSXERFEIFCrY7YEURGkP3JCcJiWhwJscDO5cCvf1pFDs7g5whrajwf27799tuC476Iu4Ec2wJAWFgYevbsiX379ln2bdq0CbNnz0ZCQgJKS8nAZdCgQVAqlTh58qRH3yNhE7BiCdwodvVKcuuWKMsLoaBN8Vt8pQlYSkCJiiCJv1KbAFReRbYdGmgv+uKLL2Lnzp0wm834+eefodFo0LJlS9x111147bXXcOHCBQBkOcTu3bvx3nvvIS4uDsM6rwYMQD6bgM2MeBMIO4Q35m0G1MsAUwlad2wOpN6Jzt1WAPgDEezkWkQ4AJ66adeuXZDJZFi+fDmWLl2KrKwsvPDCCygvt/7nNpvNWLBgARYsWICbN29i3759uOeee9ClSxfLcQD47bffsG3bNvz222+YP38+Tp8+jejoaHTv3h3h4eF49dVXXfq9TH4BaN8amP3f5zFqaGs8PfNPFBQUAzGt8dwbz0Gv12Px4sWW9gsWLMDDDz+MNWvW4PPPP0d6ejrmz5+PZcuWIS8vz+H3lOaJPHkEAE2pNVMYnZgYwJ6EHpYEbKxwf4tk4PgZ//eHQgl1bmkV6B4AOr3wc3KidcLRGVKpBOCNNxzF2LvT22FvUR7MZqIOqZMw2P3HHxg06DZEKZRYvXq14LpvvvkmDh06hM2bN2PZsmUoKSlB8+bNceedd2LFihX4448/HPbJUYytqiqHddW6f2Msx/Tp09G7d2/s2LEDJSUl6NmzJ15//XUcPHhQ4Km3YMECPPTQQ/j222+xZMkS9OnTBzNmzMDjj5OZ3dJK1gM2hJ7ab5ZZld8NpaqabBnW/saZBQEAHGLnhZWKxqeApVAowUWkynqvu1luTcDOforY/9iueOFWmoweBOw5Uv/1+fcws9nzsa0/4q4/x7aTJk3CqFGjsHXrVuTn5yM1NRUzZ85Eamoq3n//fUu7L7/8Ek8//TQ2btyIefPmQa1WY/78+fjtt98EiVp3kMhYBazIDF/26rXodfcImAz26lgKBaAesJQA0rEtUH4QKMkGPnldeIxLZqYlkYGhp+zbtw+DBg1Cs2bN8O2332Ljxo148cUXkZeXZ+dns3LlSqSlpeHqpWzAcBUAeei/XgjAcAG42g+1tVog5UugxRY88/xsXMjVQ2Yiyzk4hVP3joLL4tSpU5g6dSr69u2LTZs2YfLkyXjggQdQWVkpaPfBBx/g7bffxsyZM7FmzRrExcVh3rx5pB9VVZZ29913n6UI1rZt27B48WL0798fe/fudfn3UlUNHM4B1m46CSg74s25n2HFd1uBhNdw4e9D6NmzJ27csM7aXbt2DcOGDUNsbCzWrl2LuXPn4uuvv8ZTTz1ld22zKcBra0WoKLRmFsa88BSkTaGSiZfgErBx0cL9/CJuFArFNTb/QSYeg4Gd2cCcz62fq10oJGI71HAUY8u1NdAaDdi/ej0AQB6mxMoff0SUQolzuVdw9epVwXUuXLiAfv36QavV4ssvv8SWLVswe/Zs6PV6wZJJMRzF2LKySktSOS7avzGW49KlS8jKysKiRYuwbds2PPPMM/jmm28wfPhwgXLm0qVLGDlyJDIzM7FlyxbMnDkTs2bNwtKlSwEQb8CmUoTLEZpqoI4swHGqgAWAvAKg8CZNwFIoFN9yYCUZ93Hxkz/pNOUe4MmHnJ9/mwu1Hfk5PobxbGybnZ3tl7jrz7HtuXPnkJCQgPfffx/btm3D22+/jfz8fPTu3RsnTpywtNNoNBgyZAjKy8uxcuVKfPbZZ9i5cycmTPB8KZLUooC1T7Jqq4iXRAQt+kxxAhOI1+HDhwPyvfQVPK9hA8AwZ8Hs/5FsJ4yyHntnFhjdSbL//uH+7de0+8n3MmfB3DMEzFvPWD93bQ+m4E8w57eStvNfAFN7grw/8jNpk7sTzGf/BVO0t+F9WbJkCZObm9vg6wwePJhhGIbp2rUrI5VKLfvlctL/+S+Qn405C2bcnZ59R7cRQ5n3c7KZ9WdPMAzDMO8e/D3gf2P818KcbMsrqXVGwPsTKpxLV5gAACAASURBVK/ICPJ38cI0MDFq8t54GszcZ8Tb/76+M/P7+s5e+W4aJ+jvrrG87hlC/u98v4BsoyL8873vzAKjPe74eJgSjOk06dPmL6yxLqWZePv7XntBcC91dN05e7Yy416dxaRndWQW5mQz7xzezQBg3ty9mbn/jRf99nu/fzj5ef74Vvy4r2Ost14/fwTm1EYwsx6VMUz+owzDMExkZKTffo/B8Ko4DKbqCPn3rDhUf/ttX5G2H70a+L5780VjbHC86O+OvgBrzFw8m3zevNi6jzkLZvUH9uc0iyfHtCeEbV35nghV4H/mhr68FXcD+WrWqiWzMCeb6THqTrtj0c0SmYU52Uz/B8YFvJ/05d7LX/E1hBYzURobCvav76WFwO6vgZkPAqtZ29GIcOKjE6YEPnoVWLPd8XW8TT5vGaZMBhQIizWi5/3kfw8A3CgCwsOInw/DABevAS1TrD+bO2RlZWHixInYv38/zGYzRo0ahUcffRQvvfSSxz+LLSdPnkRFRYWlurLRSAzgH7ob+HkbacM3hHeHtORkPNe5n5d66luS27ZG8ZWr9TekoEYL1NURH0WOqmpiQUChUNyDK6IUo7ZXnN45ANi+FOh8D3D6gn/6o68jcSw9FdDq6m9vZD3AOaa89xaObtyKM38IVSoSiQSM2QxDHQkoivAw8n01WoRH+k8CzPlWp6cEJsZ6i5JyICkpA+8ty/XqdUMKBjCagYXLgZX2tWfsuMy6I9VbWI5CoVAaCBc/OQVsnYEo8O8Z4vicKg2gIqERU1wMQza1sIIef8TdQGApwiWyxIJTwKqoApbiAJqApQQMJevTrakBvl4PDP+H9ViEigSzw3uBO24lD9D+WkamtPqHIyMNuJovPM5PyN5gV3pwy7E1NYBSWX8hEzFqamowcOBAPPnkk4iMjMTVq1fx0ksvYeHChe5fzIajR4+id2+yzsVoY0ZUWU2KnalY2wdPE7DFpaX4/mIObvx9HsltWsEgsiwjGDCbzUhu2xo5O3YHuishQ1mlMAFbqQE6OvBnnjLzvH86RaGEIJW8BOwN4UpBjLyN3Q70XwIWAC5fJwlYVzDZJGC7DB2M+Oap4glYhoFRLzSb1ddoERbhvwRsHinCjJapgYux3qC0AmgWnY91X/XGuGFAv0mwVJ5uKsSoSX2AF951rf1N1oqwsSVgaYylUIKHG0VAdBTw1iLyedcB4JF7rWNJrsAxxxszrWPEqhpis/fX38B3G1z7vlBLwPoy7gYSiYz4AYkV4TLq9TDo9dSCIATxV3ylCVhKwOBUogYjUZo2TwY2LgKemEsUsFod8NM2YMRAMnjyV/VfvnpVJhUmXG0DH+cv1yKFbDWk8DM6t3M/YZybm4shQ5xMlTaA6upqh1UuX/8I+OYdoOst5HOdQbRZvRiNRhTpanA5/wbkGc0RHlVPlQw/M/+eSTDo9Hh82adIadMq0N0JKWwTsCUVQN9uQOsW9hVer+d7mMGnUJoAXAI2VuS5vIRNGCV6VzxZL5fzgMF9hPskDtqaDNbk4hfTn8aAifehWUa6fUM2AWuwScDqtDUI86MCtqiEbBkmcDHWG+w/AQAGDOl2FNABhw6F3kC8oZy+CJRX1t+Oo2cnsu3Q2jf9CRQ0xlIowYPRRFYQcsWk1++0bxMfC5Sxx+fwSmdwxQVti2I6I9Q8rX0ZdwOJREKekswm8X+Q2ioNVcCGIP6Kr41sXpgSSlgSsAZSMEFTA9x9OzC0H5uArQUusKvEPVGUNrRfcz4HPvkOKHBSGfo6q65pnkS21VrAZPL/ALohHDxJtoNYI3hPFLDh6ij88723AAD7V63zUs+8S/GVqygvKETRpVwk0QSsW9gmYLfvJQ+MH4kUJp1wbyIm3NuAynkUSiOmkh1wiRUR4hR7zeL91x8AuMQu1R4/ghTmAgCFQrytrQWBqa4OMrn9XL5ESiwIjDYBRV+j9WsClmGAR18Feo3321f6hM27yQA/Rk2eMZpa8hUAOo8BbnvY9fbL1pBtapJv+hMoaIylUIIXLqnKp30r8bbchKzOhXHXAXas5iDfR/EzUhlrQcCI/4NoaQI2JPFXfKUJWErA4CtgX/8IaDaAfE5tZrUguJBL9rVr5cd+sQPPr9cTNaitByyfwhIyG8lZEJjNZDlnKHHhKlGVPDCSfPYkAZt2S6blffGVXO90zEcUXc5FSts2mLJgrmjigGKPbQK2uAx45QNgzB3Ao/cJ2z4+NQWPT03xbwcplBChgi36GxNlf4wbuKX7+b8Pf+nj/c8AD/0fcC1fvK2tBYHRYIRcqbRrJ5FIAQYwiCVg/WhBAAAr1pElnqHO31fI1hic7j5Bx362CHbzRpaApTGWQgkNDv1Fth0cWHZVsasmZS5kY8Y+AfSdSCbgKIFHKmUtCJwoYCOio/3ZJYoX8Fd8pQlYSsDgEp3cikZ9HUkEpiRaLQgKbgLVNUBmSz/2i5cYBpwvyTcagaJSq3oUAI6cItso/44xPYZhgJO8waknFgTcUoxQ4MTWHSi6kovuI4chrrmLxodNnOIyYjeg5rlKfPg1SSb17Rq4flEooYYzBSx3G+X7ofsDvs95pQb4YZPjtnwLAgAwGuogE6k6yRXhMtYFVgHbmDifS7YGD22Cmhqc/cS2vc7bUSgUije5/Z/ArROA/g+SsW3HNsDHrwFvPiFsZ7EkciFPV1xqTehSAo9ESh7YGAf1TmqrNFAnxqPjbQMQrhaZcac0aWgClhIwbBOdAEm4pjazWhAAwMVrQK9OZHlkCz9M+ov1yxl1BqBHR+vnNdvJNkLl3X75knmLre89UcBKWTPyUOD6mXP49aMvAACqKBoUXWHJT+QBceo44f5zV/w7OUKhhDrOPGClvHmsYC0cZLIpMGVypICVSsAwZpht5Dp6LU3AegqngA0PC2w/QgWGAVIHuV5dnEKhULzBH4eBwzlkVeT5XLJa7KmHgf89KfR75RSwcVQoGfRExsZAxVO0cgpYxizuB6StqkJKZhv8+/OFGP30f/zSR0roEKSP+JSmAJfo5CsuC0tYBSxrQQAAZy4Bg/oAP30IbP7Cf/3iq0y4ZLAYP24mySmu4iXnWxtK7Dxgfe9JAlYiDR0FLADoqokMTRVNE7CucOgv4MxF4N6hwv2XrgFtaQKWQnGZWj2JLWIKWH7SlW/54Q8qNcDWPfW3s03AGuscKGClUlGfUn2NFkqVKqRWTQQLnAKWOue4TuFNz55pKBQKxRucuyy0IODbDXC2Q2ITspTgQSqXYc6erXhr3zbLPnUiMes3O6iKVlulsbxPbdfWtx2khBw0AUsJGFzC0iCWgOUpYJ99G5j8f2Spf5ofvLzEFLD3P0MKcp27Yt/+4jWyTW0m/BxKmM3ALjYJW611/3yJJLRuJVwCNpwqYF1m/U6gV5Zw38VrQMtU6/9lCoXiHIYhNgT1JWCTEvzXJwCIvRUY9Zj75zlUwIJYENii19ZCKpVCER7uSTebNGLPHxQKhUIJXn7bL/zML3DJJWB3ZPuvPxT3kcqss55KlQrqhHhM/fAdALBb5cPBT8CqE/xcWZUS9NB5dErAcGZBoK+zKmBvlgE/biKFSebPIt6q9SUJ77qdtK3WAvc9BeQXu94vLpnEV+Zu3eNYHXSjiGy5ytXO1LLBzP3PAFmZ1iWy7iBxxUE+iKitoglYd1m/E3h1hnDfxWskadSquVWdNX7aOb/3jUIJJSqq6rcgSIoHzjTgO5QKYPc3QP/uDbiICLbKVWNdHeQK+xkYiVQCBvYSWH0NCd6RsTGoqw3RYBkgzlwEnpwL5BUGuieUQEJjLIUSeGQy4LUZQEYaEGY/B2lhqxMP6uhI4hPLPT9Tgh9VdJRgApkRW+oDQMtPwCb6eUad4jH+iq+hlTWhNCpsi3ABRAEbGQHEx1oTsByX88i2TXr91358Ekkm9u0K3DOk4f1yxvVGMhiqqAL2HfPs3FBVwKa1z0RcKq0m7AqHc4Ar18l77mHzEqv2zsywtistM6K0zMX/PBSKA3qNGYWFOdkIi2h8fqGeKmDvvh2YNFr8mj8uBIr3WT83i/d+8hUApDbmtFxRLpltElYiEfVGM5tIe3UzOiDxhM9+ADbsCnQvKIGExlgKJfB0agvMfoq879fNcbu8Auv7WptxbXoqcOAEUFbh/f5RfINKrUYd7x+ScUEBGx4VKdqGEnz4K76GVtaE0qhQyMnSd/4qxYKb1ve2SlJ3ErAASRjV1ZHZSXf7BQAO7ql23BBR13KJKm8wYua/Me3jdzHu1VlB65sntfGArSgsClBPXENfowXDMLjtoQmYtebboP29BhvvLiXb9q3IlrPbWPeJdeLikUlJeGSSH7xCKI2a8dPvwCDpx0hITw10V7xOpQaIERHf829DXdoB818QxruNi0iiVYxJo62rMACizvEJIgpYAHYqWKlUarEgOH/gMP78dhUA4OY1EhyV1IKAQvEIGmMplMDDtz5PSXTeds8Rsi2rFO5Pp/qPkODW+8ZY3odHRYFvcO/IA1avFS7VlcpDp1h1U8Zf8ZVaEFAChkJurzItLLG+t1XAXmITsG1dTMACwLUCzxKwdW4UbSivJLOaKt54sutYouL1BkP//YilyMme71ej5Gqedy7sRSRSa2CRyGR4/4FHEJuaHMAeOYdhGPz60RdIbdcGPe8aAWWEyrI0luKYUxfItlMm2d4sI8tiO2UCA3sCvx8EprKB6+uVbvh+UCg2TExdhNbSK+jWoR3y/w50b7yL0QQM6UfeqyPJs3y1VqiAHdqfKFjrDMCXq4D/95zj6/GXP4aHkSrL3naFCY+KRLu+vaEICxPsNxmJV49cqYCevYVaJrTYQcri6U9b2htY5YhSpfJuBymUJgKNsRRK4OEXQ4yoJ5yduQTc1ts65s05D3S5BVi82nf9o3iHdn174/5XZ1k+q9TC2XMxr3sAKLokNG2PiotD1U2S5IhNSUbXO+/An9+u9HJvKQ3FX/GVKmApAUMhFxbgAqwqV8B+qUalhizTcFUBCwC5+cSf0u1+uak+v24j+KzWAtfy3buGI0xGIy4cINOnwVpJUcJTwMoVCtRUVOLG2fMB7FH97Fr6DS4cPAqALCmh1M/Bv4Bte4Fn5ln39ZlAEj533x6wblEaIXoDGd2kNGt8qgFO9SKVAgV/ApWH2c88cSk3oGueBNw/HJhyj+Pr6U5a33OFKr2tgB319H8w9cN30GvMSMF+I2uWLuMX4mITsGYRbzTO91WpogpYCoVCoYQm7kxyHmMN3fWsuKe8CpB0BFb96v1+UbyLyShMCKiihQlYs0k8AVtRKEzg8Qtx/evTBRj74jOISW7mpV5SQg2agKUEDIVcWOgKIEv3//ky2R45bX/OpTxg5oNk5tAVcm/4JwF7w8cr7osuX4HZZELaLZm+/SIXCFdHQSYXiuclPOmWWEXsYKW2qgoAoIqmCVhXMBiAkdOBQ39Z92lrifJ1+gOB6xel8VGpIwm6ZgmNzx5k7Q6yzWxJPM+lUqJi5W6jxaVABJuffPQ+4InJwvPDeSJUW/eU5uzCA28rYA06PQD7ySoTO4sq563H5CbkxJQhdVQBS6FQKJQQhz/JWZ9l3c4DZHuUHdfS1eihQ61GWJna9hnIkQLWtsioOtGagA2LJJ6wdt75lCYDTcBSAoZSIZ7o/PYXoM2dxJjcli9/ItuHnaiB+FzNB1KbOa9QaYvCQb+cwRXi6tzOvfPEiIyNsZsVM+j0KLl2HSlBoIB9besaPDR/tmCfVJCADZ2AUqshxbhoArZhHD5FllJ3aBPonlAaCxVakmVsFtc4ErA9O5FtrBr4aSt5362D9fgTk60J2MISawIWEBa5A4D4GMff09xHClhtJTGvC4sQKlc5BSx/4s1SlFGkODBVwFIoFAol1OGSqK+8D2SOcN720jWieN26l3we0MO3faN4D9tiouE2FgSOPGBtUSfEIzIuFkP+NQUMQ86xLWpKaTrQf3lKwPAk0fnVT8D+48A/XAxeuTfItqUbPrBiytz6WPIz2bqrtrUlPCoSc/ZsxX93bEDrnsKymgUXLiGtfWbAFaYR0dHoNnyIYJ8kZBOwZGbT1tOH4h6/7SfbFrSgAMVLVNSQ+0hCrGsPt8HOG4+T7T96AmcvETV59w7A6Ytk//ABQCLrG15UCiTFi18HcJ6A5WKdtxWw3DI7ZUSEYL+RVcDK+ApYVpbLDTL46KkClkKhUCghDjfJueeodaxZH9RyIPRxVQFrS4usjhj3yvO469mZSExvAQBI79zJ6/2jhAa0CBclYHiy1B8A9h4DnplCVK36eoplcUHx9j7AhVzXru9ImeuMP1kPv/JK5+3q/W7e4DYuLQVXjlnN/fL/voBuw4dg7t5tmDfqfmhKyxr2ZV5EGqoWBJwClnrANoh81uoorRkw+sEzge0MpVFQWU3uKfHR9aztCxG4W6REQib4zlwiCliu9t+I28iLayN38nTmrMBjFutSww0OP/uh/jjpDnKbJXMWBayCp4DlLAhEPGCNej3MZjOUEVQBS6F4Ao2xFErg4RSwDixARXFX3EMJPmwFO5w9kxgmo9Fi2adSRwnESgDw8PzZOP7rdu93kuIx/oqvVAFLCRieJmD3HSPJV1dsCLiq7bf19n2/0u8AOtzl/nmOUEUJb/L7V63FgZ9/gVIVjqiEOO99kRs48qvhgorJYMTFw8f82aUGUVvFJWCFv2uJVGrnc0txTMFNsk1LAmprzaitbRyqRUrgMNSRxGu8WngzbpECPDQGaN0iEL1qOJxn68m/gbsGi6vGj56293bl40wBy3nRcQrYrXuAWfM966srmAwku8uPDRYFrFnEgwDEhoAqYCkUz6AxlkIJPNwkZ33+r7Z0HQt0u9f7/aH4B75l3Zk/96H0umP5c2URGRwZDQbIlUo7P1lK8OGv+EoTsJSA4Wmicw8pXI8ZE+pvW1EFfLsBGHWbVYHkUr88mKW8XkiKp3gLzqSbQ1tZhYILlwAAGV27eO+L3IBvLyDhZQg4xdPbdz0AHasqDQV01eIesI8v+xTvHt8TiC6FJLU6ov5OSwIefzQFjz9KvQgoDYNTVsZGCuWbbz8HfPcusOh/geiV56xnC28dZBc1bGO94NKS7NuWVji/lrMELFegV+aBOscTjGwQF8YGEmwdF6fQQRlOFbAUiifQGEuhBB5uktPoZgI25zzw19/e7w/FP/AFO6d/dz5OPLJxCwBAW1EJpSocOk2NT/tGaTj+iq80AUsJGJ4mOssrgf9+AvTp4prn5MbfgcQ4YOxQN/rlQWLY26jUkXb7oti1p4MfedDf3QEgtBcY9thUy3vOgsBVL5xggTGbUauptrMgaNuLOuS7S/5NkkyaMDYRE8YmBro7lBCHMZNRTYxKuLwrnNTmCjkF7MbdZHuGzKFh7W+O27ZJd34tZwnYGPZWxg0O3VXnuIuxTkQBy1kQiFXhAqeApQlYCsUTaIylUAIPt0jO1zGWElzYFuFyxrbPlmDusLEozr0GpUolqoC1tSWgBBZ/xVf6r04JGAqF5344m/8g27ObrYofR3BKo1cfc71fwZCAtVXAAsDWT5fgwM+/IDwyAnFpKZDKvVzquh74KqcBE++3vOcCiKvVIIOJWo0GKgd/RHSZrOvkF4ur+SiUhhAdrhPdnx7iAjCdHriWL36srB4F7NRxjo/F+FkBa2JnUQXFF+u1INDReyuFQqFQQhZPFbCU0MbdmiEVRcUw6HRQhIdBV22vgI2Kc2LqT2m00AQsJWB4UuyK49R5MniNigA6tHHetqoa2LALyGzp2rWDRQEbHmWfgAWA6rJyRDdLxOvb1uGB/77s1z5xhVYOb/gV0c0SEN88FUD9S06DGZ2m2s4DliM2NdnPvQldCm4Cqc0C3QtKY0Ot1IruV4UDCSH+3Hrhqvj+dTucn5eVCWSkiR+zWBD4QQErVygsVhFCD1j2y0WKcAFUAUuhUCiU0EbuoQdsYycuNQX9HxiHuNQQnyV3gKPxojO4SWeT0T65EJ1EVzM0RepNwC5duhRFRUXIyckRPT548GBUVFTg+PHjOH78ON544w2vd5LSOGlIorPOAIz+D3nvylLUnQeA2GhiReDLfnmT8Cjxm3x1Wbnlfechg/zVHQBWlVMh60Xbukc3AICUHe2LVb0OdrRVGoTbzGhWlRAz3xfX/4C2fXoGolshR34xkEYTsBQvI5Oa4aD2H9JT/dsXb3OeTcDaPpOXV9Z/riO1uT8VsFHxsaIKWM4enGGceMBSBSyFQqFQQhR/rTIJNYY9NhXj//si7vzPtEB3xSdExcchIb25W+dwvvcS2FdXjU6kCdimSL0J2BUrVmDkyJFO2+zZswc9evRAjx49MHfuXK91jtK4aWii88p1sm3jQgL2fC7Z3tKq/rbKBlgjeMIt/fvgta1rkXlrL8F+ZwpYDgVniOgnOA/Y0rwbqK3SoM/YuwBYPf/MITgVrNNoEGFThOvKMVIpRyKRoHnHWwLRrZAjvxhQKuu3BKFQ6kOhAO7qfsXy+bZe4u1C3YbgQi67tVHCllXVf26Kg8kOXyhgo5OaoV3f3nb7I+PiLApYuZzvAcutiBCfkDPU6qgClkKhUCghi8WCIAgEO8EEN070RCkaKiS0cDcBy676sc+/ouddw73UK0ooUW8Cds+ePSgrK/NHXyhNjIYmYLW1QOFNUrDkqYcB3UmgYA/QSuS+6E4C1tPiYJ6SntUJ8c1T0WFgf8F+lxKwYf5NwMpYlZNBr0dFUTFS2hH/B4mUTAWHogK2VlONcHUUWnRqD3UCkUibTSYUX7kKk8GIqDgXZNMUHPyLbI8fOIU77j0V2M5QQprbegHtUqwy0JenC4+XsLfAUFfAXsoj245thfsreXUaXl4ofm5yAol9tudGqEhxEG+qc55btRwdBvaz25936oxFAStTKjBnz1bMXP65tQiXUwsCqoClUDzhjntpjKVQAo2lCBdVwIrSGGO8ppTkw8Ii3PvZDDo9FOHhkEjsM7DqxASv9I3iHfwVX73iAdu/f3+cOHECv/76Kzp16uSw3fTp03H48GEcPnwYiVRy3eTxRqLzyg2gdXNgSF8gTAmkJAIjBtq3u5oP1NW5kYD144wm5wkTkyyUNDlKwGp4CVh/w81sGusMOLl9F9QJ8ZApFNYBdwh6wNZWVSM+LRXPrlyOJ75eLDhWXVaOqHiagHWFQ3+Rgne9HIcASiOi+8hhDu9RDUUhF34e0MO6rB0AikvJ/TzUFbAHTorv599GFywTHjt4khxPTgAubQdOb7Q/PzqKl4D1hgLWZoBgNpnwUu/bcenIcRg5CwKFApGxMWjbu4dlmZ3zIlxUAUuhUCiU0IQqYB3APqspVP4VCPkDblJZGRHh1nl1Oh3CIlSiCdgwN69FaRw0OAF77NgxZGRkoHv37vjkk0+wfv16h22XLFmCPn36oE+fPigpKWnoV1NCHEUDinBxXM4jKiAAOHEWuFkG9O5s385kAm6WE6Xs7bf6vl+ewE/AGuvqnHjABk6RLmfNGI11BlQUFgEg/ZayRVfMITgVXHQlFwCxG1DZWBFUl5fTCpVucCgH6NItDa8846BCEKVREJuSjCkL5uKR9+d59brqSIA5S+7TALDP9Bh+0TyPSJW12GJ881TEp7dAqTYSd98uPL9dK692x+cUl9bfhp+Mfe5t4MEXgNIKMtnoiJgongWBD27JUpkMRr2eXF/MA5azIHDgAaunClgKxWNmzUzDrJk0xlIogYQqYMXhkoyNMcZzIqOwSPd+trraWgDAfa+9YHcsLJImYIMJf8XXBidgNRoNampqAABbtmyBQqFAQgKVU1PqxxtK0ys3SBGuW7uSz0dOAb2zxNsajEBUBPDlHN/3yxNikqwJWF11DcIjxdVl2goXDAJ9hFUBW4eKwmIAJBkjkTkfcAczB35aj9oqsubXVpVFFbDucegvQKaKxwNj4gPdFYoP4VT7Gd1EZrsagJq95d01mGyvMX1wU04K/d3ahW2TEA+5UgmzMhad21mVnq88BpzfAjz+oFe7FFTsPEC8zwtLgGRnCVi1dxWwzuA8YGVsbADgggUBVcBSKJ5y9/B43D2cxlgKJZB402e9McElYMMaYwKWYWAyGhHf3L0EnUGnc3iMJmCDC3/F1wYnYJOTky3v+/TpA6lUitJSF2QdlCaPN4pdHT1NtlxF6COngc7tALGVD62HAW9+CrRNB5yN/QKVgI1Ntpa11lXXQKaQQy7i8Wo2mWCsq/Nn1yxwKiejwaqAjU1JgiSEFbAAUHajAACgDA+HjFdyvaa8ApHxVAHrKodyyLa1C4XxKCEMw0ACk9eXTomtWK9SZKKqGnhoDPE35dhTOQYA0C6DfJ73HNkO7OnVLgUFtkrZolLnCthoHytg+ZhNJpjNZsvqCACWeODYgqAWMrlccK+lUCgUCiVU4CY5jTQBK0pjm2Q99fuf+Grm89DXaNHrrhFkp4ilgBh1WvEEbGVxCbUgaKLUm4D94YcfkJ2djfbt2yMvLw/Tpk3DjBkzMGPGDADA+PHjcerUKZw4cQIff/wxJk2a5PNOUxoH3kh0rt8BLF1D3stkRAErlwND+olXYz91AZBKgY5t6umXH4twcciVSijCiIpIV01U5SoXCnFxpN6SiTGznkJS6wwf9pGzIKizJmCTk3mKp9BMwHLG6oDQCkJDFbBuUVwKMAzxY6Y0XqIjzXhOPhC9JD/44dukyD4B3DkAWPeJdW+FoiMAMuHGJxCTZ/UxdRzw2ATxY8+9Azz9lvPzuaJj7Mp+FN4kHrAXr4q3j/GyB6y5Hm9vU51BkIC1eAM7UcAC1iWK/y97B4bNeLThHaVQKBQKxQ/I/bTKJORopBYERzduRcH5S5bxOSBcueqMOgcK2MPrN7ld0IvSOKg3ATt58mSkpaVBqVQiPT0dy5Ytw+LFi7F4MSlW89lnn6Fz587oiNbBKAAAIABJREFU3r07+vfvj+zsbJ93mtI48JbS9BBbfT21GSkCtOsA+dy+tX3bUxfI1nbQbtuvhipznaFOTECLTh0cHgMAXXU1ACDMjUJcAyaMw+1TJ+PO/0zzUk/tkStIZs1UZ4BBp0dNRSViU5IgZUf7jhRPwQ4/oR2bYlX1V5eWIzwyUlSJTBGnsMTlSWFKiBLBChsGSj+HTC533tgLvLS4OXLOA7f1AiQSco+piewEkwnocgtpk3OebIPxb++T14C+XcWPffg18K1IIS0+JRVkG8NaVBeVkgRsbr54e28rYM31jDCNBoNAzRrJ+mY7mpDj/NCU7FKV8KhIjHrysYZ3lEKhUCgUP0AVsOJwj2CKcPfGTVKZDB0G9hMtVBVM6GqsCdi09pkuneNodaiupgZSmazRqYUp9dNgCwIKxVO8pTTNvUG2iXGAvo4UKXHExWukTZaTBKzSx0W4Zv38DZ5btVz0WHQC8R3hbvAqB4W4KouKLe+HTn8EgLXwSYd/9LMkRL2NjKeABYCKwiLiASvhql6HpgJWmIC1WkHUlJP9tBCX6xgMZkgQmn8HFNcYPvPfAACZxISUTCfLCdwkw4Gtll7VEnM+J9YxEXKiJJAoonDxmsQymVZwk2zTksSvEUiK66mbqNPb71uxzvo+n73dx7DhoLAEiIxwrLyJUXtXnWOqJ1Ab6+oERbjU7KoBs0MLAvJvSJfeUSjuU6szo1ZHYyyFEkgsMZb+VxTCjgcVYWGWcakrdBw0ANMXfRD0q2H0rAJWW6XBts++cumcuNRk0f36Gi0A+iwUTPgrvtIELMWvSCTAp28AnTK9p4DlErAczipLm0zAucvAAyOAZ/4p3kbh4wSsOsGxuXPf8WMBADoNucFzilhbTm7fZXnfsnNHwbGImGj848H7G9pNUSxFuNgBeUVhMdr07o4RbEImVOFbEPC9eLnELLUhcJ31a8+gpvBMoLtB8SGdh95ueZ+R5j21wi6beSm5hCgl2/ToiuwTZF+kUms5fvaqEvfdaS3CCABprq0I8ysO7L8s6EUsvR99FZCwt/Yn5gLvLQO27BG2dySaiI70rjqn4MIlp8dNNgrYqAT2funAgkBbSQpJ9hk7uuGdo1CaGKMnncHoSTTGUiiBxF+FLkMZd5Sd3ETvyCemB/WqQ04glf/3BeT/fcGlc87u2S+635KApYW4ggZ/xVeagG2CqMKBSQEa97RMBZ6YDGz83HuJzmsF7rX/cTMQqwbef0lY1IXDX0W4+tx7l92+1j1Jxe+aCrLmNL55iui5F7IPW96Hq9WW95yyaOi/H/FaP/nIbRSwJ7b+Bs3N0C+6xyVaTUYjbul3q3V/Ofl3cJY0pwiZ8znQbVyge0HxJe0kuy3vHdyiPIK7H+883RInzPfh2HnyUHrruDG4UQTkFQAZ0YUWhfW6veT/5aRR1mv4QgH71MPACw1wdqlvpYeDPKWFsgrg/xYARjYunb1Mtgqe+8PR08CfR2CxZfDm4LCioMjpcaPBALlSYYkLkXEkAevIguDCARK/EjNa4q39vzW8gwEgLi0l6JdKUigUCsU3cDY/Ibrwz2fw46I7PrB8C7sWHW7xap8awhMrFgk+8z1gXaX4ylXRJKxeSxWwTRWagG2CvPkk8ONCYMRA/383d1+OivBeolNs+WZCfyDZwc83/ytg2uukoEmntvbH/ZWAnTT3daS0s3Zg51ffIIwNVjdz82A0GBCXlip6rqa0DG8MHIEzf+yDSm21KdBVV2P/6nWCgijexKKAZU1yj23ejvn3hH7hveoyooA1m8xo1683ktu0AgBUFpF1zZ1uD8B/lhDl8WktMHVyi0B3g+JDhsres7yPUXvvMSI3n2QNe3QCdpn/Dz/O/hD7V61FuDoKEokEO1iLeTnITX//hTTUGYApY63XiI0WL8DYED5+DVjwf56f784SxfkurGjjinLxLdbOXAIGTyEJ14hw73rA1reM0FhHFLA15ZUAgFvH3Q3AcWLZbDJBW1WFtr26C+KXO8sVA0m4Ogqvb1uH+994MdBdoTRBXn++BV5/nsZYCiWQyGXWSVEKDw8TsHwS0pt7qzcNJiImWvCZ7wHrDgaRpU56LVnlRRWwwYO/4mtoPO1SvEo4W6G8o0jy0ddwCqdIFUmA+qrYVVmFcysCrmBLF5tJNomEKIe84U3rCBMvYscmW9fLVpdbfUjNZhOKLl2xJALF0FZWoaaiEiqeAhYgvqyqaLUlWepN5AoFTEZjyHq9OoJTwHLLQdLaE2PJisIi6LVaakHgBkMHxWLoIOqZ21ix9ZeOifbeY8R11utUD5KUYxgG+X9fhCIsDNFJiXhnCdsHkHtoRGwMikuJ5yk/d9e9A/EED0VeXlh/Gy6x2YPnPtOCtRjbtg9ok+5dBaxUJkPp9Xx8+sh/cGTDFuSdPis4bmIVsLVs8UjOxsVZnDDq62A2CzvnyHIn2FCwsbX/A/cGuCeUpgiNsRRK4JHJaAEuMYQKWOsscXSS6/5QCS0cFAQIAvTV2vobicCtEBJci03mUgVs8OCv+EoTsE2QvEKybSHuCe1TuOrZ3GSPtxKdn35PrAVc5XIeUKO1T8BySzp9qYCtY2e8ACAq3rq0nVMPcRRfzkVS61ZOr1Wr0QgURABQzfqZ+iJpKFcqLerXxgTnARseFQGDjaT67/2HkNK2dSC6RaEEHVKZcNm12otqUy6xKIFVOll6nZh8J6S3QGEJe5wh96CImGi8vYTct5MTrPFk0f+Ac796r18cMydbE5uB5Go+sOuAcF8L1griwlUgs6V3C4RIpVLUVmlw5dhJ/PjaHHw4SejHwClgbSWvjBNvBWOdwa4ysCKIfd/63HsXJr/9P6u/LUtkbEyAekShUCiUQCGXUf/X+lCqVPjHg+Px9Pdf4X87N+CORx9y6byWXbJ83DMPYBPLnAJW6uaKHaOYApZ6wDZZaAK2CVLEKkNbeNG7z1Vs/bi9leh86i1g8guut2cY4Hwu0K+7sE/cyn1f5hg5n1YAiIqzzrLU8BSwAFB4OZfMAjqxmdNpqhEWFSmYcdSUkuv4wrdUrlTUWxE7FKkuI16vN6/m2RWcKbp8BQnpzSGTy8VOpVCaFOHhwgykOtJ7Pph1BnKtQsYq7SzNYxOwLdJQRQSWiJKS/68R0dG4mk/2ZaQBN1gFbadMICFW3OO7IXz2BvCcb+y13aKiChhqUyi4kLil4MJV8nPHsavmvKKAlcvs1Kp8TAYD5AoFVNFqVBQVW/Y7T8DW2Slk+WqZYGPQlEnodfdIO3/1flQFS6FQKE0Omcw7E5yNGaVKhftenYWMriSh2mlw/XZuDMOgbZ8evu6a2yjDSbKA84B1N2lq0Nv7JdIEbNOFJmCbINyALJAKWA5/eK06IjwM6N8N+OYd6z5/KGA5021AqFIVU8AC5KYvkYonOWqrqyGVShEWFWnZpykhGfYoHyRgZbxCK3y+e/G/OLZ5m9e/z1+YDAasn/8hfnxtjl1Vy6JLuZDJ5UjMSA9Q7yiU4EGhED42qCPqqSDlBjq9BGVMS+w2P2vZV15YCJPRaOcJVlerQ0RMNK6S/Cyio4CiEqEnm5jHd0Pp3M6z8+pLhD72X2DEvz279p3/Au5/hrw/n0u2KYmufa8rSKVSME5GmkaDAe369kZMUjOBKsSpBUFdnV2CVhHuesVkf8NZBw16eCJSb8m07A/nxV4KhUKhNA1kUuoBK4bQgkAY011Zap974i/oPFzm70u4n0XPJmDdjf1iY2edliZgmyo0AetnpFLg+wXArV0D3RMgvREpYD1h7iJAUwNkWcdSULIKWJ8mYGt5FgS85Yw1FRWCdvxEYHIb8SXwOlYSpoqyrgPmltNHJ/pAAasQtyA4vuU3fP/ym17/Pn+y57tVuHH2PPLPXwQAJLXOAAAUXboCAGjRqUPA+hZKlJYbUFre+FTSFEJYmFAJro7wrgTEiDCYYS0iaDaaUF5QiFZduwj8Z7VVVSQBm28912QGCm4C3CKDru290ye+K0lzDycudeyzt20M5FjyE7B9n2fX3rEfuElu+7hwlWyTWDtVrxThkslgdpJMDeMV2pDxCkDyqxrbYtDbJ2CVQZyABYDCi5cBAN1HDrXso95tFH9DYyyFEnjkcqqAFUUigZFdKWkb05UuLEsqyy8MyolNrqAYZ0EQHuluAtb+ns1ZEobT54igwV/xlSZg/Ux8DDD5bmDf94HrAzc5FQgLgmBSwP64GfjqZ6BlqnWfXzxg+QlYngJWW1klGOSWXLuOn2YTea6t7xxHrUYDgFRl5uAKSvlCASt3oIBtTNw487fgc3HuNQDA5Hn/RavuQTBzEuSMf/RvjH/07/obUgAAS5cuRVFREXJyckSPDx48GBUVFTh+/DiOHz+ON954w889FBIWJlTjR6m8p4B1RMnV62jXrzemLJhr2VdbpUGXYYOhqQH4iwcYWJOcth7fnlJw0/q+eZJ753ZtT+LKlevks81CB69zvZAkjFuzRVy9pYB1ZkFw7dQZy/vI2BhUFpFfmG31YD5iccTTisn+ovR6PnJP5Ai82alyheJvaIylUAKPTEqLcDmCG+cqVeEC2z2+IrZd396Y+uE7yLrjNsG5+hotlKrwoBtvKcOJRRJnGxAZ516hJqOIBYHZZEJdrQ5KmoANGvwVX2kC1s9wgo9gsJN00z/aK9hOfgXaTvRqPikIlsDeRy0JWH95wPISsGaTCTpNtaDtgZ9/wQ+vzHaoLjWx0T8yzloIxFhXh9oqjY88YJWWmc3GSt6Zc4LPRr0e37/yJgCgTa/uAegRpTGzYsUKjBw50mmbPXv2oEePHujRowfmzp3rtK2vUSiFHrCR4d4bgcSnic8KrnvnfdRqqpHRtbNln16rRUR0NCRSKXJvWNsm8W5744Z5p1+8WzY6umFr0DwZOLke6NYByL0BKLoAJeX1n+cqYslVhiHLIpVsLPOOAta5BQG36oIj7zRJyKqdrMIw1tUJlioC1gFOMFNeUIi09lYfinCagKVQKJQmh1zuuyJcMrk8ZFfdSSQSi7JTqVIJng/4K0Z6jLoTXYYORr/xYwXnczZ9T327GOrEBD/02DW4CWJuVaS7GNhJ59+XfSfYr9dq6URuE4QmYP0Mf7wh8V7tEo+5/Vb/fp9tjQ1fFrtyBW75ass0slX4wYKAC0yA/QyatrLKrv3RTVtxk1Vh2hIRowYAdB4yWLBfU1rmsyJcjV0BK1Zk7NimbSgvKERquzYB6FFoMe/1DMx7PSPQ3QgZ9uzZg7KysvobBglhSmHgSoiqddASeGAk8MErrl87qXUGGF7VQZWa3N9Krubh9+XfISa5meXYkV+2AADUiQmW+7hCKcMXq6zX85bPuUyYc7abSCzNJtZCtshtzvO2X1xcXyBWJIYfP2vtIzdAVCcmYMqCuVBFq93+HqnUuQWBbXGJ/POkkKHU9hfHw6ivg1QqPK5w5M8QREREqxHG+wMIiwi+pZKUxg2NsRRK4JFJfWdBMPqZx/HcquVIbtPKN1/gQyQSq9BIqVKhmpeA5StgJawKzDb5yClMASA6QAnYpNYZWJiTjfTOnSz7OPsEfqFRdzDqydhZplQI9uu1WjqRG0T4K77SBKyf4Sdd27YMfB/6+1nQF0wWBABwjUvAsjYE/rAgMPAMBePTUjFm1pOWz9pK99annvljH4x1dUhonibYryktQ/eRwywBzlvIFUqYAp01DxASqRSdbq+/gmdTp39vNfr3dj/JQ3FM//79ceLECfz666/o1KmTw3bTp0/H4cOHcfjwYSQmJvqkL7ZFuDol56ODg3mJT18Hnv2ndYWBq3CFBPkFnW5ezQMAXK8hN+vywkIAQFxqMn7ZRdr0yTJBkWT1HZDJgBgv/CnKbG6jUTbPyvGxxFrIFl8vT9TUAJUa+/2lFSTW8nOmt467G91HDsMdjz7s9vdIpVKYnfww/JgGAAyb9XWagDUYILXJUPvTAzapdQbkYe4rbg+s2SD4TJUrFH9DYyyFEnhkMt8V4eJqUCS2bOGbL/AlEgkMej3MJhOUqnBBwlLwTMDmImy9VPkJWL69nj9p07sHAKA/T51rW1DMXTgFrMLmuUNfo0XLrlkNujbFe/grvtIErJ/hJz9f8rDisRjzngMy0upvZwvf/9QfqNhBYTEZXwc8Acspp0YMBF55DJj9FPnsq34ltWktMBc32Qxqa20sCOpDW1mFg2s3om2fHpDzZtV0bJXG5h08LNntAKKAbfwJ2I0LP8We71cL9ulrtAiPjMSd/5mG6Ys+wNQP30F0UjMHV6BQvMOxY8eQkZGB7t2745NPPsH69esdtl2yZAn69OmDPn36oKSkxCf9CVNaHxsqmRToTUrMe068bSV7O0tyUcRgMpJ7S0XRTSx/5mWc3bPfcoxbBfDe32/ipbNfo6KgCAAQl5KMFeuAG0wX5JjvESRgASDZCwIK2zyibQLWEfx4r1JHYWFONlLaueFh4CElFUQBy18eyf3+Mjx40JfKZU49YG29zTi1rETqeJmPQa+3S9Aq/JSAbdW9K17asBIP/j/3/ZQvHTku+EwTsBQKhRIcjBgI8BzZfIpc5jsFLLca0pmPelDDEBWsQhXucNUkZ0FkW3CLn4BVBSgBW1VMnp+jk6xChkPrNzfompwCVq5UCvZLJBKnE9yUxglNwPoZ/oCsR0fvXLNVc5I8/HWxe+dVaoB0PydgI8KJnx5XsTnQCdjSCkBbCzw+iSSxxw8n+/lFV7xFWGQEXlz3HToPGWTZN/+eiYI2CelkttOd6opn92QjLCICfcbeZdm3++sfAFiX8HoLmVIBo6FxWxAAwO4V32P9Ox8I9u1YsgIAMPKJ6egwsB+6DB2MzFt7BqB3lKaERqNBDVt1dcuWLVAoFEhICJwvlpxNwOaab8X3puU4U9oGHVpbjz80BriX9V7lvFMTxWsI2mGo1QGQQCKV4NSuPwTHSq4RBawyIgpmyFBeQBSwsanEN3aV6Uv8Zn4FVTphQszV5K8zbBcSRLpYK0qQgI0mA6lBD0900Np7lJSTyU7+4JCzVmnZxYMErFTm1APWVgFrZtvaWgzwMdUZIJMJzfD95QGrZotatuvb2+1za8orBJ9pApZCCX1atGiBXbt24fTp0zh16hSefvrpQHeJ4iaqcGDrEmDrl/75PpnUdwrYGnY1pCoEE7ASVtpap9MhpW1rpy0BEQWslqeAjQpMApbrQwwrstm+aCku20y+ukvuSVJoN2fnbsH+K8f/crugFyX0oQlYP8MNyApvAt07ANFeuLeY2cJenTLd68O1Av8rYCNUgFZn9X4NdAIWIL8HADh3GRg8BUgdBBw86f3vCYuMtLME4PvBAkDBhYsA4Jbvz/n9B1F85SoAILoZma3TswrYhgwO2/XrgzumPSxQKcmVyiahgBWj+PJVy/u/duwGAEQHMBFGaRokJ1uNTPv06QOpVIrS0tKA9YfzgP2LGQcdYlGiS0KbdGuS8rt3gXWfkPfc/d3VBCynsjSJBAaDTo/ygkLEsYW69DVa1FZpEJcqNHotqRT6a3lFAVuPBYEj+AlYg45koz1J+rlLaYVjdY5SFe52YQuJTOqWByzn+WabrBScU1cHqVz4i/WXByxnPRAZ65lUivu5jHV1gqIiFAolNDEajZg1axaysrLQr18/PPHEE+jY0UsqGYpf4Obvbu3qn++Ty32vgG3d3U8/jDeRSMAwDJTh4aLPctZm5AEpzFYBK0jABsZjnbO/imMn+E021dZ+nvsufpoz361rllzNw6wu/XH69z2C/dWlZYiMjbGzZKI0bmgC1s9w47Hdh8myxgE9Gn5NT//PXisA0sWLTvsMVRhRRXEDU29WhPaUMtZ29VIe8OcRkhx3hlKlwh2PPlSvv2rHQf9w6oEHAAzDCD7/8fWPAMiA11VMRiO+eeE1wT4du4QjzA0lrS2T5r6Gu597Apm39rLskysafxEuR9y8ai2Epq+pgUGvR5QPCp2FOtfz9bier6+/IQUA8MMPPyA7Oxvt27dHXl4epk2bhhkzZmDGjBkAgPHjx+PUqVM4ceIEPv74Y0yaNCmg/eU8YE0g6kWduj3ClEBzm4JXzeKt6pBENyf3HS1d15SWISwiAgp2pFVRVIxYNgF7PvsQaWMQzmome8EK11ULgqH96y86Ft881ee+blxcdZQznfHlR25dTyqVwuyk3LNtAvbwL5vxwyuz7Wxc+Bjr6uzio788YBU2SwDFCFdH4YH/vYyRTz5md6z0BvEu0tdoBQW5KBR/QGOs9yksLMTx40ThVl1djbNnz6J58+YB7hXFHcJ4t/XuPsqdd24H/LYMaJHCFuHy0cpxbQUZmLbsmmUR1oQKEokEDBjknTrr1EKAe86TKxSCZfmCBGyALAi4vnFFS20tArJXr8OBnxzbgbmDppQ8sEXFuahUoPgUf8VXmoD1M1ziMfsEUFcH/PIZYD4DnPvVfpmjq3iagM0rAGKjAbUfJ5g4Bey9TwFjnwBOnPXfdzti/U6ydfX3MOrpGbj7+SfR7c47HLZp3bMb/v3Zexj9zONu9eXKsZNY/b952PjeJ26dV3jhsuCznl2y3JDKinpWnStIwDZhBay+RovKIpKdZxgGmpIyqBNpAtaWKTMvYMrMC4HuRsgwefJkpKWlQalUIj09HcuWLcPixYuxeDHxlPnss8/QuXNndO/eHf3790d2dnZA+6tkLQjMkMNsMkGv7gAAyLQpKjlioPsKWIABA4lFGWHLhgUfA7AWcigvKEQq66nKTWbVhVlnFc1mIMkL/0Vt88GOCnvtWEaKjnHwT1OFWR/gH1v8YcM75YRSVnhqM79n7Uu0e9Y0UpkMjDMFLM+CoPJmCRiGwdFNW50mbY16+wSsvzxg5byRuiMFa3pWR/QbPxZ3znjUYh/BUZ5P7C90NVpIZTJEJyWi420DfNdhCoUHjbG+JSMjAz169MDBgwftjvmj0CUAxLdIw0PzZ0OmUNTfmAIACOP9qo6vBTJ9UMj8n2OBYf2B+4ezRbh8bN0Zm5yEe1953rdf4gsYBtqqKlELBW4FDv85LzI2Bg8vmANAuAJKFSALAuHTG5w+yzSU6jKyYigqniZggwF/xVeagPUz3P1GqwOmvQ58+wtRYLZvDXTysDYHPz7bqpBE+8BuuaX3/vKBzUgDJo0G9HXA1RvAhl3++d764H4PrtoxhKmI4sV22QQfmZyow1p2cVyx3BEH1260LD9xFVslrVUB25AELLlGZh+rz6m8iXjAOqI4l9gQRMXHQVNaBjVVwFKaGEoFiSCbP16K71/6HzSyVgCsCdgzxEUFrZqTBKDR5HoClruNld0oED2uYZe2c8vDym4UIKFFc/R/YJyljSzSury+pNw3Rbh++hAY0s9xey6/x88jJ6jJfVNXU+N2AtRdOAWsICywnbl89IRLSlNVdLSlAIhE6roFwZaP/z973x0vRXW+/2zf23vhFnqRDgoCYocoYMEaSyzRrz1YEixR1PysiUajxkTFHlvsYi+xA6KAIiC9c3vZvdv77vz+OHOm7ezubL9c5/l89O7Ozs6ce9k957zP+7zP+4SiMYaCwWgFbI4sCIRdiMvqEjdSlJ5jbSUKWKruOe++O3HJYw+q64EKFQc4ioqK8NZbb+G6666D0+mMej0XjS4B4Ixbb8DBC44T7b9VxIdJUtggTQpnAi5WnFldwdr8ZImXo+Sky9qXslVO3kB5DrtDtonY7x/+K/E8FWyQaoYNQSGb6BTuT/LVhEta4ZpdApZVwKoE7K8KA4aA1emAQQdAQ3I63zAM8PL7wCW3AdPPJMdStSMQKmBnTlb+vmSJx3Qxeij5+WV0Ujmv2E9iKcV/hzBbV0tJVjn4XKT9dy4n1Hvnn4HH/28RANKVOhwKpWVBQDFk8gTc8vGbOOvOJSgoLUH4V6qABQh5AQDjjpwNp8WCkuoq6AwGFFepCyfFQ3cPw0N3xzPeV3Egw8ASsMFgBLvWroMTtQiEtJzvmodtvDV6KKAz6BEKa5QTsOEwwoEAXrvtHtnXfU4yr2rY5k6fP/k8AKB2GC91KRSoFbssGbIg0ALPvwO8/xV/bHwcz3Xq7S4mYMm8uW/9LyICMBvojW29ioDXB6OCsvm7V36Ku1Z8CgDQ6rRxu/QKFbARhaZ4IX90iVeuLAiEClgl5Z3l9bWi57auLgB8h2rqExcvKatCRaagrrHZgV6vx1tvvYWXX34Z77zzTl7HQpNahhw1JhwIkBKwyitvlMPH6k+qyrOrgKUl8Pt/2XzAEbAa1gNWSMA6LVbsWbcB6z/7EkMnT8SM004WaUyFVj5aQWydbwsCikg4ew1rqLBATeD2D+RqfR0wBOzfbwDavwUq+3kjORqQCcUke1qBrl5g1pTUrikkYJPxvdnTSn6eNT+1+6aKNz5JfE79yOG4/u2XcjL5UiJaqQVEiO0mHa80SKMhF0tIwMpX2qYES2sbdq7+kXvud3vSsiAAAFtnF1zWPlQMqseomdPIIvpTFjqUHSD47PFnAJDMrk6vR1VzI+7/6Vvc8fVHeR5Z/8GUCUWYMkElIgYqjKwHbDDIwGmxontPC+yRWlxyhrgCY9QQoGHMSGgMBaitSsLTOsyIPMCE8DqIIknHLnrOXgt8LjeGT+MXT6HiotuSOQVsnwM453r+2PGHxz5frrlmeTHZwAe8PhhMpoQe4unAEpeA9UJvMCTV8EGr03EN0uQg9YBVAjkrm1w14RIpYGsTZ+7L68QEbNuW7aLnNCmbbWJdhQpAXWOzhWeeeQZbtmzBQw89lO+hcEktdU5RjlwQsPQe1eWxG11mBiQ49NgdoqSyEEMnT5T1KM87NBqAIWPXGwzQ6nTwuz341wWX44XFpF9J3fChogw1JWDXffQZtq38njueryZcNIanCGeYad+y/DvuMVXAVjTUY9jBSajoVGQFuVpfBwwBO4ctB2xiA8D3Hyf+59dEAAAgAElEQVR+bJXlxKulv0ArUMAK8d3PwMmxLUXjQsgDTjko8fl0zmvvJj+li1Z/wIl/WoRBo0Zgyry5Wb9XR4KmWwBQVFGOM/5yE4wFBZwSKJ4ClmbPEmUu9frs+Tv53O60LAgAoH37TvzlqAW4YcrhuPu4U3HP8afh50+/yNAID0w8cPr5+Ptp58FUWChSbKlKBRW/BtD1JhAki5iltQ1r8XsAwPSJfOnWqCFkExuBHrXVysi+RPkoSnQJE1vm4iKRAragtAQNRwL1RxAFLK28SAdaDSk1ZG2xARCLhVgoLSak7dI7ol8LeMlFsllub3OwSV6ZPyj19jYWKG8epdXqwMSJNIUKWKUIyjRzzJkCVtDwo7Q2sQK2TELASu0YIpSAVdcAFSoOSMyePRsXXHABjj32WKxbtw7r1q3D/Pk5VqcIEPST+TFXvtgDAdJYtioLgiwze4/6arLGZ9uCwOtworBcnoC9+qUn8ZvLL8rOANIEVcACpMmWFNNOnk9sCFhQL/bN364UnWfOkwestA9Bpi0Inr3mRtwycw4AwOdyIxQIYOYZC7HoP0+o+4hfCQYMAevwEDKsgp2nTjyadCR+8g7gzUeIx2p/gCYGAdvSQcjiVPgyKmRp61JGwFIwDLDix8wohGJhaCPwu5OSfx/Nhh00O47RXoYQx9qOw6GnnohZZ5yCYy85X6CAjU3AarXKCAe92RTXWy8d+N2ejFgQqBCjY/tOOLp78NhFV+GmQ47ijudro6BCRS5hoArYEFnENn21Aju0xyMSASaPARrHjgZAgh8z7IhAj6ryGN2gpNAoPE+Az554FnqjkZtzC0qK0dWnQ1cvsUOorhBbAaQCnQ6IMOJ1e/xIoJZdO6VTeGkRIaN/I9OXKeAlHg3JEKDJIhIhFR1lMlMSTwAru3/z+LHQ6JR7wCpFWIaAzVXgYTCb4LbZ4XO5MXTyhITnSxWwUpsF+rcxGPthNluFChUJsXLlSmg0GkyePBlTp07F1KlT8fHHH+dtPKoFQfKQErCNtfLnZeIeDbXEmihrTbg0vALWYDLFTdj2t0ZtGlDymBCw0vF9/tR/AJDqE5pUj2WLlD8P2OwSsJFQGH43X+kl9PotKu/npdwqMoIBQ8CWDCa1901DxIrDZrYhciZUMJlALAJ27SbyMxUfW0rArv0FaKoHXnkQeO0hoEKBbUymPPJiYcXLwEv3y5f3mwoLcdqS63HOPbdj+CFi/4WNX34DQKxUySbuXQpcdaf4mLBE1NLSBgAYfsgUhFkCVi6rx79XWcTv6O7Blm9JKYK0kVa6yIQFgYrYYBiG+ywA+dsoqFCRSxipAtZPFbCtCMGMvV0mTBojPrfO1IYw9Kgsi6CsBPjprfjNq1KBy2KFVqtFkWDBo2Xl67eS5+k2mtRp5ZUu97OWBFa7+HhpMeBwyV+L2itkk4CNB0oAmxT4wALAZU8+DK1WGzcASUkB68+fAtZgNCLkDyAcDMp2aZZC6gHLsHYMVE3MUAJWJUtUqFCRAXAWBGpSRzGkBOycDO81rr8YOJjtq9xYl5smXFRFKmdD0F9Jeo0GgFABaxTHytRioKS6Ej6XG0D0foi+N9sNS2NBakEQzwM/E3BarBwvVNzfvTRVZAQDhoAN6EjwVVtLJiKurJzlwUZkoRtiKihm+TDJd5sbbyoELBVifr4K8AeAcxYAv50HnL0g8Xu7MuSRFwu1rKe0XPJu8MRxmH326Zgyfy7OumuJyJOOkpvVg+PUeWYQSx4GHv8v/7x6SDMeWL8SE+ceDYAvfR1xyFSEg+SxNq4FAf8PLO30TLF44iwEvD68eMOteOD081MKYuPB53KrCtgcIl9eRf0N23d5sX2XN/GJKg4IzL/6ctSPGsE917NNuAJBQjr1ssmp3T2VmMwSsBZmKHd+hNGjpCCCkYOBqeOAL57L7PicMh1kaTODjaxV56ghUW9TjI+fZEsNZQSgx80mP6VTd2kxWYsp7E7g0ffJIJIlQDMFGtAFOAI4PtnZsXM3gn4/CktLYSos5EhGOdD1MRnk0wNWbzIi6Pdj68rvUVFfH/dcR68FZfV1omOWVtK588tnXwTAJ0/1xv4VCKsYmFDX2IGPYIAsKvp+Rq5R3HRJ/xE2UUgJ2PJSIE6YphiDaoBHbyW9Zo6ZQY6ZTeR+2VPAkh8cAStjZ0djxlwlLhVDowEDBp4YCljadKqwtJRrWC3dD9GEb6GCBGk2IK2aSmWPkwyYCC/AymXzbhXRyNX6OmAIWJePzLyTRpMgwUa+95wCdtLofIwqGjddQn5KSwNTJWCNBuDMeeTx6o1A8SFA6TTyvD6GslU4sXT1khLNTCxScqAxVoHMHoKW8H/5zIuobm7Cby7jvWyo8XxlY0Ncr9VsoXpwEwBg1hkLo16j446vgOW/WtNOjs+EB31+dGzfmcow48Lv8aTtAatCOQpK8pOp7W+4fPEuXL54V76HoSIDMBaYMfey32PR849zx0YMIpv+YIBdazu7EA6F0OZtxIjBQCH6YGca8P1WsnGOgMyXwrUtljIlFacAF7uZL66q5DbttIRrxz5yTqqBol4PzDuCtSCQ8I/3PQ1UxqgyKSsRr7NX3Qks/ZhkgZO1AEgVu1vEz6k1hFIPWLe1D30dXQCIwkZadp8uQoHohGMuPWCDfj+sbR0or6+N25BMA6B26GAUCCxmvA4nFk+cheUvvQaADzD7mxJJxcCEusYOfPTnJlxDG4G/LQae/2u+RyKGlIAtLQYOm5r+de+8Blj0u+jjZlMWFbBcEy5SXiPXTyTgI8nceD7Bt33+Lm75+M0sjDABGMRUwFICFiAJ6XAoFLUfobY+Or0+yo81F5A2Sc20BYEUtq5urjS6uLIyq/dSER+5Wl8HDAFrdZMvb2kx+ZVoOSLdD2e6FCFVtHaSn5+tFhNjqRKwV54DXHomeRwMAaEQ4HQDPVagJsF3mAHQzc6DNYKEy5AGYGQaiiEhKAErJ/ahxOqmr75F0O/HqBnTuNcMJhNCgSB0ej1HhuYSNKgvHxStjimuIH+seEGbVjB5D540LsOjUwafy61aEOQQU+ZnpmHcmMNmkA6hKlTkGRqtFsM036HEyHtVXXUiYfZoE65IKIy+jk5s85L5uxBk7vx623AAgEFDCL+5s/jrfv4ccAQ/3YvAJEnD0g6yWq0WbhsJVoZOnYSxRxyG9m7A7UlPAUshJWAtNhLwyU2xpUViAlboLsN7wGaXbBx3IlByCHms1elw3BX/J7l/YgJYqPrIdAAiq4DNoQdsKBCAtbUdWp0O5RKFqxDt23dCo9HI7kMCLJlNyxPVcmEVKlRkAhPr9+FP+lmoLMtOj4h0UMrmomZNiX9eMvjyeeCTp9K7hkmiiQmHgaX/T3xs4mhgrow3ezz09skfLzDLV8ZkApwFAasmk7PK4Uh6ybqpN5lwzj23o6SqEuV1tahqyn4l6ZDJE3DEeWcBiLZPkCpgfU4XZ5/ARCII+QMorRErxoRNP2uG5r6EOdcErLPXwlXLqgrYXwcGBAFbYAZKdb0AgHJWhEa769GOhcX9hIdysErdk+54QHTcaiMliw1JmoYLg0KhQr7bSsr/y0sB22o+2B0xGLiRxGEwG4kFASD2gd37BbDjk+TGEQu0DLNQJtakk3IoGMLPn3yB8kF8EGQwm7gJmip3cglaDiAXmFHiNZ4yVzh5a1LSdaUPtQlXbrD2fdKoIVNNuC5b+jD++PrzGblWPrD0wRFY+uCIxCeq6PcoLNThVN1inFV4Q9RrTjfPKlpb22EccwI27QD0miCqNHvQEyKEVYmmB/sspbjwFHLuO5+Tn9MT9z5SBKGaghKwx158Hi557EEARAUrp4CdMhb49GnlSU9pR2UalMl1Wi4tFqt5xQRsbhSw/gDgYnlzoQKF3l+JBQK12wEybwcUkvGANZhMUYFPNmAwmhDyB2BpI1YCVY0NMc9d/vLrMV9jGLbMkv3HVhWwKhJhyry5aSdY1TV24OP0Q4iB+aSmngRn5h6lWWh3cMwM4PjD07uGVAG7eRcwXJI32/Au8L9nkrtut0X83ElsS6HXiePujIIlMd0siVlUFq2ApURn8zix+f74ow/HtJPn45Q//zFLg4vGNS89hVNuuo7ExRoNGIZB0OdH0O+XrRal+zaGYWAqKsSIaWKpsttm4x7nwy9fGrWHs+wB63U4oWP3aSoBm1/kan0dEATs2/8EfjP0BwBAWYk4HWUyka9RZbm8D2muoWWbMzWNHxv1WkdP8grYHj72FHnRdFsIATtxNCmHvPc6cvz044CxI8i5NgexIACy5wPrpxYEcgQsS2CGg0H4XC6U1tZg1Mxp0Op0MJjNXKB40uKrszM4BTAVFmD6KSeISiAoAavUgqB5/Fjo81BGpFoQ5AavLrkL+zZsQmEGzeJzRURkA6NHFGD0iPw0GFKRWZhNZI6u1uzhjvXYjdgTmYk+QeMpp8WK0ppq9DhJBFSm6YBNN5J7/asdY1HOCjhefh9o7wYmjQHGjQTuuz69MXodToTYZng+lwvhUIhTEuiNRhgNwJEyattLzyQericcrew+0iSuhY0PqmMRsEIFrOA1ToEql5XMEoTNLJMhgMMhXqVaKBMAis4NJheJhoLRBCyQuURWPFAPWCtLwFY2xu7S5nO6SHlgDHgdLq7ipT+WC6voXzj/73fhxnf/m/jEOFDX2IEPaqtXVpRd4icVCAnYGC0u8gIpAfvS+4AxRpWK0qr2i04D/vFn8bGWDvLTaMimApb8pBYEheXRCliHhTDDEUl5jruPbE5ySeR5ncTLtaq5kYiO2Kyz1+FE3YhhUT0yXBY2g80A7dt2RNkoPP2Hxdj4BWnGbcyxXz6QewWs18nvI/JR9auCR67W1wMzwpdg3hH844oy8ayq1fChT3P8Xgs5QbxJPxUCVth9OShVwFbxKp1almClty8+mJzDKWCzRMByFgRxFLDhUAgFZaXQ6XS44qlHMfbIw2AwmxDw+rBr7bq8e2sOniC2EKgZ0gwAXLZKDkILgsaxozH5uGOzM7g48Lnc0Gq1eeu2/WsBwzBw9vZm3Cy+bsSwjF5PhYpkYTKzan8Nv7hoNIAD9aJN/+p3PgAAXPM0r2LQV/B1/9+0HCK67vqtwOQxwJsPk4qMoY38tVMBtSEAw6tgAaCioR4mE1BSFH1tlgeN6eMqxPPvABcvER+jBGwsBWys/ElAoQdrJiFMAPIesIkJ4IhA3pPIi51WrChFUEYBCwBjj5wlezyTIARsAPauHoRDIVQmKNFs27I95ms+l4tryKmXMgAqVKhQkQKcLAFbXBBt1ZJvlAq4tMGxc1cpIR1CVzr9UuVqrYwdX63CmPdUGWexbisQCBCP+KzxcuyGJRQIwO/xyMYXlv2tAEiSUAiv0wkgtwRs9x5iuF87jOz7aGNKW1cPNBpN1FiECtgdP6yFQfKPZ+/qwRdPvwAg+3ZNctBoxRvGrBOwbMMyAKhsyPCXSkW/xIAgYBmG/6KUmMimXk6N0dwPPtNUSclAE5VhSYWADcewIOixEl9XqoqNRbByCliZhl2ZsG2IS8CyStJwMIgvn/4P3rr77wBI2b/BRCwINvzvKxjMprxJ8m2dXVH3Hn4wMT6K1zCE/ts+dNbvYevswqS5R3Gvbfp6Ob598bUsjFYMv5vUn6oq2OzD43BmnIAdOmViRq+nQkWyoASsEGRq03C+lwDQuWs3AKBsUDN3rKyuFo5gCbrCIxEw1GCjgMNavw0YN4IoSADg6EP514Tl+nK4a+5C3Hfy2aJjnJoCgEdAwFY1NeCxV8hj6XrmSYKApc28AMBOYhuRBYFGI15/43vAKidAMwWhN6mTVc0oIYCFjbekPm5SJEvAynnAAkCFjO86QNbUTFWSEI/5ACLhMII+H44877dxz2/bSj68cnO81+niyGlVAatChYpMgBKwJeb+R8CWCAjYTPirCzE0DacbKQFLBUavPggMlrjMjFNYYeyTWdY0GqCnDzDoxJWnmQTHFTBERdosUzVLeY6otZzdb1ArxlygZ+9+ACwBK9j7PHnZtbLnO3vJPw4DBpaWNtlzeLukPMSwkox9JGteEwReIYmeH9dCFTnGgCBgI+CDxEIjO1syDDqYg2AN1aONIURGU+w+CzkDz7lqorIcHT3A+JFRb1EMkQWBldgu0AC3LIaI1OUhgeP914sXVUB5hjAeqMhF1oJAoIDt2rUXq95YhkgkguLKCkLA+vzoaye1HrGCsmzDZe1DhaA8UaiEief3ptWRf2gmwuCXL7/FmMNmYtaZxARx09cr8O79D2dpxDx8bmJUVFKldlTMNjx2BwoyZEFAjeunn7wgI9dToSJVmEzRWwRzYQEYaBCJ8AuOy9IHv8eDqia+dKqstgZLfvobnnE9AXNREWx8gh8btpHSwBFsb4Wp0bFFTNi6ujm1BYXTynvxmASlbpWNDbCxhKl0DaT+8MkmPQ86AZh+psCCgM3PWXjLsigLAuFjakEgF1QMnjQeD25cFbckPhVQD9jVyz5E547d7P2TU+DqDAkUsHKRahyEAuR8YaMvR68lph/rWXcuwX1rv07qHrFgYC0IAKBr9z7oDAY8uHEVFr/1ouz5ts4uAPKlgT6Xi/v7qgpYFSpUZAIujoCVrxTIJ4QWBHMzXLBQLyMGUgppDxWqgD10Eu/7upPdOixUWJTolVnWSoqIyEmny54FAcfCMQwhWGVIObp2xkrm5jL2o/HmISfNh0ajAcOywF6nE/s3buZsoijonk0DDSytMQjYJKp1Mg2Nhux9HT1EpZZAF5A2hASsKpr6dWDAEbBFBh8XEDmYRjxmfx5vhh8F0D8UsNycCi0OPfVE0Uv7WV+ZCaOSv2xnLyFwKejCI+dPJ8UX35Of0sXrst8CC46KPj8ZUJHLpDHRr/EesGQRYSIReGx2FFeUw1BAFLDW9k4AEJGguYTT2iciyoVecFLPGiFo9jISCWPdR/+DwWzCcVdcnL2ByqCP/dtNO3l+0u/VG40wqw28FMNjd8BUWJhQJaYEtHQnX0mHdPHzL278/Is738NQkQGYTNEKWI2GAQMt16iQwtLShqrmRmxzjsOGyEIUlJbAWFSMSDgCc0kx7C76fuCzleJrXnM+MGMykOo219FFFr/CslIUC1QfVU2NnGK1XErAsvmzZBtfdvYAa38B+lhCmVoQRBGwgvcIk5uRcBihQEA2qJh2Epmrxx01O7lBJQAlBn/54mswDAO/x5u0BUI8z3MgdQUsw1pZrP/sS1jb2lEZg4CdvpAkpDIRjOmNPAH73v2PcHuRhtHyGfCuncQDWS7J5nW4OI/dw885A8VVagMNFdmFusYOfAQjbEd0ky/PI4mGkICVKkvThZKKlFj4w7ni5z18YQzXiJNWsyjNP3pl/vx1VeTaOkkTruYJ4zBx7tFKhxsXvAKWwf6Nm6E3RCf3KAEbLxalyFWDyPoRw0gFqGAr9+j5l+Hm6ceIzqMJ2+ohTehNqIDNvY0e7dfjc5F5NtsksNCCIC+KXxUccrW+DggC1gfxpniOICOnMxgRhgmuUFm/8IDVcRYEQPP4g0SvPfsWmez/+wBplJUMzrhW7EXTzQqChCrWWAvls2+Tn5zpN5nzcNMlwIdPADLe34qxp5W9twx/yilgBXYRrj4biirKWQWsD30dhESszKMCtqi8DCaWjKTqRAAYOf3gmD6dGtbIiIkw2Lt+I26dfTz2rt+Y/QELsPfnDdjxw1pMnf8brnGYUlz36rOcl4+KxPA6CMuTyUZcZXU1B2Q3zD/eugd/vHVP4hNV9HuY5QhYEAKWNoegsLS2o6q5EU/svh6fR0jXirLaGkRCYZiLijgi1GwiZOVXP4iv+/2rdA1Kvv5q5WtvASDlb9SPFgAqm3gFrHQdo/vphiQVsBThMNBnlydgDxkvVr1Kyd+A1ydLgNJ5xJxh33ODkQRf1Hc14PUmHVBoE3nAJquAFXjA3jr7OLx00+0wmExoniAvh/awAUpxBlQ9BrOJuz+1z4gHem85EtrncnHBrd5oxJxLLkx7fCpUxIO6xg580GrJYmP/JGAdLuCT5cCI5sTnJ4OJo5N/T1U5wGzhn9/6CNDaKW5SDZCKUOoxW6EwrpVTwBoNrAJWK1bAXvffZ/D7h/6a3OBjge4fGAZBv1+WQI2wTTKVJFOz7TkvalSt03FCEoAknaUeqnvXbQAAmIuKOLGQFP48+OVTUAUsVaaas0yKeh28AlbasExFbpGr9XVAELDtkQnc40DEiFmT+ddo2ZwTdTi0H1gqagQWBM0Txc2devuA594BJowG3ngovfvQhadGEKvs+0JeiUoVQPOPJFnBDdtJlvAPd5Hj6TToonOwXBdq+m8TFpQmuKx9KK7iLQh8The8DmdOFbAGswmnLSGtuam3IC0JFRKwADB65nTZa2ipApZddLwOBxw9lqyMNx6++c9/UVpTjXu//wKXLVVuezBoVJIZgF856OciUzYEnTsJKdAwJgU5vAoVGYJRxoIATBjt23dzpfQUlpY2VDWRLB8tRyuurEAkHIapuJC3AmDVM5t2Rl96ROk+pKKCbduyHZu/WYmVr77FkWUAMOGYIzjid/lLwD8FjbQK2HimMQ1rol6bvAVBMBifgPV7PLIEKN3sF5QUR72WDqgCNhQQErCxgxo5BUbLL5vj3iN5BSwZCwNCPEdCYRSWlcVUu9C1uLQ6jRpVFgYjT8D6XG7Yu3rini/8TEnhdfIK2M5dezBqhsxmR4UKCUYfNiPhOdNOXoBj/+8CEbmh4tcB2kC6UO/N80iiUVJECNid+4GRgzN77XuuAy48Rfn5Bw0HHr1Vco0ngCFzotWrR00npCmQBAErw3+XFpMYW6OVb8KVCeEE3y+GQcjvF/m4U0TCETAMA6NckxUJ/vz+aygqT0NenAQS2RUBxG6IIhyU9zmmPu3GPChg6QZuzbsfAgDatu3I6u3onhkgXvKJmp6qOPAxIAhYJswrKDuCIzBrCv+ajk13BbRlmDJWvtlULkEn1f0bt6CwtDTKU+zmh4C2LnGJRyqgFgSP3Ex+rt9KfsoZnFNv3H/cBLh/AsYOB1o6gG1sAiAdL1gqvBwzDKiQzP2cBYGghsPdZ0NxRQUMZhMX0FnbO3LaFXDmGadwDZBcrE8Nvb9Q9eX3eGKWS3IKWEEWkKqbpM3XsomtK1Zhz7oNsLZ3YMxhM5JWwuZyrAcyKAFbWJaZDU47u9g3HnTgEbAvPjYKLz524I1bRTSEFgR0KtCAEc1rFL0trTCYTKhqaoRlP19SFgmHUVBczBGh1Iv1F5n9rFmfHIknxDOLrsfb9zwAL70RiBLDLuhtcPV5/GPKf5aVAEWFwPGHA10rgHv/KFbTxIPFxitg+wQcncHA+68DgFUsFo6tgGW7FxcUZ5uA9cVUwB51wTm494cvUFpDNkt7floPAHj1trvj3iNZApYrnxQElqvffg8arVaWcKJdk6fMm4Oq5mgv1mRgMJsQDPAK3K49e+OeL/xMSeFzuqBlvxybv16OQaNG5LT5iYoDE1PnybRXZ1E3fChOW3I9zrnnNpxw3ZWolyTE1TV24IMShYV6Nw4ant+xCKHVAvOPAAIhQsCWl5J+I+lCSGTOPlj5+5a/BJxzQvTxiIw3a1O9QAGrcKsuV9hhMhILAq1G3GDTZSVJwtrhQ5VdPAYqGwfBTPcADKlciWchoEQhWlhWijuXf4KRhx6S1tiUQKfXJ+ym6uwVC5KkCX2KVOySMgENa0Gw6esVWDxxFtdkLFvwezyi56oPbP6Qq/V1QLArPjv/Re6MjMOhk4BaUzsAnkDazMwDkF6HxUyAxhX7NhI1yUGHz0LDQaO5kkOHE3jp/fik5wM3yi84QuxpIyQqTaI8x9oMyGX9rr8fWCIQR5aVkLmTkri1aVT86QR83yt/l7xmMIjsBwBWAVtZAaPZzJU09rV3YNxRs/HgxlW48pl/pT4YhdALImcnu6BSv16hAtba1oHKJnlieAyrbhCSy5SALchheQHDMPjXBZdj+YuvAwCKK5LLzFanGej+WsBZEMh0yU4EjVaLQ06aj8PPPYNTvHrsDljbO3DwifMyOs5coKnBhKYGtRv4QIBQAVtVSeZFDRhEmGiCbOPnXwMgfmT27h5s+mo5ALAK2CLeCoAlYOUUsAAwtChxSXg8SNWK3rD8fFsg+IgeMQ24YxFZd2++jBxTUlppsRFvucY6cbUJAKx5g/z84Gtg6evi12JZANCmE+ZMK2BZ/zjOgsDjjak0HXvkYQDAWdA8cek1+MtRCxJaDNDXC6TdPONg1RvLsHoZbxkRYK8hF2xSAvaI3/0WN7zzkuJ7SEGtj4S/T/fuvXHfE47TAVnYPGPn6p8AAJPmHhPrdBW/cnjsDvR1dKJpnEw5GouFN16L2Wefzj2vHylm4NQ1duCDxorlegu2fAiMHp3ZNSFVDGkgVZPDmwgBC6SvgtVoxLFiQRIfbV0CFqNbwPMNqkleASvXZOunzXyVqTDRShN5dWkSsEs+eRvHXPQ7AMQjPej3c1UWckjGTigXMbROr5dN0gtBvVUp9qxbL3tewOuFKS8ELPtBSfB7ZApCSyZAtSHIJ3K1vg4IAlav5VNn7Ub5sp5ehjRXSLbhRqbBJlXQuXMvfC43Tr35T1j8xn+w5JO3OHViRw/JsMXK0C2+CFh6R/z7BIPAzLP55262ioUuOuc/cJcoq+QSJ1/AQN5HNlnotCTQ3rlfvMACZJKWdkaknqvGwgIEfCQj9uljz+CbF/4LAKgZmn1fUp/TLXjsEpUGiAjY1tgNQ6h5uLW1nX+vg5app2GqmyJo8JpsV8yaIRk2eBqgiGVBMHXBcTj4hOPivrdhzEice+/tOPXmxTjjthu54y5LH8rr8jxhqfhVw2Tgidb6QWS90GgYRGT2pC5rH/b+vBEGkxFF5WXY/ePPAACtXge9wYCwkSR/xpZJPjkAACAASURBVB5C1mIpAfv5qsyMmSZDKII68XxL/dWFMcvHS2kTMB63XJ74XgxDgjoAOHic/DlPvg64JetrLAUsRaZVKgaJAtYfx4LAbRPLdUOBAKfsiQd7Nynjl6r14uHNO+/Da7fdwz2n66bc2Nx9vMeDwZT65piSuyGhAlZAwCbbAKOqmd8DtGwi0una4ap/uorYsHf3oH7UiJh7wb6OLtHz+hi9BlQMXFD+x6AhiaJJk3PX0T4ehEV0O9mGVukSsNKK9WQqzoXWP3LoFvjA3nE1r65VSsDKFQ3OvZhv8CXMFdJmoJn8vjJxPGAp8kFQxoNWr0/aSYojZCXVLwGvLy8WBBrWhJeRk1LnAKoCduBjYBCwOv6b3sZMxbJVJCJy9Xbj508+x+ZvVsANUk6XasONTIHOLZFwCE9f9Se8/+C/0LlzNwpLS1A/gmS5O1g7slhkcSBIPHgGJfhd2rsBOqd5fKQkg3aYnHDMEZgw50ju3CgCluEXtpo07Gx0OlLCMep4mdcMekQkyhIaZJmLihBiSxrbt+3Ae3//J/735HMoriyHVsrkZhg0kASIZcSq15dxz4UErKWtnfOGlQMlPSk4BWwGGzUphYsdi9IGJtJyCBXxQcl1qQL2vPvuwO/+Fj9bQq043H02lA/iDSk3fbMChWWlcTPfca9rMGDsEYel9F4VKgCxArauhgQAGkTAxNiTllSTbN2QyRNgaSPJJ9qYrkdHGE7dxHMAkAZWt/0TuHcpsOJH4Jp7ZC6YAjwSAtZQWMY1lgSA6axlfIEpuhEYBcPwXZMBogqlvuBCbNhGkqUA8MK7sa8lRSwFLC17y7RXG2dBIGjC1TTuINlzPRICVil2/LAWAFCYRoIxyCZds9mxmVoeCC0ThGt+sv67+zfy3rjhUAj27p5+FxCr6F+wd/VAq9VyKreo17vFnsT1I1UC9tcG6gFLUVPVP8J1OqqWDr7JcjKWAXIwSnobKrA0BQA8fDMwUpLr+l4ipBQqYPU6ntguL+Ufx4PUirPbQvYuNJY+QpArpX+bUTF6g6SKkD8QOw5gmKQbamYLtKI1Ff9SSsDSah2KgCdfCliWgM2RAhYAHj3/cmz84hsAhANRMbDRP2b0NCFUwEbCYWy1jwcANBS248UbbsPLN98BD8oRimgSkpbZhlarAcNowEQY7Fm3AV8//zKevZqo3prHk4CIErCxxkpLKKYraCr2C6syKiwAbA5AOIeX1fI3cEt83hkGCIUICZuuB6ycSTkQQwErULlISx772juh0+tF484GhAbixVWVHHkJiIN7a1sHzEVFioNlrkw9DwQstVJQqoClCiOh6khFbPicLkQikZQsCCgsbe0cgQXw2fTSmtS+gAtvvBaXPPZgTKJFhYpEMBr5LUJNDVk8iAWB/PkPnfV77nFfewe5Brt59lbNwGOhj7GFmc8l0e5+nNjfHHEesGVXZsYsbZRYWFbK2R8AwHjW2slsAuxOoKM7+hq7WoAZk0iiEwCGTp4oKgmm2N/BP45lE0r/VHTu1ep0YCIMGg+Kbves4bt0ZtR/mwZvVPWpMxhgMJtkvUrd9tQI2P0bNgHgrShSAbUgMJrNGHnoIXhw4ypUNaXvG6XT63HMRb/D3Mt+z/3OQgWspYX3LK4a0oSS6uh18t4FZ+KuuQujjlOrDYqgL75aKV+YvnBBwmoMFbkBTc7HathGbTIo6kb0IxNQFVmHsaAAhx9ZLzrWVJc7IigeaBXnLQ8RMZDVRmwJ0oGUWyxTGCJde0H0Mamy9X/fxX6/kvsIFbB/ewo4+kLy+CPCk6FeJhxNttIwEYJ+P3R6vWwPDwbKPGBzAZ/LhXAoBJ1eB0aBBPaJS67G0suuIe9lK02lpfeJGoZmC3T/lUsCdu/PG/DlMy8AAEyqBcGAx4AgYA06Xo5j2d8Ke+lMAMCgYpL68jldCHgDsHkL825BAA3AkDYm3CFLaxs8Dgeaxo8FQJSrgDwBazAQVWk4IiZgpxw/B8VV0VLVH0lMhAKTuEkIAK7JBhBdIklV992W9D1gqYdOQGxxAr3BgEhIzM4KyU5pUw8a0FfEUZ1mAnrB5reqqQEOi3y3Rjoe6pWXCJ7+oIBV0J3TVFgIrU6Hr557GX898axsD21AgGEYBNwezDxjIcrqanHGX24SZaVjlbVqdTpuoXd0E1UMzbxSFUyqCQdK8OSaDFi11olVa2M3rVFx4MAosCCorqKJKSamLZZP4IdpaeXZSVtnF4ZOnggfygFocOUz/8p4kELhdUQTsEJydJzAgsDrj14XAWB3C1lr3/t3/Hu1y5C3UtC/1XFX/h8AYMS0qahqbpRXiQjK78wZbMRFCVjaeOqnDz4BABTLELAem8wfRAFsnV1YPHEW1n38vxRHyXvgGgsKMGU+aVI0etahuOKpR6MI8GQ6wzePH4sT/7QI86++HJOPOxaAOMErTKxe9cy/8ZcvP8Chp4iN9i0trbB1Jf4HD/r90KdhkZAtnH33bQmrMVTkBkwkgtXLPoiZXNVLJIE1Q5qx8MZrueff/+hS19gBjCv/NA3jtR+LjjXX9xMClmUNgmzo9u6XJFmZDqQWBLOmpK6qrZIsabTZp9w6r8SGQMh5vv4Jnyju7CU///ok+Tnh2KMw9ohZAJLzZBXi9NtuxBVP/ZN7HmEDcVq5YjDKrytSgnLhTddxj5NtjpkOIpEIPHYHa0GQ+PO644e12L5qDQDAzypgzZLSe7/Hmx8LAnZ7kWsLAj9LxpiTtEJSkTnkKoYdEASsyAN2+06Yhs+OOsfR2wt7oCzvBCzhVjRRk1Prpq0YOoUwqpwFgYB30WiA42bz5uSdPcB15/Nq2MPPPRP/9+gDUfejMYZBH92JWUTAyihgAeKfk64HLFXA7mkTv6aVUcD2dXRyj4MSU2prO3mtYpA4M5xpCNUHa9/9SEQKC+Fng8WFN/1R0XW7dpLmMltXfp/mCJOH3+NBwOtTRHqYWdlXz779UWSGitjweTwora7C1S8uxawzTsHh5/6We62iQf4z+/efV+C8++8EANi7yY6OquDSJWDpJnDRf55I6f2p4pa79+GWu/fl9J4qsgOTqAkXiUQ0YBCJyJNfQrWAcO7Yu/4XDBJ4gw4/ZAqGT5ua6eGy9xVvnKIUsMSCFgUmwOuTD8z2tQMOF3B4AivWjp74rwP8Wkq/x3qzifPHLa2pxohpUzF4Eqna0Wr5v2s6anopDBILAurpKncP6r2eD9B7GwrMAsueYoyaGa0UlFPvxoJG0KmleQJJdAsVsELV9Ko3lsHdZ8PBJ8j4JsUAbdKl0WiIX58pNdsYFb8eOHosKKmqkk0kGEwmuG12/HfJXXjtduLNcgjbkHPmmafA+Nv/4t7H1b3ZQEVjeXTw31Ado5Qwx+Bs9FheasVPQHUFMCYNlwyab3Dw+VuseDnKDjQKVpkCvWqJxmQL29NTzitWEQHLksN/eRT4eQt/nGEAzVjgHnZ7fdZdt6CAbaatNxpTKsOffNyxsvYFlESViilGsgp6KeE7QrC3ksbY2YbX4YROp0taOUotCKTKz1h2TdkGjcNyqYAFeCWwqoDNH3IVww44ArZj+06UVlfjnfADuH35FdxxR3cvwkVD8m5BoNFqiAJW8p3u3rMPDaNHQqvXweMlC5FwrOedDHz6NPCHc8nz3a1AcRHJFFI0HDQq6n4Bdu41GqIDzbJ4BCwdVwYVsHtZAracXfT0Mh6w1rYOvHbbPQh4fejeI/4C2NjGBLHILCEmHHskbnr/NfzxteeTbmRELQjumHMyunbvlXi5Mnjt9nvx6q13Yf/GTaLzm8ePxeHnnhlTZWrr6saSWXPx7QuvJjWeTMFpscqqpKWgyitpl0oV8fHkFSTrTP9+J1x3JfcaVb/JobKBKLptnURdRRWxlIAtrUuRgBVkjeVKl1SoSASjkY+AqsrJ51KriSASy4MgBvat/4V7/NJNfwGQvQZ/Aa+YQCwsK4VQ1DmsiVjyxFPA7m0DZp0TfVxavSAlYD/8Jvo9cgKK9Z9+AQCoGToYVz33GK59+WkAYguCTBKwUgsCSjhm8h6ZAPWANRaY4WWj8VierEOnJC+78tgdXGWAMMEbEqiE3rzzPjxx6TVJXffte0jyO+jzswRs/1PAquhfcPT0QmfQyyYS9AYDQv4A1r73EVa/8wGWv/w6Z9sy+TfHAAAax0RbmKgYGBBqT14PkTKMKcPkhSC5BlXAcgTsj+Tnycemfk1KwF51J/GFp/j9qfzjhXPEnq1LrgAqFeTgdu0HamcD2/dGvxar0bUQOi0hb+98LL6oU9rFPpUmStKYV8v+wrRaQ+gDO3TyRAyeMA5arTZuiX4kGIr5WjbgttmJAjZJUOKxQFL54/d4YSosxIJrr8ScSy/MyBiVoJrdn+acgOWUwCoBO9AxIAhYnYYnYLesIOrCPcxs7LXz3mFBnw9efT0a65WXrWUDWmpBIPlSW9tIuSZVKLZ3A00CnpF60f2WJMHx6ofkp9AAXC/xjQIAOvcaDTIK2NrECtiePqAmHQJWS7xkAWDjdvKzjJ1fdQaDbHZu9bIPcPOhx2D7qtWi46FAAI6eXo6wiocZp5+M2qGD0TRuDMYeGa2Ijgf6d6R2A9JmWqvfeR9r3v0IfrcHa979kAsQT1tyPU69+U+YLildFCKfpKbLYlWkgKVZXGE5sYrE6Nq5BwGvL6p8ECCZ7USKLUq4UhWc1+FEwOtLOoFAIdyUzV+koKV7hvDmc2Pw5nNjcnY/FdmD0IJAGKwo3ZI+ecUf8cSl14jK0sPBIPo6OlEzhLROzma5ts/tJhYE7FTWyRKm11/EK2ClFfdHnAf843liQyDF7x/6qyiw6rKIXz9lEVA9S3xM4rIDjUaDnr37ARAClkJnMHD2I0DmyFGNRoPCslKx4pNVlw47eApKs+ypngwoeW40CxWw8n+H8cccnvT196zbwFX+hOKUZnZs38mVfyrB92++i8UTZyEcCiHkUwlYFfIwlxRz32tHD6l4EVaiUeiMBoSC/PfVbbOjoLQEWr0O9u5enFT+Hzx2e//wfVSRefiD/DrQiinYGTkSJn3/UMDSJYrmYCmx+X/RFumKQbfMgSDQIwi36tmvxknHAMv+Bfz5Uv61u3lHjoTosZK1XgqlCtiQAg5TWuqfCgHLxGiYQq2DYtmJxVOIRmQIxGwKMjx2B3R6nSILAiH8CRSwcy65AAuuuULurVnB4eecASD3FgTUhimVz4+KzCBXMeyAIGCFClhPnxWf/PspAOIP8DcvvgYXU42qMiaq42IuMXjCQQA0KJIEV70tpJ1kSRWp9+/oAeYJ4osu1m9mCqmeQ08fsHmnmICVA1XAGmQUsPE8YDkLAgsp6UjVhkCv5xWwtz4CLL4PeONT8lyn10d5wCaCtb0DM047SVFjof2/bEYoGBR1llcCnYSAdffFbkpi7+5FaXU1NBoNp4SVNlDoL3BZ+xISsMYCMypZhbHXpRKwycJl7YsKvtu2ksxDosSB22YDwzAi4lSn1ydVCqvRaHD+3+/CqJnTRZuyYQdPVnyNdFFVYUBVRf/8DqhIDsKprLY8JCg/jJ3IvGf+6bhz7skAgG0rv8eO79fA2WtB56493Dk9+1pQM6QZ8xZdhvvWfs195sORzG5JPHaHSAH7Han8x4IjiQLWF4heF7fuJtY9Pj+/7lKMPPQQzLmEV2GEQuLmW7RxJeU63/4frxDav3EzAKBnzz7Yu3sQ8PpEKuDxRx8uqrnMFAF7wnVX4Yjf/VZ0jCpgj7nod7hx2Ssx36vEMzyT4CwIzGZeERNDATtk0oSkr7977TrusccR3+OrYzvbwTQJr1mABOL9pQnX7LNPx53LPxGVuauBXf5wxzcfcY+dPSR7I+cDqzcaEQrw4gTaDLWwrBSOnl6YtW5UVahVLQMVGkZI+mjQxkxGsSnAVQ/mE1SFKuTX9rSS/1KFkIDtJe44cHv5+JYVf2NmGttYT6oErC46iSoHqWWetJmUEoRjkH1yCljhuhRPAStncVJUpqxxdCrw2O2k0WiSwtGWTVsBAJu/WSk6HvD6YvbQyAWYJKu90r4fw8Dndqf0+VGRGeQqhh0QBKxOI05PtbJf5IYxfEm+o6cHYZDJK582BHQy3Lt+o+i4g92M0S7om3YCRYV8l0ZpQ2SvD1j+Y3T3SFqmRCFUwEp5RCFRFEsB+8MG8vOs+fF+q9gQesD6A0RZRJ/HUsDGw4pX3gQATJk3V9H59q5uVCRNwBIiNcT+8eJlwERlZOzfbOjk5APDXMBpsaJhzCg0jYud2bnqucfwu/tIow5VAZs8XH19UcfsXUR2J2we99s7bsE5994uPpFhojZLXqdTvOlKAL3JiCnz5uKKp/4p2jiU1+e7+6CKAxFUARthdGiq9kSVH8rB2trOfeaFoJl9AOjZux81wwZj6vzfAOCrMa5dcS9uWPevjIw96PPDa3eisLQUXlac0lQHvPoRUFlG1lSvL766ZZeMCrakWpzEkvOBpevpwy/w5aTfv7kMALD3541gGAa9+1tQM2Qw53s+Zd5czn4EyBwBO3rWoQDEwZvf5UaEXYhjEZwAUDd8aEbGoBRBL29BQDchck0rO3bsQt3woUn5wAIkGfbeg4/ijTv+xhOsLF64/lY8eTnfvMTRS/ZkyZYCBvuRAvb4qy5BUXkZ5zEM9D/biV8ThFVq9h7WYqgmOiDRGw1ixbqNbN6Lyss5MlaXxL5AxYEFk55flHauWQc7GgAQ+5x8osAMHDODPK4a3MwRY5t2ptcrRKSA7eMfH384Wae72UqTZkFVqLSpcyJ4vNHHmhX0c1ZKwEZZEBQmT6AxYfmNVSgQ7QGrFfiax1PAyhKwWU6s6o1GNMpYIsaDpbUNNx58JH58X9x8LuDx5DWhyTC5VcACpBGXakEw8DEgCFi9JoRfIifildDTsDk1aN1MCFhh8xpHjwVekM16PgWKfrcLDDToZBsyUTjZzX4pG9y98zk5fijpyxWl2vX6gU/FiSIAwLCpYl80TgEr04QLAIrKSSZMSsDSAPuT5cC2PcAJR8X5peJA6AEb9Zpez6lMlWLdR59hz7oNXMOyROjr6Eq6aZdUARsPwjIyaitRNzwNN/osYuOXxKBw+sLYFgnN48dyj70qAZs0aHAkhLWtHYBYATvjtJMw7aTorMaGz78WPV/x3zdRUFKsWFUtzDr37ufZo7K62n6rzFbRf2HQk827B+VgoOcJ2BREAX5BmUXPvhYUlpbCwAYOww8hZuaBiAmBSPqb7VtmzsFfjlrAKWBfY/f0tVVE8UqVRF4fMHZE7OtQAjYoaEwlrSKQI2C9MtXtUkVIz74WjD/6cE6NaiosFAVLmSLKdqxeCwDYt2GTYCxMv5zfqQLWaDZzCh9qiSPE3p9JAnvGaSclfY9vnn8F37/5btTx9Z9+gW3f/cA9j6dQjIegPwB9P2nCtembFQAgWmvonk9FdnH23bfhnlWfx3zd2UtqrWUVsAaJApYSsBXlYGimP8fehCpyh0IBn/b4xX/Apk1kjRieZwL2jYeBh/5MHp/4p6txys2kAXG3BahJg9OTsyCoKCXk6zEz+P2GkDB1JOnmJrcm04ac8aDUgiAsOenqF5fi4n/er3B0BLHIPqqANQiSLkKxlVaniynUkCNgi5NMXCoBvc/uH9cD4MVkyUAu5pZ6+uca+Zhm/W6PWqnyK8CAIGB1mhB8KEEnxkOj1XKenUJPFo/NjkCYLRHP429N5ihNVBMTOmY6aa3ZSEhQ2mRLSsB6vMA7/wOklqKDRoujyWCcJlwAuPJm6RwnnHQ+/pZkIufMjPuryULoARv1mkEftWgpwb71v6Bp3BhFXSZtHV1JWxDoDQZEwmGR8jWWUpcnYKvAMBH0trShpLoySoncH7B1+Srs/vFnkTI8HnyqBUHScMm0ZXXbHfDYHahsjE63+z1i7w9LC+lUR5VwDtqIK4XNTKGgzEir1SpqXqdChRBUAWsJNaDIHOT831Ipy/J72MVKo0HPXtJsgjaCrB85nL6UEfjdHvg9HngcDhSUlXIdkKvKSaBYxcYfXj/wv+9iX2cXsWqFPsibvUrL8um6evA4/liDAsF5zz7C7tKmUKYiCQFbWipSxKaKSDiMSCSCf18o9k+jxG9/AhdoFpi5z4KcQrd92w4AxF5BTiErhVwQmghr3iPl4vt/2ZzU+2gTLlNhIcbMTmHTlEH4nOQ7R5XmgKqAzRWmL1zAlZEOnzYVt33Ok/5FFeUIBQLw2B2yHrB6k1HkAetiE7tFZaXQso36LK3t2Ry+ijzCbBavr7Yw2bvlWwErFOIw0GDycXMAAN3W9BSwY8nyj0AQ2Llf/FpdFUBn7yoBb+hIMjyRKmB37gPMCvJkySpg6doEAOOPOSKZIcb0HZfzgKUK2B2ricfR5OPnYMmnb0cJLeT2ENkgYClWv/N+Rq/nl5Mu5xC59oAFSK+YyqaGnN9XRW6RcHf/zDPPoKurCxs3box5ziOPPIIdO3Zg/fr1mDp1akYHqAQ6hBAGmXQoKfePMy/E/aecy53DMAw87GY0n9yYRqMBA01UWiUcDMJts3ObMacb+GUHT8AaJFwjzeatZUUtOg0hCBtGi8m1gICAlVPAUpWwNMsjfPolKwp5+YH4v5schB6wUhAFbPIE7N71G2EwmTDuqMTNtfo6OlFWW5MUIaozRI/rhcVL8MPb76N7j3h34OimBCz5O/rdHhhMJlT108mzfdsONIwZFTMgpQEwwzDcYxXKIVXA7v5pPTb+7yv0tXfKKrGl/w6WVkLA0kSMnRL8tdFBWiJIP4NVTY0xzswsvvjWhi++jSaiVRx4oHt5V7AQJYUR3gM2BVWAj1XAGs1m7Ph+rei1WkEzKkZxi6/E8NgdqB8xjCNgS4qAIQ28pY/XB6zfFvv9tMHI1JJvuGPl9eKE3qusrWNTkvmNla++JXpuLi7iCBuf240hk8bjgfUrcfCJyj2gYyEcCEYlO/sjARsJhxEKBGAqEChgZQjWoD/Aef0n41ObTEfj3WvXYfHEWejYvkvxe8jYiAfsyTdcg8ueeAj1o+JIrHMEYWOTwhhNzVRkBzqDAfMWXSpqpkkJEHt3D2affbpIvabV6VDZMEi0BxUqYDVaDfb7R+Grlf3v+6siMyhgebbPwjcDALZv2AtPpBTDm+O8KcuILqDSwlRIvEe7LYDJCJTGdrOJi6fuIj8DQV40RBtmVkoE+4UFwJfPA/7kiiejFLBFhcDhCXqoAISAjdEbS4SA34f9Gzfj2atvTG5gAmhkGnQDQg9YnoDVaElMu3/DLwCAE669EpUNgzBqhviXklXAVmXXguD+U87FvQvOzMi1kq2SzTTyYUFgMJuSsp5TkVnkKoZNSMA+//zzmDdvXszX58+fj1GjRmHUqFG47LLL8Pjjj2d0gEqg04TQsmUP3vnrg3BZiYFM29btsEoyxG47CQCz2AAwITTs/+UmWWevRVTe+NUPpPxi7izgX7eKz6WKVeqNUwAbIpEIBo0R11QILQikpZKRSCSmOlQ4ZX+yAnjzM5KJPGh4/N9PCqEHbNRrBkNKCtg960iJw9EX/S7huX0dndDp9UkpCOW8aTd9tRyv/+XeqMWA+sRRgowqGutG9E8bgratO2AuLkJlozxBvHPtTwBI1k8tWU8eUg/Yf194BTp27IK1vUOkQKX+ixqNeAqmClhKnnIEfwoKWClylRS4+x+tuPsfaXRkUNFvQKcAL1MGs9bDJS/jNeGKBWpBYCoqRDgUwk5WuQEAY484DBc8eE/a45WCfs+cXj6D+ReBxazXT5puCSHM1X28nPzUa/hFrKSqUqQqoSpZYdX5jn2Jx+bs6RWtM4NGjcAJ110FAPDYHByx2DhmdOKLpQCPgydw5DzWHL0WtGzakpV7x0PA54PBbIYGsS0IXNY+bmxKFLC5BFXA0nHV53kv4HU4seq1d7jnhaoFQU5RXlcLl0W8L6CfDVtXNwBgxDReuHLk+WehsnGQ6HMt9IDVaLX4wf0b3POQqoAdqCgwMQgyZvzCkGaWTosVDk0jRjRnqEQkBVRJRJOMIErsZm0D2r4GGpMrOBSBxquTFgJTTiOPpQTs3FkkLpazPPjDXUDd4dHHAV4Ba7EBM84icamSfJxer0wBazAaEQz4uURzKtDqdbKNqUNyClh2DxJgu4vtY4nYcUeJ/wByzZxixX9SFFdVpFQK37VrDywtmYkBpM0ytbkmcPJgQdC7v1VRha+K7CBXMWxCAnb58uWwWq0xX1+4cCFeeOEFAMAPP/yA8vJy1NfnptT1ttsn4p+PkLaI9j4X16ApFoqCJCqalsceSRoNq++RJWCtIt+Up94kQd3zf43OPtKOjnThK0QfWjdvxaCRI0RqT2ETrtUbxNewdXRFqXkohHN2MAhcdy95fKqy3lcc4nrAGpL3gAUAl6UPK199C4MnjEtYTmfr6AIAVA1WXrujNxgUjyscDMLdZ+PILdpoRug/3J/Qvm07AGDkDPnUr8FohLvPhicvvy7vmccDEW4ZCwIAsLZ3YJBACUUTRRqtYEOt0XBlhVXNRK3KWVyk+XkK+vzcNVWoUAoDu5R094Zh1vmg07FNuVKyIGAJWFY107Nf3OFq8nHHZs6DgAX1PS0fROw/Pl8F7O/gX/f6gLYuwDgJuPkf/DEK6o2+0S2utjCaeZM+qsQRErC04WW8X4dhGG59ksJts3E+okIipqyuJmOlabVDh3CPpb62AKkievjsizNyr2QQ8PpEHrA6g15UhnjHnJOxdcUq+Nga1NEzp/ercr2gzw+tTgdrG/mg5aryIB7evvcB3DiVlMOqFgS5RfmgOm69p6Df6ffufwSA+N/EXExkhJ88+iR3LBQIwO/xoKiijEva5qM0VkVuYDYyCIEn21zWPvQywzH7YCZpEUymIK3CZAT0ARUCFRcBV5+X+j0oAbtxO9DVC9gc0cRvQ+2KJwAAIABJREFUDbtUSSvrTZOAx17hxyIFjZlf/4TEwq9/omxMOq0yAlZvMiLkD/BWSylAq9UiHI4WJcl6wLJEpN9L1kZaPTv77NMT3mfMYTMUjeeOrz/Cnz94XdG52UJfR4foubGgIKf3z8c867HZ1SZcvwKkbTDW2NiIlhY+kGptbUVjo/yG89JLL8WaNWuwZs0aVFcnX1IrxaLTLLj6OKKGDCjgilxOMoktODLtW6cM6gErq4C1WEQdlrfvJVk6ud+NBol3/Bv4attwbGYWoHXTVhjMJtz93Wf46+ovMXjSeJECVnpLW2dXzO7oRZI5rq0L+HETcO8fgf+3SNnvCiRQwOpT84AFgJ8//hxanQ7XvvIM9HE6DvfuJ1kMoQdaIiRrjeC22bnrR8Jhrqt1f0Tnzj0AgFEzpsm+rjca0bplG3b8sFb2dRXx4RJYELx4w23cY0rM0zJE+v0XKumMBQXcZoMuvu4+G8LBkKxPnBK8edf9WDxxFlo2bcGsM08VKW2yhY9eHYePXh2X+EQV/R4GA8AwGtjdOmg1DMqKWQI2lSZc7HeAdk7u3RedYa4ZMjjqWDoQNsArPxQ44XKgRbCfpy4rwSDwt6cAw0Sxt1wwCFTOBD60i/1ThV2HafNjoZ8c9YUtjN2cmIyvvUP2uLvPzpG80xcuQFVzIwrKynD75+9hycdvyb4nWez4fg33uKS6CnMvuwjXvPw0hk7OY4YaQNDrg7HALCqd1ArmSUd3D5hIhFPwzr/68oz9TTIB2nvAxQoX+osdUTgUgt/jRc3QzH7HVMiDfg7K6+u4Hg8UlHD1suouIQEbYffEW1esEr3H3WdnFbAanFrxFD54eUzWxq4ivygwRaII2O8il6GoADj9uPyMSdpXUE4BC6TXjEsa61psRAErTGTOZrewwl4ur36UmANYSYr78Alb1eL2Rse5clDahMtgNCHkDyASCovs25LxH9fqklfA0iRuvMbUwoab4VAI3XsUlOiwyET1XTqQJq9oAj9XSMa2KFPwulwwl6gEbL6Qqxg2p+2onnrqKUyfPh3Tp09Hb29v2tdb+j5PSgQCib8kr383BJ3MWJQU5aeM47G/AL8ZtwtMDALW0WNBdXMTN2EHg0BLp7yClGbzhh99EtaNeBkBFGHjF1/ju9feRs/e/TAWFGDEIVM4BSxVs9/yEPkZgR62zi6U1lRH+aO2dgKPvhR9z8tuJz+Pmq78d45XvqEzGFLygAWAls1bEPD6UD24CXXDh8Q8z9Lahs6du+MuTnLjitV0Sw5tW7dDZzBAy3ry0OYq/dHDJRQIIBwKYehk+b+H3mjkzORVJA+hBYGQiG/dvBUAUFQpTucLy0wKS0sQCYXx2RPP4olLrgZAFn+nxYKyFDxgAcDHbrxeWLwEXocDR/8+sW1Huigwa1FgHhD9HX/1MOgZhKGHw03+PctLyc9URAFCCwIA6JUoYAGQRnUZ3O/2sSrEysZBsDtJkCYkWKW+cHKBVp8dYDTiEhSDgIClsZZJhoAtT1AdT8cnRcDn41RyWp0Ot3z0Ju5eoVCyoxDvsuo7AJh5+kIcfu4ZGDJpPKYvPCGj90kWAZ+PNOESVAfIWSR4JaWJ/QU0+Kb7uP5UeeDus2HaSfNRoPrAZh3081kxqI6zEKCgPry0vFaoctfE6FfgttlQWE4a8+k1QZhN+StHV5FdmAxEAfvVcy8DICSUC7XodRgwJE/5nFgEbEFpqUh1Wp0GASu1JbfaoxWwdexWWLgknLM48bU3bieVLu99SZ57vKRCM5Zv7XUXAsfOVNaEq7yuFsWVFVyzLJ+bV8EaFRKGGo0Gww+ZIlvyz3vAGtE4djQ0Gg03T3Tv3RfVzBcANn29gntMK+kAIOD1Zic2zXD1EoW0sTFN4GcblPTOB/wuN0yFhRlpwqoieeQqhk37Dm1tbWhu5p3Bm5qa0NbWlu5lFaGjk/+C+BX0C/I6XXAydRjcmJ8P9ZVnAyXmACDThAsAOneSZg8TjuUluntaAaOg9OOoC4jPDa3IE07WTksf3rr773jorIsQ8PpQXFmJD78Blr4GLGJNzv/6JDD9pgVgoIOts0vWH3XORcB/P4we/0+bgf8sA4Yn0YlTp828BQFAFqR/nncpAKCqOf6Afnj7fQwaNUJxmaI+yXHtWrsOWq2WMzZfs+wDAPLdm/sD2rftgNsmXypPuu+q1gOpws56uklBm3MteuFJjD9a3qSKqmA+/fdTIgWyvbtXVC6cDKjC3GmxYuean7iO6ypUKIFBB0Sg40jLMtaPLSUFrISApYkqKZJJliWCnfVZjeV5JrQbiAeNTrxnEJbB0XyVHAFbkcBu0xqjWsLnTLLFcwoICjZNh556IgBSFZNvUAsCDeIHdF7J30jORoFDloJDOdDATcvW7PYne4Qvn3kRADBi2pQ8j2TggwbP5fV1iMTYBIeDQfg9XjEBq9Vw3tVCuPvsGDZlUlKKOhUHHjQaYEpTK4JhHT74BzEspx7CXbbC/BGwMk24AKC0uhK9gnAiFQLW4QL+8bxYSQvwClghhArbNz4BzJOV30cY2lB7Ifsa+XMf+jPwxXPKCNjbPn8XZXU1nHjFL/CBlfMwl4OZjRflvt/BAFmrqwY34k+v/wdzLr0QOpaAZSIR2WSkUDka8PEbHYZRTgoni2yoRcPBoGitl2tmnA0EvD6semNZTu4lhddFCHw5/14VAwdpM5HvvfceLrjgAgDAjBkzYLfb0dmZmxLstjZ+UgkEEktygn4/nKhFU21+vZNiKWB//OBT9O5vxfkP3I0jzjsLALC7FSgXiBW+XUN8bijcAsWdcNPmsvahuKoCoRBwxf8D2mV4IVsnORjLB1YOu1tIt2ejwv5MujgdJNOxIAD48tJEJX6bviI1J6fdoiBNiuSbg9m7SHcz6vvas1eeWOgv6Nq1N2YjDoPJKArMVSQH+lkAIGpiRrsYG80mTJlH7CqEvoZA7GYy9q5uDJk8IanOpZu/XQlbVzdat/At3tu2bkdZXU1SXcNV/Lqh1zMIM3rYHGS9qiihHrDJX2v7dz8AAFa//T4AvuEchVClkSkwkQhsHV2obJDftEsVsLGg1UoJWF4B62TFLh9+w7/+A3FG4hpfNhw0GkNkSvtjKWAtrdlPYku9zUqqKhFQykhnEUGfjxDcbCBqjfE3CgUColLPWb89NeG1c1FOSMek05P5v7JhUNbvqRSrl32AoM+PEdMPzvdQBjzoHCFsdPvMohsAAC1sRQwAeJ1OThELkMacEZkJtmv3HhSUlpAGr3loDKMiN5g6Figze1Gr38sdo2Raj6c0pwSssA9QlAKWIfNzSXWViNisiZMHSxayClhWL6TTkkrQVAv23ILt95g4fRKPnQnUKvydKFEqJGDNCoU48Tw/I6EwwqEQp/4cPetQLikcCYdF67aUNOzctQchn3ijk+sy/nThFli7mXJESmq0WtH+IpfwUwJW9YEd0EhIwL7yyitYtWoVxowZg5aWFlx88cW4/PLLcfnllwMAPvroI+zevRs7d+7EU089hauuuirrg6ZoaeGzIr5g4h2J3+WGk6lFcSETs+wgW1g4h3+shTy5FwmH8dVzL0On1+NISsC2xC6RAAC3ja/ZEJKGTos1piKEJtj6WO+YWA2Z5LC7lZifD1VYVZdIAZuO2tLv9sBl7UNVcyO0Oh2GTJ4g629maW2DrbMLg0aPVDbmJC0IpKohaXOZ/gZbZxfKamtkyxv0BtWCIF189MgTAMSkjXADUdlEAnKfi8xfW5Z/hx3fr8Xyl+TN7le9QTpYT5xztOIx7P7xZ9w1dyGsrXyn5PatOwAADWNGKb6Oil83DDogzOhgd5BJvKqKRGFMChJYW1c3Fk+chT3rSDfIUCCAJ6/4I1697W4AwLL7Hs7QqMVwWqyoHtosOkb31YoVsJK50iRQwPr8wKyrJ+CWp/lF8T/LgEN/Cyz7nDy/8ulHMfP0k6Oua2mV72SeiAjNVCOK5/94M5679ibuOW3okU8EfD4YzCZunyK0dZHC43Bw+54p85LsEJol0ASm0F5m0OgRsU7PKcLBIPb8vIE0vFORVRhYD+cKgcCh5ZfNuGfeaXj84j9wx7wOpyj5qtVpZRu/fPH0Cwh4fZhy/BwwKgM7YEGLGrd6ea83v8eDoM+PPn8VBuconzOsCfD8BNx1LXkuJWA1GvIZLZFUUFZLCNN0YLVHe8BSCwKtVlnvl1gQ6h8aE2iQlDY+o77tPkEjrjGzDk34vrrhQ3Hls/8GILYOECLo93MJxJKqSs7yLhKJiNZtGmtodVosOew3pCJWoIDVaDQ5K+PPFFzWPm5dLa7I4AcsDjRaDSIRBd3XsgAvGxuedP3VIiGPioGFhATsueeei4aGBhiNRjQ3N+PZZ5/F0qVLsXTpUu6cRYsWYeTIkZg0aRJ+/PHHrA5YiJb9vOxeiQdsJBKBE2Smbc6xKGHZv/jHJk20XwvF928uw3evv8Nlz3cn4PKEqleRAjYOAUtBPfhoeSaN+eL9JXftJz9HKOzjoNNF++odef7ZKK2tgU5vkDUcTwaWljZUNTXitCXX45qXnsKf338NgydGmyevfPVtlNfVKlp4krUgkJad56J8NB3YOruh0+tlPx96kzGv3jcDAV88/R88dtFV2Lmanws9ghKhKvb75mOznEG/H09cenVMBeD2VWvQuWsPjjr/bPzh+ccx55ILZc9L9H1vYwnYbKufPvjMig8+syY+UUW/h17PIMLoYLWRebqiihivpWJBIIdtK7/HmmUfYvHEWVj/6ReZuagEZXU1aDxI3LBmBduQQ2kAJ1XAUnKF4syHnsL1774pOrZmI/84EKOqoH3bdtnjtcPiW44UxlDLJ4uNn38tmqf6gwKWWhDQqFuYvJLC63RxQWlZXU1OxpcIvAJWQMCOyg8BWz9qeFRlxZ6f1qOstgbjjzkiL2P6NcBgNnFzRv3I4aLmuta2DpFCzuNwiC0INFpZywJ3nw2/fElk9ru8B6lr7AAFdbtZbhN7cTutVtiZOhSYgdoc9EUa0kCacN54MXlOCVgLOx0bQEg/Gm+tJnnVhLY7ycBiIxWgwuWXjkOrTV39CogVsHUyf0+bg/9dlWL/xk0AxArYk2+4BtVDmmO9BQBw+m03cpWcthi2RCF/AHqWjCuuquB6t0RCYQQF6zaNIwrLyuBzuhDy+0VVjRqtJmsWBNlCQVkJDGyz7VwRsFqtLiWhQSbgZz2EJx93LI664Oy8jOHXjFzFsAe0w29vDz+p+H2JibxIKAQXQzbpzbmxEUkJ9u4eFFdWQGcwoEUwFxcksO2KCBpauax9KK4kk/TCm64TZylpky+/Hy2bt3KbQ7cC8ctutnG1Uh9YvU6sgC2vr8PCG6/Fxf+8L20FLABY2tpR1dSIEkF59shDp0Wd17OXdH2sGRp/IQSSbw7mttkPqLJ9qtgtr6+Nek1vNCKUTlpZBQDiCyyEUNFSUl2FwrJSeJ2ElNUryHD+/MnnqBk6GMMPmYIF114R9frwaVPx/77+EBOOjR1Uex0OeBwO2QRFJvHgY+148DF5ZZ+KAwt6HYMwo4PVSuaEynJCKqViQZAvdO3aC61WK2o2edntwJKHgTaFlqdSBazQgkAJfE75hlGxCM9Y/rgUZhkCdtjUSZiUgrLR53JzHnKBfqCADXqJBQH1wpN2QRbC63By55mLimQbmOQanALWwBOwiXzqs4XRM6M7pq78L0kU1A2PU3erIi1QhfruH38GAIw+LLYKzmt3cP7vACFIGEZ+gqVVa2ucR6pr7AAFXaaCQfFnwGXtg0tLSLpc2BDQJle0XxMlPq20n5yPPChi7cx6Yk/TKcNqJ0RrcYxpPZ1QRUTAyvS4DQSVWxRZ2zvw4wefYMUrZG6lJeQUBy84Lu77hUKkjV9+yz1+6cbbucdBvx96A/lHKCwthZZaEEQi3Jrz0SNPwMUmLIVWY0KCVqvTiSp4DgQEBf8QRTmyUNNoNWDypYB18p8fam2oInfIVQx7QBOwQvj9iSPC6iHNvAK2HxOwDs5TtFpxgOiy9sHRy7eidFqsKKoox7Cpk3DkeWfh3Htvj34TAzh7LSitJqvP86TSGfY4zYW7eknpxtGJqyoAsBYEgjmMyunL6+ugNxgQScMDFqAK2AYMP2Qq2rZuR/eefRgyKZpg6t5DCNhEyiI6xmSbgwm9PwGiauivsHXF9v41mIycj5GK7MFgMsHnIllyJSb9Xz33chSpKwQtc5x47FFxr7P7x59RPTg/ZICKAw8GXQRhRgeLlUhNysto2Vs+R5Uctq38HgBgEvhp7WkF7l0a6x3R0Gi1+PnTLzjf5hHTD06qQ204yUqPHd/H6AzCQtrg8cGNq7DohaW48MF7kroPRR+blAv2AwWs3+NFWV0N5i26DEB0F2QhvA4noNHAaSFqhfK66KRirlFSRZLddcOGAgBCwSCqmhR6NqWBioZ6HHzi8SgQ+InKwW2zw2XtQ2Vj//GmHWigCZo1yz5E6+ZtMBfG9vLzOJwiRXs85ZWT3eMrSdqqOHAwaEgdrrtrITQaDbRsuX1YhoDVN04FALzzKPD/2Tvv8Ciqto3fW9N7QkJCIPQOgiLYRQUFxN5FX3vvfhbsvBZERcUC8irYEQsKiChYEQHpvYaQRnrZzW6yvXx/nDmzM7MzW5JtSeZ3XVzZMjs7Ibtz5tznfu5nfBDNp9oDFWABIoCyAixzOlbYDSjbvZc19zRwDGP+Svq5JCeSmD2x3nLUgSolOHekSbyJM9S99SQwfCDJvH32HhIDoVAEHlEE8CMA7YIqwqxC8fN/ao8cqOPi4HJ6Xqur9mSe7/z5V/a2w2qDitN8hV5/uJ1ONjbO5XKilRkLuQLs2g8Wo5nZr0qlRlxSYlAxBMFc64SDBbfdx96OpAPWFWUHLADe4pxM16LLCLCWAARYc4sRbSBi45tPRLQxLg6XAr9vCmzblnpPUyexEot+J431ci9+8tCTvAgCY1MzrwQuTWJiYmxoQmoOGUAffwPIOwOobxLdlKXV5B2MLqRkLdD0L5CcxHfA0gtTWk7QUQdsxd4DADwnqYq9B9B71AivTpKNlVVwOhzICaCbfHucucIc2NlTr8RrF18b1D4ihVTzNaVaBaVKJWfARgi7hYg5fcf6v5J2WK3YzDQvEsPYRL60Uhd6lIq9B5CZ3zOs3TX/XD4Cfy73bjgk0/kgDlgldDor3G4F0lOZJlydKIKQZi0npPA/89l9CnH1f58O6AJXqVKiuaoaL59PGj2detWlGD1pYsDHEOxCo78YG+6iTSi6ouuqSalNJJpU+WPD18sAeCJVWps9M3thPI7ZSBywbCPMGBBg6eSJLvY2H69Gtp/zciiY/uj9uH72Czj31hv8bttcXcM2phs4YRzOuP6qcB9et4I6YG1mM9p0Op8lv8IMWOK8Ep/P0IWGKzPny2NsF+KLRYPx1hUrcPbkfshg6uGz+/DnKqYWAyxaUsFXkAu8/2x4j4mb+Tqkn+f+T4xBs9aUA0N9I1IZAbaEU7QxtD9wyXnAyvni+77lck+MwssPkZ+TT/Pejrptp55JfjYKXLacIoOgaRMkAd5xJfDGY8B/7wdefYQRYBkvypJVwe175+pfeffFFuC0CQl4/veVuO29N+DkzN3NzNhftnsvb3u71Qo1R4BlIwicTlbwdTtdbMUIV4CtLy3Hy+dfBpPBgP3r1kOpUuGVzb8HvAgXSMVPKK5DpOBeDyVFMANW6jwcbsyc3zctN4jVDJmQEKk5bKcXYF1u8itYLP6/KP8uW4GSHftRbeqJ5CQgT6TsIFwolUBtgE2euQKsWCX8PYvexcPffOpzH3QVjLohaMzAyHPPwjUvPgOA5FQZGpuQnJkBhVIJt5s4XP2xdoP/JlxJCSQ8HeBnwNLSByoAddQBe2DdP1j3+VIAxLlasXc/UrOzkNGTb3F22u1obdbhjBlXoe+YUT73qQ4yggDwiJoFQwcBIBdLdcfKgtpHpDAbDKzLiAstb5EF2PBgNZErPlqW2KZr8bW5F8ZGXysj5OLHnwBLg/tH+HHKysgAgFrphtOlgqXVBCuSkJLMCLCdSIGlWctxgo6yp197BU6+9EIMP/t0n69XaTRQKEkuo5VjiRE2H2kv2378GZu++YH3mEkisoAidMDynvPjgBRDJ5E7Fw0ayyux6TtPJ+fWJs+s+61rbuFtazYYoYCCzWGXcsBGcK0dhzduhsNmY7tfN1YeR2av8NcMU1dkn9H8icPaBYu8ttVV1yIjn0y+7/rwHVzy5MNhnUB3N2gzHqvZgladHnFJ0gKsyWBEXGIilGoyNitVKmkB1uc1gExnJSeenL9OGxeP1CwycXIJpueH/vkXygSP+BTuKs54jgA7tL9HgP10hRL/c6xAtfsEGBqbkNqDTKTnfOSpKhnWH/jqDWD6RO+5Yv/ewKKXgKNryH3qExoo0ldExxQS5jBa4npBixltB4zgwsi9B24AHryR3B7AHAvtXXW0Irh91xSX8O6LzTmpqDlwwkk885TF2Irnz56KD267n7e93WpDr6GeLHtWgHW52Nxxp9PJCrBxIos+z552Pkq27mDvP/LNp7h05iN+f5+Am36GcQF3359E+U+OUASBr/NwuKGmAQDI7V8UlWOQCT+dXoC1uomN3hJABixAVv5/N5ImNsGUSXQUpYK4hlbtHwGDy3emByvA5vYQFWBdbjeSM9LZ7B0xjMxJmLpIEplJWU4RGVkOb9yM5qoaGBoaoVSpgjqpHTsO9O7pGTjFqPBUUfAdsIJBwRGk0ClGzWHSXCijZx6O/LsVTocDeQP6QaXiH6DL6URCcjKuZgRoKdoTQbD+S9LBvrPktbTU1aP/SWNwxoyrMfi0CQBI/AAAOOyyABsOaM4ijQoJtpMxN2JEWBJE7yf6EV9qio8CAOLC6ICV6TqoVS44XCpY20ywIQmpzMcmStFY7YIKsFKipS/BUqFQ4LUdf0OlUsPtdsHByfoecvopITm+r576L9Z+sJj3mFVozxGQkCotwNKKFoC4MPuNPQEabj2pCE3HqwCQpg/UZafiZOZGmubjnvwto84jwNYKJrZmYyug8DQeSRPJNecRIYevsamZ/bw1VVYhrUeO379BqOg1bAgr5knRXFWDjPw8nuia3pN/QXz/F//D6PPPDcsxdnWouGIzm+FyOH3GDJlbiMpEx26FQgGXHwesTNfCaCWfF4USUCnJOeqXBR/ztqnYewAueL7X4W7ExT1dLXrRk8OamJWHVvRAWi5xwCampkIdFwe7neSqN+qIALuRScyaOJ6/XyrkpiQRAbWSmStqtfDicCn5mcP0sBNWZ8aJvCZQTD7iBfJ78B2w2UFqfm364Lp35fTxqM9OhwOtTTpWVKUkpCTzqnXobZfTyVaGuF1OmFp8x9/RGCUASEhNwenXXen3+LjCb7T4+IEnsOnb5RERYOm4KHUeDjfCv71M16TTC7AmO7PSHIADFiACrDt9AAByko0USiXJzVu48WzMb/vG57Zmg5F1KIo0Q2VPDn1Gj5TcB3XAXnDf7aLPL77/cThsNhgayIjGnbT541glCYrv7aN6Qan0zHW4GbDClbRghU4xGitIZ7C4xAQ0lFVg+atvAfC4USmzp12FXz9YjJw+hT6bdbQnguD4gUOwmS04smlLkEcfHSr3H0Th8KG45ImHcMu7r0EdFwc1czVjlx2wYcHECLA0LiAhWVpEEcPY4LGnCyNIhF3apTi8cTMAID6I/CeZ7ota6YLDpWQF2EE9ycW9KwZK1QOFlnPFC75vdCLiK4JAwTS6UCgVcAsG49Qc7xKaYJtzUYSl9f6cF/E+BB16XPEpyXhs+RIUnSB9nUDZuvwn9vY/TJMmmyV6ebCNlVXsba4DVogmPg4KhQKDTjkZhsYmr6qOaMEVypoYMblwRHibH1K0CfHoOaC/z2101TXQxMUhOSuTvdbhHp9SrULR6JG48Y2XwnqsXRV6nWu3WJDaI5sXByaEXhfQGAKFUuk3gkCma2G1kTldUjygUpHbzTX8vhJNlcdh1PuOpgkVy94Brr+Q3N5xANBogEvO5R8rABgayTUpd/54oIQIsEfKyP3H+EUL4K4NnTwKEPyaPHQtQGsbcc0CgJ7RFu12sv9VfwX3e3HxtcaZ34NUTdCCl5wgNT+XSOa7r3NAbr8iv/s8IsiFn3wX+Y91OZ2sYKdQqtgYIak5LFeAFaLWatF3zCg2jo5y2/y5GOOnkVgkaNXpkJiWGvZqDXrdFy0HLBdaTSHT9ej0AuzKP8jPsuLAulXpqmpgVpGV/og6YBkBVqFQBJSzZqhvQEbPPF6zk/Nu/w8SUlOhVCrhcjrRd4z0xKqpqgZmg5G3WjT+8ot4J1WAM4BmB57HcIzonehXKL2NRk0GSYDvgBWWRTg7GEEA8CdrALDjpzWi2zntdpTv2Q8AyB88UHJ/7YkgAICnTzkPC+94MOjXRYOvnvovnj51Er544nmoNRoUDBkItZbJ5ZUF2LBAV6bNTJc7msEb6GeNu7LNXTEHAg/Jt1usaNPpvdxOMjJiqFQuOF1KWNraoIINDheZRITruvSFs6fhhYkXhnSftJxrzNRJvAZ0NE8tNcAoAeG4nTegL1tmTuFmOQaDw0c7Z+pO5TLlvjskJ3Q0big+MTHghRnqzgeA3xZ+jKcmnOvXSRNOmiqPs7cNDY1orDiOvz//2mu74i2kJjWrsAAtdfXoHSGR0x/GRo9QRuMRUplqpHBC/46jJp/jc7tmJvN3xMQz2Px6bgM3RURDG7oetNLLZrbgx7nv+dyWxnEVDCGGAaVSKdmEi/s9lek62J3k+5aSrIBaTW47Hd6fgZri0rCb+FUq4LJJwBknkfuPziE/aeNl7lBlqPeeP+4/CpwwlDhcARJfQKedD94IvPKw5/WnnAD4609ZyUnHoZEErSZg8BTg21+C+c34+HLAZmd/Y5ZZAAAgAElEQVQQByzdJlgHrBhSi4OBzoGlcuFdThccTONkWsX47ow7MGf61aLb20zSyvNZN16L+z5biDFTJnvNKcZMmRTQcYaTtmY9VGp1u6+zAkWhIL+7S8wBF2G0CfE+xXuZzkunF2DvmdmIEy8HDhUHZtnW1dTChAw4nBF2wDIRBFAAbrf/L3VLfQMGnzYB3MWqSXfehMl3k1UvfW09zrn1RknHjcNqxRxBE6irXpiJIkEWDc2UCtYBCwAjpDVMaNSAjRlXeA5YoQAbgggCYS4WLTkVo+rQEQBAwRDpg29PBAEAXo5PrON2u2ExtrJ5QL1HDGMFCWEHT5nQsHbBItSXlqNi/0EA5ILs4wef8PqeSsEVgHL68Fc/FEzr3BbGJStssMZFV1OHvmNGoXD4UJx69WU4/borgvo9/PHNikZ8syLAwGuZmIY6YO0WK2pcw5AYR86L4RJgjU3NIc85pOPB2KmTMfOnb9nHqbMg0CxXYfMHpUqFs264hvfYoAnjeCV9mvg4PLP2BxQOH+pzfPAV+/Lmlf8RfZwrJnNJYxyw/srQfeEvAiHcNHEiCFwOB2ZPuxIrXnvba7tDf29kbzusNlbEijatHKcijZRSx4UugiA+OQmP/fAl+o8by3u8uYrU82b4WWBrriL/v1c89wSyCz2fIzrRi3bX62ihjtNi0l23IH/wgA7thxtBUHPkqM9tqfu998jhAMj/vctPxssR82h5jO1C0ClhapIbSsYBa3d4D7KW1lZe82gfhXwh468twG+cBtJ2Fzk3bPp2ucfA08MjwL77BcmPHck5FdO59tszgWlM+4GqOmACp//sjgPi78+Ns6MCbEeyXymBTNfMzPy7PQLswX824fjBw+z9dE5fkjFTJ+Ok6VMAkEWaQLBKCKdul4utWqTNrct272XHAu/9SDtgqWFrzAXnQSW4fug9MvqLm606Eu0Q7hgCJXXABqDVRIKENCI4q8VyOmRCTqTmsJ3+KstilT5xi9FcVQM3VGgyxqEgChEECqUSgUQ/Hj9wGHGJCUjJysSTc8ljTmjYsvpKRsQZNGGc5D6MjU1sbuSv//sEAJCalSXYhkwUhp4p0oJSgmpi6MB106S30ag9K6XcFc44YQRBCBywYrx0/qV4VWQF0NDQCGNTM/qdOEYyQ1et0QQdQdBZMTQ0wmQwYsS5Z3kyYGUHbFgo2boDcy66BrVHSI5hRs887Pvjb57byx9vXD4DVpMJ2QIBljrdqKDuS4jQ19ai58D+eGjpYky57w5cOvNRnHf7TUH+NtIs+LgWCz6OnaY+Mu1HpSACLACY7HFI0DICbCeKIJBakNNQATbAxUexTuYnXTSVd/+al57lNbVIz8tlG0JSl6taJLhOrGSRInX8yRKOyryBpPxcWO0SCNVMnnq04bp9AqkYAsDG/8TFQLyKocmziEDLGJOzQjdpzMjPQ96Afrhn8ftIz+2BK1+YieETz4A2KQEVew8g0Ud/AIB0xV67cLHX43SiRxf0ust1ECUpLQ0X3Hs7Ln/mcfaxrMJeuHHuy4E3ooHHCU/FldIduwGIL4psW7EaLpeLdeorfDhgKbvNp8ljbBdCoyLfsx7pNqgZAdbp9P4MNFYcx367x90e7kZclH3MsECma+R64OiW7RwHrGcMPVgCGE1AH07fQbGmzQePEQcsFZTfWj9NNI+UCrB2O9DCDAuhEGD9oVR63u+LH4N//Ud3P4J5192Kn98lncm4sWEz5szC9P8jTbZsZmlBlIvUdYDL6YSdyaYXu7YQYvMhwNL5+NAzT/VacE7xV8ERgaIJ2mBsygN3dWg/abk5OPkS6Uor6oAVxk5Fi8TUVKTmZGPO9nU47ZrLo304XZ5IzWE7vQAbLLoaUm5lT+wTnQgCBBZBsPPnXwEA/ceNxZyPgKF3nAI3VMjr1xcAsOfXP2E1mTDolJN97qf+WBkAwMqcvJMy+SdVuvo+8tyz2A7C5972H1z8xEOS+3S7AbsDKPOujGTRaACq4/l2wIbmAl9XU8tzGOmqa9FQJt66snL/QYyefA4eW75E1OmhamcEQWdFrdGgz6jh7OqpMI9QJrS0NPgIvfJDzZESNJRVss30KPRzvGHpMgCeBRox6DkQIF1TAWDEOWe2+5iEJCQokZDQ7YaWLola6YTDRa6sTTYtEtTk3NCZmnA5bDbeOY2KINSlFkgEwfZVa/D1M/w8zA1Ll0lOSlRMR3ru5Io6Ie3W0DRYkHpvOg4GK8A+PuYMvHX1zR0+rlCxedlKVOw7AEubdEULF1pWL7zGiQZcByxVGAaefGLI9s8V7C989D5MuPwiAEBO70K0tbT4bNAKEFF4zXsfsrmCbYyzKLdvEZOxR87fao0mpMJxrEMF53hOk8pzbpmB0ZPPwZipgZXgZvbKx8WPkSgq+v1fdP9jWPrsS2ip8x773W43rG0mtlGXQqnw64BVwyaPsV0IrZoIPZOHFePC8UTUFIsgsLaZYFF5StnDKcC+9AEw4Hxyey8pHIRa7elBArcbbfoWOB0O9BrGb9KUmQakcarEuWIsZV8x0DMHmDGd3J946394i5cUGkGgUABMehc0IRRgv1sD3M8M7Vy9LS2FVHGqhgOvfST9+oKhg5CZ31M0l9TlcGLdZ18BADLyxP9YgWatc8dBXQ1fHHIIHLC+kHLSAuA1qRRrHOgvqzbQxdL2Ur57HwCgh2D+Eyw3vvEyrn7xaclYCOqAdUXRAbvi9XmoZpomJ6amsrFxYy88P2rH1F2I1By2243gTrsdTcerYVHnoVfPyHX5VSqA7KI+xMYfwEmq+nAxzMZWDKAX7cxr6KqUpbUVR7fsQI++ffzsh3yBXU4nXC6X6IX5itfnAfCIo1MfvAtnzhDPj6HsOgiIGIJYNGriTgaEGbCJsJrMaGU6G4fKATt72lWYebLv3DPKt7PmYN3nS5GSlelVyg2QJlyhEoY7Az/OfReauDjk9ifivizAhhc6ed73x7p2vb6hvAJDTz+F58ihDlhziwEvnncxVvnIndPX1rO3U7IyYWxq9sqy7AirvxqG1V9Fv1yps7Bo0SLU1dVh7969ktvMmzcPxcXF2L17N8aMGROxY1MpXXA4yWfLaNWyHZpjxBgQMGaOo7L/SaRsm3alT8nK9FtyXXes1OuxlroGaOLjRMvCqIDDzdJsKKvAi5MuERVhgmHPr38CkBZgabOxYAVYp8MRUzE637wwG/OuvdWnO5hLazMRPUXLE8PctEOIkdM4TFdVgzZ9C1rqw1PSJszma9Pp/QqwlNLtuwAAZsZ9ec/H8zHr7595YoIwb7wrQ39vDafxSV1pGQDfVSVc0np4JvW0OY7ZYOQ1uhNiNhqRkMp8b/04YKsOHsGlmR/JY2wX4epri3B67/3s/WG9yXfRISLA2kxmmNye81tRAfDWTN9xcO3FYgVKGA/LPm5hBO0Qz8xJbWaLVybn16vJzwomSUZMgP2VSY85/3Tfx0H3oVYDhhD3IFMMBa58CDjOeBJUgssAt9t/3NIj33wKQPr8wPZdyBMvubVxwmj/WPSZ5PtYOQ7YpYLFYBobF4gDViyCgC5GKzWerFGxnNV8H+dApUIZ9uZYNrMZW35Y5bOJdiDQRXipqDZ6PRhNB+zfny3FN8/NBkD+Fi5GK5HzYMNPpOaw3U6ABYDvX34drchBQY/wrdY8czdwYBXwBlPJpFQC/cediKITRga0SuRyOnFs204MPfNUqOPiEJ+UxHveajKzHc19QbPlVBo1zAaj6AoZvUjMYwS4QNAbgXQfOdhqFWARc8AmxMNmNrMTlFAJnU67PWDh0FDfgM3LVgLw7kysUCqhUncvAZaWrQ8+dTwAsHlCMuHjiRPPwicPP9Wu19YePQaAn8lELxhcLhf0dfU+Fzb0gtVzu8VKVvC7ae5ftPnkk09wwQUXSD4/ZcoUDBw4EAMHDsQdd9yBBQsWROzYVAonnEyDEIfKI+qE2+kQarjle9TFQTNglSoVkjICE6y4tOmJazAxPc3LpcmO14IJCW14FCy0+/n8W+/FF088D6fDgeSsTCSkpng5Pqn4254Igs5I2a69+P6VuWhtJn+PFB/5cJH61HJzjN1wo7mqmpeTGCr2/PaX12MmvQFJ6YG5gMt2k0WfNl0L+5hSqWQjCICOu406E3QM5HaepmWvNP7LL8y5cd3nSwM+T1qMrUhgFkFJBIH0xP+dGbejdMeewI5FJuaZ9SBfNEtNJNduDpGFJ4vJBBM8C28njwIeuhH4Z0l4j3E/J8aYvU5kPttHNm1Bbj/+3LGKWeNvMwO1DeIRBHoD8PlK/+/NzYANtQBL2b5f/HF/X1+uGOYrS15XU4f8wQPx6rZ1eGnDWt5z1CVfeeAQfnpb+tqOew0jjAqic/iAHLAi+e4Z+T0B8H+fRBEBlqsRcDPo41OSMf7yi5CaE/oxToiltc1LDwkWA1ONJHW81NAS7QxYs4GEHiempbJzOlUo7d8yUaVbzribq2pgcOchLdmFE4eH5z2mnUW6P957HcmrIdGv9Esd2EXZP199h/TcHhh+9umY9vC9vOdsZjM2f+8/mIbNndNo2DIzIbQJw7WvPMd73Ffmld4ApKdKvy/XAcvN69EmJsBmNkPFTA6jVepfX1oOq8mE3iOG8h6nA5CjG0UQ1B0rg7GpGaMmTQQAtqOmTPhw2Gw+J1m+2PXLbwCA4RPPYLOb6YQ5kH1WHS6Gi7Od3WqFSqNmI0hkIsv69evR3Nws+fzFF1+Mzz4jzojNmzcjPT0deRLlbKEmR1vDdmg+XuoRlcLVhCtc0HxFAKzTn+tyy+nTG5m98jHlgbuQ3bsXTrxQWhCntOmJaJWUnuY1qWEdsO1whPzy/ocAgC9nvsAKbKYWciFu0hvgtNvR2qxDSlYmnlnzA2b9tVr0vbuLAPvuDXdgw1ffsUJZUkb0S+YNHAFWqVKjpb6B54wMFbuZsYBLm16P+OSkgJwyxZu3Y/mrb+Gnt97nPU5FFqfD0a0csLT0VJvo3dy2aPTIgPahYL53B/76J+D3Nbe2Ip6NIFDyxmchDpstppzqMh1DoeDPB+M05L5d1AFrgs7t+T7SCIJwRwJxhzc2gYD5jNYUlyCrsIDXEJr2CUlKAMqqxR2wDifwp4iHSDhm1nAKRgyBpdEETSVH5N22L/DXqTiO0cQ06Qmxvq4ORSeMhCZO6+UspTnR/npvcBd5hRLCgXUbUFNcgj8+knbQUuwikQeZBeQPxPt9RKoo8gaQa6cR55yJmT99i+ETzwAQ/qZYXCxtbYhLTuqQ25Yu1kpFOLKGliiXetHrPvKZIb+vWhZguwzdUoDV1dRiv3sq6gxJWDgrPO9BT5DxccBJI4CE5HhWgA109aZk2064nE7k9e/Ldqin2MwWOKxWHN2yHYCnnFIIdXKqNBp2giLk7y++xoF1/0CbkMDr1JvqozmJPwesRg3Q5o40CyghNRUnTZ8Cm9mC2pJjcDocaCivlN5JGHG7XGiursXIc89G0Qmj2MfpANSdHLCAxwULeER7mdhEz5Qwnznjatz2/hsAAIWSTPr8Ne8ASCn0E2PPxMrX3wEAtvlaZi+Rq2SZqFNQUIDKSs958vjx4ygoELGUALj99tuxdetWbN26FdnZoXEjNOrJOVFv8Hy2xBqExDIWo2fyQl0c2oR41JeWAwDu+/QDPP3zMpx3+38w86dvcd3s53kTSjFMHAFWuKjKZki2Y47w6wekOdKOVWvw6cMzAXgyOqlLrrWJCLDcrEpKAhtBQK43fv/oM/z24afBH0gnI1IdkgOhqcLTWDE+KREtdeERYMW+hXRhwF8jLoBcB63/8hvUlvAjNqgDqE2nx4QrL+nwcXYWlMw4qomPF53gjz7/XL/7oK/zJaIKsRha2e+tQqFo9+KsTOdDITFIOB3enwGryYxqjMbNc/pgxwGgNzEuhk2Y5PLBUuCndZwGRczJp+bIUSiVSuT278duSwXY3GygvBro2wto2crfn9MJ/LXF+33iBdmjTRzfUFX7CkiC4swbPLf9eaWUnEUuXwteNApQDOqAVfqpQLO0chd5+QdmNhjwxmUzUMf0fPGFmAEsi7n25/4OwhiblvoG9m+c3ZtE9/U78QQA7Vtobi/W1jYolcqgmiIKMTSQOKDMgp6iz7MRBAHMp8IJjc5KTEuFiolNCGRcl+kcdEsB1m6xor4J2Hh8JEYOJNky4WDHAfLzjBMBlUrJCrDcVSZfOO12NFVWIbd/X9QUl/CeozkutLFHisRkm3XAarXshbmQlrp6HPibBPLM2fYX+/jN8+bghtdfFC1N1hv8CLAagEbN5BeQDQuHDwFAOnl++vBTeHzMGe0uyQwFTrsdabk5uPARj7uYri45Hd1LhFw+5232tr+VWJno4rBaeW52bUIClEo66QvMCuFyOtlGXXT1O6uXuKgn03n48MMPMW7cOIwbNw6NjR3PnDztjnxcfQPp4K1r8Xy2Ops+wHWP5A0gkwhNfBwq9h2QdJMJszUpu9b8DsC30CXmgFUIA+YELH32JXxw2/2iz5lamPdKI+9lbGqWbI5E85yVKnKdcXTLNvz8zgc+37sr4LBaYWlri4mmUW63mxU1FUolWuobkJSeJpoXHGq4zuxAMRuNvPsJjJurVadHQkoyMvIj1G49ylDXuFKpRGZBPubu3cRzvgZSJcKWrwZxkrTbbCgYOggPLlkEpUrV6SJeZDqAhHYllgFLKy1GProUOlcB64DVhtAUd9914o/fPQu4d8EI3Pb+XACe8uzqI0RcLBzuacRFIwjitEBxOdC3AEgVtBlwOIHS4/Aiu5B/HWrmGDYjYfw2Wzxz12AiCHxRumOX5HNUgBU2qBZi5Tlg3fjmhdk4uH5jQO/vjx5MLBM/goDv6LVbrcjpU4gR55zJNu2lY0wkBViaVx4nsvgcKPT/XKohmSfSLbqVBm6XC2aDEQmpKezYlJyR3iHxWSZ26JYCLEBiCFrVvaHVAsMHhOc9GpqB8irg1UeBOIUJ7nbYYepKy9Cjbx8kpqehsdIzWtETyOENpIaDrugIobmoaq2GbXwlhlWk07A6TosTLjhP1LmhNwJJidLdKDVqoI0ZOE+dfhrvBP3Xx19KHkckeXfGHdj03XJeIy6ar9KdIggAkllHyx1C1aVbJnxwG2lNvPl69nMbzIpt1cEj7G2nw4H8waE5EX6ytB6fLK33v6FMQFRVVaGw0HOO6tWrF6qqqiLy3hvXV8NuIxOtZp3nnNjZBAJuBEFiWiqSszKgjY+H3WLlfZe4DJ94pujjn//fM3h05Ck+hS52csAZ94QTGiFbl/+E4s3bRJ/74ZU3sWP1Whza8C8AIsBKN+FiIggYx4QzwCZWXYHWZh2SMwLLPw03VIBTKBTs9Vk4cmCFmNohwLocTl5ueBqTjUf7DOQG0R+gM8NdJMkbSBZqqNgAAHF+RBKAGwcU/Dmy98hhyCos8Nv8RR5juw4qhfjf2mEXd8BSlLmjQIeZAD09AfG2j9YEN8+b4+kcz1wD6KpI/f6EKy5lt6vmfDT3FwNiaThSw5KwwZJZMB3ZewR4KczriQ3MVDlUAmzl/kOSz9EIgrhE342luBmwbpcLm5etxEf3PBrQ+/tjwmUXQalS8QVYZvwo2UaqI6nZ66a3ZqPvGFI1SheEKe1tLBwMtBlZQgcEWIrUGKmMEQcsAJgMBiSmpbIL6gDa1bNAJnAiNb52WwFWV10DTSoZSJ67h0QFhIP1OzxuoVTbEd8bi1B/rAw5Rb2RnJ6O0h178MlDT2LXmt/Zk9D2Vb/g1elXo/jfraKvd9AIAq2G12hBCL+8ASj+dxt+eIWsdLIDLgc9Y5hIE2merlSSf2WMRlDiPoOXtxcrOGw2NJZVIjkzg83l6a4RBADJ0vth9puSURUysYO+zjM49Bk9Alc+/ySA4ELjuau/rU06FArykNvLp0vr8ak8OQwZK1euxI033ggAGD9+PFpaWlBbW+vnVaGnsdFzTuxsEQS0lIsuMl31/ExoExJgs1jYx7gYGhpROGKoZHkowBe6hNslJCdDEx/HdkgGICmYBoK+rh5fPvE8HMziWCsjwDZX1Xhtq4mLg0qjYXPWu1M5c1uzPiYiCADg+1fmoqa4BI0Vx9HCxMaEKoYgb5D0YhltDpcUpBDNrXw56aKpAICWeiIc5/XrHgIstwyYiq0JnJLoQJxHnhLtICIIjJ4FovxBA+Dy81p5jO06OCA+N3KIjLE2zjVbvcrjzA6lA5YiNvJxxzAXI07RxVjuvIErwOr55nq/xCfzJ5VC1+uoi4Fn5wW3z0CYdCtwI7mMRmOAUyCuYLll+SrJ7cwGz3+CsOKGmqn8Le7wmkyH+PJLpVEjKT2NF6nQb+xo5n3JdV9TJZnQcytiWQcs89iO1b+G9sBEoNVMHXHAUpLSJARYFRVgo794bTIYkZiayi6oAwi4yaZM+4jU+NptBdjm6hrUp54PALhsEvDZq+F5nxseB4ZPJ7dTHaW+NxahtqQMao0GSRnpMLW0YO/v6/D5/z3DcyA1lFVIvp4Kib6acAF8hxBALh5p1mSaSNmVnpmzijXioquxtQ3AXONqFLvPCcg5EA0aysn/Hc20oU7C7ijA1peW458l30b7MGQCgE6yAf7KebD5ve/fdDfeveFOVB06ErImXFmZamRlhinXpQuyZMkSbNq0CYMHD0ZlZSVuueUW3HnnnbjzzjsBAKtXr8axY8dw9OhRfPjhh7jnnnuicpxNTR4rSmfT9BqZTE46Bqb3zIUmPg52swUmo7cAq6uuRWp2Fkaee5bkPp0OByytbaIXw3FJSeg5sD+b2QpI5421B2NTM9RaLW8hhktCSrKnjK67OWBFBNhIlkhSjm3biTcumwGHzca6h0IlwF740N0A+ILI/Fvuxf/ufAhtzMVZsFlx78y4nb198qUXAiCCj6Ghsds4YLmN65Izyf8tNwvaX5kwEFxDTIpFUIHmzwErj7FdBymRR9QBy+mGVZU0lb0dDgG2SJBIJcxE5y4wHN2yne0lAHhK+AHAwJ9aoq6Rv00xiWGHGuT6QizXPBL8thH4fAW53cD0RPWnc1LBcsnMWfj62Zd9bksrzoTfdeqADeTcQuloBZJY6X1SZgZPUM4pIs3eaKNsQ0OT12vyBw+EQqFgx9dIVEZRs1igvXR8IbVISRtPumLAAWtuMTAZsJ6/TXKmLMCGk0iNr91WgC3+dytsak+TqSv9Nz1uN4eOAd82PohX/7kWHz/4JNYuWBTwa+mqkzYhXjLD1RdsBqzGdwQBt7wBIBeP1LUhJszQVU2xHFgqwNodgNlOLmiFZSWxAm0CllNEBFh1N40gkOlcODmfT21CPJs36GuRRYxj23ehbNcelO7cjfS83JBc/H63eAi+Wzykw/vpLlx33XXIz8+HVqtFYWEhFi9ejIULF2LhwoXsNvfddx8GDBiAUaNGYfv27VE5zuYmE1xupjt6JxNgj23fCYDko25dsRoJqSlQqdWwWSwwt3hbdOqZRc0b3njJ537b9C1IFFmFjE9OYl234YB1w0hMeOKSkjwRBN2oY7rZ2IqCIYN4ZeM8ohSdQQVYyeMKEgsjxCSlp+HLmS9AV1OLY9t34fDGze2KIAC8rwEBUoJZV1LWbQRYnrtLZHIelAM2iMm78P++98hhPreXx9iuhPjikF0sA9bMUTZVcaghp5WQRhBQxg7n348TCl6ccykZB8XPN0IB9sk3gf6TPfmvrzPTYTPI67NioBls4BEENObH/3yxvowozXZBjw362sYKkUBcSTo2jolV/Zx3241IycpE+Z79+PTRp9nHD2/cDIfdjs3LVrAVtRRtQjymPXyvJ2opIgIs+UDFp4iU3waJ1Gf2joWkJ0qsOGCLThiJuz58h31MdsCGl0iNr91WgD2yaSs2Ll0WsffbYz4btcZ07PtjHdbM/yjg13GbVLVPgCUne5VWi9YmHwKscAXeTTor2swW8QxYHw5YulDjcHoEYH/5NtGiqbIKLqcTUx+4C/d/8T/c9dF7ALqnA1am88AtWUzOzICltRWHmXzI9lB7lAi43WWiLRM8ZmMbXKBl7dF3BgQDjd9JSk+DzWxhs8vsFitMBu/JSEt9A77772v+96vXs0IXd1ITn5wEVxhVatrtWKqhZ0JKEhtB4HJ2n8XExkqyoHrzvDl4ccOaKB+NB4uxFU67g1fO3hFam4hFSx2nxY5Va/DS5EtZx6XDZoPNYsXUB+4K7hhF+gC43S7UHStFn1HDo+IijjQqTplnisBJbbdaA8yAbX8EgbDZrkzXR6EQH0udIuOH0Lm4l0m1U6lCF6N3+Bj5KXTVqgUNP7jXACbGpcflodnAXS8ALQIB1mQBjlV67n/4LaAdrUAbyDxz8t23Yuy0ye06doVSicdXfIVRkya26/WUxkAFWBpZF4AAW324mGwrmFsmZ6Tjx7nv4aun/xvw8XXUaWrSe1/zjJk6Gb1HDoPL4UDxv54sel11DZ4Yeyaaq2pgqPfuNTN22mSP/hqB0ii6WBUKB6xao/FpDouF61wxU02S7IDtEnRbARYA6krLI/ZeSqWqXScnh92zWmZqhwBbxzjjjmzcgoq9+yW3sxi9IwgAoKWu3mcGrD8HLBWAgymviCROhwPN1TXI6JmHotEjEZ+ciIq9B9jBUkYmFvnnq++w78+/0arTIzUnu8MXI7Ul5Ko7TxZgZSSwGFuhVpDJQyyUZgUDXbxUqlTIG9AX8cxFt81igVlg0fn8sWfx1ydLsGvNb373a9IbkMo0LOJeKMcnJ7GlyOHAxHStLxg6WPT5+ORktpw6nEJwrPHbwk+w74+/AfhvehZp9v35NzLy80KyL5ojqNZqRZ8v27Un6H1yy5spbpebzRnu6SN3tqugUHJy9gSTXJvJHJAD1pMfGIwDlpyDuI0xZbo3YhEEwjiZg6Wez2tpiOI36XAhnNupBIosVwQ0tRi88jslBbwAACAASURBVDTnfQYs/NrbAcuNJ2D3peCfx/qdOCa4g2aIS0xAbr8iXPfK8+16PYVGEPgTtWlZuCsAAba1Wc9sy/8b5vQpxF+ffBnUd7+jRtMfZs+VjC50OhwwcxaludcPhkZvATY5M4OTe92x4woEulAYqqgKX1npsZCfL8z5dzocsgO2i9CtBVjhCSg5jCZNhUoJV3sEWE6mY3scsPWl5XjmtMnY9O0PoiVmFOHFN7141NfVi0cQBJABa7cDTtYBG5sCLOApDzy4fiOePOlszLvuVuiqI9/kRkYmUPS1dfj4gSfwy3v/A4AOT+x1VTWwmszIHdAvFIcn0wXhltQ7O5kAy3Wd1HPGfbvZ4vXdKd68DWaDAWaDkdc8QwyryYQ85jvDHZ/jk5LC6hh0caKFxIhPToaCFWCjX0YXKdxuN0985JaURxt9bR3S83JDsi+nHwF24e0PYNWbpJon0GZcYpNNt8uFQ0xlRXeojqDiqc1sxsDx43jPWc3mwBywzPc+mOt91tUVzkmITEyiVjphd8fje+ebvMftdvHz9q5fPAuDR2s9KmleaOKlQfXBw4KWJcJzDU+A1bdApVGLugmNgmmn2JDFdZ6LvdfF9wKnXefnwDmv03TQDkwdsFl+Tp00AzYQB+zB9RvhtDtQvocYoajb/d9lK4M+vo4Kg6U79+DV6VeLPif8XbjnMTEHrEqt5lzrhP+6kGoVoRJgk32Mj6khymzvCMJoCrOx1ecxy3QeYufqNAoU/7uVd78gNNfGAEhIcsGQQTjj+qsAkO6q7ZkIJaR6BlhTS/ACLMDvwPj2tbdiw9Jl/I6K8D7p0sG1pa5B9CQUsAOWmfjmxnAX3Z1M58ZQNciQkYkUVQcPA+h4xIfb7Ub14WKMmHhmzMaFyEQXs9EIm5t8NmLAGBA0Hz/4JOZcdA02cyY8NovFZ5OqhopKyecAwNjYBJVajbTcHKRkexoixSXzBdgf33gXz581VWwX7aKxsgrL57wl+Tw/gqD7CLAAWXSmJIQgJy5U6KprEZeYEHQ2qxi0SRO38Y2Qst37AAB9Ro1o//u4XWgsr4TT4UBu/6J276ezoGQEe4VC6SW2BuqAZSMIgjhJGpl4MJvFii+eeB5fPP5cwK+V6dxolTZUusei0c1f/HY6xcUs7kLfrgr+4mFKCDQptxtYtxW4/EH+416LfdwM2Bbp3GmXC2D6TKG8Gli/zWsTr30LBdSVfwAbd/o/dqkFyWChGbB52b63U7ECrP8x1tjYhMfHnsFWV7pdLjw68hTs+fXPwI+LWTwOJt7EH3aLlXefagGtzeQ/gXv9YGjwFmABsDHGkWjC5Xa5YGlrC50D1oebNNieGuGgsZIvwLbp9QEvqsrENt1agBUSKgE2Mx0Y2VuPvCwHpj18D7QJCVCq2hdBQBthAZ4cu45Que8Avn/5Db/bsREE9Q3I6pXvJcrQMpKrLiD5Q1zoIqjD6Tn+WHZP1DN5ej36FUX1OGRkgiWUTu3V73yArF75OOnijglFCz6pxYJPZAd5V8NuscIMsuLmkpgcxjL7/liH+tJy6Ko9JV12iwXbVq6WfE1juW8BlpvZaOXUViYkJ/MEWH1dPTuhCQUOmw3rv/iG95i+vgGL738MQPeNIAD40VJSTTaiga6G5Pmn9+z4hSadFKt8CA6V+w8BAMr37Gv3+7hdbjgdDjRWHI/pRfRQQV3je/9Y5/WczWzxitI688Zr8PiKr/j7aIcAW7ZrD7578TV8//Jc7Fy9Fjt/9l1PLo+xXQeN0g474rHx1wPsYy63UvLzw80ab3Hn4U5OtX3fXsG9d0I8MOMicjsjDVg5H+hXCDS3AEaTGufceiNb4SF0pXKdkTQeb/xlF4m+j5nR+M6/zeMu5SI8j2kknP3+UPtYkAqG48xXa9KpvrdTBeGApVTsI3/n/MEDgz6uD+95FIvvf8znonEwPDXhXDx/1lSe0EjjFHRM/xmuANsi4oAFPK7/SDW5tLaaOhS7VjBkEHtbTMw0G1tx/MBh7PwlRLkeHaD5eBV7e9Y502Gob5QdsGEmUuOrLMByCJUA+/B/yM9sxTFo4uIw9MxToVAq2zURcjkc+PPjLwG0L4KgvdAIgsr9BwEAE6642Gub+iZg3EjgonP4j8+6j/y85FxP6eeIiWew5V2xBnXMhGr1VEYmUrQ262C3Wv1vGADHtu1E5YFDGH/Z9A7t55vljfhmucRKuUynxuJmBNhOrOlxhVCbxYrm6hrJbRsYATYlK1P0eX1dPXubVlIAQMHQQfzy9whMTA7+vQEH/9kEgDhw6XjbnZpwAUBzVTV7mzqyYqGBlK6GfM4yevbs8L5oE7aVr78juY3DasULZ0/DijlvB7zflyZfiufP9izAURGorqS0W+SDU9d4W7O388lu827CdfFjDyK3XxFSczzVU/SzFqwbbNM3P/CyF30hj7FdB63KhrrKRsFCoEJSgOWKZanZWeCe2ooKgnvvVx4GPp8DnHcqcOJwYPpEj4u2cMQwTHvoblz7MnFjq4VdubgOWCaT7rw7bsIpV13q9T4WxgFrlxiKqJBJCcRpLoY6zuOczeoV5H8Gh20Brll5MmADF0SPbQvAyitBU+Vx7P/rn3a/Xoi1zQSryQQj55qIunn1zIIht7mapAMWNHYlMgKspa0N8R2obhkz1dPkjWb483C7cWz7rpAJ3R3BRu3jAEwGI9r0Leg7djS7wC4TeiI1vsamIhZBnG7Ph7h3gXhH4WCJ44xTphYDZsyZhYSUZLhc7fsy//TW+5h58kSv7onhhJZi7f3tL5Tt3ovTrrsC2vh43jYnXUl+DhFcl+czkbGpyYCSySNIykjHjDmBd3mMJEamo7CMTGfD7XazF0qhYMsPq1AwZBD+8+Yr7d5Hr3wteuWHxokgE1vYFESAVauif2EaCuxmCxrLK/Hq9KvZcYA70axlmliOnSrelZlbocLF5XKBNzMOswD43JlT8P3Lb8DlcMJusaL3iGEcB2zX+FsFCnfSlChoDBOJEkkp6Hk6IwQOWPp7GBubfG5nbGoOyp2lq6lFa5NnMk7/t+qOlaFH3z7oM7r9cQadAbpo0tbiLYS67E5JYejZX39gn6P7aE/Ph0CRx9iug0Zhh8Wm4AktgHTlQhsnii4lOwvJyZ45bLAO2JwM8rNHJr85VlE+oE0gYmavYaTRIx0XnVRF5Yxp3Hg8sYUaC5N4JynAavhzb270XjBwnbNP/fwdMgs6tth11E+f7mAyYGOZVp4AS36XjV9/D7vVylaIApBcIGLNSxEaXy3GVraRakeZ9tDdGHDyiSHZVySgDnipBqwyHSdS42u3F2A/c36BVc4XYXUn4dGbQn/yKN25m70g6zf2hHbtw+12ew3O4SY+1bO6tP/P9cgqyMfVLz7N26ayBqhtAPr35r+WGn9cLkCt1qDywCGYDIZ2D6qRwNjUjCOCTGAZmc6ALwdfsFAXhlgzhUD5fP4gfD5/kP8NZTodVsYBmxLfuSccFBtjzWkoq8DCOx7EluWrYGjwiFpHNm4G4JloCWnhOGC5KJVK3oJluJtQtun0rPBoMhigjY+HUhW8O6er8OWTpC43FHmroaJN3wK7xYrTr78yJPsLp8BHoS68Esa1dcF9d4T9PaMJdY1zBSVaIeVw2NkIgjFTJ0OpVmHbjz8zr1Mhl4mwUigZB2wY3WDyGNt10CitMFsVsJrNOOYiNe9KhVPSAVtzxBN7k1PUG30eWoO1h4cDAPoGafqk0QDC4WnMMECt5eew0ggCEyPCcfOnubEIYrEv/QrJT5uEh0gYQZCcldGuqgWhSze7d5CKNIdJtwKnz/C9DW0e5gpSgH11+tWYc9E17T20kMN1VVOB/cimLXhqwrlstQUANFWJzzXo3N4dgSZcAHHAJqQFNrb7corSWKC7F70XkuOKBNt//AVAbOXbdzUiNb52ewFWhyIccZ+HZhQhI8WJHPFKw3bx2/GzsPj+x/HSZFKSUbpzd+h2HmYayz3Bz399ugTN1TXod+IYr+DrkkqgfyH/tWVMZMmRMkCpUcHa2oZnTzs/zEfcMV44exoW3v5AtA9DRiZoQpkDazOZUbx5W4cEWJmui9FKRMWUpM4t6tG8VrvFs7BZc+Qovn72Zd7E12oyw9DYhB9emSu6H1OLQVII414gJ6Smim7TUd66+ia8d+OdvMcOb9iM3AF9oaSTw86cF9FODqzbACC2BFiAOEyzC3uhR98+0T4Un9DGLPS7UPzvVpRs39nubMbOQlIGsQSa9B5BiTrInTYblEolRpxzFmbMmYXz77kdphYDzK2tAMD+TRUKJgM2hI1yZLouGthgtipgajFgh8vTmV7qvF1z5ChmX3gVaopLkF3YC3YkYV//j7DnMDDtLODBGwN/b9p/KYGvtWLux3wxMykjnRVJaVNnDWeBkSvAJqVJj3VSDljqoPzp7fmoLy1Hem4P3PzOawH/Hux+4vi/SGIHxt3fNgJ1fqqQ2+uAbSir4DWLjDbcKhluVKBw8VaqKdW4Sy8kNyLkgE3OykTh8CFQKpU+BVaVRoPXd/2DKfd7rpEufPheAICltQ1VBw95veaWd1+PWbOYQgFYmPGmIxEMMrFBtxdgP7znEWxYugzrLDcDAEaGSPS2OrX4tuQSAIC+tg5PnHS2z7yuWMDBRBy8f9Pd+HbWq+zjLocTnz/2LJIy0vDYD19ixDlnsc+VVAL9BIuMXxNTAL5cRTJyIhmdICPT3WhlLooSQxTM3lBeiZw+vf1vKNPtWFV9KQ65zsNPm8IjKEYK6vTmNs4Sw+1yYdbEC7F91S+S2xjqxWMI7ljoyd4M1wX98QOHUbpzD++x2qPHkJqdxS6idLcIAoBMrpx2B+vGipUGm588PBMAyVf0xcSbr0fvUcMlnw93pq3ZSEQWbmSDRqtFskQWcldg+Nmn47pXSN6lodGjvFBxxcGoR9oEIjz1HjEUADlHOB0O5PQlY6aSdcDKAqyMb7TxSigVTpjMQPPxatTA85339flpLK9ES10Dm03eXFWD0uPAgD7A2zOBtACHG1pYmcBJl5t0K/B/r/EbWuX0LmRFUo8A6xE7uWOMmAPW2EZ+SumUVMisPnKUHWuHn306UrKzAvtFGISNwhJ8iMGhoD1NuGKRhrIK9nZ8srSwR//2QvqOGQUgvK5/LmU790ChUODJVd/g2d9WSG5HDWPcHjYTbyG25nWffYVWTta3WquFSq3G8LNPD9NRt5/da/8AQPRti5EIsHSBX63Vhm2BXya8dHsB9tD6Tfj+5Tew/xhZRRk3tv2d9QCSeypWregIUaOccGJtJaOkobHJa/Cv2LMf3856Fel5uThjxlXs4yUVQK88gFv5Qcciu52sQNFQb9oxWhGjzbhkZDojx5lGeTl9Cv1sGRgN5RVISk+LOfeYTPSpb1JgtetFmG2du2Hhqjffw7s33Cnp6AgGvUQMAW+bEOY0+6PuGMmtTetBGgN1xwgCgJTK0nPYZU89CkC6mVqkqC8th9VkYsU7KS585D48+OVHvncWRreRmZnkca8Dswp7IadPIXoO6h+2940mKUwzlhWvzUMZZ1GDiksOGwmypMJUv5PGsNs0VVahRxHjgFWSuUSkxAiZzkt6GlE+zRY3XE4n7Ai88sjY1ISUbHI+U6pU+Hub57lLzwtsHzQSIEVk2st1u2f3KWQdsfTcIOwJQkkUET2ff5f8NEtMg9UaGpfj4DWbHnHOmT6P32s/gggCsWMJJV1FgG3lXAf5qn6j50AhdJyNVMZ6xd4DAICswgKkZmex1T5CqDs2OTPD6zmFQsGLmsnIz4tYhEKwLJk5C7OnXQmH1cp+/y5+/CGcc+sNeHzFEry0YQ2KThgV5aOUCRZZCWNY/PR8mNwZmHCy9xc1GFq2ArdfSTLg8od0roymXxd+DJvZgjZdi+jzW5f/hA1Ll6FgyCDWgVFSSTJfpcLfVWo1OzhVHy4GAKTn9gj9wcvIdFNoo6D4pI4tHlEaSslquOyClRHSpicX6p19xd1mtqBs1x7/GwaAoZ645bJ798Lb196KbSt/5j2/YekybFm+KiTvFQi1R8n5gHb3dXZDByxAMleFE3AqSkcLt8uF4wcOo3C4bwE22lAHLLer9eePPQsAKBrdtSd6O3/+lSeoNJRXAvA03KNlzWqNhm1W21BW4YkgoA5YOYJAxg8pqUyuqoV+zwJ3thsbm1iBSaVR45PlnucCreSkJtcMwXB+0eMPYsD4kzz3H3uAjRzY+PUyAEDx5u281xw/cBiAd+NDAHjrU0AxlJhyxKD7dtgdbJyB2+UKuokWN5cW6FgEQSCwGbBS2QqdBG5zrUDz6j9+8Am8OOkS/PXpElaIRoQEzFadjnc/f9BA0e3Yhogi10Ap2VmwWTwrAlmFBXh95z/sfWUMGcUcNhsaK0gspNVkAkD+TtMeugdZvUjwc04RMeCk5eYgtUcOFEoleg4aEJ0DlgmI2PmERZmaI0dRZ++NEQM6ftGUnAhoFJaouy2CZf2X3+Cp8edIdjoEyCCbkJKMrELypS9mYmx2LwfOPcV7e24EwYo5b2PLD6uw/69/vDeUkZFpF80SwfjtpaGcEWD7tk+AnTu/CnPnV4XykGRihBZGbBRmgXdnSrbtAADk9i9C5b4DWDP/Q97zB//eGNEYHn1tHawmM7KZMdrdTQVYk74F+YP5E7OtTPRENKnYewB9Ro9AXGIHcrbDm0CAOkbE535ui//dCmNTM/qMHhHeN48x/vz4C3xw+wM4tmMXAH6cSEY+EYjqS8uR06cQCqWSM+kPnwArj7GhZ9GiRairq8PevXsj9p6paUQwbGsLXrgyNDazt1UaNbi+GaGgKgVNEcjneGKUSiXOuuEajJ06GQDQWFGJpPQ0DGQE2ZJtO/HoyFPQVHmcty92cbYd2ZR3/m8eAHK+oQKs3WpD0eiRQe1H2Dgsf3B4Baj2ZsDGGiZOtECg49K+P/6GvrYONpMnRz9CBlgvk1jfsaNFt6POarGc2OzevdiscwCskEkZdMrJHT3MiEDF5SRm4eO531bi+d9XYuLN1+P/ln0uO2PbQaTGV1mAZXC73SipScCArGoU9Y7z/4Iuir8SgqqDZJWz19DBAIBt+4BHXiUrqSeLjJUqjccB26ZvwdfPvQyb2XfunoyMTOCEWtxprq6ByWDAJU88jFOvvizo169aq8OqtTr/G8p0OlbPW4B1ny/Frl9+i/ahxAw0g1XDTP5oiRglGmVtDpsNKqYcsztmwALk75DTpxBFo0fC1GLA+i+/YfPToklDGVm1zh8yECddNJXNpAuWcJZ7/jRvAZY+8yJKtu3kPV6+ey+KupkA67DaUPzvVtiYvGiuwEQFnsoDh6DWajFg3Fi2OiycDlh5jA09n3zyCS644IKIvmdKCjlHm8zksyJV4i3GoX82sbdVag1P/OoToHGUZr+OHiy9zfevvAnAEwfgsIlfb3KjA9qL026HidmPUq1CvxNP8Mp19YXQARvu7O+uEkFgbGxib2v9OGDn33wP3r72VvY+b8E5Qgpsm8ABO/Gm60W3o43jxMju3QsOm5V3n0tGz7wOHGH4cTKua/p9TMrgO8+nPXQPAKDXsM5ViR0MM+bMwshzz/K/YZBEanyVBVgO2/aRn6edRazcTz09Aj0LgnP6VFR7bq+e90GoDi1mqD16DA67HcOZwdjlIuUlFitwy+XA8/fyt+dGEMjIyISHg/9swr/fSYfRB4PL4cT8m+9FXUkppjxwZ9ANXwb1T8Cg/oGVMcl0LiytbVj52rygJopdHeqioE1JLMZWXgfraGRBVu47iLjERLhcrojlssUaa94nE8OCYT7UhShQtos47NJze+Dal59luzLHEm06PbauWO21uFe2ex9yinojPS83SkcWeeh3mRoH4jkZiXSSfmAdqeoqGjOKjSUI5/deHmNDz/r169Hc3Ox/wxBy8YUkEsXYShbJyvcegMUdmIOU2ziJOv0oEycA91znfx/xjF5ZVAAM7iu+zeEN/+LYjt3sfakFfxNHgKXxN8HidDjYTHXa9GvA+BMB8Jt+SaESZMCm5mSHtZdBVxFgqw4ewY9vkKBef9f7Jdt2onLfAd5jdqbHjStCjQe5zbMAICVHPAeWK8Cm5ebw7u/4aS3K93h+jyGnTeC9NpDPW7R44expeO7MC+Cw2djIm6R00oS56TjfuZmS3b7vYqyjVKswZupk3PT2q/43DpJIja+yAMth7c/EmdBnYA+cf34eXp6xD9985rtbrZDElHhsqx2B1eZH8PtHn4bjMKOK0+GAvrYO2YX81SJjG5CXDbxwHz/QXRZgZWTCz0d3P4JvZ4VuIKo5chQbvv4eiampyB3QL6jXLpzbHwvnds1GLTIyQtjmPIxTx+1286o8oiFWG5uaEJeUCHcYy6BjnapDR2BpbUOPotjKstbXEoFhDFPi6wux0kkAyOvfj5O7Fzl2r/kddou13a7dzsS+P/8GAFjbSOaelXHAxiUlwWl3oL60nN3WbrHC0NCIjLxcTwZsGMUIeYyNHrfffju2bt2KrVu3IruD4sae/SYcNfTHunWkSePm71ZgsfM7fOT4PqDXVzINWIVOv71HgDuvEnsFgZocqcakVAKP3cLfpnTHbmxYSvJea44cBUBcd1ILehu/+YG9nTdAQs0VgSv4Oe0Or8aYSenpKBg6CK9u/Uu0Q71aq0VaLhGyNYIIAqVSiXGXXBjwsQSLSkMF2M5fZfLXp0uwZv5H+N9dDwf9WjONMIjQYq/NbGZFX4D8nTPzvW3f3IWJngP7I5GJj/lh9ptYPW8BKvcdwPNnTcXO1WuRJuhN88eiz8J09B3H2NQMS2sbWuoboFAQGU/ogKWkZmdF8tAiRhIna5p7DlHHxeHc2//j0/3sj0iNr7IAy8FkI1/WKZeNwDNzLwYAJKcFl9OVmJwAdY9BOKS5MuTHFyvs/fUv5A8ewJsA9DgNuOEJcnsIR69RaTSsVV5GRqbzUMpk3vWTyFeSkZHxdsACpMkXAGz6djlKd+4WfV04MTY2IS4hodvGD1DqS8uRE2MCrNVkgtvt5okJNDdUeDsxXTzMMRxld4HQXFWD2pJjyOqVH5X3jyRLZs7C3CtuZMtz6aJKn9EjYTOb2aayag1ZeNFV1yIjP4+dEHdX53lX58MPP8S4ceMwbtw4NDY2dmhfny4+goHjS3BwH3He7l/3DyxIgwGBZQjUHStjb6vjPOPPH5uBfr2AtBTSk4TL/90CtO0AsjNIBMG2fcB3a4ChAr3h0IZ/8f3LbwAAaopLAHgER9FjKSnF82dNBQDk9usLhULBOyYplJx5pJUZN7f9+DO+fn42ACIs0YawJ06f4vX66199Ac/9thJz927CqEkTec+5nE6cE8bFInrsri5iMlq7YBFqmb91MLCN00J9QD6gQr2DcWSLNQ2m52YAuH3BW8hiYgZamz3l5a3NOuz5fR2v+dj2Vb/gp7cXhOW4Q4nT4YSacX1TB6xG8J07+dLwLUC0B21CfND5ukNOn4B4QbZ0UkY6e/uNPRtxwpRJyOyVj3EXT8XUB+7CubfeEJLjDSeyAMuhrbYSbjdwuup/OF21EABgcgdXvqCEA26Iuxa6ChX7D0Kt1Xp12DvInLeHcgVY2QErI9Mpaa6qQUtdA86746agcrhkZLoTtCttKadMk7oOdvy0Bq4ouGMMDaRDtsvVzQXYstgTYAHg5fMvw7rPlrL3e/Ttw96mDkoASM6MvUaubboWdrLXlbG2mViRFSDfqZb6BiRnpMFutbJRElomSFNXW4eMnnmsgB5OB6xM1yTYjOpD6z05sJc99Sh7+1glkJwE6LcA25fxX3PBGeTn+NEkgsBkAVb+6ft9ao8eC+h4Wpt1aNPpkTugLy596lHM2fYXb0FJDGrk2bXmNxjqGwAAXz31X2z5fiWcDgeS0tPRwjwuzOVMzcnmia69BHEz2378GUkZ6ZKVBB2FHnt3X+ikAmywcWUdgTbiaiyvBABk9yn02oYuGDQyDePOu+0/ADiOXYbyXXt49+P85ODGCumM8xvwCJKauDg0MP8nscjVLz6DO/83D5kBLuJm9MzD7QvewvVzZvEeF0aL3PDaf/H0z8tYcb33qOGhOeAwIguwHPYVA4MEC2xKa3BBvAq3A811Tdjz21+hO7AYg+a/nHDBubzHSyoBu93jgL1j4VuIT06CS3bAysh0Skp37kZajxwMn3hGtA9FRiYmsZktmHPRNVjy1Cz/G0cI6tqLRv5sLNFQViFamhhtdDW1aKzwTJL6jCSThZMvuZDXhTo5I/aEzladTrLcsSvjdrnw2aPPQKFUwg1g58+/8p7XVdcivWeupwlXN//uyYSfst172dvjL5uONxaT26XHPdsMKuK/5lwm6nLUIBJBYLECq9d5nh82xFt8ClSABYDaklLk9euLEy44D4CnUZ0UVCQr27XPa9GiTd+CpIw0NkonvSc/e/qBLz+ELyr3kYiGcOXAqtRq1oHZnaGCZnxycD1zOkIr04irTd8Ck8GAHBEBVptAPstr5i+CsakZQ888FYBHMKa01Dfy8mu1icFVPkeLPz/+kr2dmEaqZdRxWpTv3hetQ/JL3zGjAAB5AwIr8aeLLn1H87u8J0p8p2lkUOHwoe09xIghC7ACjpbz76cmBbeypVS4YGhswacPzwzhUcUWuupaAED/cWN5jzscQHG5xwFLXRIOhzxAych0Rr5+7mUAQF85hkBGRpL60nI2igDwlGxGCwMVYLt5GXQ906iGTk5iCV1NHXu796jhKBw+FFe/+DSue+V59nEpAba1WcfmM0aaNn33cMCKUbF3PwAgLSebV8YKAPraWmji4thSSbdbdsB2JpYsWYJNmzZh8ODBqKysxC233OL/RVFGV12L7/47h73/zPuJUAwFjnEEWL1B5IUARg8BEhgBtkkPfPkjefzyh7xL9oWOQV/U3c7wNAAAIABJREFUHj2G/CGDcPzAYQDAgHEn+txe5aOMv02n52U9CvMs/XWqpwuRKZzXqTQaVpjrKCq1Wo7YA2BiPh80YzUStDFN39xuNxrLj7MCrDYhHtqEBIw872zcNn8uAKD+WBlmT/PEQgoFWADQVdewt+NC9PkIN8YmT9PAxLRUKFUqaOLivBpxJWdmRPrQJGmqJMeWki1d3ZORn4ehZxCxXKEiMqVd0EshSeLaSMlsH0u/sxSyACtCZS2nBExrDSjHhqKEE3ZH15/0lO3eK1ouc6gUoJE+dPInO2BlZDonNMvy5IunBfyal96sxEtvxm4JjIxMuKHijFrb/kYAHYEKsN2d0u272NvquNiKUdHV1LK3T7zwAjZ6YNhZp7GPJ0lMItRabdQm/m06PeKTkzrU5KKzIiw1trS2sbepMYGK/a4wOmDlMTb0XHfddcjPz4dWq0VhYSEWL14c7UMKCBqBAwBZhQUA+A5Yq0QPyKunAGOGEQEWAPaTPltQK8RfsOOnNSjZvtPv8fz9+VKo1CqkZJFz18AJJ/GeV2u1mPHaf9H/pDEAPDmqYlF1xAErLrQMOX2C6ONcjE1kHD71msvYjPb7P1+I2Vv+8PvaQFCqVV0m/7Uj0GZwpiCE+o7CXQBrKK9gIwieWbscs7f8gZM5zdecDjvrjJQ6ztZmT/M3bSeJIGjlCLBKlQopWUTU5DYoA4AhZ5wS0ePyxdGtOwD4Frnv+/QD3DZ/LhRKJeKTiBuZK+6fcuWlGHfxVNHX3r7gLQCAy+WCUt2+6JFIja+yACvCviOeC6c4RSvGXxZ4iLESTtjtXV+Abalr8OoaCABlnIUXh50M5F2hQ6SMTHdl3x9/Iy4pkXUqZBUWILVHjuT2v//dgt//bonU4cnIxBx0cpCUEZ1VeGODLMACxCHyxePPAQCyC3tF+Wj46DkCrDYhHidOv4D3vNvtlnRxqDRq9voq0lDnUbjKeqNBcmYGzr/71oC2fe2S6/D6pdcDAF6ZcjnmXnEjAI+jmU4U3WHMhZTH2K6L0Fntj/hkT3OabKbJELNuDgDIzQbGDpN+/U9M/MC8z4EFS4FtruuZ/fLLyb988gXMv+kev8fTWHEcDpud7REyYNyJvMWazIKeGDNlEu75eD4AQMWIJKICrE7vdZ6hmbJUaBFj8QOPY/uqX1gH7ClXXIIb55JqrlCWJss9TggbvvoO82++B/v/XB+x96RNuAaMG4vWZh3S83KhiY9jPy+0aSIAdrHSzJjGLK3e5rE2vUeAjeskEQTGxmbe/VQmE9ZhtbHjNICY6uFBIzt8xSul5mQDIM51GjWg1mrZ66ErnnscRaNHwmGTvgZSKpXIyPPtkJciUuOrLMCKsM+Tu49cxWGcds3lAb1OrVFBoXB3CwdsS10D0kREmA++9tx2MEurTjkjR0am07LvD3KFnp6XC7VWiyd//BpPrPxKcvvRI5IwekTksqBkZGINOjmIVoan1WSC2+1GgqBzbHekoZzEEMRaMy6uexIATpzGF2BtZjOKThiJ3iO91RNNXBwctuhcV9HPdlfKgR182gR20uePupJSNhOzTd/CNupqrqqG0+FAbv++AMIb/yGPsV2X2RdehRfPuzjg7Vt1HuGICrAAUHAW8PIH5LawEReXz1aQnyYzcM8swAbyuRo4/iTpF/khPjmJzULWxMchi2m4o01I4Amqabk57MK+mJBpajEQByynuVOan++prqYW+/9cjyUzZ/FKtIedeRpvu1AsIKnU6m7fgItSss2/OzqU7PnV0zkuNScbSqUSWb0K2Me4oj8V6t65/jZ8O+tV0QaJtKkXAMQldRIBtokvwGYxefd2qxXNVdXs45GMhvCHillASc6SNifQRaiMnrm8CBJh5Aj33CcGrQgIlkiNr7IAK8I7XwAHjgI//03uZwc4h4pPIKsMju7ggK1vQHxykteJ6rjH1MGWL8srhDIynZdmprQys6An1HFaKFUqxCUmSq6qvv1SX7z9Ut9IHqKMTEyx7vOlaKw4jt2/+mkvHUYi2ZE4lqEdgdNFKnZihdKdu5EgmCRZ20wYNGEcHlyyiPccFSx8uT/CiccB2/lzYBUKBfIG9MPoyeewj7U3L9jS2oY/F3+BgiGDAEB0kh8q5DG262IxtkJfVx/w9nvW/oEPbrsfxqZmnsu/uh6orOVvG8iQ0FxFsjA7EjGyedlK3v0ctjz8B9z32UL28QHjTvRkwIpEqrTp9EhMS+Ud9+DTxuO8O2/mNU3iQsuwAb4LEuA7AfOZ72lHUGlkB2y0qC/1NOw5smkLAH7kE3cxwsF8tupLy/HvdytE98d1wP668OOQHmu4EAqwE668BABgt1ix/stvyW2rFYmpsZOBr9So4Xa7kZKVJbkNFVZ7jxiG6f93P/u4sAlfak42fpg9F9t/WiO6H+5nIBgiNb7KAqwIx2uB4dOB95aQ+70yjSgY6v9kHZ9Avvx2e9cP329hLhCELlhu6YvVRAY/GqIsIyPT+aBZhdzVRzJxlSeAMjJiNB+vxuxpV8JQ3xDtQ+n2WNtM0NfW4ce570X7UCR578a7vB7jZjv2HOjpGExFBGfUHbCdX4B9YuVSPLrscww/+3T2MVri3B52rfmNvd3dG+DJRI7izdvQWF6J8ZdfhFGcxQQ9J+oyJ9MjwL62yPN4j759ePuyWcgkriONC5uZa0aTgTQ7yu5NBFiu69TSZkL/cWP9ZsCq1GpeJucJUyZhyn13SDpPhcYArlA7cPxJaKwkAbncrO32olSpZAE2irx97a14+5pb2IZvmb0KWFGSq00EUoVLFw1enX411n/xtZ+tYwO6wNBS14Dmqhq22ZzdasX2H3/GY2NOh0lviKkmpCqVigiwIk24krMyoFSp2CZpUx+8m/d8Rj6Zg9KMW6VSiX+WfIevn3nJa18Om63dDthIIStjPihmFljSUYExUyb73LbXsMG45DGSj2OzdX0Blq7QpudJu0poiV1qdmClXTIyMrFHS209XC4XO/hR8gd33EEgIyMTHla99T62/LAq2ocRE7w46RL89cmX0T4ML54/eypenERcK0KBmNs0hOYpAh6XT/QyYBkBtgtkwOYU9YaSI7huXbEatcUl7d5f/bFyuJxOWXyViTi6WpJB/J+5L7P5rZy+QijkXL4ZOeknT6xcil7D/p+98w6L4ur++JctNEF6kSIgoGID7CXRV41iSTQxGjEa62tMe42JJppoYi8xRZNoNDG2RI0lmkTysyuJ0VhAEUVAOix9abt0WLi/P5YddtmlI7vA+TzPedi5c2fmzGV2zs6Zc8/pAUCeIkDh2IxrxpTyvKp8yAKhPgrzJBoj0dKiouE+yFcpBYG6Q1XxssfQpHoGgCLCtaFT//OVClKad7HjqrA3NT2PgbExfCeOA18gkKcgoBonWkMUFg7R4whkJcmd6jZdnbkXl8r/34Y4YDPjE7G87zCIE5KejrJPiV3z3sDXsxfh0dW/YOUoT/VRXlV5r1JWgSKpFEY65IDl8QVglZWcs1gBXyjE+r/OYfqnK1Fe9RJI38iQW19SWMjldFXcX67t/wmA6sub9Nh4AIAkMwvW5IBtu8QnA4wBHkUnMXrB7DoTM/d/fgJ8/f4DACguKq21X3tBUhXZoykPrALF20+CINouFTIZpJliFQdseWkpHHt6alErgiDqIvDAEZz4dLO21SDqoCA7F3lVjpOalYvLSqqXlSNg+VURXtrKAauITmlqBOzUlcswedmb9XfUAld/PNys7StkMhTnF1D6D6LVufjdj9zngVPkFcKvB1ev7+qgmoIgJaP6s62bC2zdXLD17jU4dPdA5M07OP5J021Hbqo8jYG+kSGykpK5CvXKJIc/gbWzEwa/JC9yrclJpnjZY6KUb1oxnbqygZGnBdnVRc3M7WzB48uLfjX1/jXslZcwZ/sGePuNAY+KcOkEZcXFkGSKYe3iBEFV6gzlmQzt+X8Ufz8Ukgwx0mPiITQ0AADIlH5LFEml6GRhBitnJ2y5cw123Vy1pKkcnoCPyooKmFpaqthJRTG+IdNe0Jj+JDc1ncslDQAh5y/j/3buUeunmHUmFWfBuU8vnS6oRg7YOpDJ5AaLVyh/Y9b/eb9a+7LKSuhB/iZMFNH0N+htBWlmFgBgyLQp4FV9cRQkZ8i/VBmx8fj7p19wvY2E8xMEoZnc1HSVFASSzCx4Dh1Ua5VugiAIouEoHJsKCpTyu3XprpyCQP5woq3ippWyChTnF8ChR+NfwHUyN8PIOTMxZtFcnUxh0Jy8lwoqZLKnmv+VIDShiOwEqnOulioFyXftUu2AZQzoOQlYcvZdAPKifiZKuVP1wJqVY1qRtgoAspJEsO7qpBYxH/nPLQDAgBfkxQc1OckKqkJ4lQN9FMV7GlrZPafKGQwAPZ8Zxm1nYtG0366GpvLoYuuuzuALBKjQkLuWaH2ykpJh09VZ5R5+9cefcGnvAZSXtP+guIy4eO6z8vkKDQzgPsAX/939BQyMjTBq3qutqpeiKCUAOPf2gptvP1RWVIAvFOCZ2a/g2dmvVK2tdsYKNXy340MeovuwwVw+/JqzTNb9ZzLW/WcyFxwYFxwCM1sbjJg1vYXPqOUgB2w9/Pgr0ElQBFF4JEbNnQWjOpIZlxfJE+6Ud4AiXLKyMkgyxHDr7w2fCc+prEsRyx2y/MpCnP38G8qDRxBtnOyUVHTxdIdh1dvEuHsPYOXkgOWnf1arHv3x5kR8vDlR024IgiAIDTy4cAV/7tiNnbMWQZIpRsSNW9w6V+++XOSWIsJHWxGwgHxqcL/n/sPpBACzP1uPtw/vUSmCUxPlXI5NceC2NDWdTC1RLfrs59/g9OYvmr2fuiAbS9RE2emv7Ewdv0j+d/EMVQdsQREglsin/wsNDVWm0vcYMbRZukgyqp/5shJFMLe3w4Z/Lqj0KZJK8ffPx2HYSe7Q1OSAVUwn7j26OkezImVBQ7N8hF68yn126tUDbr79AKDJwQOK+66plaXcAduOoyvbElmJIli7OIMvFCA58gkKcnIR/vcNXNy9T9uqtQoZsUoO2DJVByxQnetZ+WXu06bfuNH48Pdj6Dt2FABg2fEDcO7txX1nXly5DC+ueg8AwFOqFcTXV30RmvokGg8vB0JoaFDr74b87BzkZ+fg759+gaysDP+e/A0ZcQlw8e7daL1by742yAHr5+eHyMhIREdHY+XKlWrr582bh8zMTISEhCAkJASLFi1qcUW1RWwSYG8D/LNvL2xcnDH+jYUa+432iMAS0wUAgI6SEuaLl+cAALoPHazSnieTV6pzcjBU24YgiLbHzeOnYWTWGdNWrwAgN4jfzF4MY7POGLdkgUrfW0H5uBWUr2k3BEEQhAZYZSUCDxyBKCwcG8ZOweNr11XWKx48+JwDVjs5YAFws5pcffpybf0njUe3/j5Y9edJFcesMgZVzhYAcNQBB6xEnKXa0AKpA0LOXcKtk781ez91QTaWqIs+o5/lCstd/reqzROYNFL+WeG8lFWFyBrVePEQeulas46v7JSM/PeOSp5l5T7K9zhNjkxZaSly09Jh7yF3GiWFRXDrarvH1CQzQe5IURQXU9CYCHyvkSPw5aNbmPC/JXCuypdrZmdblQOWHLC6gDhJBFMrSxh37ozoW8FYO2oSEh480rZarYai5k597a354lOR+9mlXx+VduMagYxCQwP4vb24etnAQEXvQ+99zOXmtXFxrtNOp0XFYuWAUchLz0ByeCScevVstN6tZV/rdcDyeDzs3r0bEydORK9evTBr1ix4eXmp9Ttx4gR8fX3h6+uL/fv3a9hT2ySmKh9zuegOou8Ew61/P439etmnwkBPXpGuoEhjl3ZHkUSKBxeuwHPoQJX2QLYcDypfRnrnSVrSjCCIliTp4WNc2rMfvUc/y7WlREbh9q9/YMi0KSpRT8MGmWLYoOZHEhEEQXRUCvMkKssu/eSRHAIt54AFgOCz51BRLoPXs8O4tuKCArDKShiadKq16rKBcgSsDuQQV3YMndn8RbMKD7UmZGOJuijMk2Di0jfU2v2qAkkVDli+UB5NaqLkjNz31vv4afnqZuuQGBqG8Os3kfokRuP6ClkF4kMecsu1OTKzEpOVPou4zzw+D/+e/A0rvEdgRb/hWOE9AqfWb8OvG7arbJ8SEYXdC95CYmiYSruBsZFKkZ/a0NPTw393yyPax70+H33GyKP5LB27gCfkUwSsjpARm8B97uj/Ez29artWUqjqgBUIhbByap3iVMX5BQDA1Q/JSUnT2M/GpSsGvjCRWxbo60NU9bIl5u49ZIuSIcnIRHlJKWxcuso7NSAEXvQ4EuZ2tnXOytFEa9nXeh2wgwcPRkxMDOLj41FeXo7jx49j6tSpT10xXSG26n7v0VVuUBy6e3KJjn0mPIfnXp8PACguk/8onvwG8PtVTXtqn0TfvQdzO1tMXPoGl+MnNjID1ypXIPbhEy1rRxBES3Hl+4NICgsHIP/xCcind/GFAnQb4MP127LaBVtWu2hFR4IgiPZCdnIq/j1xBlJxFhdFosgBK9NSDlgAKC0sQk5qGsYsmsu1STLESHoktw818z0qUBTEKJJI0W/caJVCKdpAMZ0ZkM/yaCuQjSXqIvjsedi4doWrTz906e7BtQ+v+pmm8F3oG8lfiHRWyrHaUhGd3y18G4feXQVZaSkqKzRPC1Vur81pJk6srkpfkFtdUEtPTw+ysjKwykowxsAqK3H71z9w65R69HlccAhKC9UjBBsSBdunavp0TSwdHSgFgQ4helwdHa2t/Oi6QmpUNPe5pMoJqszwmS/BsWd32Lh2fSrHH7NoLt7Y9y2KpfIoUsXzYU5KKgB5ugBlHHt6qkS8Cg30kZuWjl9Wb8TJddsAyHO+ZomSYe3i1GA9ksMjAQDug/o3Sv/Wsq/1/vpxdHSESFT91ik5ORmOjure85dffhmhoaE4deoUnJw0D9DixYsRFBSEoKAgWFtba+yja8RW3fvduwKJDx+DLxRwIc2vfb4RE/+3hCtCVcqMcO5voCN99yOv/4tiaT6eWzwPU1e9B+feXoi4fhMAEHb1ej1bEwTRVmCM4fjqjQDkD+AAkBD6CKVFRZix7iOuOAJBEATRfLZMfBmnN30OWVkZvCeMBaAcAau9FAQAuN95TlVTcvkCATfNt1Mt+RUVEbCJD8MgNDCA17PDW0HT2lF2wBJEW+fSHvns0/TYOAiEQvzv5++x4vTPuHZbvt67ajau0FB+D1F8H129+3IvdloKWVkZ55wsV6oGFn07GABQkCN3wigKdlVWaC5cJ06q9j8U5uaprGtoGgIAKClUn5rakEJc+oaao2QNjI0gNDAkB6yOkJ+Vzc0a6aiF0U6u3YJ/T5xRyedcMwJWnCiCpZMjXt26FqsCTnAvRVuSycvehOfQgVyeZeU6IfnZOfj+9aUqM3zM7O1U9BQaGqK8tBTBZ88hW6QUAZ+UDOuuzg3WIyUiCgAwdvG8Jp/L06RFXj8HBATA1dUV3t7euHz5Mg4fPqyx3759+zBo0CAMGjQIWVlZGvvoGtICICsX+HCR/EcjALUfjY49umtDNZ0gLyMTa0aMR4VMhgGT/fDOT3thaKoI3W7/xcgIoiOREZeA7VNn4coPhwDIK2IHB5yH0NAAs7eu06puBEEQ7RFRWAT4fD74QqFOFOECgL8P/wKgOr8bXyBAaZE8DVetEbBVOWD/b+ceAICTl3Z/OytXzCaIts7F737E8r7DkB4dp9L+wlvAp99WL49/47/obGNdHQFrY4WJS5c8Nb2UXxbd+OVXrOg3HAXZ8mjWJzfvyFfUMqVYOQVBkUSqsk6goVp6bZRV3ZuU6WRZfwRsZaVmxzAA6BsZUg5YHSI9Vn7dd9QI2DtnAnB60+cqbQ8vBQKoTmmUHB4J5949Ye/RDQDgNsC7xfVIjZKnHek3fjTXZmhqAgDIjE9EWlQspEr51119+sJBKVJfaKCv8QVzVqII1s6O0Gtgrvay4mLE3w+t9feItqnXAZuSkgJn52qPs5OTE1JSUlT65OTkoKxqsH788UcMGDCghdXULiERgLUF0Fkgf/vm2FP+o7G0SP5G7dk5r8DMzhZ6aH4C/7bKgf99iKOr1kGgr88lfycIov2REZegYhzPbPoC/x4/A1efflqfUkoQBNHeCL/+L/R4PFg42FenINByBGxeRibys3Pg3EdeE4IvEKCsuMoBWzW119W7L6auXAZDE7njVRFxJxVnQZwogr3n06/I7ObbDy9/8iEX7Wpub8dNveQLBAi9eBWBB448dT0IorXIjK+u4J2fnYOiYuCn36vXM+ihx4gh0Dc2QnZyCrKSkuHq3VfDnloG5XtVZUUFmJKz9czmL/DDkmXIiEvQuK1i2jKgyQHb8BcopRoiYE1ridRXhmlIn6DQQ2hogIqOUnW7DaB48aDH67i+mJpE3bqLD3yfwcZxU7F+zAtICguHRRd7Lj2Am2/LO2CzRXIfofsAX67NyMRE5flQkiHmPns9U51LHpC/GNX0glmcmASBvj74QoHKPaQuom7dhZmtjU6+bK33aTkoKAienp5wdXWFUCiEv78/zp49q9LH3t6e+zxlyhRERETU3E2bZs3X8r8jBvBQVlKCHsMHo2vfXtzb/gHPT4CptZUWNdQ+kTdu4f7/XURuWjq8x4/RtjoEQbQiyRFPoG9kCNunlFOIIAiio6KYhmfl5MhFfelClI8oLIJLycUT8LnfxEOmvQAen4/BLz2PkXNm4rnXFwAA9KscsKVFxUiLjkWXVnDAvvTRcgx/5SUu4ufdX/ZjVcAJ6PF44An4ECeK8OeO3U9dD4JoLWRlZQg5fxk5qWkwtbLEoBefR5pYtY/7QF/oGxkiMz4RZzZ/8ZT1kd+r4u+HIu7+A5V1FTIZnvx7p9ZtlSPllB2woZeu4caxXxusQ0mRugO2IdOZNQUVFOTIo3eF+vqUgkCHyIiNBwCY2rSNFJetRaWsAuUlpZCKs5AcLq/NY9RZPlPZzVdzYfnmoOnFyKtb18J9oC+Xskj5e10TvkAAWWmpWvuTf++isqKiUWkTFClOzO1sVdotuthr6t6q1OuAraiowDvvvIOLFy8iIiICJ0+eRHh4ONavX48XXngBALB06VKEhYXhwYMHWLp0KebPn/+09W5VQiKAklJgaL9KbBg7BbKycvhOGg/jzqa4f+4yvpmzWNsq6gzhf9/UtgoEQbQyKRFyo+7YqweWrYnHsjXxWtaIIAiifZCdLI8Cs3Z25CI5tFmES4EoLBxdPN1h5eQIvlCAiqpIt659emH8W4s454TXSHnaLoNOxqiQySArLUV6dCysuzpBYGDQKroqKjF3rgqW6D/ZT15ERwfGsbGQjSXq48iHn+KvQ8cAAP4bV6OsHFAElTHoYdDUyejapxfKiksQdesulzfTwqFLi+vCmHwa/9FV6zQWBaoL5chVZQfsT8tXQ1RVFLYhaEpBYOtWf6EdoYb7k6FJJxTm5oGvL+yw+UZ1kZDzlxF16y6C/zinbVV0lpSIJyppNbr26dXiudAFQvXUIIpCXArnqUQsVusDAOlVTnRNv2/y0jOQFh3bqNQjuWkZAKrtPyDPSbvm0m94cdV7GrdpLfvaoPmi58+fR48ePeDh4YEtW7YAANauXYuAgAAAwMcff4w+ffrAx8cHY8aMwZMnT56exlqgvBwIDgOG+QDF0nzEBN9Hv+f+A4G+PlIjnyAxNAzihKT6d9QBOP/tD9pWgSCIViYzPhHlJaVw8uqB0LBChIapV5wlCIIgGo9UnIXyklJYOjkopSDQvuMw7n4oAOCVDR+Dx+erRIONe30BjM06AwBsXJzBFwphYGTMOULSomPB4/Ph0rdXk4/vO2k8RsyaXmefrKroYUXagcgb8opEg196HgDa5BRisrFEQ1BEagLyvMwZ2ep9Hly4AsYYft24HUDj8qo2FGtneWHu8jL1qLb6UL6nKKZNN4W8dLkjJjs5FTtnLUJeRiac+9R/7xEaqjtg9Y2MkJuWAb5AQDlgdYgiiRTfv/4uUp9Ea1sVnaW0sAgPL13jloWGBpj83tvN2mfPZ4fBquo7DgB8oQBFUqnGvor0KNJMzRGwYdfkxdv7jv2PxvWisIhGpR7JTZVHwCo7YGes+wgA8OzsV7Dy7HEMm/GSyjatZV8pYV8D+eceMKgP0Le7PGm4ub0dAKCoyiBEXL/J5YTtyBTX8qUjCKL9UllRgZQnURj+yjTMmu+NsSN1M+k5QRBEWyQ7OaUqBYH84aNCyzlgASDm7j3c/f1PdOvvDcNOndSm49q5uwGQTym0dXOBQSdj7ndybmoaAMDMzgYAMOCFiXDo4dmo48/5bD2mfby8zj7lVVMZFdFusionkMeg/gDQJqcQjx1pRjaWqBdJeib32d7THZnZityY1TkyH16WF+m5+1sADr//Mf49cabF9VBEszU3WjQvI7P+TrXw8HIgjn60Dp+9MBOisHAYGBvBpAFFuGqLgM1NSwePL2iT9w+iY3Pi0y2Iu/cAf//0C/LSMzFqrj9WX6j9e69vZFjn/hZ/9xU+PncKQ6bJZ8UL9PWR+PCxxr6fTfEHAEgy5RGwinyxCu4FnAcARN8J1ri9KDwSPD6/Xp0U5GVkorKyUiXlgL2HG/fZ1s0F0z/9UGWb1rKv5IBtIF8dAkrLgMUz5M5WBXlVBq6B+YA7BOkx8kTYQsOGfUEIgmj7/L5tJwrz8rDhY0+seb/+3FoEQRBEw8gWpcDK2ZGb3qcLEbAAEHjgCHh8PgBVZ2ZM0H2YKBW56dLdHQbGRlyeWMU0yIFTJwMAXt3yKZb/+lOL68ev0s3WVfN047boQFnzvjPZWKJeFNXIAaCLZzdk5sodr4+va04V9/ByIJjS9OSW4vw33wPQnAagMSjSheRn5zRp+/t/XuS+77dO/tagauoCDRGwd84EVDlgeajUUKQUwfqhAAAgAElEQVSLIHSZsuJi7J7/Js5+/g2X/9zSsQssnRxU+nW2tcG24L+w9W4gTK0s693vK+s/xvunDsuL05WV4d6fF2rtm58lD8cXGKhG3OempeMDn2dw7us9GrdLfiyvMeXk1aNefQD5PSM/K1vFAVupYdZLJ/Nqh2tr2VdywDaQrFwgLhno2gXISkrG1udfwRcvz8GTm7e1rZrOoUhDoHjDQRBE+0cUFo4Lu/fBoJORynQPgiAIonlkJafAobsHrF3kDwYyHYiABeRTCiNu3EJlZSXSo2Kr2+MSYGJhjiKJFLLycnTx6KYSAZuTKp8SbGBk1KTjKk8fHrt4Xq39eFX57ZTzPSpXiW+LOWAJoiGUFRfj61cXAZAXo8stqHImMqCkoPVSWPx16CiW9x3WrJcdijR/n03xx+cvzW62TkXSfAj09euNpFNEwMbde4Bz3+zFV6/Mw6l1W5GXlgE9PT2NRboIoq2Q+DCM++zYszv3WaCvj7GLXuOuf6+RIxq0P8ee3WFkagpZWTl+Wb0R68dO4dbFBodwn6ViuQPWxMJCZfuKclmdLzXSqn5jNCZXdW5auuozadWLl9jgEIScuwQAXDHR1oTuHI1AlA44V/3PsxJF3IVAqBJ27W+s6DccOVWFIwiC6Bgo3niaVhU6IQiCIJpPVFWl8GEzXgSgW5GbP775Pj7wHoEHF68iJ0WeWoAvFEKPx4OxWWdkxidizKK5MDA25orqFEskeHT1bxh0Uq1o3KW7R4OOueyX/QDkqRkmvPM6uvbrrbGfIjrX2Kwzlh77EX3GjIJBp064c0Zew4JV0vQ1ov2S9Ki6UJWho/w7oi+owCa/l7DJ76XaNtMpPho8Bl+8/BoA+cuTwty8Zu9TkU92wjuv19lP39AQJQWF2D3/TVzddxgpEVFgjHEBRp0s6k9jQBC6irKfRjmqdORrM/HMqzO45QEvTNC4vaac0Z1trCArKwerrIS06nuSHhOH7xa8xfWRiuU5YPnC6gJgy/sOqzeivCm/e4zNzNBtgC+nq+Ll9eW9B7jc1069yQGr0ySnA0521ctdbIDurlpTR6dhlJOBIDoclbIKSDKzwKOoAIIgiBYj8sZtiMIjAehO9Ksmds5aiF1zlyDs2t9c25OqwlcmlhYq05Cl4ix08XTHlA+Wcm2vbl1b7zGUqzZLxdkAY+hVS4SOwgELAC595Q4oM1trnFq3FUc+/BQhFy438MwIom1j0m0AAMDSuBjF0nyuQI2uU1Zc3OL3vCKJvF7JqLmz1KZeKyM0NEBZSYlau35V5H7XZhQRJAhd4OTaLQAAR6/qCFj9GjNTPAb153K6K1MzhQAgt7nKM0vW/Wcyvn71vyp9KisqcPmHg9j73/81Wt+9i5di+4uvNri/NFMMvoAPc3tbuX48Hh5cuILoO8EoKShEbmo6Ji19A1bOjo3WpTnQU3IjEKUDtlaA4npLvAo8Oa9dnQiCIHSJfHE2xIlJ2laDIAiiXRF79z4AQE9Pd3+6F+bmIT7koUrk3fWjJwEAxuZmKsVqpVV54EbNnQVA7hSx7uqEgVMm4ctHt9SiYxUo2ivKZbiw6wfkpKTBxkVzzjaegI9sDbOxGGMIOX8ZJfkFTThLgmg7fDl9LnLT0iEzlE/hNDdWdyh2NBQRsADQxdO91n5CAwOUl5SqtYcFyqu1R/5zq+WVI4hW5M6ZAAT9cQ5OvXqCJ1DP566YtWLXzVVtW2GNCFhF8S2ZkgM2PzsHZcXq+Z8vfPtDrcW26iL6dhAyYuMb3P/KD4cAyHPaAvLfBMrn96jqZfGA5zVH+T4tdPdXnA4iks+sgmNVFKxQqD1dCIIgdJH5bz7CnIX3ta0GQRBEuyLm7j0AqtP2dJXCPAn3WZopRkZcAgw7GXNFuIDqQhwKHly8An1DQ8xYtwoA8FwtuV0VDthT67ci5u49ZCYkwsa1q8a+fD6fm+7YXliyPBZLllMKNKJhpD6JxrbnZyIjW5770KITOWCLpFLus+/EcWrruw8bDG+/sRAaGqC8VN0BW5QnwZoR4/Hb1q+eqp4E0RqEX78JUytLeAweCB6fj75jRwEAPvB5BuvHvgAAsO6q/pKzZgTs/f+Tp6EzNOnU4GMffHcVflm9samq14vC/neuSo3HFwhQUV7tgP3js53ISUnj8sS3ln3V/V9xOkSyvGYAnO2BOFF1u7WF5v4EQRAdjajY5lW6JQiCINSJCbqHiBu3VIpI6So1q6lH3wmGrdvLKtFkikIcCjLiElFWXMIVxhk24yVc3HMAshoOEMXDXUlVZI44IQnuA/tDT09PLf0Vj89vd5XKycYSjUVWVoYHQcnAZKBUxq9/g3aOcgSs78RxCLv6Nx5cvMq1LfnhawCAKDxSowO25j4Ioi0TfVseibrwm+3IShJxUeGVFRUoLSyCJFMMG1d1B6yiSJeC3DS5o6wxdUCU0xU9DSQKB6ytNYAqB2yNXLLJEU+4ImStZV8pArYRiKrS5TjVKPDt3PBibARBEO2a58db4Pnx9FaKIAiiJSkvKcWPb76Ps9u/1rYqjSYm6D709PRgaFodGZOfpRqZqm9ogOjbQdyyUWdTvLrlU0z5YCk6mZtx7Z5DBgEASgvlldzFCSIYGBvBrGqKoTI8Ph+Vsgo8uHClRc9Hm5CNJZpCVKIeLlSswZdX/6NtVbSOIgesgpmb1uCTy3/gy0e30H3YIK7duVdPyDSkICCI9kSxVIqc1DQIDfQ1puQQJ4pg46I+y0ThgL1z+iy2T52FPIUD1sry6SrcCEryC1BeUorO1lUOWKFQzQGbEhkFWzcXGBgbt5p9pQjYRpBc5YD16QkcDahu7085uAmCIAAAy9+SJzL/81KuljUhCIIgdAGFA7W2CNjAA0cQfPY8wq5dR+/RzwIAyoqK4T1+DAAgLyMT9wIuoOeIoZj64bsAgJICuQM2M0EeEWzj2hV5GZkqx+UJ+CgvKcHRVetwasNnEBoYQKihcEhbgmws0RQKsnMQzhag0vi0tlXROoq8lgr0DQ2hby+PvB+zcC4y4hNh7eQIvlAAF5++2lCRIFqV1CfRsHTQHFGYlSji7LIyihQEoZeuISMuAZ0szAGopiDSBSRiMcyUI2CVctQCQEpEFADAoYcHlr8ln73ztO0rRcA2guKqtDnGVcXhYqvqzDjYakcfgiAIgiAIgtBlom4F4dqBn/HXwaNcW0FO9QPOnzt2QyrOUkmvsPPVRdxnV+++mPLBUry6dS3Xlh4TBwDcNj2GD1E7Ll8gQEVFBSorKlCSX4D8rGzkpKS13IkRRBuhIFv+fTOxpOjpmqlKlHHo4YFiqRQSsRiAvGo6QbR3UiOjVZaDz1ZXmRcnimBqZQlDUxOVPoKqIlzlZWUA5EU4D767Cj9/sOYpa9s4rJ2d0H+yHwxNOmlMQZAS8QQA4OjVA0amJuC3QpEnuqs0kuR0QPHyvKIqxdWkkUA3Z0BPe2oRBEEQbRQ/Pz9ERkYiOjoaK1euVFs/b948ZGZmIiQkBCEhIVi0aJGGvRAEQegO216YiR/fWg4AyElOwf/t+A45qdXOz8qKCuSkpOHPHbs1bp+VlMx9dunXW6VwxvldP6CsKioiPysb4oQkdB8+WG0f7TEHLEE0hfzsHADkgFVwasNn+GnFGpRUpTJR0MnCHHyhkIuSldYoFkgQ7ZGUJzEqyzFB97jPGXEJAKCWnkAxm0Q5T3vYtb+5lz26RvfhQ8AXqjtgpeIsSLOy4eLdBw49PeHq0+epO2HJAdtIbCwB/0mAoQFgWOWIHeoNvPQc0IiibwRBEAQBHo+H3bt3Y+LEiejVqxdmzZoFLy8vtX4nTpyAr68vfH19sX//fi1oShAE0XDECUmI+OffOvtsnjANgQeOqLSlRVdVIFaKUjO3t0NxfkGt+7l+5AQce3aHm28/lXYen6/iuCWIjkq2KAVAdeR4R+f2qd8RevEqDr/3sdq6TmZmXIqTbKUXQQTRXimt8SKiXDHtG0DSwzAAgEu/Pip9FDlgaytUp2uMmDmt1t8ET27eQc9nhnLLNi7qRcdaEnLANpLwWKCTETC4n9wJe+Ic4DtN21oRBEEQbZHBgwcjJiYG8fHxKC8vx/HjxzF16lRtq0UQBKEV9ix8G/veeh8VMhl+/2wn1+45ZCD3WU9Pdc5ZyHl5kS1vv7Eq7XyBgCJgCQLyPMpfvDwHZz//Rtuq6BSpUdFqbZaOXVBSIH/ho8cnVwnR/inMzVNZLlPK116YJ4EkQwx7j24AgHFvLMT2kH8g4BywZa2naBMIOXcJAOAxeAAAaHTAPg68DuPOnbllfSPDp6oT3VUayZj5QGUlMHKg3AGbkgk8iNC2VgRBELrBa29F4bW3orStRpvB0dERIpGIW05OToajo6Nav5dffhmhoaE4deoUnJycWlNFgiCIVqMwT4LIf24BAP45cgIrvEcgPTYetm7VVZiNOpuqbFMslSItJg5Dp7+Itw/tgXMfeXXc9piCgGws0VTSomIhK9NtZ0lrozxd+szmL7jPRRIpzn/7PY59tEEbahFEq5IWFYNtz8/klstLSlTWp8fEYtDUSVh69EdMeHsx+AIBrJzlzyoyHXfA/rJ6I3bOWsSlQDLqbKLW58m/d1BeUorzea/ifN6rnHP5aUEO2EaSJwUePqlywOoDJW0j6pogCKJVSE4tQ3KqbhvjtkZAQABcXV3h7e2Ny5cv4/Dhwxr7LV68GEFBQQgKCoK1tXUra0kQBNHysMpKnNn8BTfdEQDM7dSr3yY+eISS/Hx08XTHpHffANA+HbBkYwmiZTm96XNc2rMfN4+f5nLlVpTLcOWHQ8gWUQoCov3DGIM4MQmy8nIAQFlNB2xVHliXfr25NievHgCg8y91KmQyiMLCEfDlLgCAjUtXtT5lxSV4dO1vFFSa4/8OX0BccMhT1YkcsE3gejAwbjigrw+UVF1zaWLt6kQQBKELvPKiNV55kZx/DSUlJQXOztW5hpycnJCSkqLSJycnB2VVP3B+/PFHDBgwQOO+9u3bh0GDBmHQoEHIysp6ekoTBEG0IrFB91WWNTlgT63fhnWjn8eVfYfRfeggeAweAJ6Aj0pZ+3LAko0liJbl3xNncPG7HwEA6dHyHLk1C/UQREcgJzkVANTsZlqUvEhXbnoG1+Y+yBcAUN5GohHFCYkAgOL8fI3ro28Ho7vhA0x65um7R8kB2wQeKaWLUVxzPi8BQ/21ow+he4SFhWHUqFFN2pYxBnd3eaXBPXv2YM2aNS2pGkE8Vd6cb48359trW402Q1BQEDw9PeHq6gqhUAh/f3+cPXtWpY+9ffV4TpkyBRERlPeG6NiQje14lJeWorzqRZS5vV2t/W6d+g3ZySlYvOcr6BsZoaKdRcCSjSWIp0dajLwIYHuLnG8MZF87LjePnwYAFOTmqrQrXkyUFRVzbYqcqeVlbcMBmxYViwNLP8Tv23ZoXB8fEgpv438xwTtD4/qWRPDUj9AOuXyz+rPCAZuZLReCAIA+ffrU36kBvPnmmy2yH4IgdJOKigq88847uHjxIvh8Pg4cOIDw8HCsX78ewcHBCAgIwNKlSzFlyhTIZDLk5ORg/vz52labILQK2diOh56eHsqKSyDU18dfh4/V2q+0sAg7/Rdi6ZF9sHTs0qEdKQRBNI6M2HgAgKm1lZY10R5kXzsuN46dwv3/u4giiVSlPS0mDqlRMbi0Zz/m79gKQJ6mg8fntalZJo8D/6l1nTghCYC8YOHThhywTSAxtfpzG4m6JloJPp/fZqMt2rLuBNGWOX/+PM6fP6/StnbtWu7zxx9/jI8//ri11SIInaMt26m2rLsu8Mf2ryHJFNf5AKWgSCJF4sMw2Lh2bVMPhwRBaJfUqqnWXTzdtaxJ69OWbVRb1l3XqOl8BQBZaSm+fPk1lTa+sP25EWODnm7uVwWUgqCJxMqd5NDxwm9EI4iPj8eqVavw+PFj5OTk4MCBAzCoKvowefJkhISEIDc3Fzdv3kTfvn1Vtvvwww8RGhqKwsJC8Pl8xMfHY+zYsQAAfX197NixAykpKUhJScGOHTugr6/Pbb9ixQqkpqYiJSUFCxYsUNHp4MGD2LhxI7c8ZcoUhISEQCKRICYmBn5+fnWeU2BgILZs2YI7d+5AIpHg999/h4WFBQDAxcUFjDEsXLgQiYmJuHbtWvMGkCAIgiBqgWws2djm8O+JMw1yvirQNzYGANi5uz4ljQiCaG8kh0cCAO7+9qeWNWkcZF/JvrYWYdf+1rYKbR5ywDaR0Cfyv2Xl2tWDaFlmz54NPz8/uLu7o3v37lizZg18fHxw4MABLFmyBFZWVvj+++9x9uxZFQM0a9YsTJ48Gebm5mpv4FavXo2hQ4fCx8cH3t7eGDx4MJcTx8/PDytWrMC4cePg6emJ5557rlbdBg0ahJ9++gkffPABzM3NMXLkSCQkJNR7TnPnzsXChQvRpUsXyGQyfPPNNyrrR40aBS8vr3oNIUEQBEE0B7KxRGsRdlX+kGjj4lxPT4IgCDmVsgqs6Dcc1/b/pG1VGg3ZV6I1OLTsI6zwHqFtNdo8TBsSFBSkleO2lHj3BDvzLZhzF+3rQtIyEh8fz5YsWcItT5w4kcXExLDvvvuObdiwQaVvZGQkGzlyJLfdggUL1PY1duxYBoDFxMSwiRMncuvGjx/P4uPjGQC2f/9+tnXrVm6dp6cnY4wxd3d3BoAdPHiQbdy4kQFge/fuZV999VWjzikwMFBl/15eXqy0tJTxeDzm4uLCGGPMzc1N62NP0n7EylLArCwFLbKvtm4ntCk0diS6JmRjSVpbJr37JnPx7qN1PVpSyMbqhtDYkeiSkH0laW3pMWIoG/mav9b1aElpLftKEbBNJDQSmPY/QJSmbU2IlkQkEnGfExMT4eDgABcXFyxfvhy5ubmcODs7w8HBQeN2NXFwcEBiYqLafhXrah6zNpydnREbG9vsc9LX14e1tXWDdCeIxpKdI0N2jkzbahAEoYOQjSVak3Nf70FiaJi21WhRyMYSBKEJsq9Ea/Lk5m1c//m4ttVoUVrLvpIDliCUcHaunqrWtWtXpKamQiQSYfPmzbCwsOCkU6dOOH68+qbDGKt1n6mpqXBxcVHbLwCkpaWpHbM2RCIR3N0bnxS+5v7LysqQlZXVIN0JorHM87fFPH9bbatBEIQOQjaWIJoH2ViCIDRB9pUgmkdr2VdywBKEEm+//TYcHR1hYWGB1atX48SJE9i3bx/eeOMNDB48GABgbGyMSZMmwcTEpEH7/OWXX7BmzRpYW1vDysoKn376KY4cOQIAOHnyJObPnw8vLy8YGRmpVD6vyf79+7FgwQKMGTMGenp6cHBwQI8ePeo9/pw5c7j9b9iwAb/++isqKysbpDtBNJb5/raYTw+HBEFogGwsQTQPsrEEQWiC7CtBNI/Wsq/kgCUIJY4dO4ZLly4hLi4OsbGx2LRpE+7du4fFixdj165dyM3NRUxMDObPn9/gfW7atAnBwcF4+PAhHj16hPv372PTpk0AgAsXLmDnzp24du0aYmJi6qziGBQUhAULFmDHjh2QSCT4+++/Vd5K1sbPP/+MQ4cOIT09HYaGhli6dGmDdScIgiCIloJsLEEQBEG0PGRfCaLtoJUkt5S8nETXRDnpeHuRwMBAtmjRIq3rQdJxJPD3Pizw95YpekJ2gsaOpP0I2VgSkuYL2VjdEBo7El0Ssq8kJM2X1rKvFAFLEARBEARBEARBEARBEATxlBBoWwGCIJpHfn6+xvaJEye2siYEQRAE0b4gG0sQBEEQLQ/ZV6IjQg5YgqjCzc1N2yo0CVNT01rXjR49uhU1IQhg0qxwbatAEIQOQjaWIJoP2ViCIGpC9pUgmk9r2VdywBIEQRAtRnExVSclCIIgiKcB2ViCIAiCaHlay75SDliCaCajRo2CSCTSthoEoRO8ucAeby6w17YaBEG0E8jGEkQ1ZGMJgmgpyL4SRDWtZV/JAUsQbZhly5YhLS0NEokE+/fvh76+fq19Fy1ahOjoaOTn5+P8+fPo0qULt87MzAyHDh1CRkYGMjIysHbtWpVtvb29cf36deTl5UEkEmHNmjXcOhcXFzDGkJ+fz4nyeqJj8cpUa7wy1VrbahAEQTSL3r1748KFCxCLxWCM1dvf29sbwcHBKCwsRHBwMLy9vVXWb9u2DVlZWcjKysK2bdsavO2yZcsQGxsLiUSClJQUfPXVV+Dz+S1zkkSbg2wsQRDtAV14hgWAGTNmIDw8HFKpFI8fP8bUqVNb9kSJNkNr2lemDQkKCtLKcUlIWlpGjRrFRCJRqx93/PjxLD09nfXq1YuZm5uzwMBAtnXr1lp1zMjIYL169WJCoZB999137K+//uLWHzhwgJ08eZIZGRkxFxcXFhMTw+bPn8+tf/z4Mdu0aRPj8XisW7duLDU1lb3wwgsMAHNxcWGMMcbn87X+vyDRvgT+3ocF/t6nRfZFdoLGjoREWza2e/fubOHChWzKlCmMyT2wtYpQKGQJCQls2bJlTF9fn/3vf/9jCQkJTCgUMgDs9ddfZ5GRkczR0ZE5ODiwx48fsyVLljRo227dujEzMzMGgFlYWLCrV6+y9957T+v/FxLtCNlY3RAaO5L2IB39GdbBwYGVlpayCRMmMABs0qRJrLCwkNnY2Gj9f0PS+tKK9lU7J0iGi6SlZefOnSwpKYlJJBIWHBzMnnnmGW4dj8djH330EYuJiWFSqZQFBwczJycnBoD16tWLXbp0iWVnZ7P09HT20Ucf1XkcQ0NDdvDgQZaTk8MeP37MVqxYoWK8Vq5cyR3n8ePH7MUXX2SA/CErOzub9elT/cW2sbFhhYWFzNrautHne/ToUbZ582ZuecyYMSwtLU1j388//5zt2rWLW+7SpQtjjLFu3boxAEwsFrOBAwdy6z/66CN2/fp1brmwsJB5eXlxyydPnmSrVq1iADlgSVSFHg51Q2jsSFpaOpqNVYi7u3u9Dthx48ax5ORklbbExETm5+fHALCbN2+yxYsXc+sWLlzIbt261aBtlcXS0pJdvnyZ7d69W+vXA4l2hGysbgiNHUlLSkezr7ryDDt48GCWkZGhcrzMzEw2dOhQrV8TJK0vrWVfKQUB0W4ICgqCj48PLC0tcezYMZw6dQoGBgYAgPfffx+zZs3CpEmT0LlzZyxcuBBFRUUwMTHBlStXcOHCBTg4OMDDwwNXr16t8zhr166Fu7s73N3d4efnh3nz5qmsj42NxbPPPgszMzOsX78eR44cgb29PcrLy3H8+HHMmTOH6ztr1ixcvXoVWVlZasdxdnZGbm4unJ2dNerRu3dvhIaGcsuhoaGwt7eHpaWlxv56enpqn/v06VPreuV1O3fuxNy5cyEQCNC9e3cMGzYMV65cUdl/YmIiRCIRDhw4ACsrK406EARBEG2TjmZjG0Pv3r3x8OFDlbaHDx+id+/e3Pqa9lp5XV3bKs5DIpEgOzsb3t7e+P7775utM0EQBKEbdDT7qivPsMHBwYiIiMALL7wAHo+HqVOnorS0VM0mE0RLoxUPM705JHnakpOTw/r168cAsMjISDZlyhS1Pv7+/uz+/fuN2m9sbKxKZMrixYvrnL4REhLCHXvw4MEsMTGRWxcUFMRmzJjRpPOLiYlR0UMgEDDGGHNxcVHrO3bsWCYWi1nfvn2ZoaEh27t3L6uoqGD+/v4MAPv555/Z6dOnmYmJCXN3d2cxMTGspKSE237YsGEsOjqalZeXM8YYW7duHbeuU6dObMCAAYzP5zNbW1t26tQpduHCBa3//0m0IxSdoxtCY0fytKW921iFNCQCds2aNeyXX35RaTty5Ahbu3YtA8BkMhnr0aMHt87Dw4PbZ33bKouHhwfbsGEDs7Oz0/r/n0Q7QjZWN4TGjuRpSnu3r7ryDAvIZ6Tk5+ez8vJyVlhYyCZNmqT1/z+JdqS17Kte1YdWJzMzE4mJic3ej7W1tcY3L0TjaetjaWdnB2trawiFQgAAn89HVFQU8vPz4evri4iICJSUlKhsY29vD2NjY8TFxTX4OP3790d4eDi3r86dO8PV1ZV7W2ZlZQVHR0fweDxOj8TERG5se/fujaSkJJSXl6Nnz54IDQ1tUIGPmvTq1QtpaWnIzc3ljuPr64uQkBBUVFSo9bexsYGdnR34fD4yMjJgb2+PmJgYFBQUgM/no2vXrujcuTNkMhlyc3NhaWmJsLAw8Pl89OvXD0lJScjOzoZQKIS7uzuys7MhFovVjiMQCODj44P79++jsrKy0edVk7Z+XeoSbW0sXVxcYGtrq2012iRkY3WPtj6WHc3GKjAwMEDfvn0RHBxcax87Ozt07twZ0dHRXJuHhwfy8/ORkZEBHx8fREdHo7CwEABgbGyMHj16ICQkpN5ta2JhYQFLS0vExsY2+ZyUaevXpS7R1saSbGzTaQkb29auF12mrY9lR7OvuvIMa2pqCnd3d0RFRaGoqAjGxsbw8PBAdHQ0iouLG31eNWnr16Uu0dbGsj77qnVvc3OE3kDSWAJgzzzzDMvIyGB9+vRhenp6DJC/PRw7diwD6n57eO/evUYdKy4uTuWt3X//+1/u7WHXrl1ZSUkJi4iIYDwejwHyt4eLFi3i+q9atYr9+OOPbNOmTWzfvn1NPuejR4+yTZs2ccujR4+uNX9OTfH09GQFBQXM3Nxc4/rNmzezY8eOMQBswIABLCcnR2X9u+++ywICAjRua2tryxhjrHPnzh3+utQ1obEkaazQNUNjCXRMG6uQhuaArRlFlJCQoJID9r///S+3bsGCBSo5YOvatqbMnj2bPXjwgK5LHRQaS5LGCF0vNJZAx7SvuvIMu3z5cnbmzBmV9b/99htbvnx5h78udU3a2VhqXQH6Z+iItOWxnDhxIktJSWF2dnZMKBSyTz75hMlkMs54rVixgoWGhjIPDw8GgPXt25dZWloyExMTlpqayt6wW3AAACAASURBVN59912mr6/PTExM2ODBg+s81rZt29hff/3FzM3NmaOjIwsNDeWMl5eXFysuLmYPHz5kPB6PzZ8/n5WXl6sYLycnJ5adnc0SEhLYs88+2+Rz9vPzY2lpaczLy4uZmZmxq1ev1lpB0sDAgPXu3ZsBYM7OziwwMFAl+Xm3bt2YpaUl4/F4bMKECUwsFrNevXoxAMzU1JTl5uayWbNmMT09PWZnZ8f+/fdfbvvBgwez7t27Mz09PWZpacmOHz/Orl27RtelDgqNJUljha4ZGkugY9pYQG47vby8GGOMGRgYMH19fY39hEIhS0hIYEuXLmX6+vrs7bffZgkJCUwoFDIAbMmSJSw8PJw5ODiwLl26sLCwMLZkyZIGbbto0SKuIrOXlxcLCwtjX375JV2XOig0liSNEbpeaCyBjmlfdeUZduTIkUwsFjNvb28GgPn4+LCsrCw2bty4Dn9d6pq0s7HUugL0z9ARactjyePx2P79+5lEImGpqansgw8+YPHx8Zzx4vF4bPXq1SwuLo5JpVJ29+5d5ujoyACw3r17sytXrrCcnByWlpbGVq5cWeexjIyM2OHDh1lubq7GCpKbNm1i5eXlTCwWsy+//JL99ddfKsYLALt8+TKLj4+v8zjOzs4sPz+fOTs719rnvffeY+np6UwikbADBw6oPByGhYWxV199lQFgZmZmLDQ0lBUUFLC0tDS2ZcsW7u0mADZjxgyWkpLCCgsLWUhICBs/frzKcUaPHs3u3r3L8vLyWFpaGvvhhx+YkZERA+RvYOPi4lhBQQFLTU1lhw8fbtH8dG35utQ1obEkaazQNUNjCXRMG+vi4sJqorzPc+fOqVSc9vHxYcHBwayoqIjdu3eP+fj4qOzvs88+Y9nZ2Sw7O5t99tlnKuvq2vbAgQMsPT2dFRQUsPj4eLZ9+3ZmYGBA16UOCo0lSWOErhcaS6Bj2ldAN55hAbC3336bRUdHM6lUymJjY9n7779P16UOSjsbS60r0CxZvHix1nVoL0Jj2XpjuX//frZx40at69kWhK5LGksS7QldMzSWuihkY1tvLEloLEmejtD1QmOpi0L2tfXGkqRjjqXWinARREfFxcUFDx48gK+vLxISErStDkEQBEG0G8jGEgRBEETLQ/aVIJoPT9sKEIQucu7cOeTn56vJRx991Kz9btiwAWFhYfj888/JcBEEQRAdErKxBEEQBNHykH0lCN2GImAJgiAIgiAIgiAIgiAIgiCeEm06AtbPzw+RkZGIjo7GypUrta2O1nBycsK1a9fw+PFjhIWFYenSpQAACwsLXLp0CVFRUbh06RLMzc25bb7++mtER0cjNDQUvr6+XPvcuXMRFRWFqKgozJ07l2vv378/Hj58iOjoaHz99ddce13HaMvweDzcv38fAQEBAABXV1fcvn0b0dHROH78OIRCIQBAX18fx48fR3R0NG7fvg0XFxduH6tWrUJ0dDQiIyMxfvx4rr2267a2Y7RlzMzMcOrUKURERCA8PBxDhw6l67KJLFu2DGFhYXj06BGOHTsGAwMDui6JpwbZ12rIxrYsZF9bDrKxLQfZWKI1IRsrh+xry0M2tmUg+9pykH1VR+uJaJsiPB6PxcTEMDc3NyYUCtmDBw+Yl5eX1vXShtjb2zNfX18GgJmYmLAnT54wLy8v9tlnn3HVEFeuXMm2bdvGALCJEyeyc+fOMQBsyJAh7Pbt2wwAs7CwYLGxsczCwoKZm5uz2NhYZm5uzgCwO3fusCFDhjBAXvl3woQJDECtx2jr8t5777GjR4+ygIAABoCdOHGCzZw5kwFge/bsYW+88QYDwN588022Z88eBoDNnDmTHT9+nAFgXl5eLDs7m23ZsoW5urqymJgYxuPx6rxuaztGW5ZDhw5x1TOFQiEzMzOj67IJ4uDgwOLi4pihoSF3rcybN69J1+WDBw+Yvr5+h74uSeoWsq+qQja2ZaUl7OuDBw/Y4cOH2bffftuh72NkY1tGyMaStKaQja0Wsq8tL/QM2zJC9rVlhOyrRtG6Ak2SoUOHsgsXLnDLq1atYqtWrdK6Xrogv//+O3vuuedYZGQks7e3Z4DcwEVGRjIAbO/evczf35/rr+jn7+/P9u7dy7Ur+tnb27OIiAiuXblfbcdoy+Lo6MiuXLnCRo8ezRkvsVjM+Hy+2rV34cIFNnToUDZv3jx248YNJhaLuesxODiYqxKp6FfXdVvbMRQyZswYFhERwQoLC9m1a9dY165daz2HYcOGsTt37jCpVMpCQ0PZiBEjuHWjRo1iFRUVLD8/n5O5c+eqbD9z5kwWHh7OCgoKWExMDHvmmWcYIL/5BQUFsZycHJaTk8MuX75c64/Gzp07s7i4OLV2ui4bLw4ODiwpKYlZWFgwPp/PAgIC2Pjx4+u9LgEwPp+vcl0q3ydb4rokaX9C9rVuIRvbdGmKfQXAFixYwMrKylSux4MHD7KNGze2yH1MKBSyU6dOsfj4eMYYY6NGjarzPCwsLNiZM2dYQUEBS0hIYLNmzVJZP2vWLJaQkMAKCgrYb7/9xiwsLLh1PXv2ZFevXmV5eXksOjqavfjii9w6FxcXxhhTsc9r1qzRqAPZ2JYTsrEkrSlkY2sXsq/Nk/b+DAuAWVtbs6NHj7K8vDyWk5PDjhw5wq07ePAgKy0tVbGhPB5P7RiffPIJY4yxsWPHatSB7GvLCdlXdWmzKQgcHR0hEom45eTkZDg6OmpRI93AxcUFvr6+uHPnDuzs7JCeng4ASE9Ph52dHYDax66u9uTkZLV2ALUeoy2zc+dOfPjhh6isrAQAWFlZIS8vDxUVFQBUz195zBhjkEgksLKygqOjIwoLC7l91jfGdR1DocOZM2fwySefwNLSEsHBwThx4oRG/S0sLBAQEIDPP/8c5ubm2L59OwICAlSmMKSmpsLU1JSTn376iVv33HPP4bPPPsOCBQtgamqKkSNHIi4ujttu+vTpsLS0hLW1Nc6ePYvjx49r1MPNzQ1isRgHDx7E/fv3sW/fPhgbG9N12QRSU1PxxRdfICkpCWlpaZBIJLh3716DrsuKigqV67IxY1zfdUm0T8i+1g7Z2ObRVPtaWVkJmUz2VO9jN27cwJw5c5CWllbveezevRtlZWWws7PD7NmzsWfPHvTq1QsA0KtXL3z//fd47bXXYGdnh6KiInz33XcAAD6fjz/++AN//vknLC0t8frrr+PIkSPw9PRU2b+5uTlnnzdt2qRRB7KxLQfZWKI1IRurGbKvzacjPMOeOXMG6enp6Nq1K2xtbfHFF1+o7GP79u0qz7iKsVDQrVs3zJgxA6mpqbWOI9nXloPsqzpt1gFLqNOpUyecPn0ay5YtQ35+vtp6xthT16E1jtEYGGN48803ERUVBalUig0bNqBbt264efMmJBIJTpw4oZIP5JtvvsG4ceNw+fJlbN68GQYGBir7WrJkCa5fvw4vLy/s2rULAODh4YG9e/di2LBhcHNzQ2xsLLeNhYUF/vzzT7z22mvYunVrk2+i06ZNw+PHj/Hrr7+itLQU69atg7e3N3r06KHWd/jw4UhPT8evv/6KyspKHD16FGKxGNOmTWvQsdavX48NGzbgzp07YIwhNTWVM1ISiQSJiYkAAD09PVRUVMDDw0PjfgQCAfr37489e/agf//+KCwsxKpVq9T6dcTrsrGYm5tj6tSpcHNzg4ODAzp16oQJEyZoWy2C6FCQjVWnMTZ28uTJsLKywokTJ3D27FkMHDgQ9vb2KvuaM2cOPD09kZubiy5dugAAevbsib1798LQ0BAJCQlYvHgxt42FhQXGjx+Pn3/+GVu3boWpqWmTzqO8vBxff/01bt68yf1Yrw1jY2O8/PLL+OSTT1BYWIibN2/i7NmzeO211wAAs2fPRkBAAP755x8UFhbik08+wbRp02BiYoKePXvCwcEBO3bsQGVlJQIDA3Hz5k1u28ZANrblIBtLENqF7Ks69Ayr/gw7btw4ODs744MPPoBUKoVMJsODBw8apc/u3buxcuVKlJWV1dqH7GvLQfZVnTbrgE1JSYGzszO37OTkhJSUFC1qpF0EAgFOnz6No0eP4rfffgMAZGRkcA839vb2yMzMBFD72NXV7uTkpNZe1zF0CT8/PwwYMABDhw7Fhx9+iB9++AFz5syBs7Mz+vTpg1mzZgEARo8ejUWLFqGkpARSqRQ+Pj4YM2YMvv76a+7N2/PPP4/XX38dN27cwCuvvILS0lKUlpbijTfewO3bt5GTkwNzc3OkpKSgU6dO8Pf3x/r16/HXX38hLi4OL774osYxzs7OhqurK2bPnq3SrqB3794IDQ3llouKihAbG4vevXtrPGc9PT215T59+nDLtra2SE9PR1xcHL766isYGxsDkCduHzhwIGxsbBAdHQ2RSIRvv/0WhoaGKvvLzc1FSUkJvv32W2zZskWjDsnJyUhOTsbdu3cBAL/++iv69+9P12UTeO655xAfH4+srCzIZDKcOXMGI0aMgLm5Ofh8PgDV81ceMz6fDzMzM2RnZzd6jLOzs2s9BtF+IfuqDtnY2mmojX311VcxcuRIGBsbo6ioCFZWVrh27ZrKPeb555/HjRs30K9fP5iammLGjBmIjIzEW2+9BZlMBlNTU6xbt44bR39/f6SkpGDcuHGIi4vDyJEjOb1q3sdCQ0Mxa9asZl/P3bt3h0wmQ3R0NNcWGhrK2eOa9jouLg5lZWXo3r27xv3VtM8AkJiYCJFIhAMHDsDKykrjdmRjWw6ysURrQjZWFbKvtUPPsKo2cujQoXjy5AkOHz6MrKws3L17V8XuA8Bbb72F7OxsBAcHqwUfTZ8+HaWlpTh//nyd4072teUg+6pOm3XABgUFwdPTE66urhAKhfD398fZs2e1rZbW2L9/PyIiIrBjxw6u7ezZs5g3bx4AYN68efjjjz+4dkUVviFDhkAikSA9PR0XL17E+PHjYW5uDnNzc4wfPx4XL15Eeno6pFIphgwZAkBezU95X5qOoUts374d+fn5CA8PR1hYGC5duoT4+HhIpVKcP3+eq1Q4e/Zs7Nq1C/b29nBzc8P06dOhp6eH1atXIzAwEACwbds2vPzyyzhx4gQCAwMhEom481c8TALycXFzc8Mff/wBsVgMDw8PfPvtt3B2dq71uv3tt98gk8kAqI+liYkJJBKJynlJJBKN0T63bt2Cg4MD/P39IRAIMHfuXLi7u3NO1sjISPj4+KBLly4YM2YMBgwYgK+++gqAfNqDvr4+pk+fjmeffRY+Pj7w9fXFmjVrVI5hYWEBMzMzvPPOOwgJCdE47hkZGRCJRNxD59ixYxEeHk7XZRNISkrC0KFDYWRkBKB6LAMDAzF9+nQA6mOpOP/p06erXJf+/v7Q19eHq6srPD09cffu3Trvp7Udg2i/kH1Vh2xs7TTUxhYXF+PLL7+Eo6Mj/P39ceXKFVhYWODOnTvcPUYsFuP06dMQiUQICwvDzJkzAQCDBg1CXl4egOr7GI/Hw5UrV2Bra4tbt25h165dsLKyqvU+tmXLFvzyyy/NHkcTExNIpVKVNmV7XJe9fvLkCTIzM/HBBx9AIBBg3LhxGDVqFGefs7KyMHDgQLi4uGDAgAEwNTXF0aNHNepBNrblIBtLtCZkY1Uh+1o79Ayr+gzr5OQEPz8/BAYGwt7eHl9++SX++OMP7kXlN998A09PT9ja2uKTTz7BoUOHMHz4cE6PLVu24N1336133Mm+thxkXzWj9US0TZWJEyeyJ0+esJiYGPbxxx9rXR9tyYgRIxhjjIWGhrKQkBAWEhLCJk6cyCwtLdmVK1dYVFQUu3z5skoRiF27drGYmBj28OFDNmDAAK59wYIFLDo6mkVHR7P58+dz7QMGDGCPHj1iMTEx7Ntvv+Xa6zqGLghjjLm7u3PL//zzD5s3bx63vHHjRrZv3z4GyCsQvvXWW9y6UaNGseLiYjZ8+HDm5ubGGGMsISGBnTx5kunr67ODBw+yrVu3spMnT7L09HQmlUqZm5sbt/29e/dYTk4Oi4yMZBMmTGCjRo1iIpGo1uvWzc2N3blzh0VHR3PHUKzbuXMn2717t8q5PXz4kE2bNk3jeY8cOZLdvXuXZWdns2PHjrGLFy/WWshjyJAhXIJrc3NzxhhTKco1bdo0dv/+fY3b6unpsaysLGZjY6Nxvbe3NwsKCmKhof/f3pnHSVFee/9XS3fPDNsgyDo4IEEEFxYDuCEqqKg34npdrsGowURNVBKDyI3iHuRiriQazCvGXXBBkosrMaioKOLCPsDATFiGgQGEYZill6rz/lHL9FJd3dNd1duc7+dzYLrWp5566jnnOXXqPGto8eLFVFpayu0yRXnggQeooqKC1q1bRy+99BJ5vd64bcbn89Ebb7xBlZWVtHLlyoh2OWPGDNq6davZLo3lqbRLlsIV1q+twjo2vqSqY8eNG0dLliyh2tpauvLKK2nlypVERPTuu++afcxLL71EGzZsoMrKStq2bRutWrXKPO6MGTOovr6e9u/fb/Zj48aNo3379qXdj+3cudN2Eq7hw4dTY2NjxLLf/OY39H//938EaJPI/O53v4tYf/jwYRo5ciQBoJNOOok++eQT2r9/P33wwQf08ssv0/z58y3P1bNnTyIi6tixo+V61rHOCetYlkwK61hNWL/GFx7Dxo5hn3zyyZjJsdauXUuXXHKJ5bHmzZtHc+bMIQA0Z84cuu+++8x11dXVcSfhAli/OimsX2Mk6wVgYXFN2qK85s+fT48//ri5rqSkhAKBAJWXl1sey5iBGQBNnjyZPvvss4hzh68HYCqvVK5jypQp9Pnnn0eUrbGxkQYPHpxwX0mSaPv27XT++edbrh89ejQdOHDA/L1jxw766U9/av6+7LLL4jpgJUmipqYmGj58eNbvNQsLCwtLZqVQdGy4JHLAlpSUkN/vpx/96EfmshdffJH+8Ic/EAB69NFHI2ZlHjBgAPn9/rhO1C+++IJuueUWy3U9evQgIqLOnTtn/V6zsLCwsGROCkW/OjmGvemmm2jbtm0R26xZsyauA/Yvf/kLPfHEEwSAvv/+e9q3bx/V1tZSbW0thUIhOnDgAE2bNi3r95qlfUnepiBgGKdZsGABbrzxRgwbNgxerxePPfYYVq5caU46ZcfevXtRVlYWkQzdSRYvXowTTzwRl19+OXw+H+6//36sXbsWmzdvttx++PDhkGUZnTp1wpw5c7Bz504sXboUAHD22WfjmGOOAaB9yjFr1qyIkPznn38ev/71r3H00UejtLQUU6dOxTvvvANAy+MyfPhwiKKITp064Y9//CMOHjyIiooKV66bYRiGKQxyWccCgNfrNSctCf87mqamJrz99tt46KGHUFJSgtNPPx2TJk3Cyy+/DAB49dVX8ZOf/ARnnnkmSkpK8NBDD+Htt9/GkSNHAAAnnXQSfD4fiouL8dvf/ha9e/fGCy+8AAAYPXo0jjvuOAiCgKOOOgp/+tOf8PHHH8ekPGAYhmEYg1zWr06OYRcvXoyuXbti8uTJEEURV1xxBcrKyvDFF18AAK644gp06NABgiDgvPPOw/XXX29+jj5+/HiceOKJGD58OIYPH47du3fjF7/4BZ5++mlXrpth4sEOWIbR+de//oX77rsPixYtQm1tLQYOHIhrrrkmqX2XLVuGDRs2YM+ePdi3b19K51+/fj2uu+46y3X79+/HFVdcgUcffRQHDx7EmDFjIso2b948zJs3z/w9bdo07N+/Hzt37kTv3r1x2WWXmetGjBiBFStWoLGxEStWrMC6detwxx13mOsffvhhrFq1Clu2bEFFRQW+//57PProowC0mQwXLFiA+vp6bNu2DQMHDsTEiRPh9/tTumaGYRimfZDLOhYANm/ejJaWFpSVlWHp0qVoaWlBeXk5AODee+/Fe++9Z2572223obi4GHV1dViwYAFuvfVWbNy4EQCwceNG/PKXv8Srr76Kuro6dOrUCbfddpu5709/+lPU1tairq4O48ePx3nnnWfOxnzsscfigw8+QENDA9avXw+/329OssIwDMMwVuSyfnVyDHvw4EFccskluPvuu1FfX4/p06dj0qRJOHDgAADgzjvvRE1NDQ4dOoT/+Z//wZQpU/Dpp58CAH744Qfs3bvXFEVRcPDgQTQ2NqZ0zQyTKgK0UFiGYRiGYRiGYRiGYRiGYRjGYTgClmEYhmEYhmEYhmEYhmEYxiXYAcswDMMwDMMwDMMwDMMwDOMS7IBlGIZhGIZhGIZhGIZhGIZxCXbAMgzDMAzDMAzDMAzDMAzDuAQ7YBmGYRiGYRiGYRiGYRiGYVyCHbAMk2Oce+65qKioQGNjI5YtW4Zjjjkm7rbV1dVoampCQ0MDGhoa8OGHH0asf/jhh7Fr1y4cOnQIH3/8MYYOHWqu83q9eO6551BfX4/a2lpMnTo1Yt+rrroKGzduxOHDh7FhwwZMmjTJ2QtlGIZhmAzi8Xjw5ptvorq6GkSEcePG2W5/++23Y9WqVWhpacHzzz8fsW7MmDFYunQpDhw4gLq6Orzxxhvo1auXuf7uu+/GunXrcPjwYVRVVeHuu++O2L+8vBzLli1DY2MjKioqMH78eOculGEYhmEyTFvGsABwxx13oKqqCkeOHMHGjRsxaNAgAMC4ceOgKIo5vm1oaMDkyZPN/ex0MwAUFxfj6aefxr59+3Do0CF8+umnzl4ow6QJsbCwOC+SJLV5n27dutGhQ4foyiuvJJ/PR7Nnz6Yvv/wy7vbV1dU0fvx4y3VXXXUV1dTU0IABA0gURXrsscfo22+/Ndc/9thjtHz5ciotLaXjjz+eamtr6YILLiAA1KdPH/L7/TRx4kQCQBdddBE1NjbS0UcfnfV6ZWFhYWFhSUXHejweuvPOO+mMM86g3bt307hx42y3v+yyy2jSpEn0l7/8hZ5//vmIdRMnTqQrr7ySOnXqRMXFxfTcc8/R+++/b67/3e9+RyNGjCBJkui4446jf//733T11Veb61esWEFPPPEEFRUV0eWXX04HDx6k7t27Z71eWVhYWFjat2RiDHvzzTfTmjVraMiQIQSAjj32WOratSsBoHHjxtHOnTvj7munmwHQyy+/TAsWLKDu3buTKIo0cuTIrNcpC0uYZL0ALCwZlaeeeormzJkTsewf//gH3XXXXQSAevfuTW+99RbV1dVRVVUV/frXvza3GzVqFK1YsYIOHjxIu3fvpj//+c/k8XjM9UREt912G23ZsoWqqqraXLYpU6bQF198Yf4uKSmhpqYmGjx4sOX2dg7YadOm0euvv27+Hjp0KDU3N5u/a2pq6LzzzjN/P/TQQ7RgwQICQKNHj6a9e/dGHK+uro5OPfXUrN8/FhYWFpbclVzWseGyc+fOhA5YQx5++GHLQV64jBgxgg4fPhx3/dy5c+lPf/oTAaBBgwZRS0sLdezY0Vy/fPly+sUvfpH1+8fCwsLCkpuSy/q1LWNYQRBox44ddO6551oeK5ED1hAr3Tx48GCqr6+nTp06Zf1+sbBYCacgYNodL774Iq699loIggAA6NatGyZMmIDXXnsNgiBgyZIlWLNmDfr27Yvx48fjrrvuwvnnnw8AUBQFU6dORffu3XHaaadh/PjxuO222yKOf+mll2LMmDERn/uHs2bNGlx77bWW60444QSsWbPG/N3U1IRt27bhhBNOiHs9r776Kurq6vDhhx/i5JNPNpcvXLgQAwcOxKBBgyDLMm644QZ88MEHAIDS0lL06dMn4lxr1qwxz/PNN9+goqICP/nJTyCKIiZNmgS/34+1a9fGLQfDMAzD5LKOdZOzzjoLGzZsiLt+7Nix5voTTjjB/OzSIFwHMwzDMEw0uaxf2zKGLSsrQ79+/XDiiSdix44dqKqqwgMPPGBeFwD06NEDe/bsQVVVFf74xz+ipKQkqToaPXo0tm/fjgcffBD79u3D2rVrcfnllye1L8Nkiqx7gVlYMi0bN26kCRMmEAC6/fbb6d133yVAi/zcvn17xLbTp0+nv/3tb5bHufPOO+ntt982fxMRnXPOOSmXa/78+fSHP/whYtnnn39ON9xwg+X2p59+OhUVFVFxcTFNnz6damtrqUuXLgRon1o++eSTREQUDAapqqqK+vfvTwCorKyMiIh8Pp95rAkTJlB1dbX5+6abbqKGhgYKBoPU2NhIF110UdbvGwsLCwtL7kuu6thwcTIC9qSTTqIDBw7QmWeeabn+gQceoNWrV5PX6yUAdP3118d8mvnII48kjLJlYWFhYWnfkqv6tS1j2NNOO42IiN555x3q0qULlZeX0+bNm+nnP/85AaCePXvSkCFDSBAE6t+/P3366af0zDPPxBzHSjffe++9REQ0c+ZM8ng8dNZZZ1FDQwMdf/zxWb93LCwAR8Ay7ZQXX3wR119/PQDg+uuvx8svvwxAmxSjT58+OHjwoCkzZsxAz549AQCDBg3CkiVLUFtbi/r6ejz22GPo3r17xLF37tyZcrmOHDmCzp07Ryzr3LkzGhoaLLdfsWIFWlpa0NzcjFmzZuHQoUMYO3YsAOD+++/HqFGjUFZWhqKiIjz44INYtmwZiouLzaib8HOFn2f8+PGYPXs2zj77bHi9XowbNw7z58/HsGHDUr42hmEYpn2QqzrWDQYOHIj3338fd955Jz7//POY9bfffjsmT56Miy++GIFAAEDbdT3DMAzDALmrX9ui15qbmwEAs2fPRn19PbZv346//vWvuOiiiwAAe/fuRUVFBYgI//73vzFt2jRcccUVSZWjubkZgUAAjzzyCILBIJYvX46PP/7YjARmmGzDDlimXfLKK69g0qRJOPnkkzFkyBD8/e9/B6ApnurqanTt2tWUzp074+KLLwYAzJs3D5s2bcKgQYPQpUsXzJgxI+JzCQAgopTLtWHDhggnZ0lJCQYOHGj7WWP0uY3yDB8+UsAwTgAAIABJREFUHK+//jpqamqgKApefPFFdO3aFUOHDsWhQ4ewe/fuiHMNGzbMPM/w4cOxfPlyfPvttyAifPPNN1i5ciUmTJiQ8rUxDMMw7YNc1bFOc8wxx+Cjjz7Cww8/jFdeeSVm/Y033ojp06dj/PjxqKmpMZdv2LABxx57LDp27GguC9fBDMMwDGNFrurXtoxhN2/eDL/fH3E+u3MTEUQxObeVVbq8XLIbGIYdsEy7pKamBqtWrcLLL7+MRYsWoaWlBQDw9ddfo6GhAdOmTUNRURFEUcQJJ5yAH//4xwCATp064fDhwzhy5AgGDx6MW2+91dFyLV68GCeeeCIuv/xy+Hw+3H///Vi7di02b94cs22/fv1w+umnw+PxwOfz4e6770b37t3xxRdfAABWrVqFq666Cj169IAgCLj++uvh8XiwdetWAMBLL72E3//+9ygtLcXgwYMxZcoUvPDCC+a+Y8eONRXp8OHDMXbsWM4ByzAMwyQkV3UsAHi9Xvh8vpi/rZAkCT6fD5IkRfwNAH369MGyZcvw1FNP4a9//WvMvtdddx0ee+wxnHfeeaiuro5YV1lZidWrV2PmzJnw+Xy49NJLcfLJJ2PRokUOXinDMAxTaOSqfm3LGLa5uRmvv/46pk2bho4dO6Jv37645ZZb8M477wAAzj77bBxzzDEAtHyxs2bNwj/+8Q9zfzvdvHz5cuzYsQP33nsvJEnC6aefjnPOOQcffviho9fLMOmQ9TwILCzZkP/6r/8iIqKzzz47Ynnv3r3ptddeo9raWvrhhx/oyy+/pPHjxxMAGjt2LFVUVFBDQwMtX76cHnzwQfrss8/MfYmIBg4caHve9evX03XXXRd3/fjx46miooKampro448/pvLycnPdvHnzaN68eQSAhg4dSmvWrKEjR47Q/v376aOPPqJTTjnF3Nbn89FTTz1Fu3fvpvr6evr222/pggsuMNd7vV567rnnqL6+nvbs2UNTp06NKMftt99OlZWVdPjwYdq2bRv95je/yfo9Y2FhYWHJD8lVHVtdXU3RGHr23nvvpffee8/cdubMmTHbzpw5kwDQ/fffT0REDQ0NEWLsW1VVRYFAIGKdob8BUHl5OX388cfU1NREmzZtMuuAhYWFhYXFTnJVvyY7hgVAnTp1ogULFtDhw4dpx44ddN9995nrpk6dSrt27aLGxkbasWMHzZ07lzp27Giut9PNgDZGXrFiBR05coQ2bNhAl156adbvGQuLIYL+B8O0O8aOHYtXXnkF5eXl2S4KwzAMwxQUrGMZhmEYxnlYvzJM/sIpCJh2iSzLuPPOOzF//vxsF4VhGIZhCgrWsQzDMAzjPKxfGSa/YQcs0+44/vjjcejQIfTu3RtPPvlktovDMAzDMAUD61iGYRiGcR7WrwyT/3AKAoZhGIZhGIZhGIZhGIZhGJdwLAL2ueeew969e7Fu3TqnDskwDMMwDFjHMgzDMIwbsH5lGIZhMoVjDtgXXngBEydOdOpwDMMwDMPosI5lGIZhGOdh/cowDMNkCtmpA3322Wdtmomvrq4O27dvT/u8giBAkmUQCKIogUiFqqrm8lAgCEEUIAgiVFXVtlUVqIoKgCDKMkhRIYgClGAInqIiqEoIgABVVSB7PAgFQzAyNUiyB6oSgijJCLa0wFdSDH9zCwQA3uIiBP0BQAAkSYYSCkEQRSjBIERJAhFp5ycVgiCCiKAEg9p1iCIkSYIoywg0N0OSZYiSiKA/AF9JCULBIAQBIAJEUUQoGITkkaEEQxBF7Viy14tAc7NZN7LXCyICqSqISLteSQZAICIIEEAgCIIIAYCiKBBEEYIgQADMc2jXEIIgClBDCmSvFyACAVCCQcgej/m3IAgQJQmyzwd/YyNkrweAVm4lGITs9UBVtboU9H+IAEEAVEUFqSp8HUrgb2yCp6gIoUAAgiiAVO06REnSr82jr5OgKgokWYaqKFAV7Z4pigJBEKAqCrzFxQgFAwABqqJo91xV9HqXIIqCdm69rozja+1IBKkKiACPz6udQ19u3Aej/kVJgiAI2n0NBSF7tPpX9XOpIQWSx6O1A0mEElIA/bol2dhXq4tQINhadypBVRQIkghSCZIsgfTEIaQq+n1vgSAKWvtUFYAAIoK3uAj+xqawOgvCW1wMJRiEqmr1LXk8eh2rUEMKvMVFCLT4IXtkQBARbGmJeOaMdi5K2nUb9Sp7PXq5qPWe6Pda9sgINLdAlCWQSuZ9JP2ZDAUD5jMhyZLxdANEWjvU768oyxAEAUoopD1TqgpRFAFBMJ9hyaM/e4IIIlWrM0kCBO0aje1EWYIS0tqJIAqQPV6ooRAgClr9e2T9Xip6v6GfS99faz/GM+HR7pPeRrV6lc26UfR2KckSlFBI6070di0I2tWGAtrzBggQBGjlh9YmBUErkyiJEETJrDdSVTORjHE9aigEj8+HYCCg9zdkPs+eIp/e1lWIRp/o8UANhcx6CPoDWjvVr0UUxYhjSZIERdHqX2unXu3ZF7X2K8kSlGAIqqIk35HHoby8HD169Ej7OIVAtnSs5JH1flBrD6qiAIKg9XsgTW/6vFq7kSSoetsy+jZRljR9q3dukiQhFAho/aUotCZB0h+E1udb1PpGj6ZzlZACURIhe7wIBQN6v6vtajybBILs8SLo90OStX5AW66fwnzmBBCp+jLRtAG0PpEgez1mG/YWFyPY0gLJI0NVtGfRU1wE/5FGCJKo9WVEMGwGAZoOJBCUQBCyz6v1rYoC2etD0N+i6Q9ZggDB1CHa80Mg0ibYUFUFpGp1JgjaQx6uK2WvB4HmFvNZNconitpzTaTdr5A/oPfNpOkgWTb7o1AwoNeTAtkjIxQM6X1Uqy2ghkK6jdWas4qIIMsyFCWk96UyQFq9GbaV1i58UFVV748Fs74FAfr9lEw9DUEw9bpxj0RZghIIajqbtGuTPNq9UYJBQAjT4bqu0fS50fcIWjvSdQCRaurWUEDrD42+3CibEgzq5wia12PUmaaHQppO8cha3fq8pr4BtP5ekiSQ/rcgivD4vAgFgrod1qoPBVGE5JEhitozYdiIetE1u4dIb+sqZI8H/qZmSB5Z246AgN8PSX/GtOdPqztFt98kWatTTX9q/blxXFVR4PH5THuJVEXXkwTZo9kfoUBAtyVVs30a5dHsLS8gAEowpNsDut3R1Ky3fc32BEHrP1QVqq6/Zb3f0B5iMtsuBGh1HtT7AVXV7XsynwVAMOsm6PfD4/NCEEUEWvxmWySVIEiieXxSCUooZNpWargeJa0P0q6RIBp9k2EviKKuY7XxgWGPC/pxBFHrE0VJsy9DwZBmG6uq3nYksw8DtfZFqqKYtoKiKLptROY25j4QzGdFkmUEAwGYHWAasI7VaKt+BZzTsbLXC+OeQ7cHjfZojLUMnSVA0J9xmOMQVVVNfeHxav0RQXtODb0Y8ms6V9PHWr+kKgpEUTLPAcBsX6Ztqbc749zaiQHousmwL0kvtFaeMB1LMMcuggBzPCl5tPG58VyRokIlgigIgCiYulHrD/XnXX/OtOdTMq/Z0H2GjWKMx0jXPbJHGxdptoVijq/VUKttro3VVIi6HStKkqljRFEbkxjXZOhhA0NfivrzKun9nMfnQ9Dvbx0b6vdB8ngAkD72CUGA9qwLet9s+BhEWUKwuUXXf6T7NbQxlKLrOEMnaftq9omq20Pm2IUix8+abmm1ddSQ0trvhvkIVEXRfAZm+wgrs14BoiSa/aPRLgGYPgZzjKvbRK32iWFPaMuMNq8oiqYvgyFNJ0gSBFFstRmNflcfsxoPjOyREWjRdKE51tPHlIKg+W78TU2QZM2n0YqmF4x2ZZTK0DdGXbbe65A5NiQyxrASFEXTa4bOM+rF8D8Zul97rrRnSrMzg7qdK4f5agABWntQFEXTRVoD1J5dvZKN/RR97GjY6eH9g3mN+rUZdnW4P0lVFM32MMuAMJtT8xEZzxHp9WX4DlRFbwt61YXfd8Pv1mq7CuY9tXqOIGjPvWH/G0iyB8FAQH9ORP0aFP2+ieaxREHrG2XdftP6AW3MbIxxCdDGILrdbdiQivlb7+tEESHDNkkDO/3qmAM2GaZMmYJbbrkFANDY2IhRo0alfcybn5qDoePOaF0goDWulwB4wjYWw/43722gtRZ8ACgYuR35o2rJD+h92Id/m48Lbvu5th8AqEHAoxmikiCb537wvJ9g5rIlrecL497TzkWguRmPrPgnijt1BAi4b8IFePjzDwEAL0yfjp89Ocs8p0EIAciCFw0NP6BTt6P06/Xj7Sfm4IuFi9CtXxlmvPemtlwCWo404oea3egzeJBVNZrbhTNr0tWY/s7rAIAjjYfQsWspfjviNDyx7ktzm8/feAtnXnslAGDZCy+h//CTcewpwwGlBRtWfo4Txp1pbrvuk09x0vhx8eOuJeDNB2fhqpnTgSIAOAJ4tVX7tu/ErP/4z9Zzk9+sX4VCkEQZEIGl85/D+bfebF7L52/p5dPv4W9HauWvqdgCT5EPPQboBpeodazTThmL404bjV/8v7mt5TTqhQJRbQeR9W8gQC+3prxDiuakfuSiy/D7pYtbt9PL//U772D0pf8RcQi/2gyfWGyWrfKbbzDo1B9b1hkogHef+QtO+Y+J6PWjYyPrVwmgasNqLH3mb/jls3/CkaaD6FjUFZCBQHMLZk+6trVMki5q0LzfADD3ppuxY91GAMBp/3kZrrxvmnlfDJ698zeY8pc/mr8P7KlFt769I57F1x58ENf9YSaaDzeguHOnsLr1Y++uf6Pnsf1jrw/Ah888iwtun4JNX32J4888TVtonD+qzWp1Gv3MhqGXp3rjWgwYcTK+efd9DBh5MrqV9dXalH68Zn8Din1aGbd8/TWOO210xLkO1NWAiNC9XxnmXP1T3L3oZUAE6uv2oUuPo83rggBABtZ+8glOnnA2oCLy/oQd06ifGPRtzL7AXOaPvH7Slu+v2YXux5TpddTa3zQc+gGdio6K3Mc4Tlh9ff72WzjzuisjtmtsqkeH0i4xZQooLfCiKLKfBQCP9qyly6pVq9I+RnvCaR0re714/NtPtR9Gu41+trzQ+saoPsFun6r1qzU9EQ+jPYmA0c7X/GsZhp1/roVOBhQ1pA8cAKgtrf1AdLsEYvuM8PKF2wUe4PM338SZ112F/Xv1Z8pYH2zB/j070b28n/ZbiN5fxwcAmk1BUCFQAM0tYf0fYF1vxrHi6UrdNln14bsYNeni2P4g/NltPoQORVpfXlu1Db0HDdTXB3Dwh73o2qun2VcElBZ4vUURZdpRUYFjThxiXQ4J+O3w0yL1slHmsGu3vMbwZcY+agsgA/t36PUNoHL1Nxg0Jkz3Kc2ACGz57mt06FqKvscfF3mM6L/DfwvAN/98Hz/+yYWo+fcWbd+oNjLr0qsxfcnrOLS/DqU9e7S2QaONSEBIDUKGp/Uaw9tjTP8KQGmJ6av/8ae5uOD2n6PI28G0VQ/t1c9pdSy9fj566QVMuOVn5ouLppbDKOnSWSuT1Hoxj158Of77g7cBajH7Y/M+6fUx92c/x52vzjfL7/c3wVdSgn3bd+JovW03B46g2NextY2Hsae6SrM5ALMeD+8/gM6+bggKfniEUOw1SEDdju2a7aW0xPYn5vb+qH4gPm/Nno0r758GELB2+cf4/v1/4oY/Pha5nz42ePvxObj8v+8OO64/4fEbGw+hg24PWdkWDQfC7XCE2YCBVrsKiH0ORON4WiCGZd9ktQ/8WP3Jv/Dy3b+3L3gSsI5tG07r2BEXnY/rH3+wTfu0vojQiTemDcfoq4DWdma1na4bEn4fa9VW7daFLzP0szfOeoMoGzamTOaz5Y98zsK3D38Ow49J4fsHIn0HEeWMwqIfDL8OVVI155EEQPWD5Mh7VbVxDY4dOUz7QYi9B+a9DAAqUH94P7oc3b11vdG/WOkcKewY4dcavi58Hwmt457wfte4TqMc4ViV2aqewjhSfxAdj+oaW14r9DFt9DnqD9ahS88esdsaqLBvT2ozvli8CGdce0XsOeO1das2YdSpcUvDnqVPXnkNZ//sOnOZIoTZpVbl0m0ZWz0UbetSEJLsCTtWwPrZtiN6G/McNrowui1ZjUGTOZeB1XNkEN2e1ObIeiDE2Meq+fISms0T3UYTtVmLNvzE9ZOxe3OlTUETY6dfHUtBkAzPPvssRo0ahVGjRmH//v2OHDPC+ZphRk262HK5FsXWSoyDLgxvcREAaM5XnfCOauCokZb7aW9MY49tDGq7lfWOWF7UsYO989WCzj2Obi2TYXxGMfyC8ebfg04bHTGoHjL29IhtjzlpaMJzDj7jVMvlxmDACjNiBMBxp4+OWBddBoO+Q45rdb5GHads6PEJy2lgd28NjEiSLmH1Gc6J55wVs8xXUhzx29L5GrF+VOtAKIpjTxmOXgMHAIhsW97iInQ6upvlPuH3u9fA1uOahkMU5iBYp1vf3jHb9NMH8RHOB514zlcAptP1uNPHxN2mrQwYcTIAYMhZp2vO1yjCy3jcaaNj1ncr64vu/TQHQc+wdhTvHp884eyEZeqvlykeZSfEcYJEl61f7PUAybVVABh8Ruz1RjhfwzD6LyY3cFrHunV/bZ2vcbDT9dE61ymG6i8QDWdgON1tdJIVRtSFVf+XKj8afUrCbTrE6csBaM7XMKzud1znq4uE13eE8zWM404bHaN3kqH/sJMAxOosA6OfLI0e7IVh6PR0GDByGIo6dIhYZndOg8FnRtpIJV06W5aptGfkvbWi96CBEb99JSUAIu2tcNs0Giubo3N3zabw+Hwx6wyiba90+dGY1ufg5PPOwTEnnRB323g2tR0d4ti/BsnqVic54ewzE2/EOI7TOrb/8JPavE+E85XJKcIj94DYe9WvDeNLAJHO1zwlwvmaIjHO1xQI1xNuMOSsSH9DuG/CKSQHbI9CxHS+OkjXPr0cP2Y4GXXAFhpFHTsk3giICndPTPgD5i1q2wDY2FfyxAurSZ5kdHx4ByMKkddpfM5v/nbgc6mE5YnqnFo/Z08e4/M0pxFE6wpta/uwItGAUI26F21BCquPeIZfMtdAamr336M7BdK5hng48Zm85E3/WQMSK2s3lLkVYvQbW6bdkkvGnvZpe2ZxSxc4R9sG4q0fmrZjElSZv6nZfoMsk6zzV0zC9pEd0l3ZJtqRbacr7RzD+YQTtguTfTwF8gwyyRFvHMi4j8fn7rOW+/Yi0xbUkLs6lh2waeDrUJLUdnaGsJVDK7yT8CXp5DUwIoHc7mgMxDBDN1qxRDtck3LApumkjTa8U3kr4lrdxXFeRr8xTQU5QZnjGevJvEkPH7DEc7SKyThgKTUHivESglwYcDjxUsCp9pI7Dljn3yQy+YkTkX5OkWr/kQ655IBmnCHRy8JQIP28X26SrAMx5tNHq2MViPOnqFOUA9YmIr5QnM5aLlom35HYadOucCLghkkN2eWXb4WiWxgNt19yOtYTvPbaa/jyyy8xePBg7Ny5EzfddJNTh85ZknWISDYODSvnbHgnUdxGB6zRASRyyCWDlW8q2jkTHmEarVhiIh6TiIBM1yEW7TCILlMyyk/2utNJx3NSGgne0yHRoCydeg1XKvHqL6kI2BTLYHwW60ZnGB2lnQpOKd1E0drJfmad7udp7IDNTbKhY8UMOf2TIRsRXxzRkJh8+xxWEBLpqsxECadab8nadklFwGboRb3bFHWMTJNgd+2F8ky7HZ3T3sjWGJadNu2LZIJVGHdw++uHQvm6gtFwe8zh2Ojquuuuc+pQBYedQ8NqXXhUQlGntuWLM5w0shMpCCz0RHQHExEBK0RHwLbduZVuLr9owzvaSZ6M09y9FARxnJdORMAmMOLSiR4Nj/CMn4Ig8WAy8cDXGm+xlg/XjRQETjhgnYqATeTsSmZA7QSppO1g3CcbOlZ2KbdqKght/NzeCTgCNjG55KRPhkRfnKSqpzJFslGrMbaPRVsuFAdscZQD1s7OKxSHlxv2UHsmW2PYQnkhwCQHR8BmD0+R2xGw/CwXEm5/ZcI9QQawd8DGGorhRnGyeWbNffXZ8ZxwClkNeKNTIoS/zYtRLNEpCJKILEnXcZwoAjaZDtKtQUlcB6wDEUSJ7ne8/KvJODXC6yP+NSTuSlK9TkNppppD1g4nBjHhOWDTiTRO9PIhcykIWC0wGrnkXMvUC4hwcikFgxW5EHyab4OOhF+cZKhSUz1NqhGwVjaCEy/qc4GYFAS2Dtj8aq/x4BywhUGhPIMMk+u4bc8Vyss9RsPteSd4pJ0B7BywVtFm4Q9xWx2wRpSDEx0BWYwQ7GbEjY2Ajdki4TnTNY6jHQbRzqRkIprcyosWzwHphGMt0f2O62hMYhQYbiDGi3QVk4mAlVIbcRr1404KAgdywGZoEq5MpQYQHEiJwRQGuWRQOpGqpeBooxfPDddirjupo0noyM8Fr7YNyT6T0TlgjcksI5YVSASsryRyPgY7Oy+X+rR0UIKcA7YQKJQXAgzT3uH0bYWFqnAEbN5j51ixijAKD5NvuwNWT0HggJFpNQ6J/tQrcnsh6nfi40WTbrmjB4PRHaLxObsdTs1qH42bn54kyj2jqvEm4Up87IgI2DiRrsk47dL9tNONt1GO5IANH8SmEQGbSHlzBCyTaXJpcMjGbW6Sb2kaEqVYEXPcAZv03APeyO2KO8amsyoUZ2Q07SEC1gnbhck+hfoMMgzD5DOcgqAAkG3yjlhN0BX+Nj/6zX7Cc5kRsOkbmVbJwqM/9QonlQmvorGbETSZAXj0Z9zR+xR1SFyfbhnobiZfTzSTajqRnhE5YONEuiaVAzbN63djFnQnomqdSryeyJGRKUeHwI4uRieXBofp5gcvRNrsKnTBuZhvUZQJ7YhMOWBdPk/0s1vUMdb2KZQcsNHYOWClAvnkm1MQFAaJbHeGYRgm87iR9jAcdsBmALsBitVgIJkozXiYKQgcMKytylbUwc4BGxUBG+1wS2LAYfc5dzLOgESTbnk7JK5bj9edRN1uRsAm+gw03iRcyZQpvN7j5oBN4jjJOGltcaEzTCdnq4FTn+AmimzKWARsjk9Cw2QOdnrmOm1MQeCC0y/fnHiJXmS5UUfZQI56MeizsN1y6QWLk9j1W4USAet2dA6TGfIthQvDMAyTPjzSzgB2EXJW+ch8Jak7YA3j0gnDOtwBaziqimxzwEZFwMakJEgmB2z8cicTaZPoun1FWhSInfHq1oAym592x3MzJhNVHF7v8T7PTObepp2CwIVP7hxPQZBGlsVE9yJTM9ILnIKA0eEJQnKcHPAVenyxuUVzmUQOj4JxwEZdp5UDNt+il5PFNgVBgTi8OAK2MCjUlyAMY+D2ZEYM4wZu24I80s4AHpsUBFZOF09R6gMaJyfhiiib7sGznYQrOgI2JQdsfOPYidysRgSsnfHqVoRENg3/eHWfjFNYSiICNpn0ClKajj1XUhA44YANb5dp9NeJIlzT6RfaQqE4IJj0KZRoMcY97OybvCRTGQhc/CIGiH12rV7sF6rzxzYFQYH0aeyALQxYxzKFDsWZg4RhchqXbUF2wGYAuwgRK0PRazFbbbIYn145EdlgmYLAbhKu6BywMQ7YJJx0Nk5KJ2abNwYh9g5YdwYl0Z8EZpJ4jtakImDDHbBxJ+FKIgVBup+2O5AuIOaQDjhgwyPc03FeJvrcO53UJG3BzVzFTH5RqA6awiH7L0ucyoGdK6Stp5JESmLiyrSOHx0Ba+GALTjnuY7V5LYGBRMBG2KnRiHAOpYpdNz4epFh8h0eaWeARBGw0YayNw2jWHYwAjZigjB9nGefgkCIXhDxM5loS7tyO5EawFtkOGDjKwS3BpTZfNNtNagMBYMQkhgEyklNwpWEA1a//6nmLlNdyAHrSASsQ59xJoqATSc1CcOkAueAzW1yIVg933LAJiJjc3C5PNlhbASsxSRcBer8yVS+9GzCEbCFQaG8EGCYeDgR6MIwmYZTEBQAtg5YWYpRwJ40It0Mg9qRCNiw/LRGQyzqaDMJV4KUA8lN+GRtjKiK4ogD01Os3Qs7Z7BrKQiyONixut6QPwDJIgdxNOGTksWfhCtxR2VEVoYCgYTbWuJGBGwOTcJllQ86nExFwDKMQaE6aAqH7HtgCy6KMkMe2LQnpUxAtF6y+rKq0KKXDdrDiyOFHbAFAetYptBxezZ5hnEHdsDmPXafzkuSFOPw8zpgFDuRL9UqOrK4DSkIokkmAjbegEBVlAhHYKp49Tyaok3kp2spCLJoaFlFwAb9/uSc4uERsPFyySbx2aYR8RMKBBNuawXFnUosDRw4pFMRYIkcuemkJmGYVODonBwn+/7XgnPiZSoFi9vnifmyyuIFXqE6fzgClskXCiUnMcPEw4lAF4YpNPLaAZtM/spcwC73pyjLMYay7EBEiRMDZ8kqB6ztJFyJHLCp3y8lpDhiqBgTGdnN9O5eDtgsOmAtrlcJBpO6J3ISk3Al48g1nN5KMDUHrBv+VycO6lR7sctbBwBeTkHAZJhCddAwziF7uI2kgtuTcEXblR6LF3iF+ny3hwhYYgdsQcA595lChx2wTD7CKQhsyBfj0S4dgFUErMcJR6MDUSmiHNs8bFMQJDAk0hlwqIriSFoF43NJO6PHvRQE2XvTbRXxG/QHknTAtpY7fg7YJFIQ6E7gUKoO2ByNgHVicjgg8TPbHqJ6mNyiPTgy8pkcCICFpyg/7LBkcdsxauB2AEFMCgKLF/uFOgN7e9CVnIKAYZi8gB2wTD7CDtj4OOGQywR2jmJRjp2Ey4n0AU5Ei4pSrBFbZJOCQEzghEtnwKGGQpCdTEFgUxa3HPtOpFBIFSsHaSgQSOrte7hjMN4M0clFwGplUFJMQeCGu4GE9A0Dpz4hK7hcikzeky8vOdstOTALV6G1EbejHszzuB5cNHXOAAAS7klEQVQBG2m/GV//hFNo984g0dckhYCa4mSmDMMwDMNkl7x2wDrhqMwEdukAREm2iIB1INLTgWNY5WwttktBkCAPaHopCELOTMKVRad9NqNNrCJCQsFgwomfgKgUBPFywCZxbwXdoZ96BKzzOOB/dSwHIufbZHKNQo2QY5yj4Jx4GXLAJnphnS4xKQgs9FTB3Tud9qBLVYVnFmcYhmEYN3DbFMxrB6xTn/66jW0ErCRBkp2PgHUi36jVZ+u2KQgSTLKVTq4jp1IQ2OXjDQUCaR/f9txZbK/RgzEACPmTi4CNmIQrXgqCJHoq41xqKHc+nXPiy5hCHcQyjFW/weQOmYrWtCObuc3dQMhQYgfXI2CjXq5a3Se5QFOMJPNiOd/hSbgYhskLcsBOYZg2wykI4pMvhr/dJ8qSLMc4cJwwip343N3KiLWLdHRzMKiEFEdSENg57RWXP+nKpqPOKpIt5A9YppmIJtxJGy/KOZkIWGMblVKL3HA7YihV8iUVCsO0lfYQScakR8G1kQypGbdzwMZEwFrYH5nKd5tp2kMOWHbAMgyTD+TCi2KGyTXy2vrKl88jbVMQyFJMri4noo6cqJu2GududrKqojhyTXbHcN0Bm9X0B7HnDoWClmkm7LCKgFUVJanJeoxzpRph5MZg0Yk2yxGwTKHCbTvHyYGBTaG1kWQmlHQC1x2wUS9XC+0+2dEeHLBu26sMwzBOkCmdyjBO4vaLg7x2wGZzUqO2YOdQFSUpxjB2wnh0JAVBGwcI7kbAhhy5Jrv0DkrQ7QjYLOaAtWiDpKptvsdW24cCwaTarLFvqu1EsEiJkS4Enp2TYeKRLy852yu5EFlSaI69TNWp2w7Y6Imo2tOz7Hbd5gKcA5ZhmHygUL+0YAobt9NR5fVT4dTs424TnYsrYp0kxaQcSNcBKwgCZE8WHLAudrJaBKwDOWCzmYLAgXuS8rnjPCuJ8vbGbG8xOA0FA21ywKbap6WTQzgemcr3xzD5COeAZRJRcCkIMqQT2vr1SVuRPJH2W77Yy0xycAqC/CcXXqAxjNu4MXZjmHwnr5+KfMm9aBsBK8sxUZnRkQupnC+ZT8IT0eZO00VjghTVGQesTb0owZCrBlE2UxBYtQdBECwnWrPDysmuBENJtVkjp3DqEbBudFccAcsw8WhPUXP5SC6M3wvNsZepaB03vugIJzq/e+E5yts37IDNf/gFJ9Me4AhYJi/hFATxcWJSpkxgFx0oyrERsOl+PuXUoDmXUhAAzjjc7QweNRSyTVGQLnYTgLmNLFtftxP3OBRILgLW3CaXHLBxJhVjGCa7UftMMmTfA1tojr1MObVdj4CN+vKqPeRFbU+wAzb/yZeJpBkmHdgBy+QjbtuCef1U5Et0TuIUBFE5YNM0zJ3KySbalNtyexc7WUEUHLkuu8hgInK1TVmVP1NGdDzHc7KDQGN/K4etEgrFDO6IYiNL080BK0rO94a5EEHGMLlKvujY9koufMLqxNc2OUWmcsC6HAEbbXem+2UVk1vkwrPPpAfrV6Y9wCkIGCaWvH4q8iUFgZ3hK0pSjHMs3bdFTkWk5FSnKTjkgI26F6oaOZGBm1GqVp9qhgJB184Xce44g+RkI2CNZ83SKU/JRdcYZUg5BYEr0ao8iGGYePAnkrlNLkSWFFobETP0VURb86+3legUBBwBW2CwAzbvyZeJpBmGYdod+ZSC4IILLsCmTZtQWVmJe+65x8lDW5IvKQjsnFySLDv+FtRTUuLIcXJhcGcgCIIzKQiiIzXV1khNQRBc/STIqvxuT/xlkK4D1qgXy0GckFy0tDkgzKEUBDyGYfKFTOtXgCN0cp1c0NG5loKA1DRnh89YBKzbDljJ9jfDMJFkWscWWv5shmGYQsHtr0wcswBFUcTTTz+NCy+8EEOHDsW1116LIUOGOHV4S/JlcGhn+IpybARsuhR1cMYBGx1BkU0EUXSknmKikal1sCaIIjw+95z6lhG8Fp/qu4GUZg5Y4019vO2TywGbg5NwsQeWyQOyoV8B59LZMO4giNnvv3ItsjJdlZqpT7vdvnfR6YXYAVtYcAoCZ8mGjs2XrzgZhmEYZ3HMch49ejS2bt2K6upqAMDChQsxadIkVFRUOHWKGEZcdL5rx3aSDqVd4q47fuzp6Dmg3NHzXf3gvY4cZ+CPhztyHCfo0uNo9Bo4IO3jdO7eLeJ3uFO389HdcdOf/yftc8SjpEvnmGXFnTu5dr5wBowcFrOs14+ORefu3ZPa/1cvPYMNn3yO4k4dY9Z1Ouoo+KKc/laDg5Iu2nMQfQ+SxakXC+GU9urp+DEZxmmyoV8BoIfDuolxllyIPu3Wr2+2ixBBupNbXXzXrQ6VxB5fSQdXj39U3z5R5yt29XwMk89kQ8cec9IJrh2bYRiGSYN8iYDt27cvdu7caf7etWsX+vaNNMynTJmCVatWYdWqVeiepOPHjtotW82//U1N5t/BFn/ax04G4zyJPnkL/8w9mk7dusbs35ZP6FqONEb8DgWD6F7eL+bTdqvJnpoPN9geu0vPHtoxA4G4+4TXdfQ5o68jugxEBCUUQsOBH8xlgeYWy7KoimIeL165iSjiHEoohFAwMseqUcYjPxyMKROpKrr36xtRBrt74W9ujrsuulyhYBD+xqaYdUF/wPLeBP2RbTj6PieLcX9kPQVB48FD5jqPz4cuPY9OeIxQIIguPY7GsPPPRXPDkZj1Sti9MbCuN+05iG4n4WWyurctjdq1R+frBRBzf62wKrPR5rxFvpgyhKNYHL+p/nDk8cPKbDX5WLIkusfR520r4eW0qksDu/4qEca9YpwlGf0KOK9jjX7SCfxNrf2lElLanH7F6jlOl2zMJG7XZ0X3+0F/IM6W+vokbB07ne3E9ScbxRXdf0Vfa8S2h1u3TWxfReue1v4r+vrC7cTo+6AqWpvs1q9vUm3T6t6ElzshKegKq+Mb1xite2J+h9WT0SbCbTtjGzvdEK8M0e0w/FlNto1F6794OjkZ2qLP0z1momfUiramybDSyYGm5OxPJjmyoWMbDx5yNA2ZXZ8KRI6vGg/VO3bedIjW60rQ3bRs0X2eW9j1o4n6tkR2dFvs7LRT8qRAW3wa8cb8yRBtU8T6PVK79kTPUXQbTWSbJjNObSvhZYzWv4ns9kylPgwn3fFrsjjZr6khd8cHGf127Nlnn8Wzzz4LAFi1alXax3vzwVl488FZaR+HYRiGYfIdp3XszHEXpX0MhmEYhikEnNSx65ctx7QRY50oFsMwDJNHOOaArampQb9+/czfZWVlqKmpibt9eXm5IwPE7t27Y//+/Wkfh+G6dBKuS+fgunSOfKvL8nL+BB5ou34FWMfmIlyXzsF16Rxcl86Rb3XJOlYjWzo239pLLsN16Rxcl87Bdekc+VaXifQrOSGSJNG2bduof//+5PF4aPXq1TR06FBHjm0nq1atcv0c7UW4Lrkuc1G4Lrku27tkS78C3Ga4LnNTuC65LnNRuC7zU3gMm//Cdcl1mYvCdcl1aSWORcAqioJf/epX+PDDDyFJEv72t79h48aNTh2eYRiGYdolrF8ZhmEYxh1YxzIMwzCZwtEcsO+//z7ef/99Jw/JMAzDMO0e1q8MwzAM4w6sYxmGYZhMIAF4INuFSJfvvvsu20UoGLgunYPr0jm4Lp2D65JpK9xmnIPr0jm4Lp2D69I5uC6ZtsDtxTm4Lp2D69I5uC6do1DqUoCWi4BhGIZhGIZhGIZhGIZhGIZxGDHbBWAYhmEYhmEYhmEYhmEYhilU8toBe8EFF2DTpk2orKzEPffck+3iZI2ysjIsW7YMGzZswPr163HHHXcAALp27YqlS5diy5YtWLp0KUpLS8195s6di8rKSqxZswYjRowwl0+ePBlbtmzBli1bMHnyZHP5yJEjsXbtWlRWVmLu3Lnmcrtz5DOiKOK7777DkiVLAAD9+/fHV199hcrKSixcuBAejwcA4PV6sXDhQlRWVuKrr75CeXm5eYzp06ejsrISmzZtwvnnn28uj9du450jn+nSpQvefPNNVFRUYOPGjTj11FO5XabIXXfdhfXr12PdunV47bXX4PP5uF0yrsH6tRXWsc7C+tU5WMc6B+tYJpOwjtVg/eo8rGOdgfWrc7B+jYXyUURRpK1bt9KAAQPI4/HQ6tWraciQIVkvVzakV69eNGLECAJAHTt2pM2bN9OQIUPo8ccfp3vuuYcA0D333EOzZs0iAHThhRfSe++9RwBozJgx9NVXXxEA6tq1K23bto26du1KpaWltG3bNiotLSUAtHLlShozZgwBoPfee48mTpxIAOKeI99l6tSp9Oqrr9KSJUsIAL3++ut09dVXEwCaN28e/fKXvyQAdOutt9K8efMIAF199dW0cOFCAkBDhgyh1atXk9frpf79+9PWrVtJFEXbdhvvHPksL7zwAt18880EgDweD3Xp0oXbZQrSp08fqqqqoqKiIrOt3HDDDdwuWVwR1q+RwjrWWWH96pywjnVGWMeyZFJYx7YK61fnhXWsM8L61Rlh/WopWS9ASnLqqafSBx98YP6ePn06TZ8+PevlygX5+9//ThMmTKBNmzZRr169CNAU3KZNmwgAPfPMM3TNNdeY2xvbXXPNNfTMM8+Yy43tevXqRRUVFeby8O3inSOfpW/fvvTRRx/ROeecYyqvffv2kSRJMW3vgw8+oFNPPZUAkCRJtG/fPsv2aGxn127jnSNfpXPnzlRVVRWznNtl26VPnz60Y8cO6tq1K0mSREuWLKHzzz+f2yWLK8L61V5Yx6YurF+dE9axzgnrWJZMCuvY+ML6NT1hHeuMsH51Tli/xkrepiDo27cvdu7caf7etWsX+vbtm8US5Qbl5eUYMWIEVq5ciZ49e2LPnj0AgD179qBnz54A4ted3fJdu3bFLAcQ9xz5zJNPPolp06ZBVVUAQLdu3XDo0CEoigIg8vrD60xRFNTX16Nbt25trmO7c+QrAwYMwL59+/D888/ju+++w7PPPouSkhJulymwe/duzJkzBzt27EBtbS3q6+vx7bffcrtkXIH1a3xYx6YH61fnYB3rHKxjmUzCOtYa1q/pwzrWGVi/Ogfr11jy1gHLxNKhQwcsWrQId911FxoaGmLWE5HrZcjEOdzk4osvRl1dHb777rtsFyXvkWUZI0eOxLx58zBy5Eg0NjZi+vTpMdtxu0xMaWkpJk2ahAEDBqBPnz7o0KEDJk6cmO1iMUy7gnVserB+dRbWsc7BOpZhsgvr1/RhHescrF+dg/VrLHnrgK2pqUG/fv3M32VlZaipqcliibKLLMtYtGgRXn31VSxevBgAsHfvXvTq1QsA0KtXL9TV1QGIX3d2y8vKymKW250jXznjjDNwySWXoLq6GgsXLsS5556LuXPnorS0FJIkAYi8/vA6kyQJXbp0wYEDB9pcxwcOHIh7jnxl165d2LVrF77++msAwFtvvYWRI0dyu0yBCRMmoLq6Gvv370coFMLbb7+NM844g9sl4wqsX2NhHZs+rF+dhXWsc7COZTIJ69hIWL86A+tY52D96hysX63Jeh6EVESSJNq2bRv179/fTLg7dOjQrJcrW/Liiy/S//7v/0Ysmz17dkQS58cff5wA0EUXXRSRKHrlypUEaImiq6qqqLS0lEpLS6mqqoq6du1KQGyi6AsvvND2HIUg48aNM/PnvPHGGxFJnG+99VYCQLfddltEoujXX3+dANDQoUMjEkVv27aNRFG0bbfxzpHPsnz5cjruuOMIAM2cOZNmz57N7TIFGT16NK1fv56Ki4sJ0BLD/+pXv+J2yeKKsH6NFdaxzgrrV2eEdawzwjqWJZPCOjZSWL86L6xj0xfWr84I61dLyXoBUpYLL7yQNm/eTFu3bqUZM2ZkvTzZkjPOOIOIiNasWUPff/89ff/993ThhRfSUUcdRR999BFt2bKF/vnPf5oPPAB66qmnaOvWrbR27Vo65ZRTzOU33ngjVVZWUmVlJf3sZz8zl59yyim0bt062rp1K/35z382l9udI98lXHkNGDCAVq5cSZWVlfTGG2+Q1+slAOTz+eiNN96gyspKWrlyJQ0YMMDcf8aMGbR161batGmTObOhXbuNd458lmHDhtGqVatozZo1tHjxYiotLeV2maI88MADVFFRQevWraOXXnqJvF4vt0sW14T1a6uwjnVeWL86I6xjnRPWsSyZFNaxmrB+dUdYx6YvrF+dE9avkSLofzAMwzAMwzAMwzAMwzAMwzAOk7c5YBmGYRiGYRiGYRiGYRiGYXIddsAyDMMwDMMwDMMwDMMwDMO4BDtgGYZhGIZhGIZhGIZhGIZhXIIdsAzDMAzDMAzDMAzDMAzDMC7BDliGYRiGYRiGYRiGYRiGYRiXYAcswzAMwzAMwzAMwzAMwzCMS7ADlmEYhmEYhmEYhmEYhmEYxiXYAcswDMMwDMMwDMMwDMMwDOMS/x8jpVA9TSsiyAAAAABJRU5ErkJggg==\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 2.5865042209625244\n"]}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_point1_arr, long_en_tp1, long_en_out0 = \\\n","get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=False)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_open_idx = short_obj[-1].astype(int)\n","long_open_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_open_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_open_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_open_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_open_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_open_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_open_idx]\n","\n","short_open_epout_0 = res_df['short_epout_0_{}'.format(selection_id)].to_numpy()[short_open_idx]\n","long_open_epout_0 = res_df['long_epout_0_{}'.format(selection_id)].to_numpy()[long_open_idx]\n","\n","short_open_epout_gap = res_df['short_epout_gap_{}'.format(selection_id)].to_numpy()[short_open_idx]  # use open_i\n","long_open_epout_gap = res_df['long_epout_gap_{}'.format(selection_id)].to_numpy()[long_open_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_epout_gap)\n","# long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_epout_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ #\n","short_max_outg = get_max_outg_v4(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)\n","long_max_outg = get_max_outg_v4(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"code","source":["len(short_max_outg)\n","# len(short_bias_arr)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"bYCcZjav5ebX","executionInfo":{"status":"ok","timestamp":1652335978972,"user_tz":-540,"elapsed":360,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d9baee6e-2847-489b-b580-7fa382438ace"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["727"]},"metadata":{},"execution_count":26}]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_tf = 'T'\n","wave_period = config.tr_set.wave_period\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_tf, wave_period))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_tf, wave_period))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_tf, wave_period))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_tf, wave_period))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF","colab":{"base_uri":"https://localhost:8080/","height":741},"executionInfo":{"status":"ok","timestamp":1652336000146,"user_tz":-540,"elapsed":2191,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0f96fffd-6b9a-4f7e-88ff-692d53ae921e"},"outputs":[{"output_type":"stream","name":"stdout","text":["661\n","661\n","661\n","661\n","pkx : [0.16567421 0.37261006 0.43912516 0.62388931]\n","pkx : [0.13770337 0.25029868 0.60309732]\n","\n","293\n","293\n","293\n","293\n","pkx : [-0.52628423 -0.45473521 -0.33365224 -0.2070655  -0.1300127  -0.02544105]\n","pkx : [-0.46075458 -0.25025689 -0.14500805 -0.04852994]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"983aUwM76s6X"}},{"cell_type":"code","source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"],"metadata":{"id":"cFd7Fz0Y6ucU"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v3"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oVifICO4-Grk","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1652405670106,"user_tz":-540,"elapsed":36211,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"fcf8f3bc-585a-47b9-ccaa-782fbdce1d4c"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 0\n","np.sum(long_open_res == 1) : 0\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0330908298492432\n","en_ex_pairing elapsed time : 3.337860107421875e-05\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.057267189025879\n","en_ex_pairing elapsed time : 0.4274461269378662\n","short_obj.shape : (811, 5)\n","long_obj.shape : (1068, 5)\n","idep_plot elapsed time : 0.1911144256591797\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9694914817810059\n","en_ex_pairing elapsed time : 0.5055937767028809\n","short_obj.shape : (836, 5)\n","long_obj.shape : (1128, 5)\n","idep_plot elapsed time : 0.19333624839782715\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9642536640167236\n","en_ex_pairing elapsed time : 0.376798152923584\n","short_obj.shape : (876, 5)\n","long_obj.shape : (1173, 5)\n","idep_plot elapsed time : 0.18571901321411133\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.98199462890625\n","en_ex_pairing elapsed time : 0.3753018379211426\n","short_obj.shape : (915, 5)\n","long_obj.shape : (1225, 5)\n","idep_plot elapsed time : 0.19108033180236816\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9509379863739014\n","en_ex_pairing elapsed time : 0.37926292419433594\n","short_obj.shape : (952, 5)\n","long_obj.shape : (1267, 5)\n","idep_plot elapsed time : 0.19208621978759766\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.976454496383667\n","en_ex_pairing elapsed time : 0.39745235443115234\n","short_obj.shape : (977, 5)\n","long_obj.shape : (1303, 5)\n","idep_plot elapsed time : 0.20897817611694336\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9996294975280762\n","en_ex_pairing elapsed time : 0.3830239772796631\n","short_obj.shape : (1011, 5)\n","long_obj.shape : (1363, 5)\n","idep_plot elapsed time : 0.2001340389251709\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9643218517303467\n","en_ex_pairing elapsed time : 0.38087916374206543\n","short_obj.shape : (1052, 5)\n","long_obj.shape : (1414, 5)\n","idep_plot elapsed time : 0.21887779235839844\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.963221549987793\n","en_ex_pairing elapsed time : 0.38904428482055664\n","short_obj.shape : (1079, 5)\n","long_obj.shape : (1460, 5)\n","idep_plot elapsed time : 0.21519899368286133\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9699625968933105\n","en_ex_pairing elapsed time : 0.37929582595825195\n","short_obj.shape : (1110, 5)\n","long_obj.shape : (1508, 5)\n","idep_plot elapsed time : 0.21287035942077637\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9488162994384766\n","en_ex_pairing elapsed time : 0.37953877449035645\n","short_obj.shape : (1151, 5)\n","long_obj.shape : (1558, 5)\n","idep_plot elapsed time : 0.22272086143493652\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9614591598510742\n","en_ex_pairing elapsed time : 0.3778510093688965\n","short_obj.shape : (1190, 5)\n","long_obj.shape : (1604, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21757030487060547\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9593703746795654\n","en_ex_pairing elapsed time : 0.3861563205718994\n","short_obj.shape : (1222, 5)\n","long_obj.shape : (1651, 5)\n","idep_plot elapsed time : 0.21741151809692383\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9588632583618164\n","en_ex_pairing elapsed time : 0.3811676502227783\n","short_obj.shape : (1257, 5)\n","long_obj.shape : (1695, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2217397689819336\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(short_open_res == 1) : 68606\n","np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9813926219940186\n","en_ex_pairing elapsed time : 0.3856852054595947\n","short_obj.shape : (1277, 5)\n","long_obj.shape : (1739, 5)\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res == 1) : 68606\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.23118329048156738\n"]},{"output_type":"stream","name":"stderr","text":["np.sum(long_open_res == 1) : 68441\n","wave_mm\n","np.sum(short_open_res == 1) : 68605\n","np.sum(long_open_res == 1) : 68438\n","point validation\n","np.sum(short_open_res == 1) : 68602\n","np.sum(long_open_res == 1) : 68436\n","cu_wrr_32_ <= config.loc_set.point.wrr_32 : 2.58300 0.25000 (0.0)\n","co_wrr_32_ <= config.loc_set.point.wrr_32 : 1.00000 0.25000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9849779605865479\n","en_ex_pairing elapsed time : 0.4973738193511963\n","short_obj.shape : (1308, 5)\n","long_obj.shape : (1773, 5)\n","idep_plot elapsed time : 0.23403620719909668\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","val_list = np.arange(-0.0, -0.5, -0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.ei_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    # enlist_rtc(res_df, config_, np_timeidx)\n","    enlist_tr(res_df, config_, np_timeidx)\n","  open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","\n","  try:\n","    result.append(get_res_v5(res_df, open_info_df, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open_{}'.format(id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":68,"metadata":{"id":"eiQ36_SLLE3w","executionInfo":{"status":"ok","timestamp":1652409313965,"user_tz":-540,"elapsed":308,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx = open_info_df.index.to_numpy()\n","  len_df = len(res_df)\n","  s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","  s_open_info_df = open_info_df[s_idx]\n","  s_open_idx = open_idx[s_idx]\n","\n","  open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","  side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v5(res_df, s_open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v13(res_df, len_df, config_list[0], high, low, s_open_idx, side_arr, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":65,"metadata":{"id":"8LiKwfiJ4bvM","executionInfo":{"status":"ok","timestamp":1652409262778,"user_tz":-540,"elapsed":4,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def plot_info_v6(gs, gs_idx, sample_len, tr, prcn, rc, bars_in, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    # title_str = \"prcn : {:.3f} rc : {:.3f}\\n len_pr : {} dpf : {:.3f}\\n wr : {:.3f} sr : {:.3f}\\n acc_pr : {:.3f} sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f} liqd : {:.3f}\\n acc_mdd : -{:.3f} sum_mdd : -{:.3f}\\n leverage {}\"\n","    # title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n rc : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    # title_str = \"tr : {:.3f}\\n prcn : {:.3f}\\n wave_bias : {:.3f}\\n bars_in : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","    #           \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    title_str = \"tr : {:.3f}\\n hhm : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n len_pr : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {}\"\n","    plt.title(title_str.format(tr, rc, prcn, bars_in, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"]},{"cell_type":"code","execution_count":67,"metadata":{"id":"xafHpMLwESKf","executionInfo":{"status":"ok","timestamp":1652409300235,"user_tz":-540,"elapsed":352,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def idep_plot_v13(res_df, len_df, config, high, low, open_idx, side_arr, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5), fontsize=15, signi=False):\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        fig = plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","    \n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","      sample_len = int(len_df * sample_ratio)\n","    else:\n","      sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","    point1_arr, valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res    \n","    assert len(valid_openi_arr) != 0, \"assert len(valid_openi_arr) != 0\"    \n","    short_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.SELL)[0]  # valid_openi_arr 에 대한 idx, # side_arr,\n","    long_valid_openi_idx = np.where(side_arr[valid_openi_arr] == OrderSide.BUY)[0]\n","\n","    valid_open_idx = open_idx[valid_openi_arr].reshape(-1, 1)\n","\n","    short_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[short_valid_openi_idx]\n","    long_obj = np.hstack((pair_price_arr, pair_idx_arr, valid_open_idx))[long_valid_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_point1_arr, long_point1_arr = [point1_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_valid_openi_idx, long_valid_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)    \n","    # print(\"elapsed time :\", time.time() - start_0)\n","\n","    short_true_bias_idx, short_false_bias_idx, long_true_bias_idx, long_false_bias_idx, short_en_tp1, short_en_out0, long_en_tp1, long_en_out0 = \\\n","    get_wave_bias_v2(res_df, config, high, low, len_df, short_obj, long_obj)\n","\n","    len_short, len_long = len(short_valid_openi_idx), len(long_valid_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","      # start_0 = time.time()      \n","      if len_short == 0:\n","        short_pr = []\n","        gs_idx += 1\n","      else:\n","        short_tr = short_tr_arr.mean()\n","        short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","        short_cum_pr = np.cumprod(short_total_pr)\n","        # short_liqd = liquidation_v2(OrderSide.SELL, h, short_obj[:4], short_lvrg_arr, short_fee_arr)\n","        short_prcn, short_rc = precision(short_pr, short_true_bias_idx), wave_bias(short_true_bias_idx, short_false_bias_idx)\n","        short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","        if signi:\n","          short_idep_res_obj = (short_prcn, short_rc) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, short_tr, short_prcn, short_rc, short_trade_ticks, short_pr, short_total_pr, short_cum_pr, short_liqd, short_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in short plot_data :\", e)\n","\n","    try:\n","      # start_0 = time.time()   \n","      if len_long == 0:\n","        long_pr = []\n","        gs_idx += 1\n","      else:\n","        long_tr = long_tr_arr.mean()\n","        long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio, inversion)\n","        long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","        long_cum_pr = np.cumprod(long_total_pr)\n","        # long_liqd = liquidation_v2(OrderSide.BUY, l, long_obj[:4], long_lvrg_arr, long_fee_arr)\n","        long_prcn, long_rc = precision(long_pr, long_true_bias_idx), wave_bias(long_true_bias_idx, long_false_bias_idx)\n","        long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","        if signi:\n","          long_idep_res_obj = (long_prcn, long_rc) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, long_tr, long_prcn, long_rc, long_trade_ticks, long_pr, long_total_pr, long_cum_pr, long_liqd, long_lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in long plot_data :\", e)\n","\n","    \n","    try:\n","      # start_0 = time.time()\n","      if len_short * len_long == 0:\n","        both_pr = []\n","        gs_idx += 1\n","      else:\n","        both_tr = (short_tr + long_tr) / 2\n","        both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","        both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","        both_cum_pr = np.cumprod(both_total_pr)\n","        both_liqd = min(short_liqd, long_liqd)\n","        both_true_bias_idx = np.vstack((short_true_bias_idx, long_true_bias_idx))  # vstack for 2d arr\n","        both_false_bias_idx = np.vstack((short_false_bias_idx, long_false_bias_idx))\n","        both_prcn, both_rc = precision(both_pr, both_true_bias_idx), wave_bias(both_true_bias_idx, both_false_bias_idx)\n","        both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","        if signi:\n","          both_idep_res_obj = (both_prcn, both_rc) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","        else:\n","          gs_idx = plot_info_v6(gs, gs_idx, sample_len, both_tr, both_prcn, both_rc, both_trade_ticks, both_pr, both_total_pr, both_cum_pr, both_liqd, lvrg_arr[-1], title_position, fontsize)\n","      # print(\"elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","      gs_idx += 1\n","      print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","      if len_short * len_long > 0:\n","        for obj, cum_pr in zip([short_obj, long_obj, both_obj], [short_cum_pr, long_cum_pr, both_cum_pr]):\n","          try:\n","            # start_0 = time.time()\n","            gs_idx = frq_dev_plot_v3(gs, gs_idx, len_df, sample_len, obj[-2], cum_pr[-1], fontsize)\n","            # print(\"elapsed time :\", time.time() - start_0)          \n","          except Exception as e:\n","            gs_idx += 1\n","            print(\"error in frq_dev_plot_v3 :\", e)\n","        plt.show()\n","        plt.close()\n","\n","      return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_true_bias_idx, short_false_bias_idx, short_point1_arr, short_en_tp1, short_en_out0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_true_bias_idx, long_false_bias_idx, long_point1_arr, long_en_tp1, long_en_out0\n","        \n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v5(res_df, open_idx, open_info_list, ohlc_list, config_list, np_timeidx, funcs):  # 이미 충분히 줄여놓은 idx 임\n","    side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","    id_idx_arr = id_idx_arr.astype(int)\n","\n","    ep_out, ep_loc_point2, lvrg_set = funcs\n","\n","    point1_list, valid_openi_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(8)]\n","    len_df = len(res_df)\n","    len_open_idx = len(open_idx)\n","    i, open_i = 0, -1  # i for total_res_df indexing\n","\n","    while 1:\n","        # ------------ entry phase ------------ #\n","        open_i += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i >= len_open_idx:\n","            break\n","\n","        # ------ ep_loc ------ #\n","        op_idx = open_idx[open_i]  # open_i 는 i 와 별개로 운영\n","        if op_idx < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ dynamic data by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        id_idx = id_idx_arr[open_i]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        open_side = side_arr[open_i]\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()  # => eptpout arr_list 만들어서 꺼내 사용하면 될 것\n","        point_idxgap_arr = res_df['{}_point_idxgap_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        ep_arr = res_df['{}_ep_{}'.format(side_pos, selection_id)].to_numpy()  # Todo - while loop 내에서 to_numpy() 반복하느니, pd_indexing 이 낫지 않을까\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","        # bias_info_arr = res_df['{}_bias_info_{}'.format(side_pos, selection_id)].to_numpy()  # ex. rolling(entry ~ end)'s high\n","        # bias_thresh_arr = res_df['{}_bias_thresh_{}'.format(side_pos, selection_id)].to_numpy()  # ex. close + dc_T20 * 0.5\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ ei_k & point2 ------ #\n","        i = op_idx + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        point_idxgap = point_idxgap_arr[op_idx]\n","        if np.isnan(point_idxgap):\n","            continue\n","        else:\n","            # ------ allow point2 only next to point1 ------ #\n","            open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","            tp_j = int(op_idx - point_idxgap)\n","            if np.sum(open_arr[tp_j:op_idx]) != 0:\n","                continue\n","\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side,\n","                                                                                 [*ohlc_list, ep_arr], ep_out, ep_loc_point2)\n","        i = exec_j\n","\n","        if not entry_done:\n","            continue\n","\n","        # ------ leverage ------ #\n","        out = out_arr[out_j]  # lvrg_set use out on out_j\n","        leverage = lvrg_set(res_df, config, open_side, en_p, out, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","        if leverage is None:\n","            continue\n","\n","        exit_done, cross_on = 0, 0\n","        # ------ check tpout_onexec ------ #\n","        # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","        if config.ep_set.entry_type == \"LIMIT\":\n","            if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                tp_j = exec_j\n","            if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                out_j = exec_j\n","\n","        while 1:\n","            # ------------ exit phase ------------ #\n","            if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                tp_j = i\n","            if not config.out_set.static_out:\n","                out_j = i\n","\n","            # ------------ out ------------ #  # out 우선 (보수적 검증)\n","            # ------ signal_out ------ #\n","            if not exit_done:\n","                exit_done, cross_on, ex_p, fee = check_market_out_exec_v2(config, res_df, np_timeidx, open_i, i, len_df, fee, open_side, cross_on, exit_done)\n","            # ------ hl_out ------ #\n","            if config.out_set.hl_out != \"None\":\n","                if not exit_done:  # and i != len_df - 1:\n","                    exit_done, ex_p, fee = check_out(config, open_i, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","            # ------------ tp ------------ #\n","            if not config.tp_set.non_tp and i != exec_j:\n","              if not exit_done:\n","                exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                           [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","            if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                # ------ append dynamic vars. ------ #\n","                point1_list.append(tp_j)\n","                valid_openi_list.append(open_i)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                pair_price_list.append([en_p, ex_p])\n","                lvrg_list.append(leverage)\n","                fee_list.append(fee)\n","                tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                # bias_list.append([bias_info_arr[exec_j], bias_thresh_arr[exec_j]])  # backtest 에서만 가능한 future_data 사용\n","                # bias_list.append([bias_info_arr[exec_j], tp_arr[tp_j]])  # bias_info 는 entry_idx 부터 & tp = bias_thresh\n","                tr_list.append(tr_arr[op_idx])\n","\n","                # open_i += 1  # 다음 open_idx 조사 진행\n","                break\n","\n","            # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","            # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","            i += 1\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(point1_list), np.array(valid_openi_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_eik_point2_exec_v3(res_df, config, op_idx, tp_j, len_df, open_side, np_datas, ep_out, ep_loc_point2):\n","    o, h, l, c, ep_arr = np_datas\n","    ep_j = op_idx\n","    # tp_j = op_idx\n","    out_j = op_idx\n","\n","    selection_id = config.selection_id    \n","    allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ ei_k ------ # - limit 사용하면 default 로 ei_k 가 존재해야함\n","            if ep_out(res_df, config, op_idx, e_j, tp_j, [h, l], open_side):\n","              break\n","\n","            # ------ point2 ------ #\n","            if not allow_ep_in:\n","                allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","                if allow_ep_in:\n","                  if config.ep_set.point2.entry_type == \"LIMIT\":\n","                    ep_j = e_j\n","                    # print(\"e_j in point2 :\", e_j)\n","                    continue\n","\n","            # ------ check ep_exec ------ #\n","            if allow_ep_in:\n","              if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","                entry_done = 1\n","                ep = c[e_j]\n","                break\n","              else:\n","                if open_side == OrderSide.SELL:\n","                    if h[e_j] >= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                            ep = o[e_j]\n","                        break\n","                else:\n","                    if l[e_j] <= ep_arr[ep_j]:\n","                        entry_done = 1\n","                        ep = ep_arr[ep_j]\n","                        if o[e_j] <= ep_arr[ep_j]:\n","                            ep = o[e_j]\n","                        break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = c[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, j, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        try:\n","            if config.tr_set.decay_gap != \"None\":\n","                decay_share = (j - open_i) // config.tp_set.decay_term\n","                decay_remain = (j - open_i) % config.tp_set.decay_term\n","                if j != open_i and decay_remain == 0:\n","                    if open_side == OrderSide.SELL:\n","                        tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","                    else:\n","                        tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        except:\n","            pass\n","\n","        if open_side == OrderSide.SELL:\n","            if l[j] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if l[j] <= tp_arr[j] <= h[j]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[j]:\n","                        tp = o[j]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[j]\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if o[j] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if h[j] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[j] != tp_arr[j - 1] and not config.tp_set.static_tp:\n","                    if o[j] > tp_arr[j]:\n","                        tp = o[j]\n","                    else:\n","                        tp = tp_arr[j]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if o[j] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = o[j]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_market_out_exec_v2(config, res_df, np_timeidx, open_i, j, len_df, fee, open_side, cross_on, exit_done):    \n","    close = res_df['close'].to_numpy()\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[j] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and j != open_i:\n","            exit_done = 1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[j - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[j] < 50 - config.loc_set.point.osc_band):\n","                exit_done = 1\n","        else:\n","            if (rsi_T[j - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[j] > 50 + config.loc_set.point.osc_band):\n","                exit_done = 1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[j] < ha_c[j]):# & (ha_o[j] == ha_l[j]):   # 양봉 출현\n","    #           exit_done = 1\n","    #     else:\n","    #       if (ha_o[j] > ha_c[j]):# & (ha_o[j] == ha_h[j]):  # 음봉 출현\n","    #           exit_done = 1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[j] < bb_lower_5T[j] < close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] > bb_upper_5T[j] > close[j - 1]:\n","                exit_done = 1\n","        else:\n","            if close[j] > bb_upper_5T[j] > close[j - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[j] < bb_lower_5T[j] < close[j - 1]:\n","                exit_done = 1\n","\n","    if exit_done:\n","        ex_p = close[j]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_out(config, open_i, j, out_j, len_df, fee, open_side, exit_done, np_datas):\n","    o, h, l, c, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if h[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if l[j] <= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if c[j] >= out_arr[out_j]:  # check out only once\n","                exit_done = 1\n","        else:\n","            if c[j] <= out_arr[out_j]:  # check out only once\n","                ex_p = c[j]\n","                exit_done = 1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = c[j]\n","\n","        if open_side == OrderSide.SELL:\n","            if o[j] >= out_arr[out_j]:\n","                ex_p = o[j]\n","        else:\n","            if o[j] <= out_arr[out_j]:\n","                ex_p = o[j]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":74,"metadata":{"id":"FCpPCl931ojV","executionInfo":{"status":"ok","timestamp":1652409793592,"user_tz":-540,"elapsed":312,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_df\n","del np_plot_params"]},{"cell_type":"code","execution_count":72,"metadata":{"id":"rMIwv1Nr1ojX","executionInfo":{"status":"ok","timestamp":1652409493980,"user_tz":-540,"elapsed":5297,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","front_plot = 4    # 0 : whole, 1 : open, 2 : ep_tick, 3 : tp_tick, 4 : bias_tick\n","bias_plot = 1     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","pr_descend = 1    # 1 : 큰 pr 부터, 0 : 작은 pr 부터\n","position = 1      # -1 : short 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 50 #  150 100 20\n","# post_plotsize = 60\n","post_plotsize = config.tr_set.bias_info_tick\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_point1_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_false_bias_arr, short_en_tp1, short_en_out0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_point1_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_false_bias_arr, long_en_tp1, long_en_out0]\n","pr, obj, [point1_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, false_bias_arr, en_tp1, en_out0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","# ------------------ data chunknize ------------------ #\n","np_df = res_df.to_numpy()\n","\n","# left_end_idx = obj[2] - prev_plotsize  # left_margin 기준 - entry_idx\n","left_end_idx = obj[4] - prev_plotsize  # left_margin 기준 - open_idx\n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, point1_arr, lvrg_arr, fee_arr, tpout_arr, en_tp1, en_out0))[invalid_left_end:]  # all arr should have same dimension\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = false_bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":855,"status":"ok","timestamp":1652401690393,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"a6c5b106-8da7-4e07-ae89-504fe9f066b5","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_tf1 = 'T'\n","wave_period1 = 5\n","wave_tf2 = '15T'\n","wave_period2 = 5\n","\n","step_col_list.append([['dc_base_{}{}'.format(wave_tf1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_tf2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 1\n","dc_tf2 = '15T'\n","dc_period2 = 1\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 60\n","\n","step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","step_col_list2.append([['cci_{}{}'.format(wave_tf1, wave_period1], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf1, wave_period1)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf1, wave_period1)], 1, '#00ff00', 7, '*'])\n","\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_tf2, wave_period2)], 1, '#e91e63', 10, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_tf2, wave_period2)], 1, '#2962ff', 10, '*'])\n","  \n","stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_tf1, wave_period1)], 1, '#00ff00', 5, 'o'])\n","stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_tf1, wave_period1)], 1, '#ff00ff', 5, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_{}{}'.format(wave_tf1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['cu_wrr_32_{}{}'.format(wave_tf1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['co_wrr_32_{}{}'.format(wave_tf1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_tf1, wave_period1)])\n","data_window_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_col_arr = strcol_tonumb(res_df, data_window_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_col_info\": data_window_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close'])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_tf2, wave_period2), 'wave_high_fill_{}{}'.format(wave_tf2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":73,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1hUYo5n-lZZDXiY9UIh7EbHLS-Qg3qS1q"},"executionInfo":{"status":"error","timestamp":1652409524398,"user_tz":-540,"elapsed":8800,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"a7b34477-a889-4c3b-cc0f-8e1801ae3052"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["_ = [plot_check_v6(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v6(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, lvrg, fee, tp_line, out_line, en_tp1, en_out0 = params\n","\n","    # if exit_idx - open_idx < 50:  # temporary\n","    #   break\n","\n","    # ============ gs 0 ============ #\n","    ax = fig.add_subplot(gs[gs_idx])\n","\n","    # ------------ add_col section ------------ #\n","    a_data = data[int(iin):int(iout + 1)]\n","    # a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v5(config, ep, tp, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                    front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline_v3 :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *data[int(open_idx), params_[0]]) for params_ in col_idx_dict['data_window_col_info']]  # * for unsupported format for arr\n","    ps_msg_expand = pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    plt.title(ps_msg_expand)\n","\n","    # ============ gs 1 ============ #\n","    fig.add_subplot(gs[gs_idx + 1])\n","    [step_col_plot(a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","    plt.axhline(100, color=\"#ffffff\")\n","    plt.axhline(-100, color=\"#ffffff\")\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v5(config, en_p, ex_p, entry_idx, exit_idx, open_idx, point1_idx, tp_line, out_line, en_tp1, en_out0,\n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  point1_tick = open_tick - int(open_idx - point1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if front_plot == 1:\n","    x_max = open_tick + 20\n","  elif front_plot == 2:\n","    x_max = entry_tick + 20 \n","  elif front_plot == 3:\n","    x_max = exit_tick + 20\n","  elif front_plot == 4:\n","    x_max = bias_info_tick + 20\n","\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  plt.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ wave_line ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  plt.axhline(en_tp1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_tp1, ' wave_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  plt.axhline(en_out0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  plt.text(text_x_pos, en_out0, ' wave_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  point1_ymax, open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [point1_tick, open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(point1_tick, 0, point1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff7722')\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","VdukVo5-Suzj","Bw5JibDKSuzj","Pe0QpnORSuzk","E0n53hflJbnp","MlFkpO1MSuzl","t1E_eAyPSuzm","nUs4fjVHSuzl","L7l5CTJfSuzn","x_XGJqBi8Jex","MSUY4nnku3s9","epgS5Dksu-HX","Iy76iO7gztne","x2yj2SwAXDLp","Q_1wJTcRYpm8","02DcTVB2cYuR","EOXQbXixiQcK","xpyP5t8Ht_pE","aTV4h3LjTZBp","MuD_2vY7TI_8","sZAYhcdoXnm4","5rdQZm_71ojv","tApzvz_gK9lR","OJqkmkpsLCYC"],"name":"stem5_43_vec_backi2(0512_waverange_v11_3).ipynb","toc_visible":true,"provenance":[],"authorship_tag":"ABX9TyOWLfJH9ygA8Nz/hdrol2bw"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}