{"cells":[{"cell_type":"code","execution_count":2,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1658884002611,"user_tz":-540,"elapsed":31694,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d5508960-6324-4bc9-c76e-d693bd98abcd"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1658884034437,"user_tz":-540,"elapsed":31830,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","    \n","    # --------------- stochastic --------------- #\n","    df = stoch_v2(df)\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    print(\"stoch phase done\")\n","\n","    # --------------- ma --------------- #  \n","    # df = ma(df, 60)\n","    # print(\"ma phase done\")\n","\n","    # df = macd_hist(df, 5, 35, 15)\n","    # print(\"macd_hist phase done\")\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    # df = dc_line_v4(df, df, dc_period=10)\n","    # df = dc_line_v4(df, df, dc_period=20)\n","    # df = dc_line_v4(df, df, dc_period=100)\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    # print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 100\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    \n","    # df = bb_line_v3(df, df_15T, 60)\n","    \n","    # df = bb_line_v3(df, df, bb_period)\n","    # df = bb_level_v2(df, 'T', bb_period)\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")        \n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":620},"executionInfo":{"elapsed":492,"status":"ok","timestamp":1657897792233,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"odqVwQHpYo1M","outputId":"1bdfa271-4f0e-4409-9a3f-ff7ded70a640"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n","stoch phase done\n"]},{"output_type":"execute_result","data":{"text/plain":["                         dc_base_T10  dc_upper_T20  dc_lower_T20  dc_base_T20  dc_upper_T30  dc_lower_T30  dc_base_T30       ma_T30       ma_T60  stoch_T1333\n","index                                                                                                                                                        \n","2022-04-27 08:41:59.999     2797.380       2806.93       2778.97     2792.950       2806.93       2761.27       2784.1  2792.450333  2806.733500    89.511327\n","2022-04-27 08:42:59.999     2798.165       2806.93       2780.26     2793.595       2806.93       2761.27       2784.1  2792.417000  2806.293167    87.416561\n","2022-04-27 08:43:59.999     2799.570       2806.93       2780.26     2793.595       2806.93       2761.27       2784.1  2792.547667  2805.914333    83.950235\n","2022-04-27 08:44:59.999     2799.570       2806.93       2780.26     2793.595       2806.93       2761.27       2784.1  2792.546000  2805.607667    81.475031\n","2022-04-27 08:45:59.999     2799.570       2806.93       2780.26     2793.595       2806.93       2761.27       2784.1  2792.391333  2805.184500    79.154400"],"text/html":["\n","  <div id=\"df-dc258601-603d-491e-8779-7a016ea6c688\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>dc_base_T10</th>\n","      <th>dc_upper_T20</th>\n","      <th>dc_lower_T20</th>\n","      <th>dc_base_T20</th>\n","      <th>dc_upper_T30</th>\n","      <th>dc_lower_T30</th>\n","      <th>dc_base_T30</th>\n","      <th>ma_T30</th>\n","      <th>ma_T60</th>\n","      <th>stoch_T1333</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2797.380</td>\n","      <td>2806.93</td>\n","      <td>2778.97</td>\n","      <td>2792.950</td>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2792.450333</td>\n","      <td>2806.733500</td>\n","      <td>89.511327</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2798.165</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2792.417000</td>\n","      <td>2806.293167</td>\n","      <td>87.416561</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2799.570</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2792.547667</td>\n","      <td>2805.914333</td>\n","      <td>83.950235</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2799.570</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2792.546000</td>\n","      <td>2805.607667</td>\n","      <td>81.475031</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2799.570</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","      <td>2806.93</td>\n","      <td>2761.27</td>\n","      <td>2784.1</td>\n","      <td>2792.391333</td>\n","      <td>2805.184500</td>\n","      <td>79.154400</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-dc258601-603d-491e-8779-7a016ea6c688')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-dc258601-603d-491e-8779-7a016ea6c688 button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-dc258601-603d-491e-8779-7a016ea6c688');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":21}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gOQxwYqK0jCS"},"outputs":[],"source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmiB5VU5DN6B"},"outputs":[],"source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1671,"status":"ok","timestamp":1657898286047,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"183b3d68-2433-4956-b317-9cc177917417"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":4,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":8508,"status":"ok","timestamp":1658884042934,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"7FPBG5Qqg2jB","outputId":"8414e231-42d4-48b4-c7f8-54ba9f935ffc"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 6.550065040588379\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes\n","# res_df_.index[[0, -1]]"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1657898275247,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"cf3fee46-d616-45e7-a3e2-3e0683513582"},"outputs":[{"output_type":"stream","name":"stdout","text":["['stoch_T1333']\n"]}],"source":["col_list = list(res_df_.columns)\n","\n","# ------ check target cols ------ #\n","print([col_ for col_ in col_list if 'stoch' in col_])\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'stoch' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["\n","def tc_cci_v2(t_df, wave_period):  # high_confirmation\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    baseline = 0\n","    band_width = 100\n","    upper_band = baseline + band_width\n","    lower_band = baseline - band_width\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    ohlc_list = [t_df[col_].to_numpy() for col_ in data_cols]\n","    open, high, low, close = ohlc_list\n","    \n","    t_df['short_tc_{}{}'.format(itv, wave_period)] = (b1_cci_ < lower_band) & (lower_band < cci_)\n","    t_df['long_tc_{}{}'.format(itv, wave_period)] = (b1_cci_ > upper_band) & (upper_band > cci_)\n","\n","    return t_df\n","\n","def tc_cci(t_df, wave_period):\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    baseline = 0\n","    band_width = 100\n","    upper_band = baseline + band_width\n","    lower_band = baseline - band_width\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    ohlc_list = [t_df[col_].to_numpy() for col_ in data_cols]\n","    open, high, low, close = ohlc_list\n","    \n","    t_df['short_tc_{}{}'.format(itv, wave_period)] = (b1_cci_ > lower_band) & (lower_band > cci_)\n","    t_df['long_tc_{}{}'.format(itv, wave_period)] = (b1_cci_ < upper_band) & (upper_band < cci_)\n","\n","    return t_df\n","\n","def tc_dc_base(t_df, dc_period):\n","    t_df = donchian_channel_v4(t_df, dc_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, dc_period)].to_numpy()\n","\n","    close = t_df['close'].to_numpy()\n","    b1_close = t_df['close'].shift(1).to_numpy()\n","\n","    t_df['short_tc_{}{}'.format(itv, dc_period)] = (b1_close > dc_base_) & (dc_base_ > close)\n","    t_df['long_tc_{}{}'.format(itv, dc_period)] = (b1_close < dc_base_) & (dc_base_ < close)\n","\n","    return t_df"],"metadata":{"id":"7V1RdTqtVM2b"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","metadata":{"id":"O1uu9vQnY5dn"},"source":["##### plot_check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YqBXjVPzdccC"},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 370940\n","# i = 185369\n","i = 186060\n","\n","plot_size = 300 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PgaNnempXRd_"},"outputs":[],"source":["wave_itv1, wave_period1 = 'T', 20\n","roll_hl_cnt = 3\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)  # to_htf 는 ohlc, 4개의 col 만 존재 (현재까지)\n","    # htf_df = wave_range_cci_v3(htf_df, wave_period1)\n","    htf_df = wave_range_dc_envel_v1(htf_df, wave_period1)\n","    \n","\n","    cols = list(htf_df.columns)  # 그냥 다 넣어버리기 (추후 혼란 방지)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])  # wrr 은 4개의 cols\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  # t_df = wave_range_cci_v4(t_df, wave_period1)\n","  t_df = wave_range_stoch_v1(t_df, wave_period1)\n","  # t_df = wave_range_dc_envel_v1(t_df, wave_period1)\n","\n","  valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v5(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","  t_df = get_roll_wave_data_v2(t_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","  t_df = wave_range_ratio_v4_2(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"elapsed":3886,"status":"ok","timestamp":1657898548226,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"-Dr_tTk9csFm","outputId":"e32038a0-9b82-417d-a689-7e1dea7b4972"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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4AQ7TlK8cqKTiJES1tQS8txJJ/KH9XyhJrjHwZGkrmtvWE0tIe2496AGX12YBllfVxY3EIS90p7pu+qqq9Te3q6NGzfqzJkz6uvr009/+lN9+9vf1te+9jX19fVpy5Yt+va3v62mpiZt2bJF69at07p163Tdddfp+9//vhoaGux8L/AIY4r//MpTGthel/LxXrwaBAAAkEg4EvFtj9uuveG4529GevVAT/SckPO87Eh7pm/9+vV67bXXNDk5qenpab300ku65ZZbNDs7q9/5nd+RJJWXl+u9996TJG3btk0/+tGPJEmvvfaaKioqVFVVZcNbgJcEu8c0HJpI+3g/XQ0a2Zr96lIAkCk/pJcBXhFbICQRP2QMWc8N/XSe5zZpz/SFQiF94xvf0AUXXKDJyUndfPPN+vnPf64//dM/1QsvvKC/+qu/UmFhoX7v935PkrR69WodOXLEPP7o0aNavXq1jh8/nvm7gGcsdpUnWcZVIK+yXsHz65U8AMiF9u0B8+TQKMKS6t8IYz0f4FYjW5tTDgS9xnpuaNd5XnVnh7nExwuVNXMh7Zm+kZERPfzww9q3b5/6+vo0PDys6elpffGLX9RXvvIVfexjH9NXvvIVPfrooyk9b3t7u4aGhjQ0NKRVq1alOzzAlfz+wQ0AuWIUYckExVvgdlwgTo9RxE9yf32HXMmoeudjjz2mxx57TJL0jW98Q0ePHtW3vvUts6jL3//93+sHP/iBJOnYsWNau3ateeyaNWt07NixBc/Z1dWlrq4uSdLQ0FAmwwPSRjoTACzkts9GowjLwEB0tq6pJeTwiADAnTKq3llZGU2rWLt2rW655RYFg0G99957uuGGGyRJf/AHf6B33nlHkvTss8/qjjvukCRdd911On36NKmdyIlMK8y57SQHAAAAifmlyrAdMgr6uru79dZbb+kf//Ef9aUvfUmnT59We3u7/vqv/1rDw8P65je/qR07ot/s5557TocOHdLBgwfV1dWlnTt32vIGALgHefMAllKlKg1qUFfrag1qUAEFzPuS2bYeV3Jyler//PHotkpUr/qkjkv39ezc1yvHLbZviZapXtf46j2lclw2GNUrB3rqVLJpMiuvgfyWUXrn7//+7y+479VXX9W1114bd/+77747k5cD4ELVnR3m7aGd93mufxCA3PmqvqpN2qSf6Ce6UlfqAT0g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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","\n","wave_cu_prime_idx_ = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_ = t_df['wave_co_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_prime_idx_fill_ = t_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_prime_idx_fill_ = t_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_post_idx_ = t_df['wave_cu_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_ = t_df['wave_co_post_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_cu_post_idx_fill_ = t_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_post_idx_fill_ = t_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","plt.step(len_df_range, t_df['dc_upper_{}{}'.format(wave_itv1, wave_period1)], color='#ffeb3b')\n","plt.step(len_df_range, t_df['dc_lower_{}{}'.format(wave_itv1, wave_period1)], color='#ffeb3b')\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","# ------ data check in gs[0] ------ #\n","plt.axvline(wave_cu_post_idx_fill_[230], color='r')\n","plt.axvline(wave_cu_prime_idx_fill_[230])\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","\n","# --- cci --- #\n","# cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.axhline(100, color=\"#ffffff\")\n","# plt.axhline(-100, color=\"#ffffff\")\n","\n","# --- stoch --- #\n","stoch_ = t_df['stoch_{}{}33'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, stoch_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(67, color=\"#ffffff\")\n","plt.axhline(33, color=\"#ffffff\")\n","\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]   # long 이라서 초록색임\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"c2yVTn1tnxMn"},"source":["###### data_window"]},{"cell_type":"code","source":["print(valid_high_prime_idx)  # = valid_co_prime_idx\n","print(roll_prev_high_idx_arr)   # = roll_prev_co_idx_arr"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"6bra-Br3lq1h","executionInfo":{"status":"ok","timestamp":1657850711133,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"7971ff1e-f4eb-4b51-ac99-9b0b0e8e0587"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["[ 99 128 170 240]\n","[[ 99 128 170]\n"," [128 170 240]]\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":331,"status":"ok","timestamp":1657413924345,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"0DgdFydfB1f-","outputId":"6bee67ce-efa2-479c-f6e6-701f42f92bd1"},"outputs":[{"output_type":"stream","name":"stdout","text":["170.0\n","nan\n"]},{"output_type":"execute_result","data":{"text/plain":["300"]},"metadata":{},"execution_count":20}],"source":["# print(wave_cu_post_idx_fill_[210])\n","print(wave_co_prime_idx_fill_[210])\n","# print(wave_co_idx_[~np.isnan(wave_co_idx_)])\n","print(wave_co_idx_[249])\n","\n","# print(len(t_df))\n","len(wave_co_prime_idx_fill_)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zj_d5wsfDzf_"},"outputs":[],"source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Z-EokTzIqb-T"},"outputs":[],"source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"]},{"cell_type":"markdown","metadata":{"id":"Q_1wJTcRYpm8"},"source":["##### legacy"]},{"cell_type":"code","source":["def get_next_fibo_gap(x):\n","  if 0 < x < 0.214:\n","    return -0.786\n","  elif 0.214 < x < 0.382:\n","    return -0.618\n","  elif 0.382 < x < 0.5:\n","    return -0.5\n","  elif 0.5 < x < 0.618:\n","    return -0.382\n","  elif 0.618 < x < 0.764:\n","    return -0.236\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로.\n","\n","\n","def get_next_fibo_gap2(x):\n","  if 0 < x < 0.214:\n","    return -0.618\n","  elif 0.214 < x < 0.382:\n","    return -0.5\n","  elif 0.382 < x < 0.5:\n","    return -0.382\n","  elif 0.5 < x < 0.618:\n","    return -0.236\n","  elif 0.618 < x < 0.764:\n","    return 0\n","  elif 0.764 < x < 1:\n","    return 0\n","  else:\n","    return np.nan # 일단은, wrr_32 < 1 만 허용키로."],"metadata":{"id":"Bmp7faPhzydp"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"02DcTVB2cYuR"},"source":["##### dump"]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"fjGcs9ngkh5s"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"],"metadata":{"id":"CLYKs7ItkgIa"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Go7ARIUhfC1g"},"outputs":[],"source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pgA8QqyXZ66o"},"outputs":[],"source":["t_df[roll_cols].tail(100)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wF7fKJ3mOhaf"},"outputs":[],"source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3vHLGont-BFe"},"outputs":[],"source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Mh3w2s-j34Zs"},"outputs":[],"source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3,"status":"ok","timestamp":1651799326382,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eQ06-kWq4m6F","outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"outputs":[{"name":"stdout","output_type":"stream","text":["11\n","11\n"]}],"source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SUFmr9Z_kcCN"},"outputs":[],"source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"_3pOQtt2ttfk"},"outputs":[],"source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1651756811396,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"kKaD1fK3WPRP","outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"outputs":[{"data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"execution_count":79,"metadata":{},"output_type":"execute_result"}],"source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"YoZpr7lDn7z-"},"outputs":[],"source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","metadata":{"id":"RZJ6uIA_VcJs"},"source":["##### instant."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLWAP1Cl2Hvu"},"outputs":[],"source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"H_zPYIshbZgP"},"outputs":[],"source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"o3IUBc59VR5D"},"outputs":[],"source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u3yFd8Dcok5m"},"outputs":[],"source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JWj02LLGbnji"},"outputs":[],"source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":5,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1658884048685,"user_tz":-540,"elapsed":5762,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","execution_count":6,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1658884049998,"user_tz":-540,"elapsed":1324,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","\n","    # if config.tr_set.check_hlm == 2:  # 동일한 param 으로도 p2_hlm 시도를 충분히 할 수 있음 (csdbox 와 같은)\n","    #   assert not (wave_itv1 == wave_itv2 and wave_period1 == wave_period2)\n","\n","    # ------------ get wave_features ------------ #      \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","\n","    roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    # roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    # roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    # wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    \n","    # res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = roll_highs1[-1] / wave_low_fill1_\n","    # res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / roll_lows1[-1]\n","    res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / wave_low_fill1_\n","    res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)] = wave_high_fill1_ / wave_low_fill1_\n","\n","    # ------------ enlist tr_unit ------------ #\n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    res_df['short_tp_1_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = roll_highs1[-1]   # roll_highs1[-1] wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_tp_1_{}'.format(selection_id)] = wave_high_fill1_   # wave_high_fill_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = roll_lows1[-1]    # roll_lows1[-1]  wave_low_fill1_   # roll_low_[:, -2]\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = wave_low_fill1_    # roll_low_[:, -2]\n","\n","    # --> out use p1's low, (allow prev_low as out for p1_hhm only)\n","    res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill1_   # wave_low_fill2_   # b2_low_5T\n","    res_df['short_out_0_{}'.format(selection_id)] = wave_high_fill1_ # roll_highs1[-1] if not config.tr_set.check_hlm else wave_high_fill1_   # roll_highs2[-1]  # roll_high_[:, -2]\n","    res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill1_   # wave_high_fill1_   # wave_high_fill2_   # b2_high_5T\n","    res_df['long_out_0_{}'.format(selection_id)] = wave_low_fill1_ # roll_lows1[-1] if not config.tr_set.check_hlm else wave_low_fill1_   # roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    # --> p2's ep use p1's ep\n","    res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill1_  # wave_low_fill2_   # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill1_ # wave_high_fill2_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill1_  # wave_high_fill2_   # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill1_   # wave_low_fill2_    # roll_low_[:, -2]\n","\n","    # --- inversion --- #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #     \n","    short_open_res1 = np.ones(len_df) #.astype(object)\n","    long_open_res1 = np.ones(len_df)  #.astype(object)\n","    short_open_res2 = np.ones(len_df) #.astype(object)\n","    long_open_res2 = np.ones(len_df)  #.astype(object)\n","    \n","    # ------------ wave_point ------------ #\n","    notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    short_open_res2 *= res_df['short_tc_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    long_open_res2 *= res_df['long_tc_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_point\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","    \n","    # ------ reject wave_update_hl ------ #\n","    notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    # short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    # long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co\n","\n","    # short_open_res1 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # long_open_res1 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # short_open_res2 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # long_open_res2 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    if show_detail:\n","      sys_log.warning(\"reject update_hl\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","\n","    # ------ wave_itv ------ #    \n","    if wave_itv1 != 'T':      \n","      wave_itv1_num = to_itvnum(wave_itv1)\n","      short_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1)\n","      long_open_res1 *= np_timeidx % wave_itv1_num == (wave_itv1_num - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"wave_itv1\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","    \n","    if wave_itv2 != 'T':\n","      wave_itv2_num = to_itvnum(wave_itv2)\n","      short_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1)\n","      long_open_res2 *= np_timeidx % wave_itv2_num == (wave_itv2_num - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"wave_itv2\")\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_mm ------ #\n","    wave_high_terms_cnt_fill1_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_terms_cnt_fill1_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    short_open_res1 *= (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","    long_open_res1 *= (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","\n","    # wave_high_terms_cnt_fill2_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # wave_low_terms_cnt_fill2_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    # short_open_res2 *= (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","    # long_open_res2 *= (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_mm\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_length ------ #\n","    if config.tr_set.wave_length1 != \"None\": \n","      short_wave_length_fill_ = res_df['short_wave_length_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      long_wave_length_fill_ = res_df['long_wave_length_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      short_open_res1 *= short_wave_length_fill_ >= config.tr_set.wave_length1\n","      long_open_res1 *= long_wave_length_fill_ >= config.tr_set.wave_length1\n","\n","      if show_detail:\n","        sys_log.warning(\"wave_length\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # ------ wave_spread ------ #\n","    if config.tr_set.wave_spread1 != \"None\":\n","      short_wave_spread_fill = res_df['short_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      long_wave_spread_fill = res_df['long_wave_spread_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      short_open_res1 *= short_wave_spread_fill >= config.tr_set.wave_spread1\n","      long_open_res1 *= long_wave_spread_fill >= config.tr_set.wave_spread1\n","\n","      if show_detail:\n","        sys_log.warning(\"wave_spread\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))      \n","\n","\n","    # ------------ 추세선 리스트 ------------ #\n","    # ------ ma & prev_low ------ #    \n","    # ma_period = 60\n","\n","    # short_prev_ma_ = res_df['short_ma_T{}_-1'.format(ma_period)].to_numpy()\n","    # long_prev_ma_ = res_df['long_ma_T{}_-1'.format(ma_period)].to_numpy()    \n","    \n","    # short_open_res1 *= short_prev_ma_ > roll_highs1[-1]  # Todo, index sync. 요망\n","    # long_open_res1 *= long_prev_ma_ < roll_lows1[-1]\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"ma & prev_low\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))     \n","\n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep1 ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","\n","        # ------ epbox as epg ------ #\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1     \n","\n","        # ------ tpbox as epg ------ #\n","        # p1_hlm 을 위해선, tp_0 를 기준할 수 없음 --> ep1 & ep2 를 기준으로 진행\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1      \n","        \n","        # ------ fibo_ep ------ #\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1    \n","                \n","    # ------ market_ep1 ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","    \n","    # ------ limit_ep2 ------ #   \n","    if config.ep_set.point2.entry_type == \"LIMIT\":\n","        epg2 = config.tr_set.ep_gap2\n","\n","        # ------ epbox as epg ------ #\n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","\n","        # ------ tpbox as epg ------ #\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","        \n","        # ------ fibo_ep ------ #\n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg2  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg2   \n","\n","    # ------ market_ep2 ------ #\n","    else: \n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","                \n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    if config.tr_set.check_hlm == 0:\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","    elif config.tr_set.check_hlm == 1:    # for p1_hlm\n","      # ------ irregular - next_fibo ------ #\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      short_next_fibo_outg = np.vectorize(get_next_fibo_gap2)(cu_wrr_32_)\n","      long_next_fibo_outg = np.vectorize(get_next_fibo_gap2)(co_wrr_32_)\n","\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * short_next_fibo_outg  # ep 와 마찬가지로, tpg 기준 가능\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * long_next_fibo_outg \n","\n","      # ------ ep1box as outg ------ #\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg \n","\n","      # ------ ep1box as outg for 1_tr ------ #\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * outg \n","      \n","      # ------ 1_tr - auto_calculation ------ #\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_{}'.format(selection_id)] + (res_df['short_ep1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_{}'.format(selection_id)].to_numpy())\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_{}'.format(selection_id)].to_numpy() - (res_df['long_tp_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_{}'.format(selection_id)].to_numpy())\n","\n","      # ------ tpbox as outg ------ #\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg \n","      \n","      # ------ fibo_out ------ #      \n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg  # ep 와 마찬가지로, tpg 기준 가능\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg \n","    \n","    else:  # p2_hlm\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * outg\n","\n","      # res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg   # p2's ep_box 를 out 으로 사용한다?\n","      # res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg     \n","      \n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    # ------ p1 point_validation ------ #\n","    short_open_res1 *= (short_tp_ < short_ep1_) & (short_ep1_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < short_out_ # res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) & (long_ep1_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation     \n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution    \n","    long_open_res1 *= close > long_out_ # res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution  \n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    # ------ p2 point_validation ------ # --> executed in en_ex_pairing() function.\n","    # short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    # short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    # long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out cannot be vectorized\n","    # long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban)\n","    # print(\"res_df['long_open1_{}'.format(selection_id)].to_numpy() :\", res_df['long_open1_{}'.format(selection_id)].to_numpy()) \n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","    \n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    \n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    if config.tr_set.check_hlm == 2:\n","      res_df['short_tr_{}'.format(selection_id)] = np.nan\n","      res_df['long_tr_{}'.format(selection_id)] = np.nan\n","    else:      \n","      res_df['short_tr_{}'.format(selection_id)] = abs(\n","          (short_ep1_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep1_ / short_out_ - config.trader_set.market_fee - 1))   # 이게 맞음, loss 의 분모 > 분자 & profit 의 분모 < 분자\n","      res_df['long_tr_{}'.format(selection_id)] = abs(\n","          (long_tp_ / long_ep1_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep1_ - config.trader_set.market_fee - 1))\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","metadata":{"id":"HuCb0phoPN83"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-DNPumVZi0xs"},"outputs":[],"source":["\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    \n","# ------------ csd ------------ #\n","    # ------ dc ------ #\n","    # dc_upper_ = res_df['dc_upper_T30'].to_numpy()    \n","    # dc_lower_ = res_df['dc_lower_T30'].to_numpy()    \n","\n","    # # Todo, post_cu ~ co 의 dc_lower == low (=touched) 여부 조사\n","    # short_open_idx1 = get_index_bybool(short_open_res1, len_df_range)\n","    # long_open_idx1 = get_index_bybool(long_open_res1, len_df_range)\n","    # wave_co_post_idx_fill_ = res_df['wave_co_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # wave_cu_post_idx_fill_ = res_df['wave_cu_post_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()   # co_prime_idx (wave_high 정보를 지정하기 위한 front co_idx 지정)\n","\n","    # # 1. dc_lower == low 여부 조사, np.nan 덕분에 vectorize 불가하다고 봄\n","    # short_valid_idx_bool = ~(pd.isnull(wave_co_post_idx_fill_) | pd.isnull(short_open_idx1)) # get_index_bybool\n","    # dc_upper_touch = dc_upper_ <= high\n","    # dc_upper_touch_span = np.full(len_df, np.nan)\n","    # dc_upper_touch_span[short_valid_idx_bool] = [dc_upper_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_co_post_idx_fill_, short_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # long_valid_idx_bool = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1)) # get_index_bybool\n","    # dc_lower_touch = dc_lower_ >= low\n","    # dc_lower_touch_span = np.full(len_df, np.nan)\n","    # dc_lower_touch_span[long_valid_idx_bool] = [dc_lower_touch[int(iin):int(iout) + 1].sum() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","\n","    # short_open_res1 *= dc_upper_touch_span == 0\n","    # long_open_res1 *= dc_lower_touch_span == 0\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"csd - dc\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","    #   # sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","    #   # sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))   \n","    \n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "]},{"cell_type":"markdown","metadata":{"id":"aTV4h3LjTZBp"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dc49JPmoTaPQ"},"outputs":[],"source":["\n","    \n","    csd_period = 40\n","    res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","    \n","    dc_upper_ = res_df['dc_upper_T{}'.format(csd_period)].to_numpy()    \n","    dc_lower_ = res_df['dc_lower_T{}'.format(csd_period)].to_numpy()  \n","\n","    short_open_res2 *= dc_upper_touch_span == 0\n","    long_open_res2 *= dc_lower_touch_span == 0\n","\n","    # ------ csdbox ------ # --> 결국 dc's upper & lower\n","    if show_detail:\n","      sys_log.warning(\"csdbox\")\n","      # sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      # sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","      \n","    # olds,\n","    # np.nan - np.nan = np.nan -> vectorize 가능할 것 => xx\n","    # 1. wave_high_prime_idx_ ~ long_open_idx1 의 valid(not_non) 한 idx 를 max_dc_lower 와 min_low 의 비교값으로 채워넣음\n","    # valid_idx = ~(pd.isnull(wave_cu_post_idx_fill_) | pd.isnull(long_open_idx1))\n","    # max_dc_lower_ = [dc_lower_[int(iin):int(iout)].max() for iin, iout in zip(wave_cu_post_idx_fill_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    # min_low = [low[int(iin):int(iout)].min() for iin, iout in zip(wave_high_prime_idx_, long_open_idx1) if not pd.isnull(iin) if not pd.isnull(iout)]\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","        # ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1658884054367,"user_tz":-540,"elapsed":4371,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","# from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        # h_candle_v3(df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        # h_candle_v3(df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        # h_candle_v3(df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","  \n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and \n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2) \n","    \n","    # ------------ wave_period1 ------------ #\n","    if to_itvnum(wave_itv1) > 1: \n","      offset = '1h' if wave_itv1 != 'D' else '9h'\n","      htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","      htf_df = wave_range_cci_v4(htf_df, wave_period1)\n","      \n","      # cols = list(htf_df.columns[-15:-4])  # except idx col\n","      cols = list(htf_df.columns[4:])  # 15T_ohlc 를 제외한 wave_range_cci_v4 로 추가된 cols, 다 넣어버리기 (추후 혼란 방지)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = wave_range_ratio_v4_3(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      cols += list(htf_df.columns[-4:])\n","\n","      # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","      res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","      res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=1), how='inner')\n","    else:\n","      res_df = wave_range_cci_v4(res_df, wave_period1)\n","      # res_df = wave_range_stoch_v1(res_df, wave_period1)\n","      # res_df = wave_range_dc_envel_v1(res_df, wave_period1)\n","\n","      valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)  # Todo, 갱신되는 high 의 last_high 를 추리기 위해 co_prime 사용함\n","      res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      \n","      res_df = wave_range_ratio_v4_3(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_wave_length(res_df,valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","      # res_df = tc_dc_base(res_df, wave_period2)\n","      res_df = tc_cci(res_df, wave_period2)\n","      # res_df = tc_cci_v2(res_df, wave_period2)\n","\n","      # ------ prev_low vs ma ------ #\n","      # ma_period = 60\n","      # res_df = ma(res_df, ma_period)\n","      \n","      # res_df['short_ma_T{}'.format(ma_period)] = res_df['ma_T{}'.format(ma_period)]\n","      # res_df['long_ma_T{}'.format(ma_period)] = res_df['ma_T{}'.format(ma_period)]\n","      \n","      # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'short_ma_T{}'.format(ma_period), roll_hl_cnt)   # Todo, for index sync.\n","      # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'long_ma_T{}'.format(ma_period), roll_hl_cnt)   # Todo, for index sync.\n","\n","    # ------------ wave_period2 ------------ #\n","    # if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","    #   assert wave_itv2 == 'T'      \n","      \n","      # res_df = wave_range_cci_v4(res_df, wave_period2)\n","\n","      # valid_co_prime_idx, valid_cu_prime_idx, roll_co_idx_arr, roll_cu_idx_arr = roll_wave_hl_idx_v5(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      # res_df = get_roll_wave_data_v2(res_df, valid_co_prime_idx, roll_co_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","      # res_df = get_roll_wave_data_v2(res_df, valid_cu_prime_idx, roll_cu_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","\n","      # res_df = wave_range_ratio_v4_3(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      \n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    # itv_list = ['15T', '15T', '15T', '15T']\n","    # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone1.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone1.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone1.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone1.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone1.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone1.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            # if op_idx1 >= 16353:\n","            #   print(\"high[16353], tp0 :\", high[16353], tp0)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면, \n","            # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","            # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                  (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                  idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:                                  \n","            # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","            # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave_gap * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave_gap * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #  # vectorize allow only for p1_hhm\n","    if config.loc_set.point1.short_tr_thresh != \"None\":  #  and not config.tr_set.check_hlm:\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point1\n","    if config.loc_set.point1.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point1.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point1.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point1.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point1.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point1.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point1.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point1.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #    \n","    if config.loc_set.point1.wrr_10 != \"None\":   # for excessive range rejection         \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_10_ = res_df['co_wrr_10_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_10_ = res_df['cu_wrr_10_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_10_ <= config.loc_set.point1.wrr_10\n","        # mr_res *= cu_wrr_10_ >= config.loc_set.point1.wrr_10\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_10_ <= config.loc_set.point1.wrr_10 : {:.5f} {:.5f} ({})\".format(cu_wrr_10_[c_i], config.loc_set.point1.wrr_10, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_10_ <= config.loc_set.point1.wrr_10\n","        # mr_res *= co_wrr_10_ >= config.loc_set.point1.wrr_10\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_10_ <= config.loc_set.point1.wrr_10 : {:.5f} {:.5f} ({})\".format(co_wrr_10_[c_i], config.loc_set.point1.wrr_10, mr_res[c_i]))\n","\n","    if config.loc_set.point1.wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point1.wrr_21\n","        # mr_res *= cu_wrr_21_ >= config.loc_set.point1.wrr_21\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point1.wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point1.wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point1.wrr_21\n","        # mr_res *= co_wrr_21_ >= config.loc_set.point1.wrr_21\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point1.wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point1.wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point1.wrr_32 != \"None\":            \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point1.wrr_32 #+ 0.1  # 0.1 0.05\n","        # mr_res *= (cu_wrr_32_ >= config.loc_set.point1.wrr_32) # & (cu_wrr_32_ <= 1)\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point1.wrr_32 - 0.1\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point1.wrr_32 #+ 0.1  # 0.1 0.05\n","        # mr_res *= (co_wrr_32_ >= config.loc_set.point1.wrr_32) # & (co_wrr_32_ <= 1)\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point1.wrr_32 - 0.1\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point1.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point1.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point1.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point1.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point1.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point1.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point1.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point1.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point1.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point1.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point1.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point1.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point1.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point1.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point1.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point1.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point1.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point1.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point1.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point1.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point1.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point1.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point1.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point1.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point1.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point1.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point1.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point1.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point1.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone1.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone1.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone1.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    if config.loc_set.zone1.use_zone:\n","\n","      # ------------ 추세선 리스트 on_price ------------ #\n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1      \n","      \n","      wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # ------ ma ------ #\n","      ma_period = 60\n","      # res_df = ma(res_df, ma_period)       \n","      ma_ = res_df['ma_T{}'.format(ma_period)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_fill1_ < ma_\n","        if show_detail:\n","          sys_log.warning(\"wave_high_fill1_ < ma_ : {:.5f} {:.5f} ({})\".format(wave_high_fill1_[c_i], ma_[c_i], mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_fill1_ > ma_\n","        if show_detail:\n","          sys_log.warning(\"wave_low_fill1_ > ma_ : {:.5f} {:.5f} ({})\".format(wave_low_fill1_[c_i], ma_[c_i], mr_res[c_i]))\n","        \n","        # ------ dc_base ------ #      \n","      # dc_base_ = res_df['dc_base_T100'].to_numpy()\n","\n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= wave_high_fill1_ < dc_base_\n","      #   if show_detail:\n","      #     sys_log.warning(\"wave_high_fill1_ < dc_base_ : {:.5f} {:.5f} ({})\".format(wave_high_fill1_[c_i], dc_base_[c_i], mr_res[c_i]))\n","      # else:\n","      #   mr_res *= wave_low_fill1_ > dc_base_\n","      #   if show_detail:\n","      #     sys_log.warning(\"wave_low_fill1_ > dc_base_ : {:.5f} {:.5f} ({})\".format(wave_low_fill1_[c_i], dc_base_[c_i], mr_res[c_i]))    \n","      \n","      # ------------ out_price ------------ #\n","        # ------ macd ------ #\n","      # # macd_ = res_df['macd_T535'].to_numpy()\n","      # macd_ = res_df['macd_hist_T53515'].to_numpy()\n","\n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= macd_ < 0\n","      #   if show_detail:\n","      #     sys_log.warning(\"macd_ < 0 : {:.5f} {:.5f} ({})\".format(macd_[c_i], 0, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= macd_ > 0\n","      #   if show_detail:\n","      #     sys_log.warning(\"macd_ > 0 : {:.5f} {:.5f} ({})\".format(macd_[c_i], 0, mr_res[c_i]))\n","\n","      # ------ bb_base uptrend ------ #\n","      # bb_base_T100 = res_df['bb_base_T100'].to_numpy()\n","      # b1_bb_base_T100 = res_df['bb_base_T100'].shift(1).to_numpy()\n","\n","      # lb_period = config.loc_set.zone1.bb_trend_period\n","      # bb_base_downtrend = pd.Series(b1_bb_base_T100 < bb_base_T100).rolling(lb_period).sum().to_numpy() == 0\n","      # bb_base_uptrend = pd.Series(b1_bb_base_T100 > bb_base_T100).rolling(lb_period).sum().to_numpy() == 0\n","\n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= bb_base_downtrend\n","      #   if show_detail:\n","      #       sys_log.warning(\"bb_base_downtrend : {:.5f} ({})\".format(bb_base_downtrend[c_i], mr_res[c_i]))       \n","      # else:\n","      #   mr_res *= bb_base_uptrend\n","      #   if show_detail:\n","      #       sys_log.warning(\"bb_base_uptrend : {:.5f} ({})\".format(bb_base_uptrend[c_i], mr_res[c_i]))    \n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone1.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone1.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":            \n","      wave_itv2 = config.tr_set.wave_itv2\n","      wave_period2 = config.tr_set.wave_period2\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","\n","    if config.loc_set.point2.csd_period != \"None\":\n","      wave_itv2 = config.tr_set.wave_itv2\n","      csd_period = config.loc_set.point2.csd_period\n","      \n","      res_df = dc_line_v4(res_df, res_df, dc_period=csd_period)\n","      dc_upper_ = res_df['dc_upper_{}{}'.format(wave_itv2, csd_period)].to_numpy()    \n","      dc_lower_ = res_df['dc_lower_{}{}'.format(wave_itv2, csd_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        csdbox = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","        mr_res *= dc_upper_ <= csdbox\n","        if show_detail:\n","            sys_log.warning(\"dc_upper_ <= csdbox : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], csdbox[c_i], mr_res[c_i]))\n","      else:\n","        csdbox = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.point2.csdbox_range\n","        mr_res *= dc_lower_ >= csdbox\n","        if show_detail:\n","            sys_log.warning(\"dc_lower_ >= csdbox : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], csdbox[c_i], mr_res[c_i]))\n","\n","    # ============ zone ============ #    \n","    # ------------ 추세선 리스트 on_price ------------ #\n","    if config.loc_set.zone2.use_zone:\n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1      \n","      \n","      wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","        # ------ ma ------ #\n","      ma_period = 60\n","      # res_df = ma(res_df, ma_period)       \n","      ma_ = res_df['ma_T{}'.format(ma_period)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_fill1_ < ma_\n","        if show_detail:\n","          sys_log.warning(\"wave_high_fill1_ < ma_ : {:.5f} {:.5f} ({})\".format(wave_high_fill1_[c_i], ma_[c_i], mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_fill1_ > ma_\n","        if show_detail:\n","          sys_log.warning(\"wave_low_fill1_ > ma_ : {:.5f} {:.5f} ({})\".format(wave_low_fill1_[c_i], ma_[c_i], mr_res[c_i]))\n","\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","metadata":{"id":"EQ63Jwpvr7qA"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"csZwxsP5r_Pz"},"outputs":[],"source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":8,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1658884054368,"user_tz":-540,"elapsed":5,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_48\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 1e-10,\n","    \"market_fee\": 1e-10,\n","    \"initial_asset\": 24500,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 50, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"wrr_10\": \"None\",\n","      \"wrr_21\": \"None\",\n","      \"wrr_32\": 0.3,\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"wrr_32\": \"None\",\n","      \"csdbox_range\": 0.3,\n","      \"csd_period\": \"None\"\n","    },\n","    \"zone1\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    },\n","    \"zone2\": {\n","      \"use_zone\": 0\n","    }\n","  },\n","  \"tr_set\": {\n","    \"check_hlm\": 0,\n","    \"wave_itv1\" : \"T\",\n","    \"wave_period1\": 20,\n","    \"wave_length1\": \"None\",\n","    \"wave_spread1\": \"None\",\n","    \"wave_itv2\" : \"T\",    \n","    \"wave_period2\": 20,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\" : 0,\n","    \"p2_box_k2\" : 0,\n","    \"p1p2_low\": 0.0,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.12,\n","    \"ep_gap2\": -0.12,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 30000\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"static_lvrg\": 1,\n","    \"leverage\": 5,\n","    \"target_pct\": 0.03,\n","    \"allow_float\": 0,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","metadata":{"id":"MuD_2vY7TI_8"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"EKag94Y2TMCO"},"outputs":[],"source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":11,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":655,"status":"ok","timestamp":1658884119156,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"qBJfPsmJzVIr","outputId":"b692c674-4025-445a-9099-a248402b4ca4"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_48\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"wrr_10\": \"None\",\n","  \"wrr_21\": \"None\",\n","  \"wrr_32\": 0.3,\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"wrr_32\": \"None\",\n","  \"csdbox_range\": 0.3,\n","  \"csd_period\": \"None\"\n"," },\n"," \"zone1\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," },\n"," \"zone2\": {\n","  \"use_zone\": 0\n"," }\n","} {\n"," \"check_hlm\": 0,\n"," \"wave_itv1\": \"T\",\n"," \"wave_period1\": 20,\n"," \"wave_length1\": \"None\",\n"," \"wave_spread1\": \"None\",\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 20,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"p1p2_low\": 0.0,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.12,\n"," \"ep_gap2\": -0.12,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 30000\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"static_lvrg\": 1,\n"," \"leverage\": 5,\n"," \"target_pct\": 0.03,\n"," \"allow_float\": 0,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","# ------ p1_hhm 의 경우 out_box 를 위해 wave_itv 1 & 2 를 동일하게 설정해야함 ------ #\n","# config_list[0].tr_set.wave_itv1 = 'T'\n","# config_list[0].tr_set.wave_period1 = 20 \n","config_list[0].tr_set.wave_itv2 = 'T'\n","config_list[0].tr_set.wave_period2 = 20"]},{"cell_type":"code","execution_count":12,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2872,"status":"ok","timestamp":1658884125729,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"8b1df5fd-787d-45aa-d432-bb94d8f7168a"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 1.149094820022583\n","make data_list elapsed time : 0.00016880035400390625\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":13,"metadata":{"id":"_iYcJk8nK8Yq","executionInfo":{"status":"ok","timestamp":1658884133747,"user_tz":-540,"elapsed":1169,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit utils config ------ #\n","config_list[0].tr_set.check_hlm = 0\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].pos_set.long_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","config_list[0].tr_set.wave_length1 = \"None\"  # \"None\" 15 110 0 \n","# config_list[0].tr_set.wave_spread1 = \"None\"  # \"None\" 15 110 0 \n","# config_list[0].tr_set.wave_greater1 = 0  # 0 50 \n","# config_list[0].tr_set.wave_greater2 = 0  # 10\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","config_list[0].ep_set.entry_type = \"MARKET\" # \"LIMIT\" # \"MARKET\"\n","config_list[0].ep_set.point2.entry_type = \"MARKET\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","config_list[0].tr_set.ep_gap1 = -0.12 # -0.618 -0.23 -0.382 0.19 0.8 -0.12 -0.26\n","# config_list[0].tr_set.ep_gap2 = -0.12 # -0.618 -0.23 -0.382 0.19 \n","# config_list[0].tr_set.out_gap = 0.0  # 0 -0.35\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.0\n","# config_list[0].tr_set.bias_info_tick = 30000\n","# config_list[0].trader_set.limit_fee = 1e-10\n","# config_list[0].trader_set.market_fee = 1e-10\n","# config_list[0].trader_set.limit_fee = 0.0002\n","# config_list[0].trader_set.market_fee = 0.0004\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":14,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1658884135489,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"ca855d72-b160-448b-9bd3-058070220564"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 42048\n","np.sum(long_open_res1 == 1) : 42240\n","np.sum(short_open_res2 == 1) : 42240\n","np.sum(long_open_res2 == 1) : 42048\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 40427\n","np.sum(long_open_res1 == 1) : 40130\n","wave_mm\n","np.sum(short_open_res1 == 1) : 40425\n","np.sum(long_open_res1 == 1) : 40128\n","point validation\n","np.sum(short_open_res1 == 1) : 28319\n","np.sum(long_open_res1 == 1) : 28683\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.2772085666656494\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":15,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1658884138268,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.wrr_10 = \"None\" # \"None\" 0.3\n","config_list[0].loc_set.point1.wrr_21 = \"None\" # \"None\" \n","config_list[0].loc_set.point1.wrr_32 = 0.3 # \"None\" 1 0.5 0.482 0.302\n","config_list[0].loc_set.point2.wrr_32 = \"None\" # \"None\" 1 0.5 0.382 0.302 0.25\n","config_list[0].loc_set.point2.csd_period = \"None\"  # \"None\" 100\n","config_list[0].loc_set.zone1.use_zone = 0\n","config_list[0].loc_set.zone1.bb_trend_period = 150\n","# config_list[0].loc_set.zone1.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","config_list[0].loc_set.zone2.use_zone = 0\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = 0.2  #  \"None\" 2 0.8 ## 0.7\n","# # config_list[0].loc_set.zone1.base_roll_period = 60"]},{"cell_type":"code","execution_count":16,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2080,"status":"ok","timestamp":1658884140343,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","outputId":"03dc9c4b-bece-474f-c303-04c76d8cb796"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.1406283378601074\n","get_open_info_df elapsed time : 1.1954741477966309\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","config_list[0].tr_set.p2_box_k1 = 0.0  # 0 ~ 1 사이 값 사용 tp_1 로부터 떨어지는 거리\n","config_list[0].tr_set.p2_box_k2 = 0.0  # 0.5 0 --> \"None\" 불가, 0 ~ 1 사이 값 사용 tp_0 로부터 떨어지는 거리, 본디 p2_box 는 p1_box 내부에 존재해야, 정확한 hhm 이 측정가능해짐\n","config_list[0].tr_set.p1p2_low = 0.5  # 0.5 0.7 0  0 is equal to \"None\", 마찬가지로 tp_0 로부터 떨어지는 거리\n","config_list[0].loc_set.point2.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point2.long_tr_thresh = 2  #  \"None\" 2 0.8 ## 0.7\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","config_list[0].lvrg_set.static_lvrg = 1\n","config_list[0].lvrg_set.leverage = 1\n","config_list[0].lvrg_set.target_pct = 0.03 # 0.1 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_bias_arr, short_net_p1_bias_tick, short_p2exec_p1_bias_tick, short_net_p1_idx_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_bias_arr, long_net_p1_bias_tick, long_p2exec_p1_bias_tick, long_net_p1_idx_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":681},"id":"TvGs5mBxsuBK","executionInfo":{"status":"ok","timestamp":1658886606674,"user_tz":-540,"elapsed":3424,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"84d8e24e-fa6a-426f-f59c-839d8cd5ac0a"},"execution_count":30,"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.6355669498443604\n","short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick : 129.93051359516616 116.48041775456919 129.93051359516616 116.48041775456919\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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bNkyu3btmuXn55t0/eP/VqxYYWZmV69etRMnToTeBw8aNMjMzFJTU0PtTZkyxaqqqtr93BGEPJAAQXgmlixZYmvXrjVJtnfv3tAboocfftiuXr1qFy9eDMXly5dDBW/o0KG2detWq62ttfr6erty5Yp98sknoXbNzL7zne+0SY7xTMz++te/tn/9619R15eXl9vjjz9+w2PyzjvvRFwXCASssbHR7r777nY/dwRBEIS3w6s19qWXXrIXXngh9DjWxOzIkSPNzOwHP/hBaNmzzz7b7E2sdOOJ2cceeyzqm8F+/frZ559/bkuXLm33c0YQBEH4I7xaYydPnmx1dXU2ZswY69Kli917771WU1NjI0aMiPm8SBOz0vW/ci0uLra6ujpbsWKFFRcX2+zZs02S/eY3v7HPPvvMMjIyLCkpyebOnWsnTpyw7t27h/5i1vnZtj/96U/5i1nCK9HuCRCEZyIjI8MuXrxo3/ve9+zSpUuh/64xfvx4Ky8vj/q8nTt32h/+8Afr1auXSdf/pXHPnj2h9W35uazxTMweO3bMnnjiiYjrvv/971tjY2Mo52ixePFi27RpU8R1gUDAGhoa7J577mn3c0cQBEF4O7xaYw8dOmTnz5+32tpaq62tta+++souXLhgixcvbrFt9+7d7csvv2z2hZqLFi2Ke2J2x44dtnz58hbL09PTrbCw0H7729+2+/kiCIIg/BNerbHPPfdcixq5efNme+6552I+L9rErDPS0tKsoaHBsrOzTZJt3bo19LEGwbh48aKNGTPGpOufMRv8q2JJtnz5cj5jlvBEBAQgpLq6WgUFBfr73/+uTZs26csvv5QkHThwQA0NDVq8eLG6deumQCCg7373u7r33nslSb1799bly5fV2Nio7OxsPfnkk22eW0pKilJTU1v8Hs2ECROUkZGhjRs3Rlw/d+5cbdq0SY2Njc2Wz5w5U+np6ZKknJwcPf3003rvvfckScOHD9eIESMUCATUs2dP/fGPf1R1dbVKS0tvdfcAAB2cV2vs5MmTdffdd2vkyJEaOXKkampq9Itf/EKvvfZai23/+9//6q233tLixYvVq1cvZWRkaMGCBXr//fdD26SmpoZqtPP3oIyMDE2aNEl/+9vfmi3v3bu3tm/frs8++0zPP/98m+4jAKBj82qNLSgoUG5urkaMGCFJGjlypHJzc3Xk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\n"},"metadata":{}},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 1.5663554668426514\n"]}]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8lYgsqH-rfAM"},"outputs":[],"source":["# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(OrderSide.SELL, ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(OrderSide.BUY, ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ # --> 추후, outg 로 tp_gap / out_gap custom 여부를 위해, 본 cell 을 지우지 않음\n","short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","metadata":{"id":"tOFkzUX2imQu"},"source":["#### consecutive dur. value survey on bias"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CgvSrXaZEkMZ"},"outputs":[],"source":["res_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","devided_cols.append('wave_length_fill_{}{}'.format(wave_itv1, wave_period1))\n","devided_cols.append('wave_spread_fill_{}{}'.format(wave_itv1, wave_period1))\n","\n","wave_itv1 = 'T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":4479,"status":"ok","timestamp":1658034578976,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"Sahvc-R0jD1A","outputId":"d8b458c5-24c9-40d3-cc1d-5672d1432ae9"},"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1800 with 20 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAAA1AAAAV+CAYAAAB4bd9NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzde3wU9b3/8XcSEkAJBIjckpBEJQjqAdQEbNEgWCFtITzAIqIlaBq0Pdja+ivgpRIOtoI9PdQ+itQTKUYEIuKFWG+gXIoX6CpBCOGSQIxJIOEWIBAuIXx/f1j2GEjILMnu7OX19PF9PNzd78x85sswHz4735kNkmQEAAAAAGhSsN0BAAAAAICvoIACAAAAAIsooAAAAADAIgooAAAAALCIAgoAAAAALKKAAgAAAACLKKAAAAC8VHFxsYYNG2Z3GAC+gwIK+LcZM2Zo0aJFdocBAIBXMMbommuuuaxlY2NjZYxRdXW1sz311FOWl+/YsaP279+v9evXO9+bMGFCvfWdOHFCxhjddNNNlxUjcLkooAA3WbhwoWbNmmWpb3O/YTTG6Pjx486kkpWVZXnZ0NBQFRQUqLS01Pne4MGD6yWp6upqGWM0ZsyYy44RAOBfQkJCmuwTERGh8PBwhYeH65lnnrG87jlz5mj79u313luyZIlzXeHh4frFL36h3bt3a9OmTS7HDjQHBRTgBsHBLftXy0qS6tevnzOpZGRkWF73b3/7Wx04cKDee5988km9JPXjH/9Y1dXV+uCDD1yOHQDQfGFhYZo7d67Ky8tVXl6uuXPnKiwsTJKUnJys0tJS/eY3v1FlZaX27t2rSZMmOZft1KmTcnNzdfToUf3rX//SrFmz6l3Zaci6deskSV999ZWqq6s1btw453amTp2qffv2aeHChW7Z11tvvVU33HBDk+tPS0vTK6+84pYYgEuhgEJAmjp1qsrKynTs2DHt2LFDQ4cOlfRtgsrOztaxY8eUn5+vm2++2bnMddddpzVr1qiqqkr5+fkaOXKk87OFCxfqhRde0Lvvvqvjx48rPT1d9913n6ZOnarq6mrl5uY2Gssrr7yinj176p133lF1dbV++9vfOqc+PPjggyopKdHq1avdMg5xcXG6//779eyzz16yX1pampYvX66amhq3xAEAuLQnn3xSgwYNUv/+/dWvXz8lJSXVmxLXrVs3dejQQVFRUUpPT9e8efMUEREhSZo3b55OnDihbt26KS0tTWlpaU1uLzk5WdL/fTm3bNky53Y6deqk2NhYTZ48ucn1lJSUqLS0VH//+9/VuXPnJvsHBwfrr3/9q6ZMmSJjTKP9evbsqdtvv50CCrYxNFogtYSEBPPNN9+Y7t27G0kmNjbWXH311WbGjBnm5MmTJiUlxQQHB5s//OEP5vPPPzeSTKtWrUxhYaF5/PHHTWhoqLnjjjvMsWPHTEJCgpFkFi5caI4cOWK+973vmaCgINO6dWuzcOFCM2vWLEsxFRcXm2HDhjlfx8bGGmOMyc7ONldccYVp06bNJZc3xpjy8nKzb98+88Ybb5jY2FhL233nnXfM6NGjTXJysiktLW2wzxVXXGGOHTtmkpOTbf+zo9FotEBr5/NDUVGRSUlJcb5/1113meLiYiPJJCcnm5qaGhMSEuL8vLKy0gwcONAEBwebM2fOOPOVJDNr1iyzfv36JrdtjDHXXHON83VycrI5ffq0ad26dZPLXnnllebmm282ISEhpkuXLub11183H3zwQZPLPfroo+aFF14wkkxaWlqjcT711FNmzZo1tv/50AKzcQUKAaeurk6tW7dW37591apVK5WUlGjPnj2Svp269v777+vcuXNatGiR+vXrJ0kaNGiQ2rVrp9mzZ6u2tlZr1qzRP/7xD917773O9a5YsUKfffaZjDE6ffp0i8SamZmpmpoanTp16pL9br/9dsXFxem6667T3r179Y9//KPJaX+jR49WSEiI3n777Uv2GzNmjA4ePOiczgEA8LwePXqopKTE+bqkpEQ9evRwvj506JDq6uqcr2tqatSuXTtdddVVCg0NrXef63f/31UHDhywlONOnDihL7/8UnV1ddq/f7+mTJmi4cOHq127do0u0717d/3yl7/Uk08+2eT6J06cqOzsbJdiB1oKBRQCzu7du/Xoo48qMzNT+/fv19KlS9W9e3dJUkVFhbNfTU2N2rZtq5CQEPXo0UOlpaX1phOUlJQoKirK+bo5CakxVte5fv161dbW6ujRo/rVr36l+Ph49enTp9H+V1xxhZ577jn98pe/bHLdzDEHAPvt3btXsbGxztc9e/bU3r17m1zuwIEDqq2tVXR0tPO9mJiYy47jUtPqrCx3qXuEk5KS1L17dxUUFGjfvn16/vnnlZSUpH379tVb7nvf+5569Oih5cuXX1YsQHNRQCEgLV26VLfddpvzXqM5c+Zcsv/evXsVExOjoKAg53s9e/ZUeXm58/WFScWVJNNY3+Ykqu/GeqFevXopLi5O69ev1759+/Tmm2+qe/fu2rdvX70EHR0drSFDhlBAAYDNli5dqqeeekqRkZHq3Lmznn76ab366qtNLnfu3Dm9+eabyszMVNu2bdW7d29NnDjR0jYrKip09dVXX1a8SUlJSkhIUFBQkDp16qS//OUvWrNmjY4dO9boMu+//77i4uLUv39/9e/fX08//bTy8vLUv39/nTt3ztkvLS1Nb7zxho4fP35ZsQHNRQGFgJOQkKA77rhDYWFhOnXqlE6ePFnvxNyQjRs3qqamRlOnTlWrVq2UnJyskSNHKicnp9FlKisrLSceV/peqG/fvurXr5+Cg4N15ZVX6k9/+pPKy8svevzrd+Xn5ysmJsaZpH72s5+psrJS/fv3r3fV66c//ak+++wz5xRHAIA9nnnmGX3xxRfasmWLtm7dqk2bNll+LPiUKVPUoUMHVVRUaNGiRVq6dKmlaXiZmZnKzs5WVVWVfvKTn7gU79VXX60PPvhA1dXVys/P1+nTp+tNe2/ImTNnVFlZ6WxHjx5VbW2tKisrnX1at26tcePGMX0PtrP9RiwazZPtxhtvNBs3bjTHjh0zhw4dMu+8847p3r27mTFjhlm0aJGz3/kHOZy/Kbdv375m7dq15siRI2bbtm1m9OjRzr4NPTDi2muvNXl5eaaqqsq89dZbl4xp1KhRpqSkxFRVVZnHHnvsom1fqt1xxx1mx44d5vjx46aystK89dZb5tprr3VpTBp7iMT27dvNgw8+aPufGY1Go9Fars2ePdu8/PLLtsdBo/lqC/r3/wAAAMAP9e7dW2FhYdq6dasSExP13nvv6Wc/+5lWrFhhd2iAT2IKHwAAgB8LDw/Xm2++qRMnTui1117Tn/70J61YsUKDBw9WdXV1g82Kxx9/vMFl33vvvUsu19g2Bw8e3BK7C7gdV6AAD4iJiVFBQUGDn/Xt27fJp+1NmDBBL7744kXvl5SU6IYbbmh0ufz8/HoPhTjvoYce0pIlS5qIGgAAABeigAIAAAAAi5jCBwAAAAAWtbI7gJa0f//+er/SDQDwvNjYWHXp0sXuMLwSeQoA7NfcPOVXBVRJSYkSExPtDgMAAprD4bA7BK9FngIA+zU3TzGFDwAAAAAsooACAAAAAIsooAAAAADAIr+6BwoALqm9pLAL3jsj6ZgNsQAA4I0uzJXkyYtQQAEIHGGS3r/gvRQ7AgEAwEtdmCvJkxdhCh8AAAAAWEQBBQAAAAAWMYUPAJqL+eIAAAQMrkABQHOdny9+vl34oAr4heDgYG3atEnvvPOOJCkuLk4bNmxQYWGhcnJyFBoaanOEAABPoIACAMCCX/3qV9q+fbvz9Zw5czR37lz16tVLVVVVSk9PtzE6AICnUEABANCEqKgo/ehHP9JLL73kfG/o0KFavny5JCk7O1ujR4+2KzwAsEd7SZHfae1bqK+X4x4oAACa8Oc//1lTp05VeHi4JKlz5846cuSI6urqJEllZWWKioqyM0QA8DxXHnnuR49H5woUAACX8KMf/Uj79+/Xpk2bLmv5jIwMORwOORwORUZGtnB0AABP4woUAACX8P3vf1+jRo3SD3/4Q7Vp00bt27fX888/r4iICIWEhKiurk7R0dEqLy9vcPmsrCxlZWVJkhwOhydDBwC4AVegAAC4hCeeeEIxMTGKj4/X+PHjtXr1at1///1as2aN7r77bklSWlqaVqxYYXOkAABPoIACAOAyTJs2Tb/5zW9UWFiozp07a8GCBXaHBADwAKbwAQBg0bp167Ru3TpJUnFxsQYOHGhzRAAAT6OAAgAAALxBe138Y+xnJB1r4fW2xDrdxV1j0IIooADAH/hScgQANOzCR31LLfO4b196hLi7xqAFUUABgD/wpeQIAIAP4yESAAAAAGARBRQAAAAAWEQBBQAAAAAW2V5ARUdHa/Xq1dq2bZvy8/P1y1/+UpLUsWNHrVy5Urt27dLKlSsVERFhc6QAAAAAAp3tBdTZs2f12GOP6frrr9egQYP0n//5n+rTp4+mT5+ujz/+WAkJCfr44481ffp0u0MFAAAAvtVeUuR3Wnt7w4Hn2F5AVVRUKC8vT5J0/Phxbd++XVFRUUpNTVV2drYkKTs7W6NHj7YzTAAAAOD/nH/66fl24W8XwW951WPMY2NjNWDAAG3cuFFdu3ZVRUWFpG+LrK5duza4TEZGhiZPnixJioyM9FisAAAAAAKP7Vegzrvyyiv1xhtv6NFHH1V1dfVFnxtjGlwuKytLiYmJSkxM1MGDB90dJgAAAIAA5hUFVKtWrfTGG29o8eLFeuuttyRJlZWV6tatmySpW7du2r9/v50hAgAAwN9xXxMs8IoCasGCBdq+fbvmzp3rfC83N1dpaWmSpLS0NK1YscKu8AAAABAIuK8JFth+D9T3v/99TZw4UVu2bHE+TOKJJ57Q7NmztWzZMqWnp6ukpETjxo2zOVIA8APtdfE/CM5IOmZDLAAA+CDbC6hPP/1UQUFBDX525513ejgaAPBz579d/a4UOwIBADQLX4jZxium8AEA4K1at26tjRs3avPmzcrPz1dmZqYkKS4uThs2bFBhYaFycnIUGhpqb6AAAsuF0w2ZcugxFFAAAFzC6dOnNXToUPXv31/9+/fXiBEjNHDgQM2ZM0dz585Vr169VFVVpfT0dLtDBQB4AAUUAABNOHHihCQpNDRUoaGhMsZo6NChWr58uSR+8B0AAgkFFAAATQgODlZeXp7279+vVatWaffu3Tpy5Ijq6uokSWVlZYqKimpw2YyMDDkcDjkcDn7wHQD8AAUUAABNOHfunAYMGKDo6GglJSXpuuuus7wsP/gOAP7F9qfwAQDgK44ePao1a9bo1ltvVUREhEJCQlRXV6fo6GiVl5fbHR5wsQuf1BaIT2ljDNDCuAIFAJ7Er9z7nMjISHXo0EGS1KZNG/3gBz/Q9u3btWbNGt19992S+MF3eDF+GJYxQIvjChQAeNKFv8PEbzB5ve7duys7O1shISEKDg7WsmXL9O6776qgoEA5OTl65plnlJeXpwULFtgdKgDAAyigAAC4hK1bt+qmm2666P3i4mINHDjQhojgl/hRVP/GNEK/QgEFAABgtwuvTktcofYnzD7wKxRQAJqHb9Xch7EF4K3sPj9xxQ42ooAC0Dx8q+Y+jC0Ab2X3+YkrdrART+EDAAAAAIsooAAAAADAIgooAAAAALCIAgoAAAAALKKAAgAAAACLeAofAAAA3MfuR54DLYwCCoB3ciXhkpwBwHvZ/chzoIVRQAHwTq4kXJIzAADwEO6BAgAAAACLKKAAAAAAwCKm8AG42IX3FEmBd18RYwAAnsV5Fz6CAgrAxS68p0gKvPuKGAP8W3R0tF555RV17dpVxhj97//+r/7yl7+oY8eOeu211xQXF6evv/5a48aN05EjR+wOF/BdnHfhI5jCBwDAJZw9e1aPPfaYrr/+eg0aNEj/+Z//qT59+mj69On6+OOPlZCQoI8//ljTp0+3O1QAgAdQQAG+rr2kyO+09vaGc0m+FCvwbxUVFcrLy5MkHT9+XNu3b1dUVJRSU1OVnZ0tScrOztbo0aPtDBMA4CFM4QN8nS89wtuXYgUaEBsbqwEDBmjjxo3q2rWrKioqJH1bZHXt2rXBZTIyMjR58mRJUmRkpMdiBQC4B1egAACw4Morr9Qbb7yhRx99VNXV1Rd9boxpcLmsrCwlJiYqMTFRBw8edHeYAAA3o4ACAKAJrVq10htvvKHFixfrrbfekiRVVlaqW7dukqRu3bpp//79doYIAPAQCigAAJqwYMECbd++XXPnznW+l5ubq7S0NElSWlqaVqxYYVd4AAAP8ooCasGCBaqsrNTWrVud73Xs2FErV67Url27tHLlSkVERNgYIQAgUH3/+9/XxIkTNXToUOXl5SkvL08pKSmaPXu2fvCDH2jXrl268847NXv2bLtDBQB4gFcUUC+//LJGjBhR7z0eDwsA8AaffvqpgoKC1K9fPw0YMEADBgzQ+++/r8OHD+vOO+9UQkKCfvCDH6iqqsruUAEAHuAVBdT69et1+PDheu/xeFgAAAAA3sZrH2PO42HRotrr20dof9cZScdsiAX4jvZHODQBAPAlXltAXehSj4fNysqSJDkcDk+GBF9y4e8PSfwGEbxC2DkOTQAAfIlXTOFrCI+HBQAA8KD2kiK/09rbGw7grby2gOLxsAAAAB50frbG+Xbh/GIAkrxkCt+SJUs0ZMgQRUZGqrS0VDNmzNDs2bO1bNkypaenq6SkROPGjbM7TOBiF95bdambV1zp6w7cBwYAANBsXlFATZgwocH377zzTg9HArjownurLnXziit93YH7wADA89zx5RlfiAG28ooCCgAAwC+548szvhADbEUBBQAAYPc0awA+gwIKuBBTIwAg8Ng9zRqAz6CAAi7E1AgA8F7e8CUXV6uAgEYBBQAAfIc3fMnF1SogoHnt70ABAAAAgLfhChQAAPBPTLUD/EL7I971V5krUAAANGHBggWqrKzU1q1bne917NhRK1eu1K5du7Ry5UpFRETYGCEadH6q3fl24b1TAHxC2Dnv+qtMAQUAQBNefvlljRgxot5706dP18cff6yEhAR9/PHHmj59uk3RtYD2kiK/09rbGw6Ay9P+CH+VPYECCgCAJqxfv16HDx+u915qaqqys7MlSdnZ2Ro9erQdobUMrtQAfsHbrtT4K+6BQn3e8HhYMG8fDfK2OeCBrmvXrqqoqJAkVVRUqGvXrg32y8jI0OTJkyVJkZGRHosPAOAeFFCozxseDwsekYsGnf9m8TwOC+9ijGnw/aysLGVlZUmSHA6HJ0MCALgBU/gAALgMlZWV6tatmySpW7du2r9/v80RAQA8gQIKAIDLkJubq7S0NElSWlqaVqxYYXNEAGCvQHmIBVP44Nu4VwhoEPdLtawlS5ZoyJAhioyMVGlpqWbMmKHZs2dr2bJlSk9PV0lJicaNG2d3mABgq0CZak4BBd/GvUJAgwIliXnKhAkTGnz/zjvv9HAkAOBZF34hJ7XMl3K+/EUfBRQAAACABl34hZzUMl/K+fIXfRRQAAAA8Eq+dJXCl2OVvDteb0MBBQAWWU2OvpaYfCnpAwgsvnSVwpdjlbw7Xm9DAQUAFllNjr6WmHwp6cML8PAewKP4ksv7UEABAADreHgP4FF8yeV9+B0oAAAAALCIK1C4fO6axhEg00NcuU+Gy/eujQHjBXgJq+fzC/tdqi/QTL52nyq8DwUULp+7pnEEyPQQV+6T4fK9a2PAeAFewur5/MJ+l+oLNJOv3acK70MBBQCAPwqQq/n+zB1X0/lRVNdwtQoNoYACAMAfBcjVfH/mjqvp/Ciqa7hahYZQQH0Xc7Ddh29CvZLd3xjyzR4AT+LqC4CWQAH1XczBdh++CfVKdn9jyDd7ADyJqy8AWgKPMQcAAAAAi7gC5Ql2T1/zwqmJ3jB1y18fi+2uWK2u1xv+bF3hS3+2QEPn8/ZVUljd/73mGPZunHPsz1PewJdixcW8uoAaPny4nn/+eYWEhOill17SnDlz7A7p8tg9fc0LpyZ6w9Qtf30strtitbpeb/izdYUv/dnCO3k0VzVwPg8byDHsSzjn2J+nvIEvxYqLeW0BFRwcrHnz5ukHP/iBysrK5HA4lJubq+3bt9sdGgAAkshV7mT3N/S+djXdHRgDoGFeW0AlJSWpqKhIxcXFkqScnBylpqaSlAAAXoNc5T52f0Pva1fT3YExABoWJMnYHURDxo4dqxEjRigjI0OSdP/992vgwIF65JFH6vXLyMjQ5MmTJUm9e/fWzp07La0/MjJSBw8ebNmg/Qxj1DTGyBrGqWn+NEaxsbHq0qWL3WF4hJVcdbl56rv86fhwN8bKGsbJGsbJGl8bp+bmKa+9AmVVVlaWsrKyXF7O4XAoMTHRDRH5D8aoaYyRNYxT0xgj/3W5eeq7OD6sY6ysYZysYZysCbRx8trHmJeXlysmJsb5Ojo6WuXl5TZGBABAfeQqAAg8XltAORwO9erVS3FxcQoNDdX48eOVm5trd1gAADiRqwAg8IRIyrQ7iIYYY1RYWKjFixfrkUce0auvvqo333yzRbexadOmFl2fP2KMmsYYWcM4NY0x8j2eyFXncXxYx1hZwzhZwzhZE0jj5LUPkQAAAAAAb+O1U/gAAAAAwNtQQAEAAACARX5ZQA0fPlw7duxQYWGhpk2bdtHnYWFhysnJUWFhoTZs2KDY2FjnZ9OnT1dhYaF27Nihu+66y5Nhe9TljlFsbKxqamqUl5envLw8zZ8/39Ohe0xTY3Tbbbfpyy+/VG1trcaOHVvvs4kTJ2rXrl3atWuXJk6c6KmQPa45Y3T27FnncbRixQpPhexxTY3Rr3/9a23btk1fffWVPvroI/Xs2dP5WaAcR4GOnGUNecsacpd15DBryGMNM/7UgoODTVFRkYmPjzehoaFm8+bNpk+fPvX6/PznPzfz5883ksw999xjcnJyjCTTp08fs3nzZhMWFmbi4uJMUVGRCQ4Otn2fvGmMYmNjzdatW23fB28Yo9jYWHPjjTea7OxsM3bsWOf7HTt2NLt37zYdO3Y0ERERZvfu3SYiIsL2ffKmMZJkqqurbd8HbxijIUOGmLZt2xpJ5uGHH3b+XQuU4yjQGznL/eMUKHnL6jgFeu5qibGSAiOHWR2nQMxjfncFKikpSUVFRSouLlZtba1ycnKUmppar09qaqqys7MlScuXL9ewYcOc7+fk5OjMmTP6+uuvVVRUpKSkJI/vg7s1Z4wChZUxKikp0datW3Xu3Ll67w8fPlyrVq1SVVWVjhw5olWrVmnEiBGeDN8jmjNGgcLKGK1du1YnT56UJG3YsEHR0dGSAuc4CnTkLGvIW9aQu6wjh1lDHmuY3xVQUVFRKi0tdb4uKytTVFRUo33q6up09OhRde7c2dKy/qA5YyRJ8fHx2rRpk9auXavBgwd7LnAPas6xwHFkTZs2beRwOPT5559fdDL2F66OUXp6ut5///3LWha+iZxlDXnLGnKXdeQwa8hjDWtldwDwLfv27VPPnj11+PBh3XTTTXr77bd1/fXXq7q62u7Q4GNiY2O1d+9excfHa/Xq1dq6dav27Nljd1i2ue+++3TLLbcoOTnZ7lAAv0LegjuQwy4WSHnM765AlZeXKyYmxvk6Ojpa5eXljfYJCQlRhw4ddOjQIUvL+oPmjNGZM2d0+PBhSd/+YNru3buVkJDgueA9pDnHAseRNXv37pUkFRcXa+3atRowYECLx2g3q2M0bNgwPfnkkxo1apTOnDnj0rLwbeQsa8hb1pC7rCOHWUMea5ztN2K1ZAsJCTG7d+82cXFxzpvd+vbtW6/PL37xi3o3mr722mtGkunbt2+9G3J3797tlzfkNmeMIiMjnWMSHx9vysrKTMeOHW3fJzvG6HxbuHDhRTfi7tmzx0RERJiIiAizZ88exuiCMYqIiDBhYWFGkuncubPZtWvXRTel+kOzMkb9+/c3RUVF5tprr633fqAcR4HeyFnuH6dAyVtWx+l8C9Tc1RJjFSg5zOo4BWgesz2AFm8pKSlm586dpqioyDzxxBNGkpk5c6YZOXKkkWRat25tli1bZgoLC83GjRtNfHy8c9knnnjCFBUVmR07dpgRI0bYvi/eNkZjxowx+fn5Ji8vz3z55Zfmxz/+se37YtcY3XLLLaa0tNQcP37cHDx40OTn5zuXfeCBB0xhYaEpLCw0kyZNsn1fvG2Mbr31VrNlyxazefNms2XLFvPggw/avi92jdGqVatMRUWFycvLM3l5eWbFihUBdxwFeiNnuXecAilvWRknclfzxyqQcpiVcQrEPBb07/8BAAAAADTB7+6BAgAAAAB3saWAWrBggSorK7V169ZG+zz//PMqLCzUV1995bc35gEAvBN5CgDQGFsKqJdffvmSP6SVkpKiXr16qVevXpo8ebLmz5/vwegAAIGOPAUAaIwtBdT69eudjxRtSGpqql555RVJ0saNGxUREaFu3bp5KjwAQIAjTwEAGuOV90D58y8XAwB8H3kKAAJXK7sDaK6MjAxNnjxZktS7d2/t3Lnz8lfmyjMJ3dHXXc9E9KX98oa+Vtm9fcBLxcbGqkuXLnaH4TVaNE+5wu7zqd3bd7Wvrwj0/QdaQHPzlFcWUK78cnFWVpaysrIkSQ6HQ4mJic3buCsnpZZer6vrbOntn4/BHUnUFe6K1R3s3j7ghRwOh90huJ2tecoVdp/77cypl7NeXxHo+w80U3PzlFdO4cvNzdXEiRMlSQMHDtTRo0dVUVFhc1QAAHyLPAUAgcuWK1BLlizRkCFDFBkZqdLSUs2YMUOhoaGSpBdffFHvvfeefvjDH6qoqEg1NTV64IEH7AgTABCgyFMAgMbYUkBNmDChyT5TpkzxQCQAAkZrSadbsB/8GnkKANAYr7wHCgBa3GnZfy8iAADweV55DxQAH9G6hfsBAOzhynmaczoCHAUUgPpcSYznr+o01ZgSB8CbUTxYP597wzndl/68fClWWMYUPsBXuXKvjit9rU51k5juBsA/cN5zD/KUb8UKyyigEBj88QECnJQBAN6MPAU/RYqsGFgAACAASURBVAGFwMADBAAAANACuAcK+C7mHwMAEJh4MBIs4goU8F1MNwAAtBR33QME92C2CiziChQAAIA7uPJkO3dw15USrsAgwFFAAcDl4vG0AFqK1WLLHet013rhGnKKz2AKHwD389dpLEz5BADvRk6BG1BAAXA/kgIAwA6Bnn9cKSDbSDrlhvX6Idum8A0fPlw7duxQYWGhpk2bdtHnMTExWr16tTZt2qSvvvpKKSkpNkQJAAhU5CkPYjoSfIkvHa+uTOM85UJfV4onP326odWharEWHBxsioqKTHx8vAkNDTWbN282ffr0qdfnxRdfNA8//LCRZPr06WOKi4ubXK/D4Wh+fFb/c8d63TnuruxXS/f1tVjdtX27/1zt/DNwZZ2tXYizjRv2y1v+DFq6uTKurvRtoLXIudjm5tV5ypXW0n+X3fX33p193TFWdv4ZeMu4umOdHNvuGS+7t+/KuHqoNfdcbMsVqKSkJBUVFam4uFi1tbXKyclRampqvT7GGLVv316S1KFDB+3du9eOUAH/4Evf6rjr2zJ/ZfXP1pVxDeBpGeeRpwDgEnzp3xVuYMs9UFFRUSotLXW+Lisr08CBA+v1yczM1MqVK/XII4/oyiuv1J133unpMAH/EehzwP0Zv1viFuQpNCrA7/0AJAX8vyu89jHm9957r15++WXFxMTohz/8oRYtWqSgoIv/BDIyMuRwOORwOBQZGWlDpACAQESe8gHu+Jbc7t92AmA7Wwqo8vJyxcTEOF9HR0ervLy8Xp/09HQtW7ZMkrRhwwa1adOmwcSTlZWlxMREJSYm6uDBg+4NHAAQEMhTfoLfKwLgBrYUUA6HQ7169VJcXJxCQ0M1fvx45ebm1uvzzTffaNiwYZKk6667Tm3atNGBAwfsCBcAEGDIUwCAxthSQNXV1WnKlCn68MMPtX37di1btkwFBQWaOXOmRo4cKUl67LHHlJGRoc2bN2vp0qWaNGmSHaECAAIQeQoA0Jgg+dHFa4fDocTExOatxF03xNl9k7cr+9XSfd0xVq5s35W+7ljn+b7uYOdYudLX7u270reNXLtB3O5jwGoMHjxeW+Rc7Kc8Pjb8vSdWX4nVnedef/0zsMobYm3p/NvMh7k091xsy1P4gIDjyl90nvBkrwB/shAA2IJzL3zoGKCAAjzBh04KAADAy/Flq60ooAAAAABfwm8A2sprfwcKAAJWgP/COwAA3owrUADgbZjyCQCA1+IKFAAAAABYRAEFAAAAABZRQAEAAACARRRQAAAAAGARBRTcjyeKuYbxAgAA8Fo8hQ/uxxPFXMNvOwAAAHgtrkABAAAAgEUUUAAAAABgkW0F1PDhw7Vjxw4VFhZq2rRpDfb5yU9+om3btik/P1+LFy/2cIQA0IK4t83nkKcAAI0xnm7BwcGmqKjIxMfHm9DQULN582bTp0+fen2uvfZas2nTJhMREWEkmauuuqrJ9TocjubHZ/U/d6zXnePuyn61dF+7t0+s9ve1e/v+Gqs796sZrUXOxTY3r85TnPuJlVjZL2JtVmvuudiWK1BJSUkqKipScXGxamtrlZOTo9TU1Hp9MjIyNG/ePB05ckSSdODAATtCBQAEIPIUAKAxthRQUVFRKi0tdb4uKytTVFRUvT4JCQlKSEjQJ598os8//1zDhw9vcF0ZGRlyOBxyOByKjIx0a9wAgMBAngIANMZrH2PeqlUr9erVS0OGDFF0dLT++c9/6sYbb9TRo0fr9cvKylJWVpYkyeFw2BEqACAAkacAIDDZcgWqvLxcMTExztfR0dEqLy+v16esrEy5ubk6e/asvv76a+3atUu9evXydKgAgABEngIANMaWAsrhcKhXr16Ki4tTaGioxo8fr9zc3Hp93n77bQ0ZMkSS1LlzZyUkJGjPnj02RAsACDTkKQBAY2wpoOrq6jRlyhR9+OGH2r59u5YtW6aCggLNnDlTI0eOlCR9+OGHOnTokLZt26Y1a9bot7/9rQ4fPmxHuACAAEOeAgA0JkjfPo7PLzgcDiUmJjZvJVZHI8gN63V1nS29/fMxtHRfd6zTXX3t3r4rfe3evit97d6+K33t3r67+rq6zmZokXOxn/L42PjSMUesxOorfe3evit97d6+K319KE/Z9kO6AAAAAOBrKKAAAAAAwCIKKAAAAACwiAIKAAAAACyigAIAAAAAiyigAADwFa3tDgAA0MruAAAAgEWn5bHH/AIAGsYVKAAAAACwiAIKAAAAACyigAIAAAAAiyigAAAAAMAiCigAAAAAsMi2Amr48OHasWOHCgsLNW3atEb7jRkzRsYY3XzzzR6MDgAQ6MhTAICG2FJABQcHa968eUpJSVHfvn117733qk+fPhf1a9eunX71q19pw4YNNkQJAAhU5CkAQGNsKaCSkpJUVFSk4uJi1dbWKicnR6mpqRf1mzVrlubMmaNTp07ZECUAIFCRpwAAjbGlgIqKilJpaanzdVlZmaKiour1GTBggGJiYvTee+95OjwAQIAjTwEAGtPK7gAaEhQUpP/5n//RpEmTmuybkZGhyZMnS5IiIyPdHBkAAOQpAAhktlyBKi8vV0xMjPN1dHS0ysvLna/Dw8N1ww03aO3atSouLtagQYOUm5vb4A26WVlZSkxMVGJiog4ePOiR+AEA/o08BQBojC0FlMPhUK9evRQXF6fQ0FCNHz9eubm5zs+PHTumq666SvHx8YqPj9eGDRs0atQoffnll3aECwAIMOQpAEBjbCmg6urqNGXKFH344Yfavn27li1bpoKCAs2cOVMjR460IyQAAJzIUwCAxgRJMnYH0VIcDocSExObtxKroxHkhvW6us6W3v75GFq6rzvW6a6+dm/flb52b9+VvnZv35W+dm/fXX1dXWcztMi52E95PE/50jFHrMTqK33t3r4rfe3evit9fShP2fZDugAAAADgayigAAAAAMAiCigAAAAAsIgCCgAAAAAsooACAAAAAIsooAAAAADAIgooAAAAALCIAgoAAAAALKKAAgAAAACLKKAAAAAAwCIKKAAAAACwiAIKAAAAACyyrYAaPny4duzYocLCQk2bNu2iz3/9619r27Zt+uqrr/TRRx+pZ8+eNkQJAAhU5CkAQENsKaCCg4M1b948paSkqG/fvrr33nvVp0+fen3y8vJ0yy23qF+/flq+fLmee+45O0IFAAQg8hQAoDG2FFBJSUkqKipScXGxamtrlZOTo9TU1Hp91q5dq5MnT0qSNmzYoOjoaDtCBQAEIPIUAKAxthRQUVFR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oqSkpHrruPfee/X111/r+PHjeuutt9SxY8dm7yO8DwUUfE5wMIetHWJjY7Vr1y7V1dU1e11LlixReHi4wsPDlZKSor179zpfh4eHq1WrViotLVVycrI6dOigp556SsuWLVNsbKwkqXPnznrzzTf1u9/9Tp06ddIXX3yh1157rdlxAQB8S2xsrAoKClpkXc8++6wzDz388MP6/PPPna9vuOEGtWvXTg6HQzfffLM6deqk7Oxsvfvuu7ryyislSX379tWLL76on/70p+ratatqamr0wgsvtEhs8C78SxQtburUqSorK9OxY8e0Y8cODR06VJIUFham7OxsHTt2TPn5+br55pudy1x33XVas2aNqqqqlJ+fr5EjRzo/W7hwoV544QW9++67On78uNLT03Xfffdp6tSpqq6uVm5ubqOxTJo0qd7nu3bt0rJly5yvv/nmG/Xr10+S9Oc//1nffPONjh49qi+++EKDBw+WJHXv3l01NTX1vkXq37+/Dhw4oFatWkmSHnjgARUUFOjw4cP64IMPXL4aEhYWpj/+8Y8qKSlRRUWF5s+frzZt2kj6vyl3v/nNb1RZWam9e/dq0qRJzmU7deqk3NxcHT16VP/61780a9Ys5zSIdevWSZK++uorVVdXa9y4cc7lGltfQzIzM/X000/rnnvuUXV1tR588MHLnm5hRU1NjWbOnKmSkhIZY/Tuu++quLjYecyMGTNG27Zt0/Lly3X69GllZmaqX79+6t27t1viAeDfwsLCNHfuXJWXl6u8vFxz585VWFiYpOadgxuTmZmpv/zlL5KkVq1a6fjx43ruueckfTtd+uTJk86cs2zZMu3bt09HjhzRunXr1LdvX0lSUlKS9u3bV+9LxdGjR+urr76SJAUFBWnatGkqKirSwYMH9dprr7l8NaR9+/Z66aWXtHfvXpWVlWnWrFnO7Z3PAX/84x91+PBh7dmzp95Mgbi4OOfUulWrVumvf/2rcyr/P//5T0nSkSNHVF1drUGDBjmXa2x9DVm4cKHS0tKc/x4YNmyYW28ZKC4u1ty5c1VRUaFz584pKytLYWFhztxz33336Z133tH69et14sQJ/e53v9OYMWPUrl07t8QD+1BAoUUlJCRoypQpSkxMVPv27TV8+HB9/fXXkqRRo0YpJydHERERys3N1V//+ldJ3yaPd955RytXrlSXLl30yCOPaPHixUpISHCud8KECfr973+v8PBwvfLKK1q8eLGee+45hYeHa9SoUY3Gs27dOt12220KCgpS9+7dFRYWpltvvVWSFB8fr3bt2mnLli2SJIfDof79+6tTp05asmSJXn/9dbVu3Vr79u3T559/rrFjx9aLZ/ny5Tp79qxGjRqlJ554QmPGjNFVV12l9evXa+nSpS6N2+zZs5WQkKD+/fvr2muvVVRUlJ5++mnn5926dVOHDh0UFRWl9PR0zZs3TxEREZKkefPm6cSJE+rWrZvS0tKUlpbmXC45OVmS1K9fP4WHhzuLx0utryGZmZn6wx/+oNdee03h4eH6+9//7tL+NVeXLl2UkJCgbdu2SZKuv/565z8SpG8Lrt27d+v666/3aFwA/MOTTz6pQYMGqX///urXr5+SkpL01FNPOT+/3HNwY9atW6chQ4ZIkhITE1VRUaHbb79dknTrrbdq586dqqqqkiS9//776tWrl7p06aJNmzZp8eLFkqR//etfOnHihPNLSunb3LRkyRJJ0iOPPKLRo0crOTlZPXr0UFVVlebNm+fSuLz88ss6e/asrr32Wg0YMEB33XWXfvaznzk/HzhwoHbu3KnIyEg999xzWrBggfOzJUuW6F//+pc6d+6szMxM/fSnP3V+dn5fIyIiFB4erg0bNjS5voY88MAD9f498PHHH7u0f83Vr18/hYWFqaioSNLFuWnPnj06c+ZMvX/PwH8YGq2l2jXXXGMqKyvNsGHDTKtWrZzvz5gxw6xatcr5uk+fPqampsZIMoMHDzb79u0zQUFBzs+XLFliZsyYYSSZhQsXmuzs7HrbWbhwoZk1a5almL755hszYMAAc88995gXX3zRbNy40fTu3dtMmjTJrFixotHlDh8+bP7jP/7DSDLp6enm448/rrfO2267zUgy7733nnnwwQednwUFBZkTJ06Ynj17XjIuY4y55pprjCRz/Phxc/XVVzs/GzRokNmzZ4+RZJKTk01NTY0JCQlxfl5ZWWkGDhxogoODzZkzZ0xCQoLzs1mzZpn169c3uJ2m1nepeGfMmGEWLVrkfJ2Wltbodlz580lOTjalpaWNft6qVSuzatUq87e//c353ksvvWSeffbZev0++eQTk5aWZvvfARqN5jutuLjYDBs2zBQVFZmUlBTn+3fddZcpLi42UvPPwQ21Nm3amJMnT5pOnTqZadOmmccff9yUlpaaK6+80mRmZprnn3++weU6dOhgjDGmffv2zm0tWLDASDLt2rUzx48fd+aegoICM3ToUOey3bp1M2fOnKm3Hxe22NhYY4wxISEhpkuXLubUqVOmTZs2zs/Hjx9vVq9ebaRvc0BhYaHzs7Zt2xpjjOnatauJiYkxtbW1pm3bts7PFy1a5Mwh393O+c8vtb5LjeWF+ea7uerC7axZs8akp6dbOjYuzHEXtvDwcLNlyxYzffp053sfffSReeihh+r1KysrM8nJybYf67SWbVyBQovavXu3Hn30UWVmZmr//v1aunSpunfvLkmqqKhw9qupqVHbtm0VEhKiHj16qLS0VMYY5+clJSWKiopyvr6cp8add/6bvttvv13r1q3T2rVrlZycrOTkZOcUN0l67LHHVFBQoCNHjqiqqkodOnRQZGSkJOmNN97Qrbfeqm7duun222/XuXPnnFM0YmNj9fzzz6uqqkpVVVU6fPiwgoKC6sV/KVdddZWuvPJKffnll851fPDBB7rqqqucfQ4dOlTv3qOamhq1a9dOV111lUJDQ+uNj5Wxamx93iYoKEiLFi3SmTNnNGXKFOf7x48fV/v27ev1bd++vaqrqz0dIgA/0KNHD5WUlDhfl5SUqEePHs7XLX0OPnXqlL744gslJyc7c9Nnn32m73//+/VyU3BwsJ599lkVFRXp6NGjzhkd53PTkiVLNGbMGIWFhWnMmDHatGmTvvnmG0nf5qa33nrLmVe2b9+uuro6de3a1dKYxMbGKjQ0VPv27XOu48UXX1SXLl2cfb6b10+ePClJateunXr06KHDhw8737M6Lo2tz9u0adNG77zzjjZs2KDZs2c73yc3BQ4KKLS4pUuX6rbbbnM+ZWfOnDmX7L93717FxMQoKCjI+V7Pnj1VXl7ufP3d4qqh15dyvoC67bbbtG7dOq1bt+6iAmrw4MGaOnWqxo0bp44dO6pjx446evSoM6YjR45o5cqVuueeezRhwgTl5OQ4119aWqqHHnrIuVzHjh11xRVX6PPPP7cU38GDB1VTU6Prr7/eufz5aQ1NOXDggGpraxUdHe18LyYmxvLYeLsFCxaoa9euGjt2rM6ePet8f9u2bc571yTpiiuu0DXXXOOc4gcArti7d6/zITXStzlo7969TS7XnHPwunXrNHToUA0YMEAOh0Pr1q3T8OHDlZSU5LxHaMKECUpNTdWdd96pDh06KC4uTpKcuWn79u0qKSlRSkpKvel70re5KSUlpV5uatu2raX9Or/86dOnFRkZ6Vy+Q4cOuuGGG5pcdt++ferUqZPatm3b4Li4ksO9TVhYmN5++22VlZXpoYceqvfZhbkpPj5erVu31q5duzwdJtyMAgotKiEhQXfccYfCwsJ06tQpnTx5UufOnbvkMhs3blRNTY2mTp2qVq1aKTk5WSNHjqxXpFyosrJSV199taWY1q1bpzvuuENt27ZVeXm51q9frxEjRqhz587Ky8uTJIWHh+vs2bPOB0P87ne/u+hbpCVLlmjixIm6++676yWpv/3tb3r88cedN/a2b99ed999t6XYpG8TSVZWlubOneu86tSjRw/dddddTS577tw5vfnmm8rMzFTbtm3Vu3dvTZw4sV6fiooKy2Pl3ARA/wAAIABJREFUTebPn68+ffpo5MiROnXqVL3P3nrrLd1www0aM2aMWrduraefflpbtmzRzp07bYoWgC9bunSpnnrqKUVGRqpz5856+umn9eqrrza5nJVzcGPWrVuniRMnqqCgQLW1tVq7dq1+9rOfqbi4WAcPHpT0bW46ffq0Dh06pCuuuEJ/+MMfLlrPkiVL9Ktf/Uq33367Xn/9def7f/vb3/T73//e+VCjyMjIS94zfKGKigqtXLlSf/rTnxQeHq6goCBdffXVzvuXLuWbb77RF198oczMTIWGhmrQoEH1Hg514MAB1dXV+VxuatWqlZYvX66TJ08qLS3tokJw8eLFGjlypAYPHqwrrrhC//Vf/6U333xTx48ftyliuAsFFFpU69atNXv2bB08eFAVFRXq0qWLHn/88UsuU1tbq5EjRyolJUUHDx7UCy+8oIkTJ17yH8MLFixQ3759VVVVpbfeeuuS6y8sLNTx48edU+6qq6u1Z88effrpp87i7sMPP9QHH3ygXbt2qaSkRKdOnbpoukFubq569eqliooK54MnJOntt9/WnDlzlJOTo6NHjyo/P18pKSmXjOlC55+UtGHDBh09elQfffSR5SfKTZkyRR06dFBFRYUWLVqkpUuX6vTp087PMzMzlZ2draqqKv3kJz9xKS679OzZUw8//LD69++viooK5+9wTJgwQdK3V+3Gjh2r3//+96qqqtLAgQM1fvx4m6MG4Kue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OFBVVVXnHde7d28VFxfr4MGDevDBBzV79mw98cQTZz0G//bwFg0ULjhz587V9OnT7U7Db40fP1579+5V586d9d///d965plnlJWV9b2O9fjjj+vQoUM6dOiQjh49qq+//tqzXVpaqm7dumn+/Plyu906cOCAPvvsMyUnJ9c7xl133aUvvvhChw8f1nvvvaeIiIimOE0AwAXkscceU2FhoTp37qyXXnpJEydO1O9+97vvdazZs2d7atFXX32l48ePe7YXL16shIQEvf/++9q9e7f27dunDz/8UL179653jIcfflg7d+5UXV2d5syZo9DQ0KY4TbQQNFC4oAQG8iN72vk+KWoucXFx2rx5c5Mc65lnnlGnTp3UqVMnTZgwQatXr/ZsX3bZZerYsaMcDof69++vLl26KDc3V3//+9/VoUMHSVLfvn31+uuv695771WPHj105MgRvfrqq02SGwDgu7OzNm3atKlJjjVx4kRPLXr66af11ltvebaHDx+u8PBwFRQUqE+fPurRo4f+9a9/adGiRZ73Dx06VJMmTdKQIUMUFxenH/7wh5o2bVqT5IaWgf8bRZN67LHHVF1drYMHD6qsrEw33nijJCk0NFS5ubk6ePCgSktL1b9/f897LrnkEhUWFqq2tlalpaVKS0vz7Js7d65effVV/f3vf9fhw4eVmZmp0aNH67HHHtOhQ4dUUFDQaC5jx46tt7+8vFz5+fme7e3bt+uKK66QJL344ovavn276urqtHbtWl133XWSpIsuukhHjhyp96nGlVdeqT179ig4OFiSNG7cOG3evFn79+/Xhx9+qJ49e553nl544QXt2rVLdXV12rBhgy699FLP+c6ePVtLly7VwYMHtWLFinrHM8bo/vvvV3l5uZxOpyTplltuUXFxsWpra7Vq1SpdfvnlnvHZ2dlyuVw6ePCgNm3apNtvv92zLzAwUH/4wx+0Z88eVVRU6JZbbjlv3nPnztWYMWM88z9kyJBmvUSzsrJSM2fOVE1Njb755hvl5OQoNDRUffr0kSSNHj1aH3zwgT799FN9+eWX+u1vf6s77rhDHTt2bJZ8ALQ+oaGhmjlzptxut9xut2bOnOn5tOD0pV+PPPKIdu3apR07dmjs2LGe93bp0kUFBQWqq6vTv/71L02fPl2ffvrpOb/fk08+qT/+8Y+SpODgYB0+fFjPPfecJKlt27Y6evSop+bk5+dr586dOnDggFauXKm+fftKkpKTk7Vz5856v1S8/fbbtX79eklSQECAZ/3fu3ev3nrrrfN+Ot+mTRvNmzdPe/fuVW1trf71r3+pe/fukk5djv30009rzZo1qqur0/vvv+853ulLt3/5y19q27ZtWr58uaRz18bGau7pOZg7d67279+vTZs2KSkp6Zx5S9LHH3+swYMH6+WXX9ahQ4eUkJDQrFerOBwO/d///Z9qa2v19ddfa+bMmbrkkkvUpUsXSdKYMWM0Z84cbd68WQcOHND06dPr/dygdTAE0RTRu3dvs337dnPRRRcZSSYuLs788Ic/NFOnTjVHjx41qampJjAw0Dz99NNm9erVRpIJDg42TqfTPP744yYkJMQMHjzYHDx40PTu3dtIMnPnzjUHDhwwP/3pT01AQIBp06aNmTt3rpk+ffp584mPjze1tbUmICDAXHTRReaLL74wVVVVnn379+83AQEBRpIZPXq06dKliwkKCjKPPPKI2blzp2nTpo2RZD7++GPzq1/9ynPc5557zsyePdtIMrfddptxOp3mkksuMUFBQWbKlClm1apV58xr6NChZu3atSYsLMxIMpdccomJiorynO/BgwfN9ddfb0JDQ82LL75oPv30U897jTFm6dKlJiIiwrRt29ZceeWVZteuXSY5OdkEBgaajIwMU1lZaUJDQ40kM2LECHPRRReZgIAAc+edd5rDhw97vtd9991ntmzZYmJiYkxERIRZvny5McaYoKCgc+b/7fmfOnWqmTdvnuff/MxjFBYWmszMTEs/P2PGjKl3rmeLK664whw9etR07tzZSDLvv/++eeyxx+qNOXTokLnqqqts/++BIIiWHZWVlWbIkCFm2rRpZvXq1aZbt24mMjLSrFq1yjz11FNGkhk4cKA5ceKEmTZtmgkODjapqanmyy+/NOHh4UaSWbBggVmwYIFp166dSUxMNNu3bz/vOjZ48GCzYcMGI8n85Cc/MS6XyxQVFXn2lZSUeMaOGzfOdOzY0YSGhpqZM2ea4uJizz6Xy2Vuuukmz3Z+fr7Jzs42ksxDDz1kVq9ebaKjo01oaKh57bXXzPz588+Z1/jx401BQYFp166dCQwMNFdddZXp1KmTkU6t5dXV1ebSSy817du3NwsXLmyw7ufm5pr27dubtm3bnrc2nqvmPvPMM+aTTz4xERERJiYmxmzcuNFTu88V3643Z9aqgQMH1jvG6X97Kz8nZ9a4xiI9Pd3s2LHDs11SUmLuvPNOz3bXrl2NMcZ06dLF9p97osnC9gSIVhI/+tGPzK5du8yQIUNMcHCw5/WpU6eaZcuWebYTExPNkSNHjCRz3XXXmZ07d3oaGUlm/vz5ZurUqUY6tQDm5ubW+z5WGyhJZvv27aZfv35m5MiR5vXXXzdr1qwxffr0MWPHjjWLFi1q9H379+83P/7xj40kk5mZaT7++ON6x7z++uuNJLN48WLzy1/+0rMvICDAfPnll6Znz56NHnvw4MFm69atZsCAAfXO+/S5LViwwLPdoUMH8/XXX5uYmBgjnWqgBg8e7Nn/6quvegr96SgrKzM33HDDWb93cXGxue2224x0qjG87777PPtuvvnmFt1AderUyWzYsMFMmjTJ89pHH31U7xwkmerqajNw4EDb/3sgCKJlx+n/iXa5XCY1NdXz+tChQ01lZaWRTv2P95EjR+qti7t27TIDBgwwgYGB5vjx455f+Eky06dPP28D1bZtW3P06FHTpUsXk52dbR5//HFTVVVlOnToYJ588kkza9ass74vLCzMGGM8v0CaPn26mTNnjpFkOnbsaA4fPuypPZs3bzY33nij571RUVHm+PHj51zfx40bZ1atWmUuv/zyBvsKCwvNM88849lOTEw0X331lQkMDPSs+/Hx8Z7937U2nllzKyoqTEpKimdfVlZWi26goqOjTXV1tRk1apTnNZfLVe8cgoODjTHGxMXF2f5zTzRNcAkfmkxFRYUefvhhPfnkk9q9e7cWLFigiy66SJJUU1PjGXfkyBG1a9dOQUFB+sEPfqCqqioZYzz7t23bpujoaM+2lafvNGblypUaNGiQbrjhBq1cuVIrVqzQwIEDNXDgQK1cudIz7tFHH/V81F5bW6uwsDBFRkZKkt555x395Cc/UVRUlG644QZ98803nks04uLiNGvWLNXW1qq2tlb79+9XQEBAvfy/rbCwUC+//LJeeeUV7d69W6+//ro6dep01vP98ssvtX//fv3gBz846/64uDg9+uijnu9fW1ur2NhYz/h7773Xc3lfbW2tLrvsMs95nZ7707Zt2/a95tgX2rZtqw8++EBFRUV69tlnPa8fPnxYnTt3rje2c+fOOnTokK9TBHCB+sEPflBv/du2bVu9NXffvn06efKkZ/vIkSPq2LGjunXrppCQkHrrqJV6dezYMa1du1YDBw701KZ//vOfuvbaa+vVpsDAQD3zzDNyuVyqq6vTF198IUmeNXz+/Pm64447FBoaqjvuuEPr1q3T9u3bJZ2qDe+9955n7d+yZYtOnjypHj16NJrXvHnztGTJEuXl5cntdmvGjBmeS9W/fW7btm1TaGioJ5dv7z9fbTxXzb2QalNkZKSWLl2qV199VXl5eZ7Xv12bTn9NbWo9aKDQpBYsWKDrr7/ec030jBkzzjl+x44dio2NVUBAgOe1nj17yu12e7bPbK7Otn0upxuo66+/XitXrtTKlSsbNFDXXXedHnvsMd15552KiIhQRESE6urqPDkdOHBAS5cu1ciRI3X33XfXWySrqqp03333ed4XERGh9u3ba/Xq1efM66WXXtLVV1+tvn37qnfv3vqf//kfz77Y2FjP1x06dFCXLl20Y8eOs55/VVWVfv/739f7/h06dFBeXp569uypnJwcPfDAA+ratasiIiJUWlrqOa+dO3fW+15W7t2yQ2hoqN5//31VV1frvvvuq7dv06ZNnvvYJCk+Pl5t2rRReXm5r9MEcIHasWOH4uLiPNs9e/ast+Y2Zs+ePTpx4oRiYmI8r525pp7LypUrdeONN6pfv35yOBxauXKlUlJSlJycrE8++USSdPfddys9PV033XSTwsLC1KtXL0nyrOFbtmzRtm3blJqaqrvvvlvz58/3HL+qqkqpqan1akO7du3OeV5ff/21nnrqKV166aX66U9/qltvvVUZGRlnPbeePXvq+PHj2rt3r+e1b9emxmrj+WruhVKbwsPDtXTpUhUUFOjpp5+ut+/btemKK65QTU2N9u/f7+s00UxooNBkevfurcGDBys0NFTHjh3T0aNH9c0335zzPWvWrNGRI0f02GOPKTg4WAMHDlRaWlq9JuXbdu3apR/+8IeWclq5cqUGDx6sdu3aye1269NPP9WwYcPUtWtXFRcXS5I6deqkr7/+2vNgiN/+9rcNPtWYP3++MjIyNGLEiHpF6rXXXtPjjz/uubG3c+fOGjFixDlzuvrqq5WcnKzg4GB9+eWXOnbsWL15Gj58uK699lqFhIRo+vTpKioqUnV19VmPlZOTowkTJnge7d2+fXsNHz5cHTt2VIcOHWSM0Z49eySdeqjGZZdd5nlvfn6+HnroIUVHRys8PFyTJk2yNKe+FBwcrIULF+ro0aMaM2ZMg+b5zTffVFpamq677jq1b99eTz31lN59910dPnzYpowBXGgWLFigJ554QpGRkeratav+3//7f/rrX/963vd98803evfdd/Xkk0+qXbt26tOnT72G41xWrlypjIwMbd68WSdOnNCKFSv0q1/9SpWVlZ6mpFOnTvrqq6+0b98+tW/fvsH/pEunatOvf/1r3XDDDXr77bc9r7/22mv6/e9/72k+IiMjddttt50zp0GDBumyyy5TYGCgDh48qBMnTtSrTffcc48SExPVrl07PfXUU1q4cGGjNf5ctfF8NTc/P1+PP/64wsPDFR0drQcffNDKlPpUp06dtGTJEq1atUqPP/54g/1/+ctflJmZqcTERIWFhemJJ57QG2+84ftE0WxooNBk2rRpo2effVZ79+5VTU2NunfvftaF5UwnTpxQWlqaUlNTtXfvXr366qvKyMjQ1q1bG33PnDlz1LdvX9XW1uq999475/GdTqcOHz7sueTu0KFD+vzzz7Vq1SrPwr9kyRJ9+OGHKi8v17Zt23Ts2LEGl2EUFBQoISFBNTU12rBhg+f1999/XzNmzFBeXp7q6upUWlqq1NTUc+bUuXNn5eTkqLa2Vtu2bdO+ffv0hz/8wbN//vz5mjp1qvbv36/+/fvrnnvuafRY//73v5WVlaWXX35ZtbW1crlcnif9bNmyRc8//7xWr16tXbt26fLLL9eqVas8783JydGSJUu0fv16rVu3Tu++++4587bDT3/6U6WlpWno0KE6cOCA5+9wnH5i0+bNmzVhwgS9+eab2r17tzp16qT777/f5qwBXEh+97vfae3atdqwYYM2btyodevWWf77QQ888IDCwsJUU1OjefPmacGCBfrqq6/O+75//vOfateunefTps2bN+vYsWOebenU/4Rv27ZNbrdbmzdvVlFRUYPjLFiwQAMHDtTy5cu1b98+z+uzZs1SQUGB54muRUVFGjBgwDlzioqK0sKFC3Xw4EFt2bJFK1eurPeE1Xnz5umNN95QTU2N2rZtq4ceeqjRY52rNp6v5k6bNk3btm1TZWWlli5d2mxPefXGz372MyUnJ2vcuHGeunTo0CHPJ2dLlizRc889p8LCQm3fvl3btm3T1KlTbc4aTSlAp26GAtACzJ07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0yU8PNyjdWeX1q1bmx49ephWrVoZSSYjI8McOnTI9ZqHHnrI3HjjjSYyMtJcdtll5vPPPzdTpkzxOE95ebkZPHhwrXUNbXPhwoUmNzfXtGvXztxwww2murra9OrVy/K+ZWFhYWnqcvZcGBUVZWbMmGGcTqdxOp1mxowZJioqykgyAwcONBUVFeY3v/mN2bdvn9mzZ48ZN26caxsXX3yxycvLM0eOHDGfffaZef755826desa3HevXr3MqlWrzKFDh0xVVZV58sknjaQLxrez+69vW+PGjTN5eXmuxzt27DCLFi1yPf76669N7969jSRjjDEPP/yw2bFjh9m1a5dr+0888YTZu3evmTdvnkd9Fx4ebh5++GFz4sQJt21mzpxp/vznP3v8fhhjzJVXXllvm3O3mZycbL777jvTvn171/OffPKJefDBBy3/22Lxz4UrUPBbTzzxhCorK3X06FFt375dgwYNkiRFRUVp7ty5Onr0qIqLi3Xddde5XnPVVVcpPz9fhw8fVnFxsUaMGOF6bs6cOfqf//kfffDBBzp+/LgmTJigsWPH6oknntCxY8eUl5dXb56EhAQtWbJE+/fv18GDB/Xaa69JunBaYVJSkowx9X76dvPNN2vLli2ux6tWrdJnn33mevzJJ58oIyND0pm59U888YSKiop04sQJXXnllTLG6IEHHtDu3bu1Zs0at/v5/vvvtWPHDhlj1KpVK9XU1Ojiiy/WxRdfLEl68803tX79ep0+fVp79uzRggULdMMNN9TbDw2pb5tt27bVXXfdpf/8z//UiRMn9OmnnyovL0/3339/s/YJAP7gqaeeUv/+/XXttdeqd+/e6tevn55++mnX8/Hx8erYsaNsNpsmTJigN954QzExMZKkN954QydOnFB8fLyysrKUlZXV4P7at2+vjz76SP/4xz902WWXqXv37lq9enWT869du1bp6elq1aqVunTpoqioKA0YMECS1K1bN7Vv377W2DVy5EilpaWpV69eruO7+OKLlZSUpIkTJza4v8OHD+u7777Ta6+9pj/+8Y9u26Wnp2vbtm1NPq6Gtnn11Vdr165dOn78uOv5oqIiXX311S26TwQPCij4pR49emjSpElKTU1VdHS0hg4dqq+++kqSdOeddyo3N1cxMTHKy8vT66+/LkmKiIjQ+++/r1WrVunSSy/Vo48+qgULFqhHjx6u7d577736wx/+oA4dOmjevHlasGCBXnrpJXXo0EF33nmn2zxhYWH6+9//rt27d6tr166y2Wy1phs01saNG5WcnKzY2FhFRETommuu0WWXXab27durTZs2uv7667Vu3TpX+zFjxujnP/+5YmJi9MMPP0iSBg4cqJSUFA0dOrTB/RUVFem7777T+++/r5ycHB04cKDOdjfddFOLD1LnbrNHjx764Ycf5HA4amVjkAIQDMaOHavf//73OnDggA4ePKjnnnuu1gdEp0+f1u9//3v98MMPWrFihY4fP66ePXsqLCxMd911l5555hl9++23Ki0t1dy5cxvc3x133KGqqiq98sor+v7773X8+PFaH8Y1Vnl5uY4dO6Zrr71WN910k1auXKk9e/aoZ8+eGjhwoNatWydjjKv9iy++6CqCJOnHH3/UM888o1OnTrnW1adTp07q2LGjJk2apMLCwjrbPPvsswoLC9OcOXOafFwNbbN9+/Y6cuRIrTZHjhxxTQcEzhdhdQCgLjU1NWrdurV69eqlAwcOaPfu3a7n1q9frxUrVkiS5s+fr8cee0yS1L9/f7Vv317Tpk2TMUb5+fn6+9//rjFjxui5556TJC1btkwbNmyQdObqjKf69eunyy67TL/97W9VU1MjSfr000+bfHzfffed7Ha7brrpJu3Zs0dFRUWqrq7WDTfcoO+//14Oh0PffPONq/2f//xnVVZW1trGs88+q5MnT3q0v969e6t169b6xS9+oaioqDrbjB8/Xtdff71++ctfNvm4Gtpm+/btdfTo0VptGKQABIvLLrus1ni1e/duXXbZZa7Hhw4dco0hknTy5Em1b99el1xyiSIjI1VRUeF67tx/dycxMVE7d+5sofRnrF27VjfffLO6d++utWvXqrq6WgMHDtSAAQO0du3aWm3Pz3jgwIFGja3SmT548803deDAAaWkpNT6gO+RRx5RZmam0tPTderUqaYf1Dnq2ubx48cVHR1dq110dLSOHTvWIvtE8OEKFPzSzp079dhjj+nZZ5/V/v379c4776hLly6SpKqqKle7kydP6qKLLlJ4eLguu+wyVVRU1Pp0bPfu3bLZbK7HngxIdUlMTNTu3btrDXzNdXaQuummm7R27Vp9/PHHGjhwoAYOHNjgIOVuXX2+//575ebmaurUqbrmmmtqPZeRkaEXX3xRw4cP16FDhxp/MHWoa5sMUgCC2Z49e5SUlOR6fPnll2vPnj0Nvu7AgQM6ffq0EhISXOsSExMbfF1FRYWuuOKKOp87ceKE2rZt63ocHx/f4Pak/z82paena+3atVq7dq3bsenc8baux54KCwtT27Zta43X48eP19SpUzV48GA5nc4mbfd87ra5bds2XXHFFWrfvr1rXe/evVt8RgaCBwUU/NY777yj9PR013eKpk+fXm/7PXv2KDExUa1atXKtu/zyy2udJJt6sq+oqNDll19e5/eamjtInS2gGjNINSb7+SIjI2sNuEOHDlVOTo5GjBih4uLiJm3zfO62uWPHDkVERKh79+6udQxSAILFO++8o6efflpxcXGKjY3Vf/3Xf+kvf/lLg6/78ccf9d577+nZZ5/VRRddpJ49eyozM7PB1/39739Xly5d9Otf/1pRUVFq3769+vXrJ0navHmzbr/9dnXq1EmdO3d2zdZoyNq1a3XLLbfooosuktPp1Lp16zRs2DDFxsa6nWbXWEOGDNG1116rsLAwdejQQa+88ooOHz6s0tJSSWem2//xj3/UrbfeqvLy8hbZZ33bdDgc2rx5s5555hm1bt1aI0eO1DXXXKMlS5a0yL4RfCig4Jd69OihW265RVFRUfruu+/07bff6scff6z3NQUFBTp58qSeeOIJRUREaODAgRoxYkS931Xat2+f20/vzvXZZ59p7969mjZtmtq2bavWrVu7bge+efNm3XTTTUpMTFR0dLSefPJJj45xw4YN6tmzp/r166fPPvtMJSUlSkpKUlpamj755BOPttGQtLQ03XDDDYqMjFSbNm30xBNPqHPnziooKJAk3XLLLVqwYIHuuusu2e32Ftlnfds8efKk3nvvPf3+979X27Zt9bOf/UwZGRn8theAoPDCCy/o888/15YtW7R161Zt2rRJL7zwgkevnTRpkjp27KiqqirNnz9f77zzToPT4Y4fP65bb71VI0aMUFVVlRwOh2655RZJZ6a4FxUV6auvvtKqVav07rvvepTD4XDo+PHjru/hHjt2TLt27dKnn37a4DjsqZiYGL3zzjs6cuSIdu7cqSuvvFLDhg1zHe8LL7yg2NhY2e12189kzJo1q1n7bGibo0eP1vXXX6/Dhw9r2rRpGjVqlA4ePNisfSK4WX4rQBaW85ef/vSnpqCgwBw9etQc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c8rOztbQoUMleW+f98a2eNv27dv1zTffuHw+MTFRS5culSRlZGQoODhYYWFhls99nt4Oq1zvdkjS5s2bK71vX2bF/uGJ7bBKk0mgwsPDVVRU5HxcXFxc6bC5u+Li4hQUFKR9+/Y5l73++uvKysrS22+/raCgoHqJ90p1jb1Fixay2WzauXOn8406JCREpaWlqqiouK423VVf/T569GitWLGi0jJf6/eJEydq3bp11b42PDxcxcXFbrdpRexXagjj/erYrRzv9RH/Zb485n/2s5/J4XDozTff1DPPPFPta+vrPQDXcqdvs7Ky9Nhjj0mSHn30UbVp00bt27dXenq6tmzZoq+//lpff/211q9fr/z8fOfrFi9erMzMTP3qV7/y6e3IysrS0KFDdcMNNygkJET33XefIiMjvbrPe3pbLvP0/l8btd3fvTX31db1vm95c/9wR23fZ63aP2pyvfOFFftGk0mg6kNYWJiWLVumCRMmOD91nTFjhm677TbFxcWpffv2Pnl+f1RUlOLi4jR27FjNnTtXt956q9Uh1UpYWJh69Oih9evXO5f5Wr8/8cQT6tOnj9566y1L47germJvCOO9qtgb0nivru99ecy/++676tKli6ZNm+Yz/0Cgav/zP/+jAQMGaNeuXRowYICKi4tVUVGh733ve4qNjVVERITCw8M1aNAg3XvvvZIujcsf/OAH6t+/v/r376+f/OQnFm+F6+3YsGGD0tLS9Pnnn2vFihXauXOn859CX3U92+JL+39T54v7R1Nm1b7RZBKokpKSSp/kREREqKSkxO3Xt27dWmvXrtXLL7/sPAQtSYcPH5YklZWVafHixYqPj6+/oP+jrrEfOnRIklRYWKitW7eqV69eOnHihIKDgxUQEHBdbbqrrrFL0qhRo7R69WpduHDBucyX+n3w4MF6+eWX9fDDD6usrKza15aUlFQ6Xcvqfq8qdqlhjHdXsVs53usjfsn3x/xlKSkpztM+qhvzdX0PQNXc6duvv/5aI0aM0J133qmXX35ZknTy5Ek9+uijSk9P19mzZ3X27FmtW7dOd911l6T/24fOnDmj999/3yNjrb62Q5J++9vfqlevXnrwwQfl5+engoICr+7znt4WyTv7f23Udn/31txXW9fzvuXt/cMdtX2ftWr/qMn1zBdW7htev/DKihIQEGD27dtnoqOjnRd2du/evcq6V1+QFhgYaDZu3GieffbZa+qGhYU5f58zZ4753e9+51OxBwcHm6CgICPJhISEmIKCAucFrStXrqx0AeFPf/pTn4r9ctm5c6cZOHCgT/b7HXfcYRwOh/OmC5dLu3btzP79+01wcLAJDg42+/fvN+3atTPStRfSJiQk+FTsDWG8u4rd6vFe1/gbwpi/MuaHHnrI2Gw2I8l079690k0k9u3bZ/z9/Wv1HkCp/79XSEiI8fPzM5LMa6+9ZmbNmmUkmVGjRpkNGzaYgIAA06xZM7Nx40bz0EMPmYCAABMSEmIkmWbNmpm//vWvZvLkyT67Hf7+/qZ9+/ZGkunRo4fJyckxAQEBRvLePu+NbfHG/n91iYqKcnmx/7Bhwypd7J+RkWEk6+c+T2+HFftHXbbjchkwYMA1N1+wYv/wxHZYsW/8p3hlJT5REhISzJdffmkcDod56aWXjCQza9YsM3z4cCPJ9OnTxxQVFZkzZ86Y48ePm9zcXCPJPPHEE6asrMxkZmY6S8+ePY0ks2nTJpOdnW1ycnLMsmXLTMuWLX0q9rvuustkZ2eb3bt3m+zsbPPUU0852+zcubPJyMgwdrvdrFy50vmPp6/ELl3a0YqLi52TzeXiK/2+YcMGc/jwYee4WLNmjfO1EyZMMHa73djtdvPkk086l/fu3dvk5OQYh8Nh/vjHP1o23l3F3hDGu6vYfWG813Xc+PqYnzt3rsnNzTWZmZlm8+bNlf45fOmll4zD4TD5+fmV7rBVVZsU7/y9RowYYQoKCsyXX35pFi5c6Bz3/v7+5n//93/Nnj17TF5envn9739vJJkbb7zR/Otf/zJZWVkmNzfXzJ071/j7+/vsdjRv3tzk5eWZvLw8s3PnTud7leTdfd7T2+Kt/f9yef/9982hQ4dMWVmZKSoqMk899ZSZPHlypWThnXfeMQ6Hw2RnZ1e6K53Vc58nt8Oq/aMu2/Hpp5+ao0ePmnPnzpmioiLz4IMPWrZ/eGI7vL1vXC5+//kFAAAAAFCDJnMNFAAAAADUFQkUAAAAALiJBAoAAAAA3EQCBQAAAABuIoECAAAAADeRQAEAAACAm0igAAAAAMBNJFAAAAAA4CYSKAAAAABwEwkUAAAAALiJBAoAAAAA3EQCBQAAAABuIoECAAAAADeRQAEAAACAm0igAAAAAMBNJFAAAAB1UFhYqMGDB1sdBgAvIYFCgzJz5kwtW7bM6jAAAMB1eu6557Rv3z6dPHlSJSUlevvttxUQECBJ6tChg95//32VlJSotLRUO3bsUHx8fLXtzZgxQ6dPn9bp06d1/vx5Xbhwwfk4NzfXrTbHjBmjAwcO6MyZM1q9erXatWvnse1Hw0cChSZt8eLFevXVV60Ow2Mef/xx5efnq7S0VEeOHNGSJUvUunVrSVJQUJD+9Kc/6cCBAzp16pQyMzM1dOjQatsbO3asc1I6d+6cKioqnI9Pnz7tVpuDBg3S3r17dfbsWW3evFmdOnXy2PYDADzvcvJzJX9/1/9ipqam6s4771Tbtm11++23q2fPnnrmmWckSa1atZLNZlPv3r3Vvn17JScna+3atWrZsqXL9n73u9+pdevWat26taZMmaKdO3c6H99+++01ttm9e3e99957+slPfqKOHTvq3Llzevfdd+vYK2jsDIXSUMrMmTPNsmXL6qUtf39/s3jxYvPqq69avl3uloCAALeWXS4REREmJCTESDItW7Y0f/nLX8y8efOMJHPjjTeamTNnmqioKOPn52d++MMfmlOnTpmoqCi3YhkwYIApKiqqtKymNkNCQkxpaakZOXKkad68uXnzzTfNzp07Le9XCoVCqUspLCw0gwcPNkFBQWbOnDmmpKTElJSUmDlz5pigoCAj/d975gsvvGCOHDliDh06ZJ588klnG+3btzepqanm5MmT5p///Kd59dVXzfbt22tcd/fu3c0nn3xiTpw4YQ4fPmxmzJhhJFUbi6uydetW89hjjxlJ5u677zbGGDNs2DAjyQwaNMhkZmYaSWb8+PFmx44d5u233zbHjx83r776qlm8eLF59913zdq1a82ZM2fM4MGD3eq79u3bmw0bNpj58+e7rHPy5Elz5513utXe+PHj3eq3K9t8/fXXzfLly53P3Xrrrea7774zrVq1snxsUXyzcAQKPuvFF19UcXGxTp06pfz8fA0aNEjSpSMnycnJOnXqlHJzc9W7d2/na2677TZt2bJF3377rXJzczV8+HDnc4sXL9a7776rtWvX6syZM5o4caKeeOIJvfjiizp9+rRSU1OrjSciIkIffvihjh49quPHj+uPf/yjJMnPz08vv/yyDhw4oCNHjig5OVlt2rSptq0lS5bohRdekCTdcsstMsboZz/7mSTp1ltv1YkTJ+Tn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x4+/7vnuSjW1uXz5cg0fPlz33nuvbrzxRv3mN7/R3/72N505c6bO60bjRAIFn9S1a1fdd999CgoK0r///W+dP39eFy9erPY1GRkZOnfunF588UU1a9ZMAwYM0PDhw6854nKlI0eOuPz07kr//Oc/9fXXX2v27Nm68cYb1bx5c919992SLk1Szz//vKKjo9WyZUv99re/1QcffFDl0aorXZ6kLp8ScXmS2rFjR43b6q6xY8c6P8Xs1KmTXn/9deckJUkLFixQbGyshg8fXuOpgO6qrs3Vq1fr9ttv12OPPabmzZvr17/+tbKzs+vttEEAsNJrr72mf/3rX8rOzlZOTo527dql1157za3XTp06VW3bttXhw4e1bNkyrVixosZTzc+cOaMHHnhAw4cP1+HDh2W323XffffVKZZt27apTZs2zrnp6sf14Z577lFOTo7OnDmjtLQ0paWl6aWXXpIk3X333Ro+fLgefPBBlZaWOr8m4957773u9dXU5p49ezRlyhQtX75cR48eVevWrZ03dgJcsfxCLArl6tKjRw+TkZFhTp06ZU6cOGE++ugjc/PNN19zG/OoqChjjHFelNu9e3ezdetWU1paavLy8swjjzzirFvVDSO6dOliMjMzzbfffmtWr15dbUyRkZFm9erV5vjx4+bYsWPO24H7+fmZ//f//p/56quvzNGjR82yZctMcHBwjdvYtWtXY4wx48aNM5JMmzZtTHl5uXnxxReddaq6UUNtbuX+2muvmaKiInPmzBlTVFRk3nvvPdO+fXsjyXTq1MkYY8z58+fN6dOnnWXs2LFutV1VbO60OXjwYLN3715z7tw5s2XLFrdvm06hUChNqcyePdssWbLE8jgoFMq1xe8/vwAAAMAi3bp1U1BQkHJychQXF6e0tDT993//t9asWWN1aACuwil8AAAAFmvdurX+9re/6ezZs/rggw/0+9//XmvWrNG9997rPOXs6nI9ZsyYUWVbaWlp9bo9ubm5Va5n7Nix193mggULqmxzwYIF9Rg54B7LD4NRKL5QIiMjK512dmWJjIysdXtjx46tsq3c3Nx6jTstLa3K9Vz+NvrrKTNmzKiyzbS0NMv/ThQKhUKhUChWFk7hAwAAAAA3NfPWipo3b65PP/1UzZs3d95O8pVXXlF0dLRSUlIUEhKiL774Qj/5yU9UXl6uoKAgLV26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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_p1_idx]\n","  long_open_data = long_data[long_p1_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  # short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  short_false_data = short_open_data[~short_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  # long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  long_false_data = long_open_data[~long_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":881},"executionInfo":{"elapsed":1957,"status":"ok","timestamp":1657335427143,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"jHh0uFkXC4VF","outputId":"7c3e0657-e0bd-4bf4-be0c-3bddb61452a0"},"outputs":[{"output_type":"stream","name":"stdout","text":["293\n","685\n","293\n","685\n","293\n","685\n","293\n","685\n","pkx : [0.05346088 0.14578409 0.37659213 0.48737999 0.77358195]\n","pkx : [0.08375248 0.15590148 0.29118087 0.78720528]\n","\n","56\n","115\n","56\n","115\n","56\n","115\n","56\n","115\n","pkx : [-0.22675861 -0.1793134  -0.1450474  -0.08178711 -0.03697774]\n","pkx : [-0.2594824  -0.17702805 -0.13854936 -0.08907675 -0.02586175]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(short_max_data))\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(short_plot_idx))\n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"mScdfR9hmjVu"},"source":["#### legacy"]},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","metadata":{"id":"983aUwM76s6X"},"source":["#### dump"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p_e8PtFXa7mc"},"outputs":[],"source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nLZDkNNxbZPO"},"outputs":[],"source":["p1_hlm_p1_idx = long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":261,"status":"ok","timestamp":1653452376525,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WhCPOi1qbkHS","outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"outputs":[{"data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"execution_count":161,"metadata":{},"output_type":"execute_result"}],"source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wgERZ65F5RBB"},"outputs":[],"source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rAao95SEnOY0"},"outputs":[],"source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":267,"status":"ok","timestamp":1653119592395,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"OEQ9KWXVnQ2J","outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"outputs":[{"name":"stdout","output_type":"stream","text":["153\n","163\n"]},{"data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"execution_count":220,"metadata":{},"output_type":"execute_result"}],"source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hOtCGUeBQ4hn"},"outputs":[],"source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QPhjkZQhRLqr"},"outputs":[],"source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cFd7Fz0Y6ucU"},"outputs":[],"source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v4"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":57651,"status":"ok","timestamp":1658286067185,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oVifICO4-Grk","outputId":"e8bca602-40c8-4ca5-f7a9-d55b6b7f4554"},"outputs":[{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 2243\n","WARNING:root:np.sum(long_open_res1 == 1) : 2197\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 2242\n","WARNING:root:np.sum(long_open_res1 == 1) : 2197\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.183316707611084\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9840562343597412\n","en_ex_pairing elapsed time : 0.22379302978515625\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 2166\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21873188018798828\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 2084\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 2165\n","WARNING:root:np.sum(long_open_res1 == 1) : 2084\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9884688854217529\n","get_open_info_df elapsed time : 0.9695727825164795\n","en_ex_pairing elapsed time : 0.20090174674987793\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 2091\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21144509315490723\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 1982\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 2090\n","WARNING:root:np.sum(long_open_res1 == 1) : 1982\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9675097465515137\n","get_open_info_df elapsed time : 0.9653093814849854\n","en_ex_pairing elapsed time : 0.19496536254882812\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21195030212402344\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 2006\n","WARNING:root:np.sum(long_open_res1 == 1) : 1854\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 2005\n","WARNING:root:np.sum(long_open_res1 == 1) : 1854\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9745476245880127\n","get_open_info_df elapsed time : 0.9549682140350342\n","en_ex_pairing elapsed time : 0.18856239318847656\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1909\n","WARNING:root:np.sum(long_open_res1 == 1) : 1731\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.22078585624694824\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1908\n","WARNING:root:np.sum(long_open_res1 == 1) : 1731\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9680428504943848\n","get_open_info_df elapsed time : 0.9761159420013428\n","en_ex_pairing elapsed time : 0.18214702606201172\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1846\n","WARNING:root:np.sum(long_open_res1 == 1) : 1655\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.210496187210083\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1845\n","WARNING:root:np.sum(long_open_res1 == 1) : 1655\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9607577323913574\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9695115089416504\n","en_ex_pairing elapsed time : 0.17920970916748047\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1741\n","WARNING:root:np.sum(long_open_res1 == 1) : 1581\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21857118606567383\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1740\n","WARNING:root:np.sum(long_open_res1 == 1) : 1581\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0782229900360107\n","get_open_info_df elapsed time : 0.9635043144226074\n","en_ex_pairing elapsed time : 0.161146879196167\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1657\n","WARNING:root:np.sum(long_open_res1 == 1) : 1516\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21243715286254883\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1656\n","WARNING:root:np.sum(long_open_res1 == 1) : 1516\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9899005889892578\n","get_open_info_df elapsed time : 0.9786531925201416\n","en_ex_pairing elapsed time : 0.15755510330200195\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2108614444732666\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(short_open_res1 == 1) : 1601\n","WARNING:root:np.sum(long_open_res1 == 1) : 1462\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1600\n","WARNING:root:np.sum(long_open_res1 == 1) : 1462\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9800107479095459\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9724676609039307\n","en_ex_pairing elapsed time : 0.17316198348999023\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1530\n","WARNING:root:np.sum(long_open_res1 == 1) : 1370\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21606159210205078\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1529\n","WARNING:root:np.sum(long_open_res1 == 1) : 1370\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9759373664855957\n","get_open_info_df elapsed time : 0.986823558807373\n","en_ex_pairing elapsed time : 0.14832687377929688\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2083590030670166\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(short_open_res1 == 1) : 1463\n","WARNING:root:np.sum(long_open_res1 == 1) : 1316\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1463\n","WARNING:root:np.sum(long_open_res1 == 1) : 1316\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9757084846496582\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9947011470794678\n","en_ex_pairing elapsed time : 0.15147137641906738\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21394109725952148\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(short_open_res1 == 1) : 1388\n","WARNING:root:np.sum(long_open_res1 == 1) : 1266\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1388\n","WARNING:root:np.sum(long_open_res1 == 1) : 1266\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9745967388153076\n","get_open_info_df elapsed time : 0.9780423641204834\n","en_ex_pairing elapsed time : 0.14276409149169922\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1319\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21091866493225098\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 1208\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1319\n","WARNING:root:np.sum(long_open_res1 == 1) : 1208\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9673671722412109\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0268194675445557\n","en_ex_pairing elapsed time : 0.13862824440002441\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1258\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21175861358642578\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 1168\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1258\n","WARNING:root:np.sum(long_open_res1 == 1) : 1168\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9668574333190918\n","get_open_info_df elapsed time : 0.9674062728881836\n","en_ex_pairing elapsed time : 0.14765095710754395\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1203\n","WARNING:root:np.sum(long_open_res1 == 1) : 1129\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20909714698791504\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1203\n","WARNING:root:np.sum(long_open_res1 == 1) : 1129\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9663641452789307\n","get_open_info_df elapsed time : 0.9678199291229248\n","en_ex_pairing elapsed time : 0.15280413627624512\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20291733741760254\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(short_open_res1 == 1) : 1150\n","WARNING:root:np.sum(long_open_res1 == 1) : 1064\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1150\n","WARNING:root:np.sum(long_open_res1 == 1) : 1064\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9645693302154541\n","get_open_info_df elapsed time : 0.9721312522888184\n","en_ex_pairing elapsed time : 0.13347530364990234\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1108\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21446681022644043\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 991\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1108\n","WARNING:root:np.sum(long_open_res1 == 1) : 991\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9566135406494141\n","get_open_info_df elapsed time : 0.9713888168334961\n","en_ex_pairing elapsed time : 0.12442564964294434\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1068\n","WARNING:root:np.sum(long_open_res1 == 1) : 930\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.20700550079345703\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1068\n","WARNING:root:np.sum(long_open_res1 == 1) : 930\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9670774936676025\n","get_open_info_df elapsed time : 0.9715290069580078\n","en_ex_pairing elapsed time : 0.12322115898132324\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 1038\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.19513368606567383\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 873\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 1038\n","WARNING:root:np.sum(long_open_res1 == 1) : 873\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.969663143157959\n","get_open_info_df elapsed time : 0.9736535549163818\n","en_ex_pairing elapsed time : 0.1262373924255371\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:wave_point\n","WARNING:root:np.sum(short_open_res1 == 1) : 42048\n","WARNING:root:np.sum(long_open_res1 == 1) : 42240\n","WARNING:root:np.sum(short_open_res2 == 1) : 42048\n","WARNING:root:np.sum(long_open_res2 == 1) : 42240\n","WARNING:root:reject update_hl\n","WARNING:root:np.sum(short_open_res1 == 1) : 40427\n","WARNING:root:np.sum(long_open_res1 == 1) : 40130\n","WARNING:root:np.sum(short_open_res2 == 1) : 40427\n","WARNING:root:np.sum(long_open_res2 == 1) : 40130\n","WARNING:root:wave_mm\n","WARNING:root:np.sum(short_open_res1 == 1) : 40425\n","WARNING:root:np.sum(long_open_res1 == 1) : 40128\n","WARNING:root:np.sum(short_open_res2 == 1) : 40425\n","WARNING:root:np.sum(long_open_res2 == 1) : 40128\n","WARNING:root:wave_length\n","WARNING:root:np.sum(short_open_res1 == 1) : 997\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21213579177856445\n"]},{"output_type":"stream","name":"stderr","text":["WARNING:root:np.sum(long_open_res1 == 1) : 839\n","WARNING:root:point validation\n","WARNING:root:np.sum(short_open_res1 == 1) : 997\n","WARNING:root:np.sum(long_open_res1 == 1) : 839\n","WARNING:root:np.sum(short_open_res2 == 1) : 24865\n","WARNING:root:np.sum(long_open_res2 == 1) : 24969\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","WARNING:root:cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 0.54867 0.30000 (0.0)\n","WARNING:root:co_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.30000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9711620807647705\n","get_open_info_df elapsed time : 0.974346399307251\n","en_ex_pairing elapsed time : 0.1185002326965332\n","idep_plot elapsed time : 0.20534253120422363\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAABXEAAAILCAYAAACuD98cAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzde1yO9/8H8Fd1d5IOKtJJjEIiMYcZohyKWU4zZ6aZMczYbDb7xmy+28zY1/A1h5zCGCaTQ5Q5W3RWUSSdnTqn8+f3h6/7J5VSd1139Xo+Hp/Ho+v+XIf3dV1d17v703V9PioABIiIiIiIiIiIiIhIKalKHQARERERERERERERVYyNuERERERERERERERKjI24REREREREREREREqMjbhERERERERERERESoyNuERERERERERERERKjI24REREREREREREREqMjbjUoHl4eGDXrl1Sh0FERETliI2NhbOzs9RhEBERUQWEEGjbtq1C1jVt2jScP39eIesiaozYiEv0Cjw9PbFixQqpwyAiIiIiIiJSWlZWVhBCQE1NTepQiBoMNuISVZGqKi8XIiIiIiIiIiKqe2yVogZh8eLFSEhIQGZmJqKiouDk5CSv09DQwI4dO5CZmYnw8HB0795dXtehQwf4+/sjLS0N4eHhGDFihLzO09MTGzZswLFjx5CdnQ13d3dMmjQJixcvRlZWFry9vet0H4mIiBoyDQ0NrFmzBomJiUhMTMSaNWugoaEBAHB0dER8fDwWLlyI1NRUJCUlYfr06fJlDQ0N4e3tjYyMDPzzzz9YsWIFX9ckIiJSkGHDhuH27dt48OABfvzxR6ioqAAAVFRU8NVXX+Hu3btITU3Fjh07oKenBwA4d+4cACA9PR1ZWVno3bu3fH2rVq3C48ePcefOHbi4uNT9DhHVY4KFpT4XGxsbce/ePWFqaioACCsrK/Haa68JAMLDw0M8efJEuLq6ClVVVbFy5Upx+fJlAUDIZDIRHR0tlixZItTV1cXAgQNFZmamsLGxEQCEp6enSE9PF3369BEqKipCU1NTeHp6ihUrVki+zywsLCwsLA2hxMbGCmdnZwFALF++XFy+fFk0b95cGBsbi4sXL4pvvvlGABCOjo6isLBQLF++XMhkMuHq6ipycnKEgYGBACD27t0r9u7dK7S1tUXHjh3FvXv3xPnz5yXfPxYWFhYWlvpehBDCz89PNGvWTFhaWoqbN28Kd3d3AUC89957Ijo6WrRp00bo6OiIgwcPip07dwrg6fdyIYRQU1OTr2vatGmioKBAvP/++0JVVVV8+OGHIjExUfJ9ZGGpR0XyAFhYalTatm0rUlNThbOzs5DJZKXqPDw8hK+vr3y6Y8eOIjc3VwAQffv2FcnJyUJFRUVev2fPHuHh4SGAp424O3bsKLU+NuKysLCwsLAorjzfiBsTEyNcXV3ldUOGDBGxsbECeNqIm5ubW+qLYGpqqujVq5dQVVUVBQUF8n/CAhArVqxgIy4LCwsLC4sCihBCDB06VD49e/Zscfr0aQFAnD59WsyePVteZ2NjIwoKCoSamlqFjbjR0dHyaW1tbSGEECYmJpLvJwtLfSjsToHqvdu3b2PBggVYtmwZ7t+/j71798LU1FRen5KSIv85NzcX2traUFNTg5mZGeLj4yGEkNfHxcXB3NxcPh0fH183O0FERNTImZmZIS4uTj4dFxcHMzMz+fSjR49QXFwsn87NzUXTpk3RvHlzqKurl8rZzN9ERESK83xefT4/l5e71dXVYWJiUuG6nv9+/uTJEwBA06ZNFR0yUYPERlxqEPbu3Yt+/frJR8D84YcfKl0mKSkJlpaW8v58AKBVq1ZITEyUTz/fwFveNBERESlGUlISrKys5NOtWrVCUlJSpcs9ePAAhYWFsLCwkH9maWlZKzESERE1Rs/n1efzc3m5u7CwEKmpqfzuTFQL2IhL9Z6NjQ0GDhwIDQ0N5OXl4cmTJygpKal0uatXryI3NxeLFy+GTCaDo6MjRowYgX379lW4TGpqKl577TVFhk9ERER4+g/ZpUuXwtjYGEZGRvjXv/6F3bt3V7pcSUkJDh06hGXLlkFbWxvt27fH1KlT6yBiIiKixuGzzz6DgYEBLCws8PHHH+P3338H8DR3f/LJJ2jdujV0dHSwcuVK/P777yguLsaDBw9QXFzM789ECsRGXKr3NDU18f333+Phw4dISUlBixYtsGTJkkqXKywsxIgRI+Dq6oqHDx9iw4YNmDp1Km7evFnhMlu3boWtrS3S0tJw+PBhRe4GERFRo/btt9/i2rVrCA0NRVhYGAIDA/Htt99Wadm5c+dCX18fKSkp2LVrF/bu3Yv8/PxajpiIiKhxOHLkCK5fv47g4GAcO3YMW7duBQBs27YNu3btwrlz5xAbG4u8vDzMmzcPwNOuEr777jtcvHgRaWlp6NWrl5S7QNQgqOBp57hERERERA3C999/j5YtW2L69OlSh0JEREREpBB8EpeIiIiI6rX27dujc+fOAIAePXrA3d2db8wQERERUYMikzoAIiIiIqKa0NXVxd69e2FmZobU1FSsXr0aR44ckTosIiIiIiKFYXcKREREREREREREREqM3SkQERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hIREREREREREREpMTbiEhERERERERERESkxNuISERERERERERERKTE24hI1QjY2NggKCkJmZibmzZsndThUAU9PT6xYsaLS+bS0tODt7Y309HTs37+/DiIjIqKKMMcqP+ZXIqL6h/m1fmCOrV31qhE3NjYWzs7OZT53dHREfHy8BBHRi3iO6ofFixfD398fenp6WLdunULWqa6ujgMHDiA2NhZCCDg6OpaZ5/vvv8fDhw/x8OFDfP/996Xq7O3tce3aNeTk5ODatWuwt7evcFvNmjXDoUOHkJ2djbt372LChAml6idMmIC7d+8iOzsbhw8fRrNmzRSyj8pq7NixMDExgZGREcaNG1fhfC1btsSRI0eQmJgIIQSsrKxK1b/zzju4ePEicnJy4O/vX2b5t956C2FhYcjKysLFixfRsWPHCreloaGBrVu3IiMjA8nJyfjkk09K1Ts5OSEyMhI5OTnw8/NDq1atXnGvSdF4/1Z+PEf1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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","# val_list = np.arange(-0.0, -0.5, -0.03)  # prcn 2\n","# val_list = np.arange(-0.5, 0., 0.03)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","val_list = np.arange(100, 120, 1)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point1.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point1.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  # config_list_copy[0].tr_set.ep_gap1 = set_val \n","  # config_list_copy[0].tr_set.ep_gap2 = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","  config_list_copy[0].tr_set.wave_length1 = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","  open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","  open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=2)\n","  open_info_df_list = [open_info_df1, open_info_df2]\n","\n","  try:\n","    result.append(get_res_v9(res_df, open_info_df_list, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'frq', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1658210884.pkl\"\n","trade_log_dir_path = \"./trade_log/0717_5_47_trader\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","source":["trade_log  # both pos_side's log"],"metadata":{"id":"9Kymnik4ZpA6"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1658222594162,"user_tz":-540,"elapsed":431,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"a06c3f6a-311d-4a7d-c425-00563fd8980f"},"outputs":[{"output_type":"stream","name":"stdout","text":["lacked_open_ts : []\n","added_open_ts : ['2022-01-14 17:27:59.999000']\n","\n","lacked_entry_ts : []\n","added_entry_ts : ['2022-01-14 17:28:59.999000']\n","\n","lacked_exit_ts : []\n","added_exit_ts : ['2022-01-14 19:53:59.999000']\n","\n"]}],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"SELL\" # BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","op_ts = list(map(lambda x : str(x), res_df.index[val_obj[4].astype(int).ravel()])) \n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","for order_type, ts_ in zip(['open', 'entry', 'exit'], [op_ts, en_ts, ex_ts]):\n","  trade_log_ts = [k for k, v in trade_log.items() if order_type in v if pos_side in v]\n","  lacked_ts = [ts for ts in ts_ if not ts in trade_log_ts]\n","  added_ts = [ts for ts in trade_log_ts if not ts in ts_]\n","\n","  print(\"lacked_{}_ts :\".format(order_type), lacked_ts)\n","  print(\"added_{}_ts :\".format(order_type), added_ts)\n","  print()"]},{"cell_type":"code","source":["# ex_ts\n","# [k for k, v in trade_log.items() if order_type in v if pos_side in v]\n","# list(trade_log.keys())[1]\n","res_df.iloc[-0:]"],"metadata":{"id":"ZlcPZeuO-UnB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### check added_ts"],"metadata":{"id":"bPfWgZCI73LZ"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"markdown","source":["#### price sync_check"],"metadata":{"id":"yMFIedEG77Yt"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1658223074884,"user_tz":-540,"elapsed":378,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"96d56d1e-03f6-472a-cddd-5f449f3001ba"},"outputs":[{"output_type":"stream","name":"stdout","text":["2022-01-17 03:19:59.999000 -0.00580000000036307\n","\n","2022-01-18 16:49:59.999000 0.0\n","\n","2022-01-27 05:56:59.999000 -0.007399999999961437\n","\n","2022-01-27 11:51:59.999000 0.0\n","\n","2022-02-03 01:29:59.999000 0.0\n","\n","2022-02-05 10:58:59.999000 0.0\n","\n","2022-02-08 17:00:59.999000 -0.00559999999950378\n","\n","2022-02-13 07:03:59.999000 -0.003800000000410364\n","\n","2022-02-16 10:32:59.999000 -0.0039999999999054126\n","\n","2022-02-16 13:43:59.999000 0.0\n","\n"]}],"source":["accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    # print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":29,"metadata":{"id":"eiQ36_SLLE3w","executionInfo":{"status":"ok","timestamp":1658886602529,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if config_list[0].tr_set.check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v9_2(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16_2(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","source":["def plot_info_v9(gs, gs_idx, len_df, sample_len, tr, hhm, p2_hhm, out_hhm, mean_low, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n tpbox_mean_low : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhm, p2_hhm, out_hhm, mean_low, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize)\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"],"metadata":{"id":"8hdpN7S8JJF-"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":27,"metadata":{"id":"xafHpMLwESKf","executionInfo":{"status":"ok","timestamp":1658886540524,"user_tz":-540,"elapsed":1269,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def idep_plot_v16_2(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    # print(\"short_obj.shape :\", short_obj.shape)\n","    # print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","          short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","    print(\"short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick :\", short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_net_p1_bias_tick, short_p2exec_p1_bias_tick, short_net_p1_idx_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_net_p1_bias_tick, long_p2exec_p1_bias_tick, long_net_p1_idx_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v9_2(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    open, high, low, close = ohlc_list\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        if show_detail:\n","            print(\"open_i1 :\", open_i1, side_arr1[open_i1])\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm   \n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ============\".format(op_idx1, open_side))\n","     \n","        # if show_detail:\n","        #   print(\"check_hlm :\", check_hlm)\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.entry_type, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry by expiry_p2 function in p1's loop : continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        # if check_hlm in [0, 1]:\n","        #   i = op_idx1  # allow op_idx2 = op_idx1\n","        # allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          if check_hlm == 2:\n","            open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","            if open_i2 >= len_open_idx2:  # open_i2 소진\n","                break\n","\n","            if show_detail:\n","              print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","            # ------ check side sync. ------ #\n","            if open_side != side_arr2[open_i2]:\n","              continue\n","\n","            # ------ assert, op_idx2 >= exec_j ------ #\n","            op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","            if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","              continue\n","            \n","            if show_detail:\n","              print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","            \n","            i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","            if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                break\n","\n","          else:\n","            op_idx2 = op_idx1\n","\n","          tp_ = tp_arr[op_idx1]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]          \n","          \n","\n","          if check_hlm == 2:\n","            # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","            # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","            # if check_hlm:  # p1_hlm, p2_hlm --> Todo, 이거를 왜 p1_hlm 에도 적용했는지 잘 모르겠음\n","            if op_idx1 < op_idx2:\n","              expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","              if expire:   # p1's expiry\n","                  if show_detail:\n","                    print(\"expiry_p1, touch_idx = {} : break\".format(touch_idx))\n","                  i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                  open_i2 = prev_open_i2\n","                  break   # change op_idx1\n","\n","            # ------ p2 point_validation - vectorization unavailable ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","            if open_side == OrderSide.SELL:\n","              if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","                break  # change op_idx1\n","              elif not (ep2_ < out_ and close[op_idx2] < out_):\n","                if show_detail:\n","                  print(\"point validation : continue\")\n","                continue  # change op_idx2\n","            else:\n","              if not (tp_ > ep2_):              \n","                break\n","              elif not (ep2_ > out_ and close[op_idx2] > out_):\n","                if show_detail:\n","                  print(\"point validation : continue\")\n","                continue\n","\n","            # ------ p2_box location ------ #\n","            if open_side == OrderSide.SELL:\n","              if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","              # if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                if show_detail:\n","                    print(\"p2_box rejection : continue\")\n","                continue\n","              else:                \n","                # ------ p1p2_low ------ #\n","                if not high[op_idx1:op_idx2 + 1].max() < tp_0_ - tp_gap_ * config.tr_set.p1p2_low:\n","                  if show_detail:\n","                    print(\"p1p2_low rejection : continue\")\n","                  continue\n","            else:\n","              if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","              # if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                if show_detail:\n","                    print(\"p2_box rejection : continue\")\n","                continue\n","              else:\n","                # ------ p1p2_low ------ #\n","                if not low[op_idx1:op_idx2 + 1].min() > tp_0_ + tp_gap_ * config.tr_set.p1p2_low:\n","                  if show_detail:\n","                    print(\"p1p2_low rejection : continue\")\n","                  continue\n","\n","            # ------ check p2's expiry ------ #\n","            exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v6(res_df, config, config.ep_set.point2.entry_type, op_idx2, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                    [*ohlc_list, ep2_arr], expiry_p2)   # Todo, tp_1 & tp_gap 사용이 맞을 것으로 봄\n","            i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","            if not entry_done:   # p2's expiry\n","                if show_detail:\n","                    print(\"expiry_p2, i = {} : continue\".format(i))\n","                continue  # change op_idx2            \n","            \n","            # ------ devectorized tr_calc ------ #   # en_p 에 대해 하는게 맞을 것으로봄\n","            if open_side == OrderSide.SELL:\n","              tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))\n","            else:\n","              tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))              \n","\n","            # ------ tr_threshold ------ #\n","            if config.loc_set.point2.short_tr_thresh != \"None\":\n","              if open_side == OrderSide.SELL:\n","                if tr_ < config.loc_set.point2.short_tr_thresh:\n","                  if show_detail:\n","                    print(\"tr_threshold : continue\")\n","                  continue\n","              else:\n","                if tr_ < config.loc_set.point2.long_tr_thresh:\n","                  if show_detail:\n","                    print(\"tr_threshold : continue\")\n","                  continue\n","                \n","          else:\n","            tr_ = tr_arr[op_idx1]\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None : continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ # --> p1_hlm 의 경우, 1번만 실행\n","          # if not allow_exit:\n","          #   continue\n","\n","          while 1:\n","              if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                  tp_j = i\n","              if not config.out_set.static_out:\n","                  out_j = i\n","\n","              # ------------ out ------------ #  # out 우선 (보수적 검증)\n","              # ------ signal_out ------ #\n","              if not exit_done:\n","                  exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","              # ------ hl_out ------ #\n","              if config.out_set.hl_out != \"None\":\n","                  if not exit_done:  # and i != len_df - 1:\n","                      exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","              # ------------ tp ------------ #\n","              if not config.tp_set.non_tp and i != exec_j:\n","                if not exit_done:\n","                  exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                            [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                  # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                  # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","              if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                  # ------ append dynamic vars. ------ #\n","                  p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                  p2_idx_list.append(op_idx2)\n","                  pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                  pair_price_list.append([en_p, ex_p])\n","                  lvrg_list.append(leverage)\n","                  fee_list.append(fee)\n","                  tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                  tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                  # open_i += 1  # 다음 open_idx 조사 진행\n","                  break\n","\n","              # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","              # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","              i += 1\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done\n","            if show_detail:\n","                    print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:  # exit_done -> -1 or 0 (0 means end of df) \n","            if check_hlm == 2:\n","              # if check_hlm == 1:   # exit only once in p1_hlm mode\n","              #   allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : continue\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {}, i = {} : break\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        # if op_idx1 >= 16355:\n","        #   break\n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_entry_v6(res_df, config, entry_type, op_idx, wave1, wave_gap, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave_gap, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[i] < ha_c[i]):# & (ha_o[i] == ha_l[i]):   # 양봉 출현\n","    #           exit_done = -1\n","    #     else:\n","    #       if (ha_o[i] > ha_c[i]):# & (ha_o[i] == ha_h[i]):  # 음봉 출현\n","    #           exit_done = -1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[i] < bb_lower_5T[i] < close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] > bb_upper_5T[i] > close[i - 1]:\n","                exit_done = -1\n","        else:\n","            if close[i] > bb_upper_5T[i] > close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] < bb_lower_5T[i] < close[i - 1]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","metadata":{"id":"qM6H6fmrKtsA"},"source":["#### legacy"]},{"cell_type":"code","source":["# np.nanmin([np.nan, 1])\n","np.nan <= np.nan"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"AH3JXLkwL_B6","executionInfo":{"status":"ok","timestamp":1658884508950,"user_tz":-540,"elapsed":1076,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0fa49ccd-e99c-44fd-ac0a-84441dd585d4"},"execution_count":21,"outputs":[{"output_type":"execute_result","data":{"text/plain":["False"]},"metadata":{},"execution_count":21}]},{"cell_type":"code","execution_count":22,"metadata":{"id":"uB-I09hKKvmu","executionInfo":{"status":"ok","timestamp":1658885138988,"user_tz":-540,"elapsed":553,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["def get_wave_bias_v6(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_p2exec_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_p2exec_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐, np.nan <= np.nan --> false\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))   # p1's 1st & 2nd pair 위해서 last_idx 마지막에 붙여준 것\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx = short_tp_1_touch_idx[short_p2exec_p1_idx]  # p2 까지 체결된 p1's hhm (p2 executed p1_hhm)\n","    short_tp_0_p2exec_p1_touch_idx = short_tp_0_touch_idx[short_p2exec_p1_idx]\n","    long_tp_1_p2exec_p1_touch_idx = long_tp_1_touch_idx[long_p2exec_p1_idx]\n","    long_tp_0_p2exec_p1_touch_idx = long_tp_0_touch_idx[long_p2exec_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------ get wave's bias_tick ------------ #\n","    short_tp_1_net_p1_touch_idx2 = np.where(short_tp_1_net_p1_touch_idx == last_idx, np.nan, short_tp_1_net_p1_touch_idx)\n","    long_tp_1_net_p1_touch_idx2 = np.where(long_tp_1_net_p1_touch_idx == last_idx, np.nan, long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_p2exec_p1_touch_idx2 = np.where(short_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, short_tp_1_p2exec_p1_touch_idx)\n","    long_tp_1_p2exec_p1_touch_idx2 = np.where(long_tp_1_p2exec_p1_touch_idx == last_idx, np.nan, long_tp_1_p2exec_p1_touch_idx)\n","\n","    short_net_p1_bias_tick = np.nanmean(short_tp_1_net_p1_touch_idx2 - short_net_p1_idx)\n","    long_net_p1_bias_tick = np.nanmean(long_tp_1_net_p1_touch_idx2 - long_net_p1_idx)\n","\n","    short_p2exec_p1_bias_tick = np.nanmean(short_tp_1_p2exec_p1_touch_idx2 - short_p2exec_p1_idx)\n","    long_p2exec_p1_bias_tick = np.nanmean(long_tp_1_p2exec_p1_touch_idx2 - long_p2exec_p1_idx)\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_p2exec_p1_true_bias_bool = short_tp_1_p2exec_p1_touch_idx < short_tp_0_p2exec_p1_touch_idx  # true_bias 의 조건\n","    short_p2exec_p1_false_bias_bool = short_tp_1_p2exec_p1_touch_idx >= short_tp_0_p2exec_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_p2exec_p1_true_bias_bool = long_tp_1_p2exec_p1_touch_idx < long_tp_0_p2exec_p1_touch_idx\n","    long_p2exec_p1_false_bias_bool = long_tp_1_p2exec_p1_touch_idx >= long_tp_0_p2exec_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p2exec_tpbox_hhm = hhm(short_p2exec_p1_true_bias_bool, short_p2exec_p1_false_bias_bool)\n","    long_p2exec_tpbox_hhm = hhm(long_p2exec_p1_true_bias_bool, long_p2exec_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_p2exec_tpbox_hhm, long_p2exec_tpbox_hhm, short_outbox_hhm, long_outbox_hhm, \\\n","           short_net_p1_bias_tick, long_net_p1_bias_tick, short_p2exec_p1_bias_tick, long_p2exec_p1_bias_tick, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"]},{"cell_type":"code","source":["def idep_plot_v17(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"short_net_p1_frq :\", short_net_p1_frq)\n","    # print(\"long_net_p1_frq :\", long_net_p1_frq)\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ get hhm ------ #    \n","    # start_0 = time.time()\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","\n","    # ------ mean_low ------ #    \n","    # start_0 = time.time()\n","    selection_id = config.selection_id\n","\n","    short_p1_idx = short_obj[-1].astype(int)\n","    long_p1_idx = long_obj[-1].astype(int)    \n","\n","    short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx] # != short_tp_1\n","    long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","    long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","    long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","    short_max_outg = get_max_outg_v4(OrderSide.SELL, config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)  # tp_box's mean_low 확인 위해 tp_gap 입력함\n","    long_max_outg = get_max_outg_v4(OrderSide.BUY, config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","    short_mean_low = short_max_outg[short_p2_true_bias_bool].mean()\n","    long_mean_low = long_max_outg[long_p2_true_bias_bool].mean()\n","    both_mean_low = (short_mean_low + long_mean_low) / 2\n","    # print(\"short_mean_low :\", short_mean_low)\n","    # print(\"long_mean_low :\", long_mean_low)\n","    # print(\"both_mean_low :\", both_mean_low)\n","    # print(\"mean_low elapsed time :\", time.time() - start_0)\n","\n","    # ------ plot_data ------ #\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_mean_low, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_mean_low, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v9(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_mean_low, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"],"metadata":{"id":"Eos0FoAgrfW5"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":260,"status":"ok","timestamp":1653436951068,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"oLDZobRcgg6E","outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"outputs":[{"data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":["res_df.low.rolling(100) #> 1000"]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","source":["def get_pr_v4(open_side, h, l, obj, tpout, lvrg, fee, p_ranges, p_qty_ratio, inversion=False):  # --> 여기서 사용하는 ex_p = ex_p\n","\n","    en_p = obj[0]\n","    # ex_p = obj[1]\n","    tp, out = np.split(tpout, 2, axis=1)\n","    len_p = len(p_ranges)\n","    en_ps, tps, outs, lvrgs, fees = [np.tile(arr_, (1, len_p)) for arr_ in [en_p, tp, out, lvrg, fee]]\n","\n","    np_obj = np.array(obj).T[0]\n","    assert len(np_obj.shape) == 2\n","\n","    # iin == iout 인 경우 분리\n","    en_idx = np_obj[:, 2]\n","    ex_idx = np_obj[:, 3]\n","    equal_idx = en_idx == ex_idx    # equal_idx 는 어차피 out 임\n","    issue_idx = en_idx > ex_idx    # equal_idx 는 어차피 out 임\n","\n","    print('pass')\n","    idx_gap_ = (ex_idx - en_idx)[~equal_idx]\n","    print(\"en_idx[issue_idx] :\", en_idx[issue_idx])\n","    print(\"ex_idx[issue_idx] :\", ex_idx[issue_idx])\n","    print(\"idx_gap_[idx_gap_ <= 0] :\", idx_gap_[idx_gap_ <= 0])\n","\n","    min_low = np.full_like(en_p, np.nan)\n","    min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","    max_high = np.full_like(en_p, np.nan)\n","    max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","\n","    if open_side == \"SELL\":\n","        p_tps = en_ps - (en_ps - tps) * p_ranges\n","        # min_low = np.full_like(en_p, np.nan)\n","        # min_low[~equal_idx] = np.array([np.min(l[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)  # start from iin + 1 (tp 체결을 entry_idx 부터 보지 않음)\n","        tp_idx = (np.tile(min_low, (1, len_p)) <= p_tps) * (np.tile(max_high, (1, len_p)) <= outs)  # entry_idx 포함해서 out touch 금지 (보수적 검증)\n","    else:\n","        p_tps = en_ps + (tps - en_ps) * p_ranges\n","        # max_high = np.full_like(en_p, np.nan)\n","        # max_high[~equal_idx] = np.array([np.max(h[int(iin + 1):int(iout + 1)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","        tp_idx = (np.tile(max_high, (1, len_p)) >= p_tps) * (np.tile(min_low, (1, len_p)) >= outs)\n","\n","    ex_ps = outs.copy()\n","    ex_ps[tp_idx] = p_tps[tp_idx]\n","\n","    if open_side == \"SELL\":\n","        if not inversion:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","    else:\n","        if not inversion:\n","            pr = ((ex_ps / en_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            min_low = np.full_like(en_p, np.nan)\n","            min_low[~equal_idx] = np.array([np.min(l[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((min_low / en_p - fee - 1) * lvrg + 1)\n","        else:\n","            pr = ((en_ps / ex_ps - fees - 1) * lvrgs * p_qty_ratio).sum(axis=1) + 1\n","            # ------ liquidation ------ #\n","            max_high = np.full_like(en_p, np.nan)\n","            max_high[~equal_idx] = np.array([np.max(h[int(iin):int(iout)]) for _, _, iin, iout in np_obj[~equal_idx, :4]]).reshape(-1, 1)\n","            liqd = np.nanmin((en_p / max_high - fee - 1) * lvrg + 1)\n","\n","    return pr.reshape(-1, 1), liqd"],"metadata":{"id":"wDQWK3v5xOFa"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def idep_plot_v16(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    print(\"short_obj.shape :\", short_obj.shape)\n","    print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"],"metadata":{"id":"6G92q_bExTVn"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oE5zkT75Beiy"},"outputs":[],"source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","pos_side = \"SELL\" # SELL BUY\n","\n","if pos_side == \"SELL\":\n","  open_ = res_df['short_open1_{}'.format(config.selection_id)].to_numpy()\n","  open_ts = list(map(lambda x : str(x), res_df.index[open_ == 1]))  \n","else:\n","  open_ = res_df['long_open1_{}'.format(config.selection_id)].to_numpy()\n","  open_ts = list(map(lambda x : str(x), res_df.index[open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["pos_index = open_info_df1.side == pos_side\n","for ts in res_df.index[open_info_df1.index[pos_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6YcqQQzsl6Ys"},"outputs":[],"source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"t7a5Hyyyd5Lk"},"outputs":[],"source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dsI-R8Zz7ls1"},"outputs":[],"source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":350,"status":"ok","timestamp":1652751452213,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"gMur2u8WeQ2K","outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"outputs":[{"data":{"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"elapsed":872,"status":"ok","timestamp":1652756329304,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"eoXMxRm3qdz2","outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"outputs":[{"data":{"image/png":"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\n","text/plain":["<Figure size 1152x144 with 2 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"dm7ZqzS9vqhm"},"outputs":[],"source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qOE2YSzntx8v"},"outputs":[],"source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_plot_params"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rMIwv1Nr1ojX"},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 0     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick, 5 : bias_tick (사용 금지)  \n","x_max = 500       # back_plot : 0 사용시, custom x_max 반영됨\n","\n","bias_plot = 1     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = 1   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 100 #  150 100 20 500 1000\n","post_plotsize = 100 # config.tr_set.bias_info_tick -> excessive bit 는 감당 못함\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","    if pr_descend == -1:\n","      pr_descend = 0\n","    pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","try:   # wave_range 단독 실행의 경우 tr_arr 이 존재하지 않기 때문에 try 처리함\n","  res_df['short_tr_{}'.format(selection_id)].iloc[short_obj[-1].astype(int).ravel()] = short_tr_arr\n","  res_df['long_tr_{}'.format(selection_id)].iloc[long_obj[-1].astype(int).ravel()] = long_tr_arr\n","except:\n","  pass\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":798,"status":"ok","timestamp":1658797807231,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"2bjxKCIh1ojZ","outputId":"a72b4daf-02c9-433f-f32b-f0943b23cb2d"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","# hc_tf1 = '5T'\n","# hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period1 = config.tr_set.wave_period1\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = 'T'\n","dc_period1 = wave_period2  # 20\n","dc_tf2 = 'T'\n","dc_period2 = config.loc_set.point2.csd_period if config.loc_set.point2.csd_period != \"None\" else wave_period2 \n","\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ff00ff', 1]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 2]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 60\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ma / ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","ma_period = 60\n","step_col_list.append([['ma_T{}'.format(ma_period)], 1, '#03ed30', 2])\n","# step_col_list.append([['long_ma_T{}_-1'.format(ma_period)], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","# ------ stoch ------ #\n","# step_col_list2.append([['stoch_{}{}33'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","\n","# ------ macd ------ #\n","# step_col_list2.append([['macd_T535'], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","# stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","# stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","# data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","data_window_p1_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_p1_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  # \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"XfvH5ngyieS9"},"source":["#### session_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1_V1FftyWa9hu2r9IEGOI6B2x0loEsqAE"},"executionInfo":{"status":"ok","timestamp":1658805854597,"user_tz":-540,"elapsed":424482,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"cc40844a-fd86-4c0f-ab15-224f4381d167"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["# p2_hlm 의 경우, tr 확인을 우해 session_plot 우선 실행 필요함\n","_ = [plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","metadata":{"id":"sZAYhcdoXnm4"},"source":["### whole_plot"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jjFziVVIhgSr"},"outputs":[],"source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","metadata":{"id":"50HXDIdJij28"},"source":["#### whole_plot main"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-tbLsXN9eN2p"},"outputs":[],"source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FtILHO-4kVlO"},"outputs":[],"source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    # print(\"p1_idx :\", p1_idx)\n","    # if p1_idx != 370259:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    if back_plot == 0:\n","      iout = iin + x_max\n","      # print(\"iin, iout :\", iin, iout)\n","\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v8(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v8(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","  elif back_plot == 5:\n","    x_max = bias_info_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  if config.tr_set.check_hlm in [0, 1]:\n","    ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg1 {}'.format(en_p, config.tr_set.ep_gap1), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  else:\n","    ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg2 {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------------ ax2 ------------ #\n","  # ------ cci_band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ------ stoch_band ------ #\n","  # ax2.axhline(67, color=\"#ffffff\")\n","  # ax2.axhline(33, color=\"#ffffff\")\n","  \n","  # ax2.axhline(0, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  if back_plot == 5:\n","    ax1.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"ddL_BC24buq0"},"source":["### dump"]},{"cell_type":"markdown","metadata":{"id":"zgTrEWWqbwsT"},"source":["#### whole_plot thing"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M4zn8wxibzAR"},"outputs":[],"source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"4IhBjPMobzAS"},"outputs":[],"source":["cf.go_offline()\n","init_notebook_mode()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"n9WZkE9wbzAS"},"outputs":[],"source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","x2yj2SwAXDLp","14chOHeXh6JD","EOXQbXixiQcK","RZJ6uIA_VcJs","xpyP5t8Ht_pE","MuD_2vY7TI_8","tOFkzUX2imQu","983aUwM76s6X","_blyFhQJUd5X"],"name":"stem5_48_vec_backi2(0721).ipynb","provenance":[],"toc_visible":true,"authorship_tag":"ABX9TyM7gTF1hh7qBCR1t3UpkTsM"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}