{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"id":"6rmQpzEGXfCw","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1654265119254,"user_tz":-540,"elapsed":20036,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"439792bf-799c-4aa6-9d39-a4d3b758f4a9"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')\n","\n","import os, sys\n","\n","current_path = '/content/drive/My Drive/Colab Notebooks/JnQ/'\n","\n","os.chdir(current_path)\n","\n","strat_pkg = 'IDE'\n","\n","mpl_finance_path = '/content/drive/My Drive/Colab Notebooks/JnQ/mpl_finance'\n","ta_lib_path = '/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","\n","if mpl_finance_path not in sys.path:\n","\n","  try:\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ')\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/{}'.format(strat_pkg))\n","    sys.path.insert(0, '/content/drive/My Drive/Colab Notebooks/JnQ/funcs')\n","    sys.path.insert(0, mpl_finance_path)\n","    sys.path.insert(0, ta_lib_path)\n","    \n","  except Exception as e:\n","    print(e)"]},{"cell_type":"markdown","metadata":{"id":"8uqYv5StTazo"},"source":["# requirements"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"9qGt60DKTZmf","executionInfo":{"status":"ok","timestamp":1654265139250,"user_tz":-540,"elapsed":20000,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# !pip install zigzag --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/zigzag'\n","# !pip install talib-binary --target=$'/content/drive/My Drive/Colab Notebooks/JnQ/ta_lib'\n","# !pip install findiff\n","\n","# import nvstrings, nvcategory, cudf\n","# import cuml\n","# import cudf\n","\n","import os\n","import talib\n","from funcs.funcs_idep import *\n","from funcs.funcs_duration_v2 import *\n","from funcs.funcs_plot_check import *\n","from funcs.funcs_pairing import *\n","# from funcs.funcs_ide import *\n","# from funcs.funcs_indicator_candlescore import *\n","from funcs.funcs_indicator import *\n","from funcs.funcs_trader import *\n","from ast import literal_eval\n","import logging\n","import importlib\n","\n","import mpl_finance as mf\n","import matplotlib.pyplot as plt\n","from matplotlib import gridspec\n","# from zigzag import *\n","# from tqdm.notebook import tqdm\n","\n","# import IPython\n","# import IPython.display\n","\n","import numpy as np\n","# import jax.numpy as np\n","import pandas as pd\n","# import seaborn as sns\n","# import tensorflow as tf\n","# from scipy import stats, signal\n","\n","import pickle\n","import shutil\n","import json\n","from easydict import EasyDict\n","import copy\n","\n","import datetime\n","from datetime import datetime\n","import random\n","import time\n","# import warnings\n","\n","# warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n","\n","np.seterr(invalid=\"ignore\")\n","np.set_printoptions(suppress=True)\n","np.set_printoptions(linewidth=2000) \n","\n","pd.set_option('mode.chained_assignment',  None)\n","\n","pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)"]},{"cell_type":"markdown","metadata":{"id":"Ic1mfmwWCIBu"},"source":["# makeset - with to_htf dataframes"]},{"cell_type":"markdown","metadata":{"id":"AUSBU7T8Suzi"},"source":["## sync_check_make"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"QmhLikYlSuzi"},"outputs":[],"source":["def sync_check_make(df):\n","\n","    make_itv_list = ['3T', '5T', '15T', '30T', 'H', '4H', 'D']\n","    offset_list = ['1h', '1h', '1h', '1h', '1h', '1h', '9h']\n","\n","    assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        \n","    htf_df_list = [to_htf(df, itv_=itv_, offset=offset_) for itv_, offset_ in zip(make_itv_list, offset_list)]\n","\n","    df_3T, df_5T, df_15T, df_30T, df_H, df_4H, df_D = htf_df_list\n","\n","    for htf_df in htf_df_list:\n","      print(\"{} -> \".format(pd.infer_freq(htf_df.index)), htf_df.tail(1))\n","\n","    # heikinashi_v2(res_df_)\n","    # h_candle_v3(df, df_5T, '5T')\n","    # df = h_candle_v4(df, df_5T)\n","    # df = h_candle_v4(df, df_15T)\n","    # df = h_candle_v4(df, df_30T)\n","    # df = h_candle_v4(df, 'D')\n","\n","    # df = candle_pattern_pkg(df, df_5T)\n","    # df = candle_pattern_pkg(df, df_30T)\n","    # df = candle_pattern_pkg(df, df_H)\n","    # df = candle_pattern_pkg(df, df_4H)\n","\n","    \n","    # df = enough_space(df, '15T', 1)\n","    \n","    # --------------- dc --------------- #  \n","    dc_period = 1\n","    # df = donchian_channel_v4(df, dc_period)\n","    # df = dc_line(df, df_5T, '5T')  # join 사용시에만 return df 허용함\n","    # df = dc_line(df, df_15T, '15T')\n","    # df = dc_line_v2(df, df_H, 'H', dc_period=5)\n","\n","    df = dc_line_v4(df, df, dc_period=10)\n","    df = dc_line_v4(df, df, dc_period=20)\n","    # df = dc_line_v4(df, df_15T, dc_period=dc_period)\n","    print(\"dc phase done\")\n","\n","    # --------------- bb --------------- #  \n","    bb_period = 20\n","\n","    # upper, base, lower = talib.BBANDS(res_df_.close, timeperiod=20, nbdevup=1, nbdevdn=1, matype=0)\n","    \n","    # df = bb_width_v3(df, period=60, multiple=1)\n","    # df = bb_line(df, df_5T, '5T')\n","    # df = bb_line_v3(df, df_15T, 60)\n","\n","    # df = bb_level_v2(df, 'T', 60)\n","    # print(\"bb phase done\")\n","\n","    c_itv = '5T'\n","\n","    # df =  wick_ratio(df, c_itv)\n","    # df =  wick_ratio(df, c_itv)\n","\n","    bb_itv= 'T'\n","\n","    # df = candle_range_ratio(df, c_itv, bb_itv, bb_period)\n","    # # candle_pumping_ratio(df, c_itv, bb_itv, bb_period)\n","\n","    dc_itv= '15T'\n","    dc_period = 4\n","    # df = candle_pumping_ratio_v2(df, c_itv, dc_itv, dc_period)\n","    # print(\"candle_pumping_ratio_v2 phase done\")\n","\n","    # df = dc_over_body_ratio(df, c_itv, dc_itv, dc_period)\n","    # print(\"dc_over_body_ratio phase done\")\n","\n","    # df = body_rel_ratio(df, c_itv)\n","    # print(\"body_rel_ratio phase done\")\n","\n","    # --------------- cbline --------------- #    \n","    # cloud_bline(df_3T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-1]), how='inner')\n","    # # cloud_bline(df_5T, 20)\n","    # # df = df.join(to_lower_tf_v2(df, df_5T, [-1]), how='inner')\n","    # cloud_bline(df_15T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-1]), how='inner')\n","    # cloud_bline(df_30T, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-1]), how='inner')\n","    # cloud_bline(df_H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_H, [-1]), how='inner')\n","    # cloud_bline(df_4H, 20)\n","    # df = df.join(to_lower_tf_v2(df, df_4H, [-1]), how='inner')\n","\n","    # print(\"cbline phase done\")\n","\n","\n","\n","    # --------------- sd_dc --------------- #\n","    # df = sd_dc(df, 20, 40)\n","    # df = sd_dc(df, 20, 20)\n","    # df = sd_dc(df_5T, 20, 40, df)\n","    # df = sd_dc(df_H, 20, 40, df)\n","\n","    # print(\"sd_dc phase done\")\n","\n","    # --------------- imb_ratio --------------- #\n","    # imb_ratio(df, '5T')\n","    # imb_ratio_v3(df, \"5T\")\n","    # imb_ratio_v4(df, \"5T\")\n","\n","    # imb_ratio(df, 'H')\n","    # imb_ratio_v2(df, '5T')\n","    \n","    # print(\"imb_ratio phase done\")\n","\n","    # --------------- rel_abs_ratio --------------- #\n","    # rel_abs_ratio(df, '5T', norm_period=120)\n","\n","    # --------------- normalize data --------------- #\n","    # itv = 'T'\n","    # lb_period = 15\n","    # target_col = 'close_{}{}'.format(itv, lb_period)\n","    # target_data = df['close'].diff(lb_period).to_numpy()\n","    # norm_data(df, target_data, target_col)    \n","    # print(\"normalize data phase done !\")\n","\n","    # --------------- lucid sar --------------- #\n","    # lucid_sar_v2(df)\n","    # lucid_sar_v2(df_3T)\n","    # df = df.join(to_lower_tf_v2(df, df_3T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_5T)\n","    # df = df.join(to_lower_tf_v2(df, df_5T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_15T)\n","    # df = df.join(to_lower_tf_v2(df, df_15T, [-2, -1]), how='inner')\n","    # lucid_sar_v2(df_30T)\n","    # df = df.join(to_lower_tf_v2(df, df_30T, [-2, -1]), how='inner')       \n","\n","    # print(\"sar phase done\")\n","\n","    # --------------- supertrend --------------- #\n","    # df = st_price_line(df, df_3T, '3m')\n","    # df = st_price_line(df, df_5T, '5m')\n","    # df = st_price_line(df, df_15T, '15m')\n","    # df = st_price_line(df, df_30T, '30m')\n","    # df = st_price_line(df, df_H, '1h')\n","    # df = st_price_line(df, df_4H, '4h')\n","\n","    # print(\"supertrend phase done\")\n","\n","    # --------------- rsi --------------- #  \n","    # df['rsi_1m'] = rsi(df, 14)    \n","    # df_5T['rsi_5m'] = rsi(df_5T, 14)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['rsi_5m']))\n","    \n","    # print(\"rsi phase done\")\n","\n","\n","    # --------------- cci --------------- #  \n","    # df['cci_1m'] = cci(df, 20)\n","\n","    # print(\"cci phase done\")\n","\n","    # --------------- ema --------------- #      \n","    # df_5T['ema_5m'] = ema(df_5T['close'], 195)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1]), columns=['ema_5m']))\n","    \n","    # print(\"ema phase done\")\n","        \n","    # --------------- stochastic --------------- #\n","    # df['stoch_1m'] = stoch(df, 13, 3, 3)\n","\n","    # df_5T['stoch'] = stoch(df_5T, 13, 3, 3)\n","    # df = df.join(pd.DataFrame(index=df.index, data=to_lower_tf_v2(df, df_5T, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","    # print(\"stoch phase done\")\n","\n","\n","    return df\n"]},{"cell_type":"markdown","metadata":{"id":"mEKyVbHWSuzi"},"source":["## make & save res_df (concat 생각하면, timeindex sync 맞춰야함)"]},{"cell_type":"markdown","metadata":{"id":"VdukVo5-Suzj"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"khKb9nhlSuzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  if '2021-07-01'.upper() not in file_list[i]:\n","  # if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    excel_name = key.replace(\".xlsx\", \"_st1h_backi2.xlsx\")\n","    excel_path = save_path + excel_name\n","\n","    if excel_name in exist_list:\n","      print(excel_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","    latest_open_index = sorted(open_indexes)[-1]\n","    \n","    open_ts = datetime.timestamp(latest_open_index)\n","    latest_open_index_1m = datetime.fromtimestamp(open_ts + a_day)\n","\n","    #   str 로 만들어 접근하면 불가함  #\n","    end_index = pd.to_datetime(str(df.index[-1]).split(\" \")[0] + \" 08:59:59.999000\")\n","    # break\n","\n","    sliced_df = df.loc[latest_open_index_1m:end_index] # to_lower_tf 의 기준 ltf\n","    sliced_second_df = second_df.loc[latest_open_index:end_index]\n","    sliced_third_df = third_df.loc[latest_open_index:end_index]\n","    sliced_fourth_df = fourth_df.loc[latest_open_index:end_index]\n","    sliced_fifth_df = fifth_df.loc[latest_open_index:end_index]\n","\n","    print(\"sliced index\")\n","    print(sliced_df.index[[0, -1]])\n","    print(sliced_second_df.index[[0, -1]])\n","    print(sliced_third_df.index[[0, -1]])\n","    print(sliced_fourth_df.index[[0, -1]])\n","    print(sliced_fifth_df.index[[0, -1]])\n","\n","    try:\n","      sliced_sixth_df = sixth_df.loc[latest_open_index:end_index]\n","      sliced_seventh_df = seventh_df.loc[latest_open_index:end_index]\n","\n","      print(sliced_sixth_df.index[[0, -1]])\n","      print(sliced_seventh_df.index[[0, -1]])\n","\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df, sliced_sixth_df, sliced_seventh_df)\n","    \n","    except:\n","      res_df = sync_check(sliced_df, sliced_second_df, sliced_third_df, sliced_fourth_df, sliced_fifth_df)\n","\n","\n","\n","    res_df.to_excel(excel_path)\n","    print(excel_name, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"Bw5JibDKSuzj"},"source":["### xlsx to feather"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VA-_gcA7Suzj"},"outputs":[],"source":["pd.set_option('display.max_rows', 500)\n","pd.set_option('display.max_columns', 500)\n","pd.set_option('display.width', 1000)\n","\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","exist_list = os.listdir(save_path)\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  # if '2021-04-30'.upper() not in file_list[i]:\n","  # if '2021-07-01'.upper() not in file_list[i]:\n","  if '2021-10-10'.upper() not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","\n","    feather_name = key.replace(\".xlsx\", \".ftr\")\n","    # feather_path = save_path + feather_name\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    open_indexes = []\n","    \n","    df = pd.read_excel(date_path + key, index_col=0)\n","    second_df = pd.read_excel(date_path2 + key, index_col=0)\n","    third_df = pd.read_excel(date_path3 + key, index_col=0)\n","    fourth_df = pd.read_excel(date_path4 + key, index_col=0)\n","    fifth_df = pd.read_excel(date_path5 + key, index_col=0)\n","    \n","    print(df.index[[0, -1]])\n","    print(second_df.index[[0, -1]])\n","    print(third_df.index[[0, -1]])\n","    print(fourth_df.index[[0, -1]])\n","    print(fifth_df.index[[0, -1]])\n","\n","    open_indexes.append(df.index[0])\n","    open_indexes.append(second_df.index[0])\n","    open_indexes.append(third_df.index[0])\n","    open_indexes.append(fourth_df.index[0])\n","    open_indexes.append(fifth_df.index[0])\n","    \n","    try:\n","      #     Todo    #\n","      #      1. 1m 마지막 timeindex 의 date 기준, 08:59:59.999000 를 last timestamp 로 설정\n","      #      2. 시작 timestamp 는 모든 tf 의 가장 최근 시작 index,\n","      #       a. 1m 의 시작 timeindex 는 최소, htf 의 시작 timeindex 보다 interval 만큼 앞서야함\n","      #         i. 따라서 1m open_index, latest_open_index + 1d 를 하면 댐\n","      #           1. timestamp 으로 변환후 1day 를 더하고 datetime 으로 변환\n","      sixth_df = pd.read_excel(date_path6 + key, index_col=0)\n","      seventh_df = pd.read_excel(date_path7 + key, index_col=0)\n","\n","      print(sixth_df.index[[0, -1]])\n","      print(seventh_df.index[[0, -1]])\n","      print()\n","\n","      open_indexes.append(sixth_df.index[0])\n","      open_indexes.append(seventh_df.index[0])\n","\n","    except Exception as e:\n","      print(e)\n","\n","\n","    df.reset_index().to_feather(date_path + feather_name, compression='lz4')\n","    second_df.reset_index().to_feather(date_path2 + feather_name, compression='lz4')\n","    third_df.reset_index().to_feather(date_path3 + feather_name, compression='lz4')\n","    fourth_df.reset_index().to_feather(date_path4 + feather_name, compression='lz4')\n","    fifth_df.reset_index().to_feather(date_path5 + feather_name, compression='lz4')\n","    sixth_df.reset_index().to_feather(date_path6 + feather_name, compression='lz4')\n","    seventh_df.reset_index().to_feather(date_path7 + feather_name, compression='lz4')\n","\n","    print(\"xlsx converted to feather !\")\n","    "]},{"cell_type":"markdown","metadata":{"id":"Pe0QpnORSuzk"},"source":["### add itv_name to ftr"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M-gl30KxSuzk"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","# dir_path = \"bbdc3m_backi2\"\n","# date = '2021-10-10'\n","date = '2021-07-01'\n","\n","db_path = './candlestick_concated/database_bn/non_cum/%s/' % date\n","os.makedirs(os.path.join(db_path), exist_ok=True)\n","\n","# exist_list = os.listdir(os.path.join(save_path, dir_path))\n","# break\n","\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","        \n","    df = shutil.copy(date_path + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n","    second_df = shutil.copy(date_path2 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval2))\n","    third_df = shutil.copy(date_path3 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval3))\n","    fourth_df = shutil.copy(date_path4 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval4))\n","    fifth_df = shutil.copy(date_path5 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval5))\n","    sixth_df = shutil.copy(date_path6 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval6))\n","    seventh_df = shutil.copy(date_path7 + key, db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval7))\n","\n","    print(\"copied to\" + db_path + key.replace(\".ftr\", \"_%s.ftr\" % interval))\n"]},{"cell_type":"markdown","metadata":{"id":"4oZ1ohTtSuzk"},"source":["### feather ver. (database to res_df)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vgVHpnUsSuzk"},"outputs":[],"source":["# db_path = './candlestick_concated/database_ub/' # upbit\n","db_path = './candlestick_concated/database_bn/'   # binance\n","\n","save_path = './candlestick_concated/res_df/'\n","\n","save_dir_path = \"bb1d_backi2\"\n","date = '2022-02-17'\n","\n","# concat_path = 'noncat' # 새로운 cols 를 기존 cum/concat 에 붙이려는 경우\n","concat_path = 'concat'\n","cum_path = \"cum\"\n","# cum_path = \"non_cum\"  # non_cum 으로 진행하는 경우, row concat 용도이기 때문에 noncat -> concat 으로 변경 (base cols 를 모두 담고 있음)\n","\n","load_path = os.path.join(db_path, cum_path, date)\n","save_path = os.path.join(save_path, save_dir_path, concat_path, cum_path, date)\n","\n","os.makedirs(save_path, exist_ok=True)\n","\n","file_list = os.listdir(load_path)\n","exist_list = os.listdir(save_path)\n","# break\n","\n","a_day = 3600 * 24\n","\n","for i in tqdm(range(len(file_list))):\n","\n","  keys = [file_list[i]]\n","\n","  # if 'neo'.upper() not in file_list[i]:\n","    # continue\n","\n","  if date not in file_list[i]:\n","    continue\n","\n","\n","  for key in keys:      \n","\n","    # if 'eth'.upper() not in key:\n","    #   continue\n","    # print(key)\n","    \n","    if \".ftr\" not in key:\n","      continue\n","\n","    if \"_1m\" not in key:\n","      continue\n","\n","    # feather_name = key.replace(\".ftr\", \"_%.ftr\" % save_dir_path)\n","    feather_name = key.replace(\"_1m\", \"\")\n","    feather_path = os.path.join(save_path, feather_name)\n","\n","    if feather_name in exist_list:\n","      print(feather_name, \"already exist !\")\n","      continue\n","    \n","    df = pd.read_feather(os.path.join(load_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    res_df = sync_check_make(df)\n","\n","    res_df.reset_index().to_feather(feather_path, compression='lz4')\n","    print(feather_path, \"saved succesfully !\")"]},{"cell_type":"markdown","metadata":{"id":"YxCPUzoyidwH"},"source":["#### just add col to loaded df"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"odqVwQHpYo1M","colab":{"base_uri":"https://localhost:8080/","height":620},"executionInfo":{"status":"ok","timestamp":1654163851869,"user_tz":-540,"elapsed":2324,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"7e8c085a-d3b1-4e24-e191-084f83ce34e1"},"outputs":[{"output_type":"stream","name":"stdout","text":["3T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","5T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","15T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:45:00  2803.55  2803.97  2799.26  2800.43\n","30T ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:30:00  2783.61  2806.93  2780.79  2800.43\n","H ->                          open     high      low    close\n","index                                                  \n","2022-04-27 08:00:00  2819.33  2822.77  2761.27  2800.43\n","4H ->                          open    high      low    close\n","index                                                 \n","2022-04-27 05:00:00  2837.34  2855.0  2761.27  2800.43\n","D ->                          open    high      low    close\n","index                                                 \n","2022-04-26 09:00:00  3006.12  3043.0  2761.27  2800.43\n","dc phase done\n"]},{"output_type":"execute_result","data":{"text/plain":["                         bb_lower3_T60  upper_wick_ratio_5T  lower_wick_ratio_5T  candle_updown_5T  dc_upper_T10  dc_lower_T10  dc_base_T10  dc_upper_T20  dc_lower_T20  dc_base_T20\n","index                                                                                                                                                                               \n","2022-04-27 08:41:59.999    2757.553398             0.354545             0.640260                 0       2806.93       2787.83     2797.380       2806.93       2778.97     2792.950\n","2022-04-27 08:42:59.999    2757.677689             0.354545             0.640260                 0       2806.93       2789.40     2798.165       2806.93       2780.26     2793.595\n","2022-04-27 08:43:59.999    2757.913681             0.354545             0.640260                 0       2806.93       2792.21     2799.570       2806.93       2780.26     2793.595\n","2022-04-27 08:44:59.999    2758.011153             0.354545             0.640260                 0       2806.93       2792.21     2799.570       2806.93       2780.26     2793.595\n","2022-04-27 08:45:59.999    2758.210497             0.089172             0.248408                 0       2806.93       2792.21     2799.570       2806.93       2780.26     2793.595"],"text/html":["\n","  <div id=\"df-9fb3d3ab-943b-41d5-b205-dc1f6447d64e\">\n","    <div class=\"colab-df-container\">\n","      <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>bb_lower3_T60</th>\n","      <th>upper_wick_ratio_5T</th>\n","      <th>lower_wick_ratio_5T</th>\n","      <th>candle_updown_5T</th>\n","      <th>dc_upper_T10</th>\n","      <th>dc_lower_T10</th>\n","      <th>dc_base_T10</th>\n","      <th>dc_upper_T20</th>\n","      <th>dc_lower_T20</th>\n","      <th>dc_base_T20</th>\n","    </tr>\n","    <tr>\n","      <th>index</th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","      <th></th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>2022-04-27 08:41:59.999</th>\n","      <td>2757.553398</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","      <td>2806.93</td>\n","      <td>2787.83</td>\n","      <td>2797.380</td>\n","      <td>2806.93</td>\n","      <td>2778.97</td>\n","      <td>2792.950</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:42:59.999</th>\n","      <td>2757.677689</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","      <td>2806.93</td>\n","      <td>2789.40</td>\n","      <td>2798.165</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:43:59.999</th>\n","      <td>2757.913681</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","      <td>2806.93</td>\n","      <td>2792.21</td>\n","      <td>2799.570</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:44:59.999</th>\n","      <td>2758.011153</td>\n","      <td>0.354545</td>\n","      <td>0.640260</td>\n","      <td>0</td>\n","      <td>2806.93</td>\n","      <td>2792.21</td>\n","      <td>2799.570</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","    </tr>\n","    <tr>\n","      <th>2022-04-27 08:45:59.999</th>\n","      <td>2758.210497</td>\n","      <td>0.089172</td>\n","      <td>0.248408</td>\n","      <td>0</td>\n","      <td>2806.93</td>\n","      <td>2792.21</td>\n","      <td>2799.570</td>\n","      <td>2806.93</td>\n","      <td>2780.26</td>\n","      <td>2793.595</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-9fb3d3ab-943b-41d5-b205-dc1f6447d64e')\"\n","              title=\"Convert this dataframe to an interactive table.\"\n","              style=\"display:none;\">\n","        \n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","       width=\"24px\">\n","    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n","    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n","  </svg>\n","      </button>\n","      \n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      flex-wrap:wrap;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","      <script>\n","        const buttonEl =\n","          document.querySelector('#df-9fb3d3ab-943b-41d5-b205-dc1f6447d64e button.colab-df-convert');\n","        buttonEl.style.display =\n","          google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","        async function convertToInteractive(key) {\n","          const element = document.querySelector('#df-9fb3d3ab-943b-41d5-b205-dc1f6447d64e');\n","          const dataTable =\n","            await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                     [key], {});\n","          if (!dataTable) return;\n","\n","          const docLinkHtml = 'Like what you see? Visit the ' +\n","            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","            + ' to learn more about interactive tables.';\n","          element.innerHTML = '';\n","          dataTable['output_type'] = 'display_data';\n","          await google.colab.output.renderOutput(dataTable, element);\n","          const docLink = document.createElement('div');\n","          docLink.innerHTML = docLinkHtml;\n","          element.appendChild(docLink);\n","        }\n","      </script>\n","    </div>\n","  </div>\n","  "]},"metadata":{},"execution_count":26}],"source":["res_df_ = sync_check_make(res_df_)  # suffix duplication 유의\n","res_df_.tail().iloc[:, -10:]\n","# res_df_.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3SKglsQCj5_x"},"outputs":[],"source":["test_df_ = sync_check_make(res_df_.iloc[-4000:])  # suffix duplication 유의\n","test_df_.tail().iloc[:, -10:]"]},{"cell_type":"code","source":["# ------ validation ------ #\n","# res_df_.cppr_15T.describe()\n","print((res_df_.open_15T.to_numpy() - res_df_.close_15T.to_numpy())[-10:])\n","print((res_df_.dc_upper_15T4.to_numpy() - res_df_.dc_lower_15T4.to_numpy())[-10:])"],"metadata":{"id":"gOQxwYqK0jCS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# np.where(res_df_.CDL3LINESTRIKE_15T) #.iloc[-1000:,]\n","\n","# CDL3LINESTRIKE = talib.CDL3LINESTRIKE(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","for col in talib.get_function_groups()['Pattern Recognition']:  \n","  print(np.unique(res_df_[col + '_15T'].to_numpy(), return_counts=True))\n","\n","# CDLCLOSINGMARUBOZU = talib.CDLCLOSINGMARUBOZU(df_15T.open, df_15T.high, df_15T.low, df_15T.close)\n","# print(np.unique(CDLCLOSINGMARUBOZU.to_numpy(), return_counts=True))\n","# print(CDLCLOSINGMARUBOZU.tail(50))"],"metadata":{"id":"RmiB5VU5DN6B"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":1964,"status":"ok","timestamp":1654163859923,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"XrgJPQRuisCa","outputId":"97689e9b-de7d-4f11-cf00-39b80b8163b3"},"outputs":[{"output_type":"stream","name":"stdout","text":["./candlestick_concated/database_bn/cum/2022-04-27/2022-04-27 ETHUSDT_1m.ftr saved !\n"]}],"source":["# ------------ save current res_df ------------ #\n","ftr_path = os.path.join(save_path.replace(\"res_df\", \"database_bn\"), \"cum\", date)\n","ftr_full_path = os.path.join(ftr_path, key)\n","\n","res_df_.reset_index().to_feather(ftr_full_path, compression='lz4')  # key 잘 확인하고 저장\n","print(ftr_full_path, 'saved !')"]},{"cell_type":"markdown","metadata":{"id":"E0n53hflJbnp"},"source":["### htf candle check"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6xW0yugCWvGz"},"outputs":[],"source":["itv_list = ['3T', '5T', '15T', '30T', '1H', '4H']\n","comp_df_list = [second_df, third_df, fourth_df, fifth_df, sixth_df, seventh_df]\n","offset_list = ['1h', '2min', '2min', '2min', '2min', '2min']\n","# itv_list = ['4H']\n","# comp_df_list = [seventh_df]\n","\n","slice_len = 100\n","for itv_, comp_df_, offset in zip(itv_list, comp_df_list, offset_list):\n","\n","  print(\"itv_ :\", itv_)\n","\n","  # df = h_candle_v2(df, '3T')\n","  # end_ts = \n","  h_res_df = df.resample(itv_, offset=offset).agg({\n","          'open': 'first',\n","          'high': 'max',\n","          'low': 'min',\n","          'close': 'last'\n","      })\n","\n","  #   앞은 길이가 다르고, 뒤에서부터 잘라서 비교    #\n","  #   last_row 빼고는 동일, 4h 제외\n","  # print(df.tail())\n","  print(h_res_df.tail())\n","  print(comp_df_.tail())\n","  # # print(h_res_df.head())\n","  # # print(second_df.head())\n","\n","  # print(len(h_res_df))\n","  # print(len(second_df))\n","\n","  # print(h_res_df.values[-slice_len:])\n","  # print(second_df.iloc[:, :4].values[-slice_len:])\n","  # print(np.argwhere(h_res_df.values[-slice_len:] != comp_df_.iloc[:, :4].values[-slice_len:]))\n","  # print()\n","  break"]},{"cell_type":"markdown","metadata":{"id":"jTN3M842Suzl"},"source":["## concat & save new res_df"]},{"cell_type":"markdown","metadata":{"id":"MlFkpO1MSuzl"},"source":["### old (xlsx)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"U-3QkfbFSuzl"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","dict_name = \"2021-07-01 ETHUSDT_bb15m_backi2_res_dfs.pkl\"\n","\n","#     load with pickle    #\n","with open(save_path + dict_name, 'rb') as f:\n","  saved_res_df_dict = pickle.load(f)\n","\n","print(dict_name, \"loaded !\")\n","res_df_files = os.listdir(save_path)\n","res_df_files.reverse()\n","\n","print(res_df_files)\n","\n","res_df_dict = {}\n","\n","base_postfix = '_bb15m_backi2.xlsx'\n","new_postfix = '_st1h_backi2.xlsx'\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for k_i, key in enumerate(res_df_files):\n","\n","  if '2021-07-01'.upper() not in key:\n","  # if '2021-10-10'.upper() not in key:\n","    continue\n","\n","  # if \"link\".upper() not in key:\n","  # if \"btc\".upper() not in key:\n","  #   continue\n","\n","  if new_postfix not in key:\n","    continue\n","\n","  # if key in \n","\n","  if sample_cnt == max_cnt:\n","    dict_name = \"%s_res_dfs.pkl\" % key.split(\".\")[0]\n","    print(\"dict_name :\", dict_name)\n","\n","  base_df = saved_res_df_dict[key.replace(new_postfix, base_postfix)]\n","  # base_df = pd.read_excel(save_path + key.replace(new_postfix, base_postfix), index_col=0)  \n","  res_df = pd.read_excel(save_path + key, index_col=0)  \n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  droped_new_res_df.head()\n","  # break\n","\n","  # res_df_dict[key] = res_df\n","  res_df_dict[key] = droped_new_res_df\n","  print(key, \"saved to dict !\")\n","\n","  #     save with pickle    #\n","  with open(save_path + dict_name, 'wb') as f:\n","    pickle.dump(res_df_dict, f)\n","\n","  sample_cnt -= 1\n","\n","  if sample_cnt <= 0:\n","    break\n"]},{"cell_type":"markdown","metadata":{"id":"t1E_eAyPSuzm"},"source":["### new col to latest feather (1m_indi. only)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xyI5NrM7Suzm"},"outputs":[],"source":["save_path = './candlestick_concated/res_df/'\n","\n","cum_dir = \"cum\"\n","\n","new_dir_path = \"rsi_backi2\"\n","base_dir_path = \"bbdc3m_backi2\"\n","\n","new_date = '2021-11-17'\n","\n","\n","\n","#     load ftr list    #\n","base_save_path = os.path.join(save_path, base_dir_path, \"concat/cum\", new_date)\n","new_save_path = base_save_path.replace(base_dir_path, new_dir_path)\n","\n","#     save to (new) cum dir    #\n","#      1. if dir. not exists, makedir\n","os.makedirs(new_save_path, exist_ok=True)\n","\n","ftr_list = [s for s in os.listdir(base_save_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","max_cnt = 10\n","sample_cnt = max_cnt\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_save_path, key), columns=None, use_threads=True).set_index(\"index\")\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  droped_new_res_df = sync_check(base_df)\n","\n","  # new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # # new_res_df.head()\n","\n","  # intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  # droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break\n","\n","  droped_new_res_df.reset_index().to_feather(os.path.join(new_save_path, key), compression='lz4')\n","\n","  print(os.path.join(new_save_path, key), \"saved !\")\n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"nUs4fjVHSuzl"},"source":["### feather ver. (col concat)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6cu-Y82iSuzl"},"outputs":[],"source":["new_dir_path = \"st3m_backi2\"\n","base_dir_path = \"bb1d_backi2\"\n","\n","# new_date = \"2021-11-17\"\n","new_date = \"2022-01-10\"\n","\n","#     save to (new) concat dir    #\n","#      1. if dir. not exists, makedir\n","save_path = './candlestick_concated/res_df/'\n","save_path = os.path.join(save_path, new_dir_path, \"concat/cum\", new_date)   \n","# save_path = os.path.join(save_path, new_dir_path, \"concat/non_cum\", new_date)   # row col 하려면 concat 맞음, noncum 사용\n","os.makedirs(save_path, exist_ok=True)\n","\n","\n","#     load ftr list    #\n","# ftr_list = [s for s in os.listdir(os.path.join(save_path, new_dir_path)) if \"ftr\" in s]\n","\n","noncat_path = save_path.replace(\"concat/\", \"noncat/\")\n","ftr_list = [s for s in os.listdir(noncat_path) if \"ftr\" in s]\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:\n","    continue\n","\n","  try:\n","\n","    #       read from base postfix's directory    #\n","    base_df = pd.read_feather(os.path.join(save_path.replace(new_dir_path, base_dir_path), key), columns=None, use_threads=True).set_index(\"index\")\n","    res_df = pd.read_feather(os.path.join(noncat_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","    # print(base_df.head())\n","    # print(res_df.head())\n","    # break\n","\n","    new_res_df = pd.concat([base_df, res_df], axis=1) # df_tot.drop_duplicates()\n","    # new_res_df.head()\n","\n","    droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","    # droped_new_res_df.head()\n","    # break\n","\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df\n","    print(os.path.join(save_path, key), \"saved !\")\n","  \n","  except Exception as e:\n","    print(\"error occured ! :\", e)\n","  \n","\n","  # sample_cnt -= 1\n","\n","  # if sample_cnt <= 0:\n","  #   break\n"]},{"cell_type":"markdown","metadata":{"id":"WVAKq3i8Suzm"},"source":["### feather ver. (row concat) , database cum 도 호환가능"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XG2p9OhhSuzm"},"outputs":[],"source":["# save_path = './candlestick_concated/res_df/'        # cols 추가된 cum db 에 new_row's cols 기준으로 합치는 경우\n","save_path = './candlestick_concated/database_bn/'   # ohlcv cum db 만들 경우\n","\n","base_date = '2022-04-25'\n","# new_date = '2022-02-17'\n","new_date = '2022-04-27'\n","\n","# ------ load ftr list ------ #\n","if \"database\" in save_path:\n","  base_dir_path = \"\"\n","  new_dir_path = \"\"\n","  concat_dir = \"\"\n","else:\n","  base_dir_path = \"sar_backi2\"\n","  new_dir_path = \"bb4h_backi2\"  # dir_path 가 base / new 서로 달라질 수 있어서 분할함\n","  concat_dir = \"concat\"\n","\n","base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"cum\", base_date)      # 기존 cum db 와 new_date db 를 cum 진행\n","# base_date_path = os.path.join(save_path, base_dir_path, concat_dir, \"non_cum\", base_date)    # non_cum db 와 new_date db 를 cum 진행\n","\n","# new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"cum\", new_date)      # 상황별로 직접 선택해야할 듯\n","new_date_path = os.path.join(save_path, new_dir_path, concat_dir, \"non_cum\", new_date)\n","\n","\n","\n","# ------ save to (new) concat dir ------ #\n","#      1. if dir. not exists, makedir\n","save_path = new_date_path.replace(\"non_cum\", \"cum\")   # non_cum 아니여도 무관\n","os.makedirs(save_path, exist_ok=True)   # noncat / concat 두가지 경우 존재가능할 것\n","# os.makedirs(os.path.join(save_path, dir_path, \"noncat/cum\", new_date), exist_ok=True)\n","\n","\n","ftr_list = [s for s in os.listdir(new_date_path) if \"ftr\" in s]\n","exist_list = os.listdir(save_path)\n","print(ftr_list)\n","# break\n","\n","\n","for key in ftr_list:\n","\n","  if new_date not in key:   # date rejection\n","    continue\n","  if '1m' not in key:  # itv rejection\n","    continue\n","\n","  # if key in exist_list:\n","  #   print(key, \"already exist !\")\n","  #   continue\n","\n","  #       read from base postfix's directory    #\n","  base_df = pd.read_feather(os.path.join(base_date_path, key.replace(new_date, base_date)), columns=None, use_threads=True).set_index(\"index\")   # key 에 new_date 담겨있음\n","  res_df = pd.read_feather(os.path.join(new_date_path, key), columns=None, use_threads=True).set_index(\"index\")\n","\n","  # print(base_df.head())\n","  # print(res_df.head())\n","  # break\n","\n","  new_res_df = pd.concat([base_df, res_df], axis=0) # df_tot.drop_duplicates()\n","  # new_res_df.head()\n","\n","  intersection_cols = res_df.columns.intersection(base_df.columns)\n","\n","  droped_new_res_df = new_res_df.loc[~new_res_df.index.duplicated(keep='last'),intersection_cols]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.columns.duplicated(keep='last')]\n","  # droped_new_res_df = new_res_df.loc[:,~new_res_df.index.duplicated(keep='last')]\n","  # droped_new_res_df.head()\n","  # break  \n","  \n","  print(droped_new_res_df.iloc[[0, -1]])  \n","\n","  # ------------- verify df continuity directly itv by itv ------------- #\n","  true_continue = True\n","  if \"_\" in key:\n","\n","    # interval = key.split(\".\")[0].split(\"_\")[-1] \n","    # itv_num = to_itvnum(interval)\n","\n","    # verified_df = consecutive_df(droped_new_res_df, to_itvnum(interval))\n","    # verified_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","    # res_df_dict[key] = res_df\n","    # res_df_dict[key] = droped_new_res_df  \n","\n","    np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","    ideal_ts_gap = 60 # * itv_num\n","\n","    for ts_i in range(len(np_idx_ts)):\n","      \n","      if ts_i != 0:\n","        ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","        if ts_gap > ideal_ts_gap or ts_gap < ideal_ts_gap:\n","        # if ts_gap == ideal_ts_gap:\n","          print(droped_new_res_df.index[ts_i - 1])\n","          print(droped_new_res_df.index[ts_i])\n","          # print(ts_gap)\n","          print(\"------------------ unideal ts_gap ------------------\")\n","          true_continue = False\n","\n","    print(\"continuity checked !\")\n","\n","  if true_continue:\n","    droped_new_res_df.reset_index().to_feather(os.path.join(save_path, key), compression='lz4')\n","\n","  print(os.path.join(save_path, key), \"saved !\")\n","  \n"]},{"cell_type":"markdown","metadata":{"id":"L7l5CTJfSuzn"},"source":["### check continuity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"w-5jn9opBl73"},"outputs":[],"source":["droped_new_res_df = res_df_"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nGzMGyC3Suzn"},"outputs":[],"source":["# print(droped_new_res_df.columns)\n","\n","print(droped_new_res_df.iloc[[0, -1]])\n","\n","np_idx_ts = np.array(list(map(lambda x: datetime.timestamp(x), droped_new_res_df.index)))\n","\n","print(np_idx_ts[:10])\n","for ts_i in range(len(np_idx_ts)):\n","  \n","  if ts_i != 0:\n","    ts_gap = np_idx_ts[ts_i] - np_idx_ts[ts_i - 1]\n","\n","    if ts_gap > 60 or ts_gap < 60:\n","\n","      print(\"invalid ts_gap found !\")\n","    # if ts_gap == 60:\n","      print(droped_new_res_df.index[ts_i - 1])\n","      print(droped_new_res_df.index[ts_i])\n","      # print(ts_gap)\n","      print()\n"]},{"cell_type":"markdown","metadata":{"id":"x_XGJqBi8Jex"},"source":["### check length of front missing value + middle_data non_missing validity"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"yRNwqVeAu8X8"},"outputs":[],"source":["#       1. new_date 의 시작 timeidx 와 base_date end timeidx 의 최소 days' gap     #\n","#       2. new_date 의 시작 부분 indi. value 는 np.nan 으로 채워질 거기 때문에 계산해야함    #\n","\n","df_count = droped_new_res_df.count()\n","len_missing = df_count.max() - df_count.min()\n","print(len_missing / 1440)\n","\n","#       3. \n","missing_sliced_df = droped_new_res_df.iloc[len_missing:]\n","df_count2 = missing_sliced_df.count()\n","# print(df_count2)\n","print((df_count2.max() - df_count2.min()))    # this value should be zero !\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY7E2_hTBsyM"},"outputs":[],"source":["# df_count2.index[df_count2.argmin()]\n","# missing_sliced_df.head(5)\n","\n","stay_missed = np.sum(pd.isnull(missing_sliced_df), axis=0)\n","print(stay_missed)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"p9yqewOw9g33"},"outputs":[],"source":["stay_missed_cols = stay_missed[stay_missed != 0].index\n","\n","for sm_col in stay_missed_cols:\n","  \n","  row_idx = np.argwhere(pd.isnull(missing_sliced_df[sm_col].values))\n","\n","  plt.figure(figsize=(3,3))\n","  plt.plot(row_idx)\n","  plt.ylim(0, len(missing_sliced_df))\n","  plt.title(sm_col)\n","\n","  plt.show()\n"]},{"cell_type":"markdown","metadata":{"id":"MSUY4nnku3s9"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"epgS5Dksu-HX"},"source":["### mv files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"aJcVpEdrslA5"},"outputs":[],"source":["df_path = './candlestick_concated/survey_df_v2'\n","files_ = os.listdir(df_path)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"cEKyEYkotFDy"},"outputs":[],"source":["dirs = [file_ for file_ in files_ if not file_.endswith('.ftr')]\n","files = [file_ for file_ in files_ if file_.endswith('.ftr')]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"IgM79tcxtPVZ"},"outputs":[],"source":["dirs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"M767iRtwtRQP"},"outputs":[],"source":["def move_fn(dir_, file_):\n","  src_path = os.path.join(df_path, file_)\n","  dst_path = os.path.join(df_path, dir_, file_)\n","  shutil.move(src_path, dst_path)\n","  print(\"moved to {}\".format(dst_path))\n","\n","_ = [move_fn('2022-01-10 ETHUSDT_all', file_) for file_ in files if 'eth'.upper() in file_]\n","# sols\n"]},{"cell_type":"markdown","metadata":{"id":"Iy76iO7gztne"},"source":["### move legacy files"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hMRht32Czwry"},"outputs":[],"source":["# print()\n","cur_dir_list = os.listdir('.')\n","for f in cur_dir_list:\n","  if 'legacy' in f :\n","    # print(f)\n","    if os.path.isdir(current_path + f,):\n","      continue\n","\n","    shutil.move(current_path + f, current_path + 'legacy/' + f)\n","    print(\"moved to\" + current_path + 'legacy/' +  f)"]},{"cell_type":"markdown","metadata":{"id":"5duWn8t4BRyv"},"source":["# IDE platform\n"]},{"cell_type":"markdown","metadata":{"id":"6HOjnZjSgzk1"},"source":["## load ftr_list"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"7FPBG5Qqg2jB","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1654265142473,"user_tz":-540,"elapsed":3227,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"d55c5332-7c32-40d7-cfcd-cf778c37ac76"},"outputs":[{"output_type":"stream","name":"stdout","text":["['2022-04-27 ETHUSDT_1m.ftr']\n","2022-04-27 ETHUSDT_1m.ftr loaded !\n","load res_df_ elapsed time : 2.5671215057373047\n"]}],"source":["save_path = './candlestick_concated/database_bn/'\n","\n","# dir_path = \"bb1d_backi2\"\n","# date = \"2022-02-17\"\n","# ftr_path = os.path.join(save_path, dir_path, \"concat/cum\", date)\n","\n","# ------ 1T_database ------ #\n","# date = \"2022-04-27\"\n","# ftr_path = os.path.join(save_path, \"non_cum\", date)\n","\n","date = \"2022-04-27\"\n","# date = \"2022-02-17\"\n","ftr_path = os.path.join(save_path, \"cum\", date)\n","\n","# ------ load ftr list ------ #\n","ftr_list = [s for s in os.listdir(ftr_path) if \"ftr\" in s if date in s]\n","print(ftr_list)\n","\n","start_0 = time.time()\n","key = ftr_list[0]  # tempoaray use single key\n","res_df_ = pd.read_feather(os.path.join(ftr_path, key), columns=None, use_threads=True).set_index(\"index\")\n","# print(res_df_.head())\n","print(key, \"loaded !\")\n","print(\"load res_df_ elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RQH_l4opEh_O"},"outputs":[],"source":["res_df_.dtypes"]},{"cell_type":"markdown","metadata":{"id":"x2yj2SwAXDLp"},"source":["### edit cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"x9wkWw15XCAm"},"outputs":[],"source":["col_list = list(res_df_.columns)\n","# # [col_ for col_ in col_list if 'score' in col_]\n","\n","# ------ drop ------ #\n","# res_df_.drop([col_ for col_ in col_list if 'open_15T' in col_], inplace=True, axis=1)\n","res_df_.drop([col_ for col_ in col_list if 'es' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if '_T40' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list if 'long_base' in col_], inplace=True, axis=1)\n","# res_df_.drop([col_ for col_ in col_list[5:]], inplace=True, axis=1)\n","\n","# ------ replace ------ #\n","# for c_i, col_ in enumerate(col_list):\n","#   if 'basis' in col_:\n","# #   # if col_[-1] in ['m', 'h', 'd', 'H'] and '_' in col_:eTa_5T\n","# #   # if col_[0] in ['h'] and '_' in col_:\n","# #   if 'bir_' in col_:\n","\n","#     col_list[c_i] = col_.replace('basis', 'base')\n","# #     # col_list[c_i] = col_.replace('m', 'T').replace('h', 'H').replace('1T', 'T')\n","# #     # col_list[c_i] = col_.replace('1d', 'D')\n","# #     # col_list[c_i] = col_.replace('eTa_5T', 'ema_5T')\n","# #     # col_list[c_i] = col_list[c_i][1:]\n","# #     # print(col_list[c_i][0])\n","# res_df_.columns = col_list\n","# col_list[-2:] = ['resi_T', 'sup_T']"]},{"cell_type":"markdown","metadata":{"id":"14chOHeXh6JD"},"source":["### lab"]},{"cell_type":"markdown","metadata":{"id":"O87s8_EUakqS"},"source":["#### instant indi."]},{"cell_type":"code","source":["\n","\n","def wave_range_ratio_v4_2(res_df, wave_itv, wave_period, roll_hl_cnt=3):\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    roll_highs = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv, wave_period, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    cu_wave1_range = roll_highs[-1] - roll_lows[-2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_highs[-1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_highs[-2] - roll_lows[-1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_lows[-1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_roll_wave_data_v2(res_df, valid_prime_idx, roll_idx_arr, data_col, roll_hl_cnt):\n","\n","    data = res_df[data_col].to_numpy()\n","    len_res_df = len(res_df)\n","    roll_cols = [data_col + '_-{}'.format(cnt_ + 1) for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    roll_data = pd.DataFrame(index=res_df.index, data=np.full((len_res_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    res_df[roll_cols] = roll_data.ffill()\n","\n","    return res_df\n","\n","def roll_wave_hl_idx_v4(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array(\n","        [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    \n","    assert len(roll_high_idx_arr) > 0 and len(roll_low_idx_arr) > 0\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","    \n","def to_lower_tf_v3(ltf_df, htf_df, cols, backing_i=1, show_info=False):\n","    ltf_itv = pd.infer_freq(ltf_df.index)\n","    assert ltf_itv == 'T', \"currently only -> 'T' allowed..\"\n","    # assert type(column[0]) in [int, np.int64], \"column value should be integer\"\n","\n","    # cols = htf_df.columns[column]  # to_lower_tf_v1 의 int col 반영\n","\n","    if show_info:\n","        print(\"backing_i :\", backing_i)\n","\n","    renamed_last_index = htf_df.rename(index={htf_df.index[-1]: ltf_df.index[-1]}, inplace=False).iloc[[-1]]\n","    if htf_df.index[-1] != renamed_last_index.index[-1]:  # cannot reindex a non-unique index with a method or limit 방지\n","        htf_df = htf_df.append(renamed_last_index)\n","\n","    downsampled_df = htf_df[cols].shift(backing_i).resample(ltf_itv).ffill()\n","\n","    if len(downsampled_df) > len(ltf_df):\n","        downsampled_df = downsampled_df.iloc[-len(ltf_df):]\n","\n","    downsampled_df.index = ltf_df.index[-len(downsampled_df):]\n","    # assert len(ltf_df) <= len(downsampled_df), \"for join method, assert len(ltf_df) <= len(downsampled_df)\"\n","\n","    # ------ check last row's validity ------ #\n","    assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0, \"assert np.sum(~pd.isnull(downsampled_df.iloc[-1].values)) > 0\"\n","\n","    return downsampled_df"],"metadata":{"id":"gWOmz--hNaSR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","def wave_range_cci_v2(t_df, wave_period):\n","\n","    t_df = cci_v2(t_df, wave_period)\n","    itv = pd.infer_freq(t_df.index)\n","\n","    cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","    b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","    band_width = 100\n","    upper_band = band_width\n","    lower_band = -band_width\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","    co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","        cu_idx, co_idx, len_df, len_df_range)\n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    # ------ term cnt ------ #\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    # b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    # b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    # wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    # wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","    #\n","    # high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    # low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","    # ------ for plot_checking ------ #\n","    t_df['wave_update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool  # temporary, for plot_check\n","    t_df['wave_update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","    t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool #* ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool #* ~update_high_co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","    t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","    \n","    # Todo, idx 저장은 sync. 가 맞는 tf_df 에 대하여 적용하여야함\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    # high_prime_idx = wave_high 를 만들기 위한 가장 앞단의 co_idx\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","\n","    return t_df"],"metadata":{"id":"euA18M1uyc3s"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"LyGnAMvLYvOZ"},"source":["#### wave_range"]},{"cell_type":"markdown","source":["##### plot_check"],"metadata":{"id":"O1uu9vQnY5dn"}},{"cell_type":"code","execution_count":24,"metadata":{"id":"YqBXjVPzdccC","executionInfo":{"status":"ok","timestamp":1654266393241,"user_tz":-540,"elapsed":338,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["i = random.randint(0, len(res_df))\n","# i = 235290, 512385\n","# i = 74470\n","# i = 82533\n","i = 387103\n","i = 370055\n","i = 370940\n","# i = 185369\n","i = 186060\n","\n","plot_size = 300 # 1500 150\n","# t_df = res_df.iloc[i - plot_size:i + plot_size]\n","t_df = res_df.iloc[i - plot_size:i]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","source":["wave_itv1, wave_period1 = 'T', 20\n","\n","\n","if wave_itv1 != 'T':\n","    offset = '1h' if wave_itv1 != 'D' else '9h'\n","    htf_df = to_htf(t_df, wave_itv1, offset=offset)\n","    htf_df = wave_range_cci_v2(htf_df, wave_period1)\n","    \n","    cols = list(htf_df.columns[-15:-4])  # except idx col\n","\n","    roll_hl_cnt = 3\n","    valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","    cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","    htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=3)\n","    cols += list(htf_df.columns[-4:])\n","\n","    # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","    t_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","    t_df = t_df.join(to_lower_tf_v3(t_df, htf_df, cols, backing_i=0), how='inner')\n","\n","else:  \n","  t_df = wave_range_cci_v2(t_df, wave_period1)\n","\n","\n","      # res_df = wave_range_cci_v2(res_df, wave_period2)\n","\n","      # valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      # res_df = get_roll_wave_data_v2(res_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","      # res_df = get_roll_wave_data_v2(res_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","\n","      # res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","# t_df = wave_range_v11(t_df, config)\n","# t_df = wave_range_v11_2(t_df, config)\n","# t_df = wave_range_dcbase_v11_3(t_df, config, over_period=2)\n","# t_df = wave_range_cci_v1(t_df, wave_itv1, wave_period1)\n","# t_df = wave_range_v12(t_df, config, ltf_df=None)\n","# t_df = wave_range_v13(t_df, config, ltf_df=None, term_thresh=1)\n","# t_df = wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3)\n","# t_df = wave_range_v15(t_df, config, term_thresh1=2, term_thresh2=3)\n"],"metadata":{"id":"PgaNnempXRd_","executionInfo":{"status":"ok","timestamp":1654266437044,"user_tz":-540,"elapsed":357,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"execution_count":27,"outputs":[]},{"cell_type":"code","execution_count":30,"metadata":{"id":"-Dr_tTk9csFm","colab":{"base_uri":"https://localhost:8080/","height":862},"executionInfo":{"status":"ok","timestamp":1654267577454,"user_tz":-540,"elapsed":1511,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2f509d9a-97e4-4384-c2e0-9f7fcb2b88e3"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1080x1080 with 2 Axes>"],"image/png":"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UH5+vsO5hFO2bNmigYEBdXR0RG4brXy88MILCgaDam9vV0VFhRNZhoPilZennnpKfX19am1tVWtrq6qqqiJ/27hxo4LBoLq7u7VkyRInsgyHFBcX6+DBg3r//ffV2dmpxx9/XBL1C66UqKxQtyCeyZMnq6WlRW1tbers7NTTTz8tSSotLVVzc7OCwaDq6uqUl5cnSZo0aZLq6uoUDAbV3NysWbNmJfU8ju9ZkSjl5uZaoVDImj17tpWXl2e1tbVZ5eXljueL5J7U09NjzZgxY8Rtzz33nLVhwwZLkrVhwwbr2WefdTyfJGfSwoULrYqKCqujoyNyW6LyUVVVZe3bt8+SZC1YsMBqbm52PP8k58vLU089ZT3xxBNX3Le8vNxqa2uzJk2aZJWWllqhUMjKzc11/DWQspMKCwutiooKS5J19dVXW0ePHrXKy8upX0hJlxXqFlKiNHXqVEuSNXHiRKu5udlasGCB9Yc//MF68MEHLUnW5s2brR//+MeWJOuxxx6zNm/ebEmyHnzwQauurm7M47u656+yslKhUEg9PT06f/686urqVF1d7XS24HLV1dXaunWrJGnr1q267777HM4RnPLOO+/ok08+GXFbovJRXV2tbdu2SZJaWlqUn5+vwsLC7GYYjopXXhKprq5WXV2dzp07pw8//FChUEiVlZUZziHc4vjx42ptbZUkffnll+rq6lJRURH1C66QqKwkQt2Cr776SpKUl5envLw8WZal7373u3rllVckXVm3hOucV155RXfeeeeYx3d18FdUVKTe3t7I7319faN+YGAey7LU0NCgP/7xj1q9erUkqaCgQMePH5c0XOkWFBQ4mUW4TKLyQX2DRNatW6f29nZt2bIlMoyP8oKwWbNmqaKiQi0tLdQvGFV0WZGoWxBfbm6uWltbdeLECTU2NuqDDz7QZ599pqGhIUkjy0R0eRkaGtLg4KBmzJgx+vEzm30gs+644w7NmzdPVVVVWrt2rRYuXHjFfSzLciBn8ArKB0azefNmXXvttbrlllv05z//Wb/61a+czhJcZOrUqdq1a5fWr1+vL7744oq/U78gLLasULcgkYsXL6qiokLFxcWqrKzU9ddfb+vxXR389ff3q6SkJPJ7cXGx+vv7HcwR3Objjz+WJP3lL3/Ra6+9psrKSg0MDESG0xQWFurEiRNOZhEuk6h8UN8g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\n"},"metadata":{}}],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 15))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols,\n","                        height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","# _ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","\n","len_df = len(t_df)   \n","len_df_range = np.arange(len_df).astype(int)\n","\n","# ============ ============ ============ #\n","# ============ ============ ============ #\n","\n","wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_high_terms_cnt_fill_ = t_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_low_terms_cnt_fill_ = t_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","wave_cu_idx_ = get_index_bybool(t_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_co_idx_ = get_index_bybool(t_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_cu_bool_idx_ = get_index_bybool(t_df['wave_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","# wave_co_bool_idx_ = get_index_bybool(t_df['wave_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_low_cu_bool_idx_ = get_index_bybool(t_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_update_high_co_bool_idx_ = get_index_bybool(t_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy(), len_df_range)\n","wave_cu_marker_ = t_df['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","wave_co_marker_ = t_df['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# high_prime_idx_fill = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# low_prime_idx_fill = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","# ============ plot_check ============ #\n","# dc_base_ = t_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","# plt.step(len_df_range, dc_base_, alpha=1.0, color='cyan', linewidth=1)\n","\n","plt.step(len_df_range, wave_cu_marker_, \"o\", alpha=1.0, color='#ff00ff', markersize=3)\n","plt.step(len_df_range, wave_co_marker_, \"o\", alpha=1.0, color='#00ff00', markersize=3)\n","\n","# [plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_cu_bool_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_co_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#ff0000\") for idx_ in wave_update_low_cu_bool_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#0000ff\") for idx_ in wave_update_high_co_bool_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# [plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_high_prime_idx if not np.isnan(idx_)]\n","# [plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_low_prime_idx if not np.isnan(idx_)]\n","\n","plt.step(len_df_range, wave_high_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","plt.step(len_df_range, wave_low_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","plt.xlim(0, len_df)\n","\n","plt.subplot(gs[1])\n","cci_ = t_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","plt.step(len_df_range, cci_, alpha=1.0, color='yellow', linewidth=2)\n","plt.axhline(100, color=\"#ffffff\")\n","plt.axhline(-100, color=\"#ffffff\")\n","[plt.axvline(int(idx_), color=\"#ff00ff\") for idx_ in wave_cu_idx_ if not np.isnan(idx_)]\n","[plt.axvline(int(idx_), color=\"#00ff00\") for idx_ in wave_co_idx_ if not np.isnan(idx_)]\n","\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, alpha=1.0, color='yellow', linewidth=2)\n","# plt.step(len_df_range, wave_high_terms_cnt_fill_, \"*\", alpha=1.0, color='#00ff00', markersize=6)\n","# plt.step(len_df_range, wave_low_terms_cnt_fill_, \"*\", alpha=1.0, color='#ff00ff', markersize=6)\n","\n","plt.xlim(0, len_df)  # for sync. with gs[0]\n","\n","plt.show()"]},{"cell_type":"code","source":["high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","high_prime_idx[~np.isnan(high_prime_idx)].astype(int)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"0DgdFydfB1f-","executionInfo":{"status":"ok","timestamp":1654267769963,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"14cbe3c2-9acf-4ae6-db5a-867b6c80bb99"},"execution_count":32,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([ 99, 128, 170, 240])"]},"metadata":{},"execution_count":32}]},{"cell_type":"markdown","source":["###### data_window"],"metadata":{"id":"c2yVTn1tnxMn"}},{"cell_type":"code","source":["idx_ = 990\n","\n","# t_df[roll_cols].iloc[idx_]\n","t_df.iloc[:, -4:].iloc[idx_]\n","\n","# roll_cnt = 3\n","# valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_v4(t_df, wave_itv1, wave_period1, roll_hl_cnt=roll_cnt)\n","# roll_high = get_roll_wave_data(valid_high_prime_idx, roll_prev_high_idx_arr, len_df, wave_high_fill_, roll_cnt)\n","# roll_low = get_roll_wave_data(valid_low_prime_idx, roll_prev_low_idx_arr, len_df, wave_low_fill_, roll_cnt)\n","\n","# print(roll_high[idx_])\n","# print(roll_low[idx_])\n","# roll_prev_high_idx_arr\n","# valid_high_prime_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"I_ZNM9n7hFOf","executionInfo":{"status":"ok","timestamp":1652690281646,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"aee10236-b76e-45db-f25d-4a3c6d352d69"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["cu_wrr_21_15T5    2.096046\n","cu_wrr_32_15T5    0.838580\n","co_wrr_21_15T5    0.780256\n","co_wrr_32_15T5    1.000000\n","Name: 2021-05-20 14:10:59.999000, dtype: float64"]},"metadata":{},"execution_count":64}]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                              idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array(\n","    [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])"],"metadata":{"id":"zj_d5wsfDzf_"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_co_bool_idx_[~np.isnan(wave_co_bool_idx_)]\n","# wave_cu_bool_idx_[~np.isnan(wave_cu_bool_idx_)]"],"metadata":{"id":"BvF0CoLn7bF3"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["%timeit -n1 -r1 wave_range_v10(res_df[-100000:], period1, ltf_df=None) # 23.7 s per loop\n","%timeit -n1 -r1 wave_range_v11(res_df[-100000:], period1, ltf_df=None) # 574 ms per loop"],"metadata":{"id":"Z-EokTzIqb-T"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df = cci_v2(t_df, wave_period)\n","\n","cci_ = t_df['cci_{}{}'.format(itv, wave_period)].to_numpy()\n","b1_cci_ = t_df['cci_{}{}'.format(itv, wave_period)].shift(1).to_numpy()\n","\n","band_width = 100\n","upper_band = band_width\n","lower_band = -band_width\n","\n","len_df = len(t_df)\n","len_df_range = np.arange(len_df).astype(int)\n","\n","data_cols = ['open', 'high', 'low', 'close']\n","open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","# b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","# ============ modules ============ #\n","# ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","cu_bool = (b1_cci_ > upper_band) & (upper_band > cci_)\n","co_bool = (b1_cci_ < lower_band) & (lower_band < cci_)\n","\n","cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(\n","    cu_idx, co_idx, len_df, len_df_range)\n","\n","# ------ get post_terms ------ #\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","paired_post_cu_idx = high_post_terms[:, 1]\n","paired_post_co_idx = low_post_terms[:, 1]\n","\n","# ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","# high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","# low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","# high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","# low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","# paired_prime_cu_idx = high_prime_terms[:, 1]\n","# paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","# ====== get wave_hl & terms ====== #\n","wave_high_ = np.full(len_df, np.nan)\n","wave_low_ = np.full(len_df, np.nan)\n","\n","wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","wave_high_[paired_post_cu_idx] = wave_highs\n","wave_low_[paired_post_co_idx] = wave_lows\n","\n","wave_high_fill_ = fill_arr(wave_high_)\n","wave_low_fill_ = fill_arr(wave_low_)\n","\n","# ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","wave_high_terms_low_ = np.full(len_df, np.nan)\n","wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","# ------ term cnt ------ #\n","wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","# ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","# b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","# b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","# wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","# wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","#\n","# high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","# low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","# ============ enlist to df_cols ============ #\n","t_df['wave_high_fill_{}{}'.format(itv, wave_period)] = wave_high_fill_\n","t_df['wave_low_fill_{}{}'.format(itv, wave_period)] = wave_low_fill_\n","t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_high_terms_cnt_fill_\n","t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, wave_period)] = wave_low_terms_cnt_fill_\n","\n","# ------ for roll prev_hl ------ #\n","# high_post_idx 를 위해 co_prime_idx 입력\n","t_df['wave_high_prime_idx_{}{}'.format(itv, wave_period)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","t_df['wave_low_prime_idx_{}{}'.format(itv, wave_period)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","# ------ for first_high ------ #\n","t_df['wave_high_prime_idx_fill_{}{}'.format(itv, wave_period)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","t_df['wave_low_prime_idx_fill_{}{}'.format(itv, wave_period)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","\n","# ------ for plot_checking ------ #\n","t_df['wave_cu_bool_{}{}'.format(itv, wave_period)] = cu_bool  # temporary, for plot_check\n","t_df['wave_co_bool_{}{}'.format(itv, wave_period)] = co_bool\n","t_df['wave_cu_{}{}'.format(itv, wave_period)] = cu_bool * ~update_low_cu_bool\n","t_df['wave_co_{}{}'.format(itv, wave_period)] = co_bool * ~update_high_co_bool\n","t_df['wave_cu_marker_{}{}'.format(itv, wave_period)] = get_line(cu_idx, close)\n","t_df['wave_co_marker_{}{}'.format(itv, wave_period)] = get_line(co_idx, close)\n","# t_df['update_low_cu_bool_{}{}'.format(itv, wave_period)] = update_low_cu_bool\n","# t_df['update_high_co_bool_{}{}'.format(itv, wave_period)] = update_high_co_bool\n","\n","if itv != 'T':\n","    join_cols = np.arange(-15, 0, 1).astype(int)  # wave vars. + wave_unit's col\n","    res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","        res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols, backing_i=0), how='inner')\n","    except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","\n","    return res_df\n","\n","else:\n","    return t_df"],"metadata":{"id":"TqMmmSAGuChM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["roll_hl_cnt = 3\n","wave_itv = pd.infer_freq(t_df.index)\n","wave_period = config.tr_set.wave_period\n","\n","len_df = len(t_df)\n","\n","high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()   # cu_post_idx\n","low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n"],"metadata":{"id":"50ucQUF-Jixd"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### legacy"],"metadata":{"id":"Q_1wJTcRYpm8"}},{"cell_type":"code","source":["\n","def get_roll_wave_data(valid_prime_idx, roll_idx_arr, len_df, data, roll_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_hl_cnt - 1:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_idx_v4(t_df, wave_itv, wave_period, roll_hl_cnt=4):\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx, this should be \"unique\"\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if\n","                                  idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array(\n","        [valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr\n","    \n","def wave_range_ratio_v4_1(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    cu_wave1_range = roll_high_[:, -1] - roll_low_[:, -2]   # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    cu_wave2_range = roll_high_[:, -1] - wave_low_fill_     # for short, cu\n","    co_wave1_range = roll_high_[:, -2] - roll_low_[:, -1]   # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    co_wave2_range = wave_high_fill_ - roll_low_[:, -1]     # for long, co\n","    wave3_range = wave_high_fill_ - wave_low_fill_\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / cu_wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / co_wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def wave_range_ratio_v4(res_df, config, roll_hl_cnt=3):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","    len_df = len(res_df)\n","\n","    valid_high_prime_idx, valid_low_prime_idx, roll_high_idx_arr, roll_low_idx_arr = roll_wave_hl_v4(res_df, config, roll_hl_cnt=roll_hl_cnt)\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    roll_high_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_high_fill_, roll_hl_cnt)\n","    roll_low_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_low_fill_, roll_hl_cnt)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","\n","def get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range):\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # high_terms 를 위해 pair 되는 fill & idx 의 nan 제거\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","    high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","    valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","\n","    valid_co_post_idx = np.array([terms.max() for terms in high_terms_list])\n","    valid_cu_post_idx = np.array([terms.max() for terms in low_terms_list])\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx = np.full(len_df, np.nan)\n","\n","    cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","    co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","    cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","    co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","    # cu_post_idx = np.full(len_df, np.nan)\n","    # co_post_idx = np.full(len_df, np.nan)\n","\n","    # cu_post_idx[valid_cu_post_idx] = valid_cu_post_idx\n","    # co_post_idx[valid_co_post_idx] = valid_co_post_idx\n","\n","    # cu_post_fill_idx = fill_arr(cu_post_idx)\n","    # co_post_fill_idx = fill_arr(co_post_idx)\n","\n","    valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","    valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool\n","    # return cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, \\\n","    #         cu_post_idx, co_post_idx, cu_post_fill_idx, co_post_fill_idx, valid_cu_bool, valid_co_bool\n","\n","\n","def wave_range_dcbase_v11_3(res_df, config, itv='T', over_period=2):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    # b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    # b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    over_base = close > dc_base_\n","    prev_over_base = pd.Series(over_base).rolling(over_period).min().shift(1).to_numpy() == 1   # min = 1 => period's all-over, max = 0\n","    prev_under_base = pd.Series(over_base).rolling(over_period).max().shift(1).to_numpy() == 0  # max = 0 => period's all-under, \n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함    \n","    cu_bool = prev_over_base & ~over_base\n","    co_bool = prev_under_base & over_base\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","    \n","    cu_fill_idx, co_fill_idx, cu_prime_idx, co_prime_idx, cu_prime_fill_idx, co_prime_fill_idx, valid_cu_bool, valid_co_bool = get_terms_info_v4(cu_idx, co_idx, len_df, len_df_range)    \n","\n","    # ------ get post_terms ------ #\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    paired_post_cu_idx = high_post_terms[:, 1]\n","    paired_post_co_idx = low_post_terms[:, 1]\n","\n","    # ------ get prime_terms ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    # high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    # low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","    \n","    # high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","    # low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","    # paired_prime_cu_idx = high_prime_terms[:, 1]\n","    # paired_prime_co_idx = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","    wave_high_[paired_post_cu_idx] = wave_highs\n","    wave_low_[paired_post_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_post_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_post_terms])\n","\n","    wave_high_terms_low_[paired_post_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_post_co_idx] = wave_low_terms_highs\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_post_cu_idx] = high_post_terms_cnt\n","    wave_low_terms_cnt_[paired_post_co_idx] = low_post_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    # high_post_idx 를 위해 co_prime_idx 입력\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx # co_prime_idx wave_high_prime_idx  # high 갱신을 고려해, prev_hl 는 prime_idx 기준으로 진행\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx # cu_prime_idx wave_low_prime_idx  # cu_prime_idx's low 를 사용하겠다라는 의미, 즉 roll_prev 임\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_fill_idx # co_prime_fill_idx high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_fill_idx # cu_prime_fill_idx low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","def wave_range_v11_2(res_df, config, itv='T'):  # v2 for period1 only\n","\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    # ------ get co, cu terms ------ #\n","    high_bool = cu_fill_idx < co_fill_idx\n","    low_bool = co_fill_idx < cu_fill_idx\n","\n","    high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","    low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","    high_terms_list = using_clump(high_terms_vec)\n","    low_terms_list = using_clump(low_terms_vec)\n","\n","    high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","    low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0]\n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0]\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    # ------ get valid_idx range (inner len_df) ------ #\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    valid_cu_bool = paired_cu_idx < len_df\n","    valid_co_bool = paired_co_idx < len_df\n","\n","    paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","    paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","    # ------ get wave_hl & terms ------ #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","    wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","    wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ check update high & low (occurs by point missing) ------ #\n","    co_prime_idx = np.full(len_df, np.nan)\n","    co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","    co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","    # valid_idx = co_idx > co_prime_idx_fill_\n","    valid_idx = cu_idx > co_prime_idx_fill_\n","\n","    update_low = np.full(len_df, np.nan)\n","    # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","    # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","    #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","    update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # high_terms' update_low\n","\n","    cu_prime_idx = np.full(len_df, np.nan)\n","    cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","    valid_idx = co_idx > cu_prime_idx_fill_\n","\n","    update_high = np.full(len_df, np.nan)\n","    update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)  # point_missing 으로 인한 low 갱신 회피\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n"],"metadata":{"id":"RVFfP9VcDG2_"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","\n","def roll_wave_hl_v3(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","    high_prime_idx_fill_ = t_df['wave_high_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx_fill_ = t_df['wave_low_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_high_idx_arr = np.array([valid_high_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_high_prime_idx)) if idx_ + 1 >= roll_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_low_idx_arr = np.array([valid_low_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_low_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))    \n","    roll_high_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    roll_low_prime_idx_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    roll_high_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[roll_low_idx_arr]\n","    roll_high_prime_idx_.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = high_prime_idx_fill_[roll_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","    roll_low_prime_idx_.iloc[valid_low_prime_idx[roll_hl_cnt - 1:], :] = low_prime_idx_fill_[roll_low_idx_arr]\n","\n","    return roll_high_.ffill().to_numpy(), roll_low_.ffill().to_numpy(), roll_high_prime_idx_.ffill().to_numpy(), roll_low_prime_idx_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","\n","def wave_range_v15(res_df, config, itv='T', term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","  \n","    # itv = pd.infer_freq(t_df.index)\n","    if itv != 'T':\n","      offset = '1h' if itv != 'D' else '9h'\n","      t_df = to_htf(res_df, itv, offset=offset)\n","    else:\n","      t_df = res_df\n","\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1)\n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)\n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","\n","    # ============ modules ============ #\n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)  # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range)\n","\n","    paired_cu_idx1 = high_terms[:, 1]\n","    paired_co_idx1 = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    wave_high_terms_low_[paired_cu_idx1] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx1] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False\n","    cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","    co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False\n","\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","    high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, _, _ = get_terms_info_v3(cu_bool,\n","                                                                                                                                          co_bool,\n","                                                                                                                                          len_df,\n","                                                                                                                                          len_df_range,\n","                                                                                                                                          True)\n","\n","    paired_cu_idx2 = high_prime_terms[:, 1]\n","    paired_co_idx2 = low_prime_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_prime_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_prime_terms])\n","    wave_prime_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_prime_terms])\n","\n","    wave_high_[paired_cu_idx2] = wave_prime_highs\n","    wave_low_[paired_co_idx2] = wave_prime_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # ------ Todo, update_hl 에 대해서, post_terms_hl 적용 ------ #\n","    wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])  # 생략전 post_terms_hl 사용\n","    wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    update_low_cu_bool = wave_high_terms_low_ < wave_low_fill_\n","    update_high_co_bool = wave_low_terms_high_ > wave_high_fill_\n","\n","    update_paired_cu_bool = (cu_bool * update_low_cu_bool)[paired_cu_idx1]\n","    update_paired_cu_idx = paired_cu_idx1[update_paired_cu_bool]\n","    wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","    update_paired_co_bool = (co_bool * update_high_co_bool)[paired_co_idx1]\n","    update_paired_co_idx = paired_co_idx1[update_paired_co_bool]\n","    wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","    # wave_high_fill2_ = fill_arr(wave_high_)\n","    # wave_low_fill2_ = fill_arr(wave_low_)\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx2] = high_prime_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx2] = low_prime_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ #\n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    high_prime_idx_fill_ = fill_arr(wave_high_prime_idx)\n","    low_prime_idx_fill_ = fill_arr(wave_low_prime_idx)\n","\n","    # ============ enlist to df_cols ============ #\n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","    # t_df['wave_high_fill2_{}{}'.format(itv, period1)] = wave_high_fill2_\n","    # t_df['wave_low_fill2_{}{}'.format(itv, period1)] = wave_low_fill2_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~update_low_cu_bool\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~update_high_co_bool\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool  # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ #\n","    t_df['wave_high_prime_idx_{}{}'.format(itv, period1)] = wave_high_prime_idx  # cu\n","    t_df['wave_low_prime_idx_{}{}'.format(itv, period1)] = wave_low_prime_idx\n","\n","    # ------ for first_high ------ #\n","    t_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)] = high_prime_idx_fill_\n","    t_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)] = low_prime_idx_fill_\n","    \n","    if itv != 'T':\n","        join_cols = np.arange(-17, 0, 1).astype(int)  # points & donchian_channels\n","        res_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","        try:\n","            res_df = res_df.join(to_lower_tf_v3(res_df, t_df, join_cols), how='inner')\n","        except Exception as e:\n","            print(\"error in wave_range()'s join() :\", e)\n","            \n","        return res_df\n","\n","    else:\n","        return t_df\n","\n","\n","def wave_range_ratio_v3(res_df, config):\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_, _, _ = roll_wave_hl_v3(res_df, config, roll_hl_cnt=4)\n","\n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","\n","def get_terms_info_v3(cu_bool, co_bool, len_df, len_df_range, prime_terms=False):\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","\n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    if prime_terms:\n","        # ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","        high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","        low_bool = co_fill_idx < cu_fill_idx\n","\n","        high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","        low_terms_vec = get_index_bybool(low_bool, len_df_range)  # -> low_terms\n","\n","        high_terms_list = using_clump(high_terms_vec)\n","        low_terms_list = using_clump(low_terms_vec)\n","\n","        valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","        valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","        cu_prime_idx = np.full(len_df, np.nan)\n","        co_prime_idx = np.full(len_df, np.nan)\n","\n","        cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","        co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","        cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","        co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","        valid_cu_bool *= ~np.isnan(co_prime_fill_idx)\n","        valid_co_bool *= ~np.isnan(cu_prime_fill_idx)\n","\n","    high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_post_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0]\n","    low_post_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0]\n","\n","    # ------ co, cu idx's terms ------ #\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    if prime_terms:\n","        high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","        low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","        \n","        high_prime_terms_cnt = high_prime_terms[:, 1] - high_prime_terms[:, 0]\n","        low_prime_terms_cnt = low_prime_terms[:, 1] - low_prime_terms[:, 0]\n","\n","        return high_post_terms, low_post_terms, high_prime_terms_cnt, low_prime_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term\n","\n","    return high_post_terms, low_post_terms, high_post_terms_cnt, low_post_terms_cnt, cu_idx_term, co_idx_term\n","  \n","def wave_range_ratio_v2(res_df, config):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    roll_high_, roll_low_ = roll_wave_hl_v2(res_df, config, roll_hl_cnt=4)\n","    \n","    wave1_range = roll_high_[:, -2] - roll_low_[:, -2]\n","    cu_wave2_range = roll_high_[:, -2] - roll_low_[:, -1]  # for short, cu\n","    co_wave2_range = roll_high_[:, -1] - roll_low_[:, -2]  # for long, co\n","    wave3_range = roll_high_[:, -1] - roll_low_[:, -1]\n","\n","    res_df['cu_wrr_21_{}{}'.format(wave_itv, wave_period)] = cu_wave2_range / wave1_range\n","    res_df['cu_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / cu_wave2_range\n","\n","    res_df['co_wrr_21_{}{}'.format(wave_itv, wave_period)] = co_wave2_range / wave1_range\n","    res_df['co_wrr_32_{}{}'.format(wave_itv, wave_period)] = wave3_range / co_wave2_range\n","\n","    return res_df\n","    \n","def roll_wave_hl(t_df, config, roll_hl_cnt=4):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    wave_high_fill_ = t_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = t_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_idx = t_df['wave_cu_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx = t_df['wave_co_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    valid_cu_prime_idx = cu_prime_idx[~np.isnan(cu_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","    valid_co_prime_idx = co_prime_idx[~np.isnan(co_prime_idx)].astype(int)  # -> 필요한 prev_hl 갯수만큼 각 index 기준으로 자르기\n","\n","    cu_roll_hl_idx_arr = np.array(\n","        [valid_cu_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_cu_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","    co_roll_hl_idx_arr = np.array(\n","        [valid_co_prime_idx[idx_ + 1 - roll_hl_cnt:idx_ + 1] for idx_ in range(len(valid_co_prime_idx)) if idx_ + 1 >= roll_hl_cnt])\n","\n","    cu_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    cu_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_high_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","    co_roll_low_ = pd.DataFrame(np.full((len_df, roll_hl_cnt), np.nan))\n","\n","    cu_roll_high_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[cu_roll_hl_idx_arr]\n","    cu_roll_low_.iloc[valid_cu_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[cu_roll_hl_idx_arr]\n","    co_roll_high_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_high_fill_[co_roll_hl_idx_arr]\n","    co_roll_low_.iloc[valid_co_prime_idx[roll_hl_cnt - 1:], :] = wave_low_fill_[co_roll_hl_idx_arr]\n","\n","    return cu_roll_high_.ffill().to_numpy(), cu_roll_low_.ffill().to_numpy(), co_roll_high_.ffill().to_numpy(), co_roll_low_.ffill().to_numpy()  # t_df 에 hl_cnt 만큼 col 만들어야해서 numpy 로 뽑음\n","\n","def backing_future_data(res_df, future_cols, itv_list): # itv 자동 조사 가능 ? (future_work)\n","  \n","    for col_, itv_ in zip(future_cols, itv_list):\n","        back_col_ = 'b1_' + col_\n","        res_df[back_col_] = res_df[col_].shift(to_itvnum(itv_))\n","\n","    return res_df\n","\n","\n","\n","def wave_loc_pct_v2(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","    \n","    cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    cu_prime_bb_gap = get_line(cu_prime_idx_fill_, bb_gap)\n","    co_prime_bb_gap = get_line(co_prime_idx_fill_, bb_gap)\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / cu_prime_bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / co_prime_bb_gap\n","\n","    return res_df\n","\n","def wave_loc_pct(res_df, config, itv, period):\n","\n","    wave_itv = pd.infer_freq(res_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    wave_high_fill_ = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    wave_low_fill_ = res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","    bb_upper_ = res_df['bb_upper_{}{}'.format(itv, period)].to_numpy()\n","    bb_lower_ = res_df['bb_lower_{}{}'.format(itv, period)].to_numpy()\n","\n","    bb_gap = bb_upper_ - bb_lower_\n","\n","    res_df['wave_high_loc_pct_{}{}'.format(wave_itv, wave_period)] = (bb_upper_ - wave_high_fill_) / bb_gap\n","    res_df['wave_low_loc_pct_{}{}'.format(wave_itv, wave_period)] = (wave_low_fill_ - bb_lower_) / bb_gap\n","\n","    return res_df\n","\n","\n","def get_terms_info_v2(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","\n","    notnan_cu_bool = ~np.isnan(cu_idx)\n","    notnan_co_bool = ~np.isnan(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것    \n","    valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx)  # co 와 pair 가 가능한 cu_idx\n","    valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    # valid_cu_idx = cu_idx[notnan_cu_bool]\n","    # valid_co_idx = co_idx[notnan_co_bool]\n","    valid_cu_idx = cu_idx[valid_cu_bool]\n","    valid_co_idx = co_idx[valid_co_bool]\n","    valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","    valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","    cu_idx_term = valid_cu_idx - valid_shift_cu_idx\n","    co_idx_term = valid_co_idx - valid_shift_co_idx\n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term\n","\n","def get_terms_info(cu_bool, co_bool, len_df_range):\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    cu_fill_idx = fill_arr(cu_idx)\n","    co_fill_idx = fill_arr(co_idx)\n","  \n","    # ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","    valid_cu_idx = ~np.isnan(cu_idx) * ~np.isnan(co_fill_idx)\n","    valid_co_idx = ~np.isnan(co_idx) * ~np.isnan(cu_fill_idx)\n","\n","    high_terms = np.vstack((co_fill_idx[valid_cu_idx], cu_idx[valid_cu_idx])).T.astype(int)\n","    low_terms = np.vstack((cu_fill_idx[valid_co_idx], co_idx[valid_co_idx])).T.astype(int)\n","\n","    high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","    low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","    return high_terms, low_terms, high_terms_cnt, low_terms_cnt\n","\n","\n","\n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","    itv = pd.infer_freq(t_df.index)\n","    period1 = config.tr_set.wave_period\n","    # print(period1)\n","\n","    itv_num = to_itvnum(itv)\n","    # print(itv_num)\n","\n","    t_df = donchian_channel_v4(t_df, period1) \n","\n","    dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","    b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","    len_df = len(t_df)   \n","    len_df_range = np.arange(len_df).astype(int)\n","    # short_open_res = np.ones(len_df)\n","    # long_open_res = np.ones(len_df)\n","\n","    data_cols = ['open', 'high', 'low', 'close']\n","    open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","    b1_close = t_df.close.shift(itv_num).to_numpy()\n","    \n","    # ============ modules ============ #  \n","    # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","    cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","    co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","    cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","    co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ------ 생략 이전 terms' hl ------ #\n","    wave_high_terms_low_ = np.full(len_df, np.nan)\n","    wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","    wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","    wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","    cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","    co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","    high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","    \n","    paired_cu_idx = high_terms[:, 1]\n","    paired_co_idx = low_terms[:, 1]\n","\n","    # ====== get wave_hl & terms ====== #\n","    wave_high_ = np.full(len_df, np.nan)\n","    wave_low_ = np.full(len_df, np.nan)\n","\n","    wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","    wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","    wave_high_[paired_cu_idx] = wave_highs\n","    wave_low_[paired_co_idx] = wave_lows\n","\n","    wave_high_fill_ = fill_arr(wave_high_)\n","    wave_low_fill_ = fill_arr(wave_low_)\n","\n","    # wave_high_terms_low_ = np.full(len_df, np.nan)\n","    # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","    # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","    # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","    # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","    # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","    wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","    wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","    wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","    wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","    wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","    wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","    \n","    # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","    b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","    b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","    wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","    wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","    cu_prime_idx = wave_high_prime_idx\n","    cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","    co_prime_idx = wave_low_prime_idx\n","    co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","    # ============ enlist to df_cols ============ #       \n","    t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","    t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","    t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","    t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","    t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","    t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","    t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","    t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","    t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","    t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","    # ------ for roll prev_hl ------ # \n","    t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","    t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","    \n","    # ------ for first_high ------ # \n","    t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","    t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","      \n","    if itv != 'T':\n","      assert ltf_df is not None, \"assert ltf_df is not None\"\n","      join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","      ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","      try:\n","        ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","      except Exception as e:\n","        print(\"error in wave_range()'s join() :\", e)\n","    else:\n","      ltf_df = t_df    \n","\n","    return ltf_df\n"],"metadata":{"id":"841i4oo2abh-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["##### dump"],"metadata":{"id":"02DcTVB2cYuR"}},{"cell_type":"code","source":["\n","\n","def get_roll_wave_data_v2(valid_prime_idx, roll_idx_arr, len_df, data, roll_prev_hl_cnt):\n","\n","    roll_data = pd.DataFrame(np.full((len_df, roll_prev_hl_cnt), np.nan))\n","    roll_data.iloc[valid_prime_idx[roll_prev_hl_cnt:], :] = data[roll_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","    return roll_data.ffill().to_numpy()\n","\n","def roll_wave_hl_v5(t_df, config, roll_prev_hl_cnt=3):\n","  \n","    wave_itv = pd.infer_freq(t_df.index)\n","    wave_period = config.tr_set.wave_period\n","\n","    len_df = len(t_df)\n","\n","    high_prime_idx = t_df['wave_high_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","    low_prime_idx = t_df['wave_low_prime_idx_{}{}'.format(wave_itv, wave_period)].to_numpy()    \n","\n","    valid_high_prime_idx = high_prime_idx[~np.isnan(high_prime_idx)].astype(int)  # roll_high 를 위한 prime_idx\n","    valid_low_prime_idx = low_prime_idx[~np.isnan(low_prime_idx)].astype(int)  # roll_low 를 위한 prime_idx\n","\n","    roll_prev_high_idx_arr = np.array([valid_high_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_high_prime_idx)) if idx_ >= roll_prev_hl_cnt])  # cnt 수를 만족시키기 위해 idx 제한\n","    roll_prev_low_idx_arr = np.array([valid_low_prime_idx[idx_ - roll_prev_hl_cnt:idx_] for idx_ in range(len(valid_low_prime_idx)) if idx_ >= roll_prev_hl_cnt])\n","\n","    return valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr"],"metadata":{"id":"Go7ARIUhfC1g"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["t_df[roll_cols].tail(100)"],"metadata":{"id":"pgA8QqyXZ66o"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["data_col = 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1)\n","data = htf_df[data_col].to_numpy()\n","len_htf_df = len(htf_df)\n","\n","\n","roll_data = pd.DataFrame(index=htf_df.index, data=np.full((len_htf_df, roll_hl_cnt), np.nan))\n","roll_data.iloc[valid_high_prime_idx[roll_hl_cnt - 1:], :] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# roll_data.ffill()\n","htf_df[roll_cols] = roll_data.ffill()\n","htf_df[roll_cols]\n","\n","# htf_df[roll_cols] = np.nan\n","# htf_df[roll_cols].iloc[valid_high_prime_idx[roll_hl_cnt - 1:]] = data[roll_prev_high_idx_arr]  # 제한된 idx 를 제외한 row 에 roll_hl 입력\n","\n","# htf_df[roll_cols] = htf_df[roll_cols].ffill().to_numpy()\n","\n","# valid_high_prime_idx\n","# np.sum(~np.isnan(roll_high))\n","# htf_df[roll_cols]\n","# roll_prev_low_idx_arr"],"metadata":{"id":"wF7fKJ3mOhaf"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# t_df\n","to_lower_tf_v2(res_df, t_df, join_cols)"],"metadata":{"id":"3vHLGont-BFe"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["wave_post_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_post_terms])\n","wave_post_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_post_terms])\n","\n","# print(len(paired_cu_idx))\n","# print(len(wave_post_highs))\n","# print(len(cu_bool))\n","\n","update_paired_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","update_paired_cu_idx = paired_cu_idx[update_paired_cu_bool]\n","wave_high_[update_paired_cu_idx] = wave_post_highs[update_paired_cu_bool]\n","\n","update_paired_co_bool = (co_bool * (wave_low_terms_high_ > wave_high_fill_))[paired_co_idx]\n","update_paired_co_idx = paired_co_idx[update_paired_co_bool]\n","wave_low_[update_paired_co_idx] = wave_post_lows[update_paired_co_bool]\n","\n","wave_high_fill2_ = fill_arr(wave_high_)\n","wave_low_fill2_ = fill_arr(wave_low_)"],"metadata":{"id":"Mh3w2s-j34Zs"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# wave_post_highs\n","# update_cu_bool = (cu_bool * (wave_high_terms_low_ < wave_low_fill_))[paired_cu_idx]\n","# print(paired_cu_idx[update_cu_bool])\n","# print(paired_cu_idx)\n","print(len(update_paired_cu_idx))\n","print(len(wave_post_highs[update_paired_cu_bool]))\n","# print(high_prime_terms[:, 1])\n","# print(high_post_terms[:, 1])"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"eQ06-kWq4m6F","executionInfo":{"status":"ok","timestamp":1651799326382,"user_tz":-540,"elapsed":3,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"5c5df956-4fbd-4aa4-e1d6-dc5d0c23ac19"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["11\n","11\n"]}]},{"cell_type":"code","source":["cu_idx = get_index_bybool(cu_bool, len_df_range)\n","co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","cu_fill_idx = fill_arr(cu_idx)\n","co_fill_idx = fill_arr(co_idx)\n","\n","notnan_cu_bool = ~np.isnan(cu_idx)\n","notnan_co_bool = ~np.isnan(co_idx)\n","\n","# ------ 생략된 idx 에 대한 prime_idx 탐색 ------ #\n","high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","low_bool = co_fill_idx < cu_fill_idx\n","\n","high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","high_terms_list = using_clump(high_terms_vec)\n","low_terms_list = using_clump(low_terms_vec)\n","\n","valid_cu_prime_idx = np.array([terms.min() for terms in low_terms_list])\n","valid_co_prime_idx = np.array([terms.min() for terms in high_terms_list])\n","\n","cu_prime_idx = np.full(len_df, np.nan)\n","co_prime_idx = np.full(len_df, np.nan)\n","\n","cu_prime_idx[valid_cu_prime_idx] = valid_cu_prime_idx\n","co_prime_idx[valid_co_prime_idx] = valid_co_prime_idx\n","\n","cu_prime_fill_idx = fill_arr(cu_prime_idx)\n","co_prime_fill_idx = fill_arr(co_prime_idx)\n","\n","# ------ get co, cu terms_v2 ------ # # 기본은 아래 logic 으로 수행하고, update_hl 도 해당 term 구간의 hl 이 더 작거나 클경우 적용 가능할 것\n","valid_cu_bool = notnan_cu_bool * ~np.isnan(co_fill_idx) * ~np.isnan(co_prime_fill_idx)\n","valid_co_bool = notnan_co_bool * ~np.isnan(cu_fill_idx) * ~np.isnan(cu_prime_fill_idx)\n","\n","high_post_terms = np.vstack((co_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_post_terms = np.vstack((cu_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)\n","\n","high_terms_cnt = high_post_terms[:, 1] - high_post_terms[:, 0] \n","low_terms_cnt = low_post_terms[:, 1] - low_post_terms[:, 0] \n","\n","high_prime_terms = np.vstack((co_prime_fill_idx[valid_cu_bool], cu_idx[valid_cu_bool])).T.astype(int)\n","low_prime_terms = np.vstack((cu_prime_fill_idx[valid_co_bool], co_idx[valid_co_bool])).T.astype(int)"],"metadata":{"id":"SUFmr9Z_kcCN"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# co_prime_idx\n","# co_prime_fill_idx\n","high_prime_terms"],"metadata":{"id":"_3pOQtt2ttfk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#  get_index_bybool(notnan_cu_bool, len_df_range)\n","valid_cu_idx = cu_idx[notnan_cu_bool]\n","valid_shift_cu_idx = pd.Series(valid_cu_idx).shift(1).to_numpy()\n","valid_co_idx = co_idx[notnan_co_bool]\n","valid_shift_co_idx = pd.Series(valid_co_idx).shift(1).to_numpy()\n","\n","valid_cu_idx - valid_shift_cu_idx\n","valid_co_idx - valid_shift_co_idx"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"kKaD1fK3WPRP","executionInfo":{"status":"ok","timestamp":1651756811396,"user_tz":-540,"elapsed":6,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"bbe470f3-17d0-4029-97e9-2fb383a0c752"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([nan,  2.,  7.,  2.,  4.,  2.,  7.,  5.,  4.,  6.,  9.,  2.,  5., 11., 14.])"]},"metadata":{},"execution_count":79}]},{"cell_type":"code","source":["def wave_range_v14(t_df, config, ltf_df=None, term_thresh1=1, term_thresh2=3):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ------ 생략 이전 terms' hl ------ #\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  # cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  # co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  cu_bool[high_terms[:, 1][(high_terms_cnt <= term_thresh1) & (cu_idx_term <= term_thresh2)]] = False\n","  co_bool[low_terms[:, 1][(low_terms_cnt <= term_thresh1) & (co_idx_term <= term_thresh2)]] = False  \n","\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  # high_terms, low_terms, high_terms_cnt, low_terms_cnt, _, _ = get_terms_info_v2(cu_bool, co_bool, len_df_range)\n","  high_post_terms, low_post_terms, high_terms_cnt, low_terms_cnt, high_prime_terms, low_prime_terms, cu_idx_term, co_idx_term = get_terms_info_v3(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_prime_terms[:, 1]\n","  paired_co_idx = low_prime_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","  \n","def wave_range_v13(t_df, config, ltf_df=None, term_thresh=2):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)   # for marking\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","\n","  wave_high_terms_low_ = np.full(len_df, np.nan)\n","  wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # 생략 이전 terms' hl\n","  wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])  \n","\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ add update_hl ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_low_[paired_cu_idx] = wave_high_terms_lows  \n","  wave_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  # ------ 생략된 cu, co 에 대한 2nd pairing 진행 ------ #\n","  cu_bool[high_terms[:, 1][high_terms_cnt <= term_thresh]] = False\n","  co_bool[low_terms[:, 1][low_terms_cnt <= term_thresh]] = False  \n","  high_terms, low_terms, high_terms_cnt, low_terms_cnt = get_terms_info(cu_bool, co_bool, len_df_range)\n","  \n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  # ====== get wave_hl & terms ====== #\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  wave_high_[paired_cu_idx] = wave_highs\n","  wave_low_[paired_co_idx] = wave_lows\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  # wave_high_terms_low_ = np.full(len_df, np.nan)\n","  # wave_low_terms_high_ = np.full(len_df, np.nan)\n","\n","  # wave_high_terms_lows = np.array([low[iin:iout + 1].min() for iin, iout in high_terms])  # for point rejection, Todo, min_max 설정 항상 주의\n","  # wave_low_terms_highs = np.array([high[iin:iout + 1].max() for iin, iout in low_terms])\n","\n","  # wave_high_terms_low_[paired_cu_idx] = wave_high_terms_lows\n","  # wave_low_terms_high_[paired_co_idx] = wave_low_terms_highs\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_idx] = high_terms_cnt\n","  wave_low_terms_cnt_[paired_co_idx] = low_terms_cnt\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","  \n","  # ------ hl_fill 의 prime_idx 를 찾아야함 ------ # \n","  b1_wave_high_fill_ = pd.Series(wave_high_fill_).shift(1).to_numpy()\n","  b1_wave_low_fill_ = pd.Series(wave_low_fill_).shift(1).to_numpy()\n","  wave_high_prime_idx = np.where((wave_high_fill_ != b1_wave_high_fill_) & ~np.isnan(wave_high_fill_), len_df_range, np.nan)\n","  wave_low_prime_idx = np.where((wave_low_fill_ != b1_wave_low_fill_) & ~np.isnan(wave_low_fill_), len_df_range, np.nan)\n","\n","  cu_prime_idx = wave_high_prime_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","\n","  co_prime_idx = wave_low_prime_idx\n","  co_prime_idx_fill_ = fill_arr(wave_low_prime_idx)  \n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * (wave_high_terms_low_ >= wave_low_fill_)   # co ~ cu’s low 가 wave_low 갱신할 경우 point 에서 제외\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * (wave_low_terms_high_ <= wave_high_fill_)\n","  t_df['wave_cu_bool_{}{}'.format(itv, period1)] = cu_bool   # temporary, for plot_check\n","  t_df['wave_co_bool_{}{}'.format(itv, period1)] = co_bool\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-15, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n","def wave_range_v12(t_df, config, ltf_df=None):  # v2 for period1 only\n","\n","  itv = pd.infer_freq(t_df.index)\n","  period1 = config.tr_set.wave_period\n","  # print(period1)\n","\n","  itv_num = to_itvnum(itv)\n","  # print(itv_num)\n","\n","  t_df = donchian_channel_v4(t_df, period1) \n","\n","  dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].to_numpy()\n","  b1_dc_base_ = t_df['dc_base_{}{}'.format(itv, period1)].shift(itv_num).to_numpy()\n","\n","  len_df = len(t_df)   \n","  len_df_range = np.arange(len_df).astype(int)\n","  # short_open_res = np.ones(len_df)\n","  # long_open_res = np.ones(len_df)\n","\n","  data_cols = ['open', 'high', 'low', 'close']\n","  open, high, low, close = [t_df[col_].to_numpy() for col_ in data_cols]\n","  b1_close = t_df.close.shift(itv_num).to_numpy()\n","  \n","  # ============ modules ============ #  \n","  # ------ define co, cu ------ # <- point missing 과 관련해 정교해아함\n","  cu_bool = ((b1_close > b1_dc_base_) & (dc_base_ > close)) | ((b1_close > dc_base_) & (dc_base_ > close))\n","  co_bool = (b1_close < b1_dc_base_) & (dc_base_ < close) | ((b1_close < dc_base_) & (dc_base_ < close))\n","\n","  # Todo, term 조정은 이 line 에서 해야할 것\n","  b1_cu_bool = pd.Series(cu_bool).shift(1).to_numpy()\n","  b1_co_bool = pd.Series(co_bool).shift(1).to_numpy()\n","\n","  cu_bool *= ~b1_co_bool.astype(bool)  # short_term point 생략\n","  co_bool *= ~b1_cu_bool.astype(bool)\n","\n","  cu_idx = get_index_bybool(cu_bool, len_df_range)\n","  co_idx = get_index_bybool(co_bool, len_df_range)\n","\n","  cu_fill_idx = fill_arr(cu_idx)\n","  co_fill_idx = fill_arr(co_idx)\n","\n","  # ------ get co, cu terms ------ #\n","  high_bool = cu_fill_idx < co_fill_idx  # 이렇게 해야 high_terms[:, 1] 이 cu_idx 가 나옴\n","  low_bool = co_fill_idx < cu_fill_idx\n","\n","  high_terms_vec = get_index_bybool(high_bool, len_df_range)\n","  low_terms_vec = get_index_bybool(low_bool, len_df_range) # -> low_terms\n","\n","  high_terms_list = using_clump(high_terms_vec)\n","  low_terms_list = using_clump(low_terms_vec)\n","\n","  high_terms = np.array([[terms.min(), terms.max() + 1] for terms in high_terms_list])\n","  low_terms = np.array([[terms.min(), terms.max() + 1] for terms in low_terms_list])\n","\n","  high_terms_cnt = high_terms[:, 1] - high_terms[:, 0] \n","  low_terms_cnt = low_terms[:, 1] - low_terms[:, 0] \n","\n","  wave_highs = np.array([high[iin:iout + 1].max() for iin, iout in high_terms])\n","  wave_lows = np.array([low[iin:iout + 1].min() for iin, iout in low_terms])\n","\n","  # ------ get valid_idx range (inner len_df) ------ #\n","  paired_cu_idx = high_terms[:, 1]\n","  paired_co_idx = low_terms[:, 1]\n","\n","  valid_cu_bool = paired_cu_idx < len_df\n","  valid_co_bool = paired_co_idx < len_df\n","\n","  paired_cu_valid_idx = paired_cu_idx[valid_cu_bool]\n","  paired_co_valid_idx = paired_co_idx[valid_co_bool]\n","\n","  # ------ get wave_hl & terms ------ #\n","  wave_high_ = np.full(len_df, np.nan)\n","  wave_low_ = np.full(len_df, np.nan)\n","\n","  wave_high_[paired_cu_valid_idx] = wave_highs[valid_cu_bool]\n","  wave_low_[paired_co_valid_idx] = wave_lows[valid_co_bool]\n","\n","  wave_high_fill_ = fill_arr(wave_high_)\n","  wave_low_fill_ = fill_arr(wave_low_)\n","\n","  wave_high_terms_cnt_ = np.full(len_df, np.nan)\n","  wave_low_terms_cnt_ = np.full(len_df, np.nan)\n","\n","  wave_high_terms_cnt_[paired_cu_valid_idx] = high_terms_cnt[valid_cu_bool]\n","  wave_low_terms_cnt_[paired_co_valid_idx] = low_terms_cnt[valid_co_bool]\n","\n","  wave_high_terms_cnt_fill_ = fill_arr(wave_high_terms_cnt_)\n","  wave_low_terms_cnt_fill_ = fill_arr(wave_low_terms_cnt_)\n","\n","  # ------ check update high & low (occurs by point missing) ------ # \n","  co_prime_idx = np.full(len_df, np.nan)\n","  co_prime_idx[paired_co_valid_idx] = paired_co_valid_idx\n","  co_prime_idx_fill_ = fill_arr(co_prime_idx)\n","  # valid_idx = co_idx > co_prime_idx_fill_\n","  valid_idx = cu_idx > co_prime_idx_fill_\n","\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]  # include open low\n","  # 1. 잘 생각해보면, cu_idx 에는 co_prime_idx_fill_ 을 사용하는게 맞음\n","  #   a. cu_idx 에 달려있는 low 가 co_prime_idx_fill_ 기준이니까\n","  # update_low = np.full(len_df, np.nan)\n","  # update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가\n","  \n","  update_high = np.full(len_df, np.nan)\n","  update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(co_prime_idx_fill_[valid_idx].astype(int), cu_idx[valid_idx].astype(int))]   # high 아닌가 => 아님 update_low 이기 때문\n","  \n","  cu_prime_idx = np.full(len_df, np.nan)\n","  cu_prime_idx[paired_cu_valid_idx] = paired_cu_valid_idx\n","  cu_prime_idx_fill_ = fill_arr(cu_prime_idx)\n","  valid_idx = co_idx > cu_prime_idx_fill_\n","\n","  # update_high = np.full(len_df, np.nan)\n","  # update_high[valid_idx] = [high[iin:iout + 1].max() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  update_low = np.full(len_df, np.nan)\n","  update_low[valid_idx] = [low[iin:iout + 1].min() for iin, iout in zip(cu_prime_idx_fill_[valid_idx].astype(int), co_idx[valid_idx].astype(int))]\n","\n","  # ============ enlist to df_cols ============ #       \n","  t_df['wave_high_fill_{}{}'.format(itv, period1)] = wave_high_fill_\n","  t_df['wave_low_fill_{}{}'.format(itv, period1)] = wave_low_fill_\n","\n","  t_df['wave_update_high_fill_{}{}'.format(itv, period1)] = update_high\n","  t_df['wave_update_low_fill_{}{}'.format(itv, period1)] = update_low\n","\n","  t_df['wave_high_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_high_terms_cnt_fill_\n","  t_df['wave_low_terms_cnt_fill_{}{}'.format(itv, period1)] = wave_low_terms_cnt_fill_\n","  t_df['wave_cu_{}{}'.format(itv, period1)] = cu_bool * ~(update_low < wave_low_fill_)   # Todo, 이곳 다시 한번 확인 (old, point_missing 으로 인한 low 갱신 회피)\n","  t_df['wave_co_{}{}'.format(itv, period1)] = co_bool * ~(update_high > wave_high_fill_)\n","  t_df['wave_cu_marker_{}{}'.format(itv, period1)] = get_line(cu_idx, dc_base_)\n","  t_df['wave_co_marker_{}{}'.format(itv, period1)] = get_line(co_idx, dc_base_)\n","\n","  # ------ for roll prev_hl ------ # \n","  t_df['wave_cu_prime_idx_{}{}'.format(itv, period1)] = cu_prime_idx\n","  t_df['wave_co_prime_idx_{}{}'.format(itv, period1)] = co_prime_idx\n","  \n","  # ------ for first_high ------ # \n","  t_df['wave_cu_prime_idx_fill_{}{}'.format(itv, period1)] = cu_prime_idx_fill_\n","  t_df['wave_co_prime_idx_fill_{}{}'.format(itv, period1)] = co_prime_idx_fill_\n","    \n","  if itv != 'T':\n","    assert ltf_df is not None, \"assert ltf_df is not None\"\n","    join_cols = np.arange(-17, 0 ,1).astype(int)  # points & donchian_channels\n","    ltf_df.drop(t_df.columns[join_cols], inplace=True, axis=1, errors='ignore')\n","    try:\n","      ltf_df = ltf_df.join(to_lower_tf_v2(ltf_df, t_df, join_cols), how='inner')\n","    except Exception as e:\n","      print(\"error in wave_range()'s join() :\", e)\n","  else:\n","    ltf_df = t_df    \n","\n","  return ltf_df\n","\n","\n"],"metadata":{"id":"YoZpr7lDn7z-"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"1MNVIExLULhJ"},"source":["#### legacy"]},{"cell_type":"code","source":[""],"metadata":{"id":"1eZov-szzNuB"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EOXQbXixiQcK"},"source":["##### volume_profile"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7pFuazxpgx9B"},"outputs":[],"source":["session_df = res_df_.iloc[-1440:] # 0.159 -> 0.024 (14400 -> 1440)\n","volume = session_df['volume'].to_numpy()\n","close = session_df['close'].to_numpy()\n","# px.histogram(session_df, x='volume', y='close', nbins=150, orientation='h').show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SoPJkiyKiXLM"},"outputs":[],"source":["kde_factor = 0.05\n","num_samples = 100\n","\n","start_0 = time.time()\n","kde = stats.gaussian_kde(close,weights=volume,bw_method=kde_factor)\n","kdx = np.linspace(close.min(),close.max(),num_samples)\n","kdy = kde(kdx)\n","ticks_per_sample = (kdx.max() - kdx.min()) / num_samples\n","print(\"ticks_per_sample :\", ticks_per_sample)  # sample 당 가격\n","print(\"kdy elapsed_time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mK2jBddAxJ14"},"outputs":[],"source":["peaks,_ = signal.find_peaks(kdy)\n","pkx = kdx[peaks]\n","pky = kdy[peaks]\n","\n","plt.figure(figsize=(10,5))\n","# plt.hist(close, bins=num_samples, weights=volume, alpha=.8, color='#1592e6')\n","# plt.plot(kdx, kdy, color='white')\n","# plt.plot(pkx, pky, 'bo', color='yellow')\n","plt.plot(kdy, kdx, color='white')\n","plt.plot(pky, pkx, 'bo', color='yellow')\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"a8tpQZCy0SO1"},"outputs":[],"source":["pkx"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gfA946s8UgS0"},"outputs":[],"source":["# ------ vp 의 indi. 화가 필요함 -> point 설정 ------ #\n","# 1. 4 level 은 미리 만들어놓는게 맞는걸로 보임 -> 추종하는 function 이 많음 (utils_tr, ep_out ...)\n","#   a. 4 level 에 국한하는게 아니라, 모든 peaks 에 대해 levels 설정\n","#   b. 각 session 별로 peak_list 가 주어질 것\n","#     i. prev_data 사용해야하는점 주의 (session vp 는 future_data)"]},{"cell_type":"markdown","metadata":{"id":"3T-9FwWFXR4f"},"source":["###### prominence_info"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RmBt2agljClE"},"outputs":[],"source":["start_0 = time.time()\n","min_prom = kdy.max() * 0.0\n","pipsize = 0.01\n","max_width_pips = 20\n","# width_range=(1, max_width_pips * pipsize / ticks_per_sample)\n","width_range= max_width_pips * pipsize / ticks_per_sample\n","peaks, peak_props = signal.find_peaks(kdy, prominence=min_prom, width=width_range)\n","\n","peak_x = kdx[peaks]\n","peak_y = kdy[peaks]\n","# ------ prominence lines ------ #\n","left_base = peak_props['left_bases']\n","right_base = peak_props['right_bases']\n","line_x = peak_x\n","line_y0 = peak_y\n","line_y1 = peak_y # - peak_props['prominences']\n","print(\"prom_line elapsed_time :\", time.time() - start_0)\n","\n","\n","for x, y0, y1 in zip(line_x, line_y0, line_y1):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        # x0=x, y0=y0, x1=x, y1=y1,\n","        x0=x, y0=0, x1=x, y1=y1,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","\n","# ------ width ------ #\n","left_ips = peak_props['left_ips']\n","right_ips = peak_props['right_ips']\n","# width_x0 = kdx.min() + (left_ips * ticks_per_sample)\n","# width_x1 = kdx.min() + (right_ips * ticks_per_sample)\n","width_x0 = kdx.min() + (left_base * ticks_per_sample)\n","width_x1 = kdx.min() + (right_base * ticks_per_sample)\n","\n","# int_from = kdx.min() + (left_base * ticks_per_sample)\n","# int_to = kdx.min() + (right_base * ticks_per_sample)\n","# [kde.integrate_box_1d(x0, x1) for x0, x1 in zip(int_from, int_to)]\n","\n","width_y = peak_props['width_heights']\n","\n","for x0, x1, y in zip(width_x0, width_x1, width_y):\n","    fig.add_shape(type='line',\n","        xref='x', yref='y',\n","        x0=x0, y0=y, x1=x1, y1=y,\n","        line=dict(\n","            color='red',\n","            width=2,\n","        )\n","    )\n","fig.show()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"zqj944n-WzyZ"},"outputs":[],"source":["# peaks  # ndarray\n","# kdx  # ndarray\n","# kdy  # ndarray\n","# kdx.min()\n","left_base * ticks_per_sample\n","# volume"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rvqv0RGojo9h"},"outputs":[],"source":["print(peak_y)\n","print(peak_props['prominences'])\n","peak_props"]},{"cell_type":"markdown","metadata":{"id":"c2729DJ6h720"},"source":["##### imb."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Rucj-iepiR_-"},"outputs":[],"source":["t_df = res_df_.iloc[-120:-100]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ktm1aB-Bh7GH"},"outputs":[],"source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(15, 9))\n","nrows, ncols = 1, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        # height_ratios=[3, 1]\n","                        )\n","\n","ax = fig.add_subplot(gs[0])\n","\n","# ------ candles ------ #\n","candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","_ = [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jMQBhQ1Ljt5Y"},"outputs":[],"source":["def imb_ratio_v4(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_range = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / short_body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / long_body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"I1Vq_BiKpY3P"},"outputs":[],"source":["def imb_ratio_v3(df, itv):\n","\n","  itv_num = to_itvnum(itv)\n","\n","  # high = df['high_{}'.format(itv)].to_numpy()\n","  # low = df['low_{}'.format(itv)].to_numpy()\n","  # candle_range = high - low\n","\n","  close = df['close_{}'.format(itv)].to_numpy()\n","  open = df['open_{}'.format(itv)].to_numpy()\n","\n","  b1_close = df['close_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_open = df['open_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_high = df['high_{}'.format(itv)].shift(itv_num).to_numpy()\n","  b1_low = df['low_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","  body_range = abs(close - open)\n","  b1_body_range = abs(b1_close - b1_open)\n","\n","  df['body_rel_ratio_{}'.format(itv)] = body_range / b1_body_range\n","\n","  short_body_ratio = np.where(close <= b1_low, body_range, b1_body_range)\n","  long_body_range = np.where(close >= b1_high, body_range, b1_body_range)\n","\n","  # 추후에 통계 측정해야함 -> bir 에 따른 개별 trader 의 epout / tpep 이라던가 => short 에 양봉은 취급안함 (why use np.nan)\n","  df['short_ir_{}'.format(itv)] = np.where(close < open, (b1_low - close) / body_range, np.nan) # close < open & close < b1_low\n","  df['long_ir_{}'.format(itv)] = np.where(close > open, (close - b1_high) / body_range, np.nan) # close > open & close > b1_high\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"mtnMUkhwkdrE"},"outputs":[],"source":["imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","# imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RVUs1YE_pgBI"},"outputs":[],"source":["# imb_ratio(t_df, \"5T\")\n","# imb_ratio_v3(t_df, \"5T\")\n","imb_ratio_v4(t_df, \"5T\")\n","\n","t_df.tail(100).short_ir_5T  # .461871\n","# t_df.iloc[:, -10:]\n","# t_df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bieHiKjBkuFL"},"outputs":[],"source":["# ------ rtc 1, 0 개념 ------ #\n","# short_rtc_1 = close\n","# short_rtc_0 = b1_low\n","\n","# long_rtc_1 = close\n","# long_rtc_0 = b1_high\n","\n","# rtc 로 활용하려면, col 로 추가해야할 것 -> 추가할만한 col_name 은 아님\n","# 1. h_candle 인 경우 -> ?\n","#   a. h_candle_v3 먹이고, open_{}.shift(num_itv).to_numpy() 진행 -> ex. res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy() "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"3X6bMXJIjPYy"},"outputs":[],"source":["# 1. 현재 종가 - 이전 고가 = imb_range (long)\n","long_imb_range = t_df.close - t_df.high.shift(1)\n","# 2. 이전 저가 - 현재 종가 - imb_range (short)\n","short_imb_range = t_df.low.shift(1) - t_df.close"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"q1nEA19v7Qpj"},"outputs":[],"source":["from math import floor\n","\n","\n","def _calc_dev(base_price, price):\n","    return 100 * (price - base_price) / base_price\n","\n","\n","def zigzag(highs, lows, depth=10, dev_threshold=5):\n","    def pivots(src_raw, length, isHigh):\n","        src = list(reversed(src_raw))\n","        bar_index = list(range(len(src)))\n","        for start in range(0, len(src)):\n","            if start + 2 * length + 1 > len(src) - 1:\n","                return\n","            p = 0\n","            if length < len(src) - start:\n","                p = src[start + length]\n","            if length == 0:\n","                yield 0, p\n","            else:\n","                isFound = True\n","                for i in range(start, start + length):\n","                    if isHigh and src[i] > p:\n","                        isFound = False\n","                    if not isHigh and src[i] < p:\n","                        isFound = False\n","                for i in range(start + length + 1, start + 2 * length + 1):\n","                    if isHigh and src[i] >= p:\n","                        isFound = False\n","                    c = not isHigh and src[i] <= p\n","                    if c:\n","                        isFound = False\n","                if isFound:\n","                    yield (bar_index[start + length], p)\n","                else:\n","                    yield None, None\n","\n","    data_highs = [x for x in pivots(highs, floor(depth / 2), True) if x[0]]\n","    data_lows = [x for x in pivots(lows, floor(depth / 2), False) if x[0]]\n","\n","    raw_pairs = []\n","\n","    for i, (ind, p) in enumerate(data_highs):\n","        lows_d = sorted([(ind_l, p_l) for ind_l, p_l in data_lows if ind > ind_l], key=lambda x: x[0])\n","        if lows_d:\n","            lows = lows_d[-1]\n","\n","            if abs(_calc_dev(lows[1], p)) >= dev_threshold:\n","                raw_pairs.append(\n","                    ((ind, p),\n","                     (lows[0], lows[1]))\n","                )\n","\n","    result = []\n","\n","    for (i_h, p_h),(i_l, p_l) in raw_pairs:\n","        if not result:\n","            result.append(((i_h, p_h),(i_l, p_l)))\n","            continue\n","\n","        if i_l == result[-1][1][0]:\n","            if p_h > result[-1][0][1]:\n","                result = result[:-1]\n","            else:\n","                continue\n","\n","        result.append(((i_h, p_h),(i_l, p_l)))\n","\n","    return result\n","\n","# highs, lows = t_df.high.to_numpy(), t_df.low.to_numpy()\n","# zigzag(highs, lows, depth=5, dev_threshold=5)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGlmdyb97j4Q"},"outputs":[],"source":["t_df = res_df_.iloc[-120:]\n","a_data = t_df.to_numpy()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ropzIp0wUPAA"},"outputs":[],"source":["# import plotly.express as px\n","# import plotly.graph_objects as go\n","\n","def get_dist_plot(c, v, kx, ky):\n","    fig = go.Figure()\n","    fig.add_trace(go.Histogram(name='Vol Profile', x=c, y=v, nbinsx=150, \n","                               histfunc='sum', histnorm='probability density',\n","                               marker_color='#B0C4DE'))\n","    fig.add_trace(go.Scatter(name='KDE', x=kx, y=ky, mode='lines', marker_color='#D2691E'))    \n","\n","    peaks,_ = signal.find_peaks(kdy)\n","    pkx = kdx[peaks]\n","    pky = kdy[peaks]\n","    pk_marker_args=dict(size=10, color='black')\n","    fig.add_trace(go.Scatter(name=\"Peaks\", x=pkx, y=pky, mode='markers', marker=pk_marker_args))\n","    fig.show()\n","\n","    return fig"]},{"cell_type":"markdown","source":["##### instant."],"metadata":{"id":"RZJ6uIA_VcJs"}},{"cell_type":"code","source":["def wave_range_ratio(res_df, config, bb_itv, bb_period):\n","\n","  wave_itv = pd.infer_freq(res_df.index)\n","  wave_period = config.tr_set.wave_period\n","\n","  bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].to_numpy()\n","  \n","  cu_prime_idx_fill_ = res_df['wave_cu_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  co_prime_idx_fill_ = res_df['wave_co_prime_idx_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","  cu_bb_range = get_line(co_prime_idx_fill_, bb_upper_) - get_line(co_prime_idx_fill_, bb_lower_)  # cu 에서 co_prime 의 bb_range 사용\n","  co_bb_range = get_line(cu_prime_idx_fill_, bb_upper_) - get_line(cu_prime_idx_fill_, bb_lower_)\n","\n","  wave_range = res_df['wave_high_fill_{}{}'.format(wave_itv, wave_period)].to_numpy() - res_df['wave_low_fill_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","  \n","  res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / cu_bb_range   # for cu (currently, long)\n","  res_df['co_wrr_{}{}'.format(wave_itv, wave_period)] = wave_range / co_bb_range\n","\n","  return res_df"],"metadata":{"id":"nLWAP1Cl2Hvu"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def enough_space(res_df, itv, period):\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_base_ = res_df['dc_base_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period)].to_numpy()  \n","  high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","  low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","\n","  half_dc_gap = dc_upper_ - dc_base_\n","\n","  res_df['cu_es_{}{}'.format(itv, period)] = (low_ - dc_lower_) / half_dc_gap\n","  res_df['co_es_{}{}'.format(itv, period)] = (dc_upper_ - high_) / half_dc_gap\n","\n","  return res_df"],"metadata":{"id":"H_zPYIshbZgP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Todo, future_data\n","def candle_range_ratio(res_df, c_itv, bb_itv, bb_period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, bb_period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_   # <-- h_candle's open_idx 의 bb_gap 사용\n","\n","  high_ = res_df['high_{}'.format(c_itv)].to_numpy()\n","  low_ = res_df['low_{}'.format(c_itv)].to_numpy()\n","  candle_range = high_ - low_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['crr_{}'.format(c_itv)] = candle_range / bb_range\n","\n","  return res_df"],"metadata":{"id":"o3IUBc59VR5D"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def body_rel_ratio(res_df, c_itv):\n","\n","  itv_num = to_itvnum(c_itv)\n","  \n","  b1_close_ = res_df['close_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_open_ = res_df['open_{}'.format(c_itv)].shift(itv_num).to_numpy()\n","  b1_body_range = abs(b1_close_ - b1_open_)\n","\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  res_df['body_rel_ratio_{}'.format(c_itv)] = body_range / b1_body_range\n","\n","  return res_df\n","\n","def dc_over_body_ratio(res_df, c_itv, dc_itv, dc_period):\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  body_range = abs(close_ - open_)\n","  \n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, dc_period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, dc_period)].to_numpy() \n","\n","  res_df['dc_upper_{}{}_br'.format(dc_itv, dc_period)] = (close_ - dc_upper_) / body_range\n","  res_df['dc_lower_{}{}_br'.format(dc_itv, dc_period)] = (dc_lower_ - close_) / body_range\n","\n","  return res_df"],"metadata":{"id":"u3yFd8Dcok5m"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def candle_pumping_ratio_v2(res_df, c_itv, dc_itv, period):\n","\n","  res_df = dc_line_v3(res_df, dc_itv, dc_period=period)\n","\n","  dc_upper_ = res_df['dc_upper_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_lower_ = res_df['dc_lower_{}{}'.format(dc_itv, period)].to_numpy()\n","  dc_range = dc_upper_ - dc_lower_\n"," \n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / dc_range\n","\n","  return res_df\n","\n","\n","# Todo, future_data\n","def candle_pumping_ratio(res_df, c_itv, bb_itv, period):\n","\n","  itv_num = to_itvnum(c_itv)\n","\n","  # 여기에도 v2 처럼 bb_indi. 추가 (자동화)\n","\n","  b1_bb_upper_ = res_df['bb_upper_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  b1_bb_lower_ = res_df['bb_lower_{}{}'.format(bb_itv, period)].shift(itv_num).to_numpy()\n","  bb_range = b1_bb_upper_ - b1_bb_lower_\n","\n","  open_ = res_df['open_{}'.format(c_itv)].to_numpy()\n","  close_ = res_df['close_{}'.format(c_itv)].to_numpy()\n","  body = close_ - open_  # 부호로 양 / 음봉 구분 (양봉 > 0)\n","  \n","  res_df['cppr_{}'.format(c_itv)] = body / bb_range\n","\n","  return res_df\n","\n","\n","def pumping_ratio(res_df, config, itv, period1, period2):\n","\n","  bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","  bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","  bb_range = bb_upper_5T - bb_lower_5T\n","\n","  selection_id = config.selection_id\n","  \n","  res_df['short_ppr_{}'.format(selection_id)] = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n","  res_df['long_ppr_{}'.format(selection_id)] = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() / get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), bb_range)\n"],"metadata":{"id":"JWj02LLGbnji"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OpkclLSzazZ-"},"outputs":[],"source":["def wave_body_ratio(res_df_, itv, period):\n","  dc_upper_ = res_df_['dc_upper_{}{}'.format(itv, period)].to_numpy()\n","  dc_lower_ = res_df_['dc_lower_{}{}'.format(itv, period)].to_numpy()\n","  close_ = res_df_['close_{}'.format(itv)].to_numpy()\n","  open_ = res_df_['open_{}'.format(itv)].to_numpy()\n","\n","  dc_range = dc_upper_ - dc_lower_\n","  body_range = abs(close_ - open_)\n","\n","  res_df_['wave_body_ratio'] = body_range / dc_range\n","  res_df_['dc_upper_body_ratio'] = (np.maximum(close_, open_) - dc_upper_) / body_range\n","  res_df_['dc_lower_body_ratio'] = (dc_lower_) - np.minimum(close_, open_) / body_range\n","\n","  return"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0-zzitQRbnz8"},"outputs":[],"source":["# res_df_['wave_body_ratio'].tail(200)\n","\n","itv = 'H'\n","period = 5\n","wave_body_ratio(res_df_, itv, period)"]},{"cell_type":"markdown","metadata":{"id":"qsyPhNR8yP1c"},"source":["##### dump"]},{"cell_type":"markdown","metadata":{"id":"xpyP5t8Ht_pE"},"source":["### calc recursive indi's min_period"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"N1Hbm4OA4Tkk"},"outputs":[],"source":["ticker_prcn = get_precision_by_price(res_df.close.iloc[-1]) + 2\n","\n","target_len = 300000\n","slice_len_list = list(range(50, 10000, 100))\n","slice_len_list.insert(0, target_len)\n","\n","start_0 = time.time()\n","# prev_int_, prev_pnts_ = None, None\n","offset = 1\n","\n","for sl_idx, sample_len in enumerate(slice_len_list):\n","\n","  sample_df = res_df.iloc[-sample_len -offset:-offset]\n","  sample_len2 = sample_len\n","\n","  # --------- input using indi.s --------- #\n","  # res = ema_v0(sample_df['close'], 190)\n","  res = rsi(sample_df, 14)\n","\n","    #    to_htf()    #\n","  # df_5T = to_htf(sample_df, itv_='5T', offset='1h')\n","  # sample_len2 = len(df_5T)\n","\n","  # # --------- input using htf_indi. --------- #\n","  # res = ema(df_5T['close'], 195)\n","  # -------------------------------------- #\n","\n","  res_last_row = res.iloc[-1]\n","  if pd.isnull(res_last_row):\n","    continue\n","\n","  # print(res_last_row)\n","  # break\n","\n","  # sample_df = sample_df.join(to_lower_tf_v2(sample_df, df_5T, [-1]), how='inner')\n","\n","\n","  #   자리수 분할 계산    #\n","  int_, points_ = str(res_last_row).split('.')\n","  pnts_ = points_[:ticker_prcn]\n","\n","  if sl_idx == 0:\n","    target_int_ = int_\n","    target_pnts_ = pnts_\n","    print(\"target {} ({}) -> {} {}\".format(sample_len, sample_len2, int_, points_))\n","\n","  else:\n","    if target_int_ == int_ and target_pnts_ == pnts_:\n","      # print(sample_len, \"({})\".format(sample_len2), '->', int_, pnts_, end='\\n\\n')\n","      print(\"{} ({}) -> {} {}\\n\".format(sample_len, sample_len2, int_, points_))\n","      break\n","\n","print(time.time() - start_0)  # (1301)(1361)(1301)"]},{"cell_type":"markdown","metadata":{"id":"rrIGjmUzqU-D"},"source":["## import utils & config"]},{"cell_type":"code","execution_count":4,"metadata":{"id":"SeJan_0t95yL","executionInfo":{"status":"ok","timestamp":1654265145026,"user_tz":-540,"elapsed":2557,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["frame_ver = \"0114_htf\"\n","ID_arr = np.array(['v3', 'v5_2'])\n","\n","utils_public_name = \"{}.utils.{}_utils_public\".format(strat_pkg, frame_ver)\n","utils_public_lib = importlib.import_module(utils_public_name)\n","utils_public = utils_public_lib   # temporary\n","\n","u_name_list = [\"{}.utils.{}_utils_{}\".format(strat_pkg, frame_ver, id_) for id_ in ID_arr]\n","utils_arr = np.array([importlib.import_module(u_name) for u_name in u_name_list])\n","\n","config_name_list = [\"{}_config_{}.json\".format(frame_ver, id_) for id_ in ID_arr]\n","cfg_path_list = [os.path.join(current_path, strat_pkg, \"config\", name_) for name_ in config_name_list]\n","cfg_file_list = [open(cfg_path) for cfg_path in cfg_path_list]\n","config_arr = np.array([EasyDict(json.load(cfg_)) for cfg_ in cfg_file_list])\n","\n","# ------ opened files should be closed --> 닫지 않으면 reopen 시 error occurs ------ #\n","_ = [cfg_.close() for cfg_ in cfg_file_list]\n","show_plot = 1   # idep's var - do not touch"]},{"cell_type":"markdown","metadata":{"id":"leSQlImg4_9L"},"source":["### utils_"]},{"cell_type":"code","source":["np.nan - np.nan"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"4soJ3shNFs0n","executionInfo":{"status":"ok","timestamp":1654268552112,"user_tz":-540,"elapsed":313,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"98b7d81b-5f3d-4360-9b29-7db564227cab"},"execution_count":33,"outputs":[{"output_type":"execute_result","data":{"text/plain":["nan"]},"metadata":{},"execution_count":33}]},{"cell_type":"code","execution_count":5,"metadata":{"id":"CB2yZdQ95Cdg","executionInfo":{"status":"ok","timestamp":1654265146006,"user_tz":-540,"elapsed":990,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# import pandas as pd\n","# import numpy as np\n","# import logging\n","\n","def enlist_tr(res_df, config, np_timeidx, mode='OPEN', show_detail=True):\n","\n","    # ================== enlist wave_unit ================== #\n","    selection_id = config.selection_id\n","    \n","    len_df = len(res_df)\n","    len_df_range = np.arange(len_df)\n","      \n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period2 = config.tr_set.wave_period2\n","\n","    roll_hl_cnt = 3\n","\n","    roll_highs1 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows1 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv1, wave_period1, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill1_ = res_df['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_fill1_ = res_df['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    roll_highs2 = [res_df['wave_high_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","    roll_lows2 = [res_df['wave_low_fill_{}{}_-{}'.format(wave_itv2, wave_period2, cnt_ + 1)].to_numpy() for cnt_ in reversed(range(roll_hl_cnt))]\n","\n","    wave_high_fill2_ = res_df['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_fill2_ = res_df['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    \n","    # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    res_df['short_tp_1_{}'.format(selection_id)] = wave_low_fill1_      # wave_low_fill_ b2_low_5T\n","    res_df['short_tp_0_{}'.format(selection_id)] = roll_highs1[-1]   # roll_high_[:, -2] wave_high_fill_\n","    res_df['long_tp_1_{}'.format(selection_id)] = wave_high_fill1_      # wave_high_fill_ b2_high_5T\n","    res_df['long_tp_0_{}'.format(selection_id)] = roll_lows1[-1]     # roll_low_[:, -2]  wave_low_fill_\n","\n","    res_df['short_ep1_1_{}'.format(selection_id)] = wave_low_fill1_   # b2_low_5T\n","    res_df['short_ep1_0_{}'.format(selection_id)] = wave_high_fill1_  # roll_high_[:, -2]\n","    res_df['long_ep1_1_{}'.format(selection_id)] = wave_high_fill1_   # b2_high_5T\n","    res_df['long_ep1_0_{}'.format(selection_id)] = wave_low_fill1_    # roll_low_[:, -2]\n","\n","    res_df['short_out_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_out_0_{}'.format(selection_id)] = roll_highs2[-1]  # roll_high_[:, -2]\n","    res_df['long_out_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_out_0_{}'.format(selection_id)] = roll_lows2[-1]    # roll_low_[:, -2]\n","\n","    res_df['short_ep2_1_{}'.format(selection_id)] = wave_low_fill2_   # b2_low_5T\n","    res_df['short_ep2_0_{}'.format(selection_id)] = wave_high_fill2_  # roll_high_[:, -2]\n","    res_df['long_ep2_1_{}'.format(selection_id)] = wave_high_fill2_   # b2_high_5T\n","    res_df['long_ep2_0_{}'.format(selection_id)] = wave_low_fill2_    # roll_low_[:, -2]\n","\n","\n","    # ------ inversion ------ #\n","    if config.pos_set.short_inversion or config.pos_set.long_inversion:\n","        res_df.rename({short_tp_1_: long_tp_1_, long_tp_1_: short_tp_1_}, axis=1, inplace=True)\n","        res_df.rename({short_tp_0_: long_tp_0_, long_tp_0_: short_tp_0_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_1_: long_epout_1_, long_epout_1_: short_epout_1_}, axis=1, inplace=True)\n","        res_df.rename({short_epout_0_: long_epout_0_, long_epout_0_: short_epout_0_}, axis=1, inplace=True)\n","\n","    res_df['short_tp_gap_{}'.format(selection_id)] = abs(res_df['short_tp_1_{}'.format(selection_id)] - res_df['short_tp_0_{}'.format(selection_id)])\n","    res_df['long_tp_gap_{}'.format(selection_id)] = abs(res_df['long_tp_1_{}'.format(selection_id)] - res_df['long_tp_0_{}'.format(selection_id)])\n","    res_df['short_ep1_gap_{}'.format(selection_id)] = abs(res_df['short_ep1_1_{}'.format(selection_id)] - res_df['short_ep1_0_{}'.format(selection_id)])\n","    res_df['long_ep1_gap_{}'.format(selection_id)] = abs(res_df['long_ep1_1_{}'.format(selection_id)] - res_df['long_ep1_0_{}'.format(selection_id)])\n","\n","    res_df['short_out_gap_{}'.format(selection_id)] = abs(res_df['short_out_1_{}'.format(selection_id)] - res_df['short_out_0_{}'.format(selection_id)])\n","    res_df['long_out_gap_{}'.format(selection_id)] = abs(res_df['long_out_1_{}'.format(selection_id)] - res_df['long_out_0_{}'.format(selection_id)])\n","    res_df['short_ep2_gap_{}'.format(selection_id)] = abs(res_df['short_ep2_1_{}'.format(selection_id)] - res_df['short_ep2_0_{}'.format(selection_id)])\n","    res_df['long_ep2_gap_{}'.format(selection_id)] = abs(res_df['long_ep2_1_{}'.format(selection_id)] - res_df['long_ep2_0_{}'.format(selection_id)])\n","\n","\n","    data_cols = ['open', 'high', 'low', 'close']  # Todo - public_indi 이전에 해야할지도 모름 # 'close', 'haopen', 'hahigh', 'halow', 'haclose'\n","    open, high, low, close = [res_df[col_].to_numpy() for col_ in data_cols]\n","\n","    # ================== point ================== #     \n","    short_open_res1 = np.ones(len_df) #.astype(object)\n","    long_open_res1 = np.ones(len_df)  #.astype(object)\n","    short_open_res2 = np.ones(len_df) #.astype(object)\n","    long_open_res2 = np.ones(len_df)  #.astype(object)\n","    \n","    # ------------ wave_point ------------ #\n","    notnan_cu = ~pd.isnull(res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy())  # isnull for object\n","    notnan_co = ~pd.isnull(res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= res_df['wave_cu_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_cu  # object로 변환되는 경우에 대응해, bool 로 재정의\n","    long_open_res1 *= res_df['wave_co_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool) * notnan_co  # np.nan = bool type 으로 True 임..\n","    short_open_res2 *= res_df['wave_cu_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_cu\n","    long_open_res2 *= res_df['wave_co_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool) * notnan_co\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_point\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","    \n","    # ------ reject update_hl ------ #\n","    notnan_update_low_cu = ~pd.isnull(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","    notnan_update_high_co = ~pd.isnull(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy())\n","\n","    short_open_res1 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res1 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy().astype(bool)) * notnan_update_high_co\n","    short_open_res2 *= ~(res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_low_cu\n","    long_open_res2 *= ~(res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy().astype(bool)) * notnan_update_high_co\n","\n","    # short_open_res1 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # long_open_res1 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # short_open_res2 *= ~res_df['wave_update_low_cu_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    # long_open_res2 *= ~res_df['wave_update_high_co_bool_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    if show_detail:\n","      sys_log.warning(\"reject update_hl\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))  \n","\n","    # ------ tf_entry ------ #    \n","    tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    if wave_itv1 != 'T':      \n","      short_open_res1 *= np_timeidx % tf_entry == (tf_entry - 1)\n","      long_open_res1 *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"tf_entry\")\n","        sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))  \n","    \n","    if wave_itv2 != 'T':      \n","      short_open_res2 *= np_timeidx % tf_entry == (tf_entry - 1)\n","      long_open_res2 *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","      if show_detail:\n","        sys_log.warning(\"tf_entry\")\n","        sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","        sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","    # ------ wave_point 분리 ------ #\n","    # cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    # b1_cci_ = res_df['cci_{}{}'.format(wave_itv1, wave_period1)].shift(1).to_numpy()        \n","    \n","    # band_width = 100\n","    # upper_band = band_width\n","    # lower_band = -band_width\n","\n","    # update_low_cu_bool = res_df['update_low_cu_bool_{}{}'.format(wave_itv1, wave_period1)]\n","    # update_high_co_bool = res_df['update_high_co_bool_{}{}'.format(wave_itv1, wave_period1)]\n","\n","    # short_open_res1 *= (b1_cci_ > upper_band) & (upper_band > cci_) & ~update_low_cu_bool\n","    # long_open_res1 *= (b1_cci_ < lower_band) & (lower_band < cci_) & ~update_high_co_bool   \n","\n","    # ------ wave_mm ------ #\n","    wave_high_terms_cnt_fill1_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_low_terms_cnt_fill1_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    short_open_res1 *= (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","    long_open_res1 *= (wave_low_terms_cnt_fill1_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill1_ > config.tr_set.wave_greater1)\n","\n","    wave_high_terms_cnt_fill2_ = res_df['wave_high_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","    wave_low_terms_cnt_fill2_ = res_df['wave_low_terms_cnt_fill_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","\n","    short_open_res2 *= (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","    long_open_res2 *= (wave_low_terms_cnt_fill2_ > config.tr_set.wave_greater2) & (wave_high_terms_cnt_fill2_ > config.tr_set.wave_greater1)\n","\n","    if show_detail:\n","      sys_log.warning(\"wave_mm\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","\n","\n","    # ============ csd ============ #\n","    # ------ dc ------ #\n","    dc_upper_T20 = res_df['dc_upper_T20'].to_numpy()    \n","    dc_lower_T20 = res_df['dc_lower_T20'].to_numpy()    \n","\n","    # Todo, co_idx 가 필요함\n","    short_open_idx1 = get_index_bybool(short_open_res1, len_df_range)\n","    long_open_idx1 = get_index_bybool(long_open_res1, len_df_range)\n","    wave_low_prime_idx_ = res_df['wave_low_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    wave_high_prime_idx_ = res_df['wave_high_prime_idx_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    # np.nan - np.nan = np.nan -> vectorize 가능할 것 => xx\n","    # 1. \n","    long_open_idx1\n","\n","\n","    # ================== pattern depiction ================== #  \n","    # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","    # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","    # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","    \n","    # ------ 양 / 음봉 (long) ------ #\n","    # short_open_res1 *= close < open\n","    # long_open_res1 *= close > open\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"close > open\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    \n","    # # ------ even_break, hhhl (long) ------ #        \n","    # # cu's roll_high_[:, -1] = prev_high & cu's roll_low_[:, -1] = current_low\n","    # # co's roll_low_[:, -1] = prev_low & co's roll_high_[:, -1] = current_high\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_[:, -1]) # & (roll_high_[:, -2] > roll_high_[:, -1])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_[:, -1]) # & (roll_low_[:, -2] < roll_low_[:, -1])\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"even_break\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # # ------ roll_high < bb_upper2 (long) ------ #\n","    # short_open_res1 *= (roll_low_[:, -4] > roll_low_bb_lower2_[:, -4])\n","    # short_open_res1 *= (roll_low_[:, -3] > roll_low_bb_lower2_[:, -3])\n","    # short_open_res1 *= (roll_low_[:, -2] > roll_low_bb_lower2_[:, -2])\n","    # short_open_res1 *= (roll_low_[:, -1] > roll_low_bb_lower2_[:, -1])\n","\n","    # long_open_res1 *= (roll_high_[:, -4] < roll_high_bb_upper2_[:, -4])\n","    # long_open_res1 *= (roll_high_[:, -3] < roll_high_bb_upper2_[:, -3])\n","    # long_open_res1 *= (roll_high_[:, -2] < roll_high_bb_upper2_[:, -2])\n","    # long_open_res1 *= (roll_high_[:, -1] < roll_high_bb_upper2_[:, -1])\n","    \n","    # if show_detail:\n","    #   sys_log.warning(\"roll_high < bb_upper2\")\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","\n","    # ------ base_15T < wave_base ------ #\n","    # dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","    # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","    # short_open_res1 *= (dc_base_ > wave_base_) & (dc_base_ > close)\n","    # long_open_res1 *= (dc_base_ < wave_base_) & (dc_base_ < close)\n","\n","    # if show_detail:\n","    #   sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","    #   sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))     \n","        \n","\n","    # ================== tr_set ================== #\n","    # ------------ tp ------------ #\n","    tpg = config.tr_set.tp_gap\n","    res_df['short_tp_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    res_df['long_tp_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * tpg\n","    # res_df['short_tp_{}'.format(selection_id)] = short_tp_1 - short_epout_gap * tpg\n","    # res_df['long_tp_{}'.format(selection_id)] = long_tp_1 + long_epout_gap * tpg\n","\n","    # ------ limit_ep ------ #\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        epg1 = config.tr_set.ep_gap1\n","        epg2 = config.tr_set.ep_gap2\n","\n","        # res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1\n","        # res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep1_gap_{}'.format(selection_id)].to_numpy() * epg1        \n","        # res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        # res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * epg2  \n","\n","        # p1_hlm 을 위해선, tp_0 를 기준할 수 없음 --> ep1 & ep2 를 기준으로 진행\n","        res_df['short_ep1_{}'.format(selection_id)] = res_df['short_ep1_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * epg1  # fibonacci 고려하면, tp / out gap 기준이 맞지 않을까\n","        res_df['long_ep1_{}'.format(selection_id)] = res_df['long_ep1_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * epg1      \n","        res_df['short_ep2_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","        res_df['long_ep2_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * epg2\n","                \n","    # ------ market_ep ------ #\n","    else:\n","        res_df['short_ep1_{}'.format(selection_id)] = close\n","        res_df['long_ep1_{}'.format(selection_id)] = close\n","        res_df['short_ep2_{}'.format(selection_id)] = close\n","        res_df['long_ep2_{}'.format(selection_id)] = close\n","\n","    # ------------ out ------------ #\n","    outg = config.tr_set.out_gap\n","    # res_df['short_out_{}'.format(selection_id)] = short_tp_0 + short_tp_gap * outg            # 1. for hhm check -> 규칙성과 wave_range 기반 거래 기준의 hhm 확인\n","    # res_df['long_out_{}'.format(selection_id)] = long_tp_0 - long_tp_gap * outg\n","\n","    if config.tr_set.check_hlm in [0, 2]:      # for p1_hhm, p2_hlm\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_out_0_{}'.format(selection_id)].to_numpy() + res_df['short_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_out_0_{}'.format(selection_id)].to_numpy() - res_df['long_out_gap_{}'.format(selection_id)].to_numpy() * outg\n","    else:    # for p1 hlm\n","      res_df['short_out_{}'.format(selection_id)] = res_df['short_ep2_0_{}'.format(selection_id)].to_numpy() + res_df['short_ep2_gap_{}'.format(selection_id)].to_numpy() * outg\n","      res_df['long_out_{}'.format(selection_id)] = res_df['long_ep2_0_{}'.format(selection_id)].to_numpy() - res_df['long_ep2_gap_{}'.format(selection_id)].to_numpy() * outg \n","\n","    # ------------ point validation ------------ # - vecto. 로 미리 거를 수 있는걸 거르면 좋을 것\n","    short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()\n","    short_ep1_ = res_df['short_ep1_{}'.format(selection_id)].to_numpy()\n","    short_ep2_ = res_df['short_ep2_{}'.format(selection_id)].to_numpy()\n","    short_out_ = res_df['short_out_{}'.format(selection_id)].to_numpy()\n","\n","    long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()\n","    long_ep1_ = res_df['long_ep1_{}'.format(selection_id)].to_numpy()\n","    long_ep2_ = res_df['long_ep2_{}'.format(selection_id)].to_numpy()\n","    long_out_ = res_df['long_out_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res1 *= (short_tp_ < short_ep1_) # (short_ep_ < short_out_)  # tr_set validation reject nan data & 정상 거래 위한 tp > ep / --> p2_box location (cannot be vectorized)\n","    # short_open_res1 *= close < short_ep1_   # reject entry open_execution\n","    short_open_res1 *= close < res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()   # reject hl_out open_execution -> close always < ep1_0 at wave_p1\n","    # short_out_  res_df['short_tp_0_{}'.format(selection_id)].to_numpy() res_df['short_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    long_open_res1 *= (long_tp_ > long_ep1_) # (long_ep_ > long_out_)  # (long_tp_ > long_ep_) # tr_set validation     \n","    # long_open_res1 *= close > long_ep1_  # reject entry open_execution    \n","    long_open_res1 *= close > res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()  # reject hl_out open_execution   \n","    # long_out_ res_df['long_tp_0_{}'.format(selection_id)].to_numpy() res_df['long_ep1_0_{}'.format(selection_id)].to_numpy()\n","\n","    short_open_res2 *= (short_ep2_ < short_out_) # tr_set validation (short_tp_ < short_ep_) # --> p2_box location (cannot be vectorized)\n","    short_open_res2 *= close < short_out_    # reject hl_out open_execution\n","\n","    long_open_res2 *= (long_ep2_ > long_out_)  # tr_set validation (long_tp_ > long_ep_) &   # p2's ep & out can be vectorized\n","    long_open_res2 *= close > long_out_    # reject hl_out open_execution\n","\n","    res_df['short_open1_{}'.format(selection_id)] = short_open_res1 * (not config.pos_set.short_ban)\n","    res_df['long_open1_{}'.format(selection_id)] = long_open_res1 * (not config.pos_set.long_ban) \n","    res_df['short_open2_{}'.format(selection_id)] = short_open_res2\n","    res_df['long_open2_{}'.format(selection_id)] = long_open_res2\n","\n","    if show_detail:\n","      sys_log.warning(\"point validation\")\n","      sys_log.warning(\"np.sum(short_open_res1 == 1) : {}\".format(np.sum(short_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res1 == 1) : {}\".format(np.sum(long_open_res1 == 1)))\n","      sys_log.warning(\"np.sum(short_open_res2 == 1) : {}\".format(np.sum(short_open_res2 == 1)))\n","      sys_log.warning(\"np.sum(long_open_res2 == 1) : {}\".format(np.sum(long_open_res2 == 1)))\n","    \n","    # ------------ higher_high momentum ------------ #\n","    # wb_tpg = config.tr_set.wb_tp_gap\n","    # wb_outg = config.tr_set.wb_out_gap\n","    # res_df['short_wave_1_{}'.format(selection_id)] = res_df['short_tp_1_{}'.format(selection_id)].to_numpy() - res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    # res_df['long_wave_1_{}'.format(selection_id)] = res_df['long_tp_1_{}'.format(selection_id)].to_numpy() + res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_tpg\n","    \n","    # res_df['short_wave_0_{}'.format(selection_id)] = res_df['short_tp_0_{}'.format(selection_id)].to_numpy() + res_df['short_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg        # hhm check\n","    # res_df['long_wave_0_{}'.format(selection_id)] = res_df['long_tp_0_{}'.format(selection_id)].to_numpy() - res_df['long_tp_gap_{}'.format(selection_id)].to_numpy() * wb_outg\n","    # res_df['short_wave_0_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * wb_outg\n","    # res_df['long_wave_0_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * wb_outg\n","\n","    # ------ tr ------ #\n","    if not config.tr_set.check_hlm:\n","      res_df['short_tr_{}'.format(selection_id)] = abs(\n","          (short_ep1_ / short_tp_ - config.trader_set.limit_fee - 1) / (short_ep1_ / short_out_ - config.trader_set.market_fee - 1))\n","      res_df['long_tr_{}'.format(selection_id)] = abs(\n","          (long_tp_ / long_ep1_ - config.trader_set.limit_fee - 1) / (long_out_ / long_ep1_ - config.trader_set.market_fee - 1))\n","    else:      \n","      res_df['short_tr_{}'.format(selection_id)] = np.nan\n","      res_df['long_tr_{}'.format(selection_id)] = np.nan\n","\n","    # ------ zoned_ep ------ #\n","    # if config.tr_set.c_ep_gap != \"None\":\n","    #     # res_df['short_ep_org_{}'.format(selection_id)] = res_df['short_ep_{}'.format(selection_id)].copy()\n","    #     # res_df['long_ep_org_{}'.format(selection_id)] = res_df['long_ep_{}'.format(selection_id)].copy()\n","    #     res_df['short_ep2_{}'.format(selection_id)] = short_epout_1 + short_epout_gap * config.tr_set.c_ep_gap\n","    #     res_df['long_ep2_{}'.format(selection_id)] = long_epout_1 - long_epout_gap * config.tr_set.c_ep_gap\n","\n","    # # ------ zoned_out ------ #\n","    # if config.tr_set.t_out_gap != \"None\":\n","    #     # res_df['short_out_org_{}'.format(selection_id)] = res_df['short_out_{}'.format(selection_id)].copy()\n","    #     # res_df['long_out_org_{}'.format(selection_id)] = res_df['long_out_{}'.format(selection_id)].copy()\n","    #     res_df['short_out2_{}'.format(selection_id)] = short_epout_0 + short_epout_gap * config.tr_set.t_out_gap\n","    #     res_df['long_out2_{}'.format(selection_id)] = long_epout_0 - long_epout_gap * config.tr_set.t_out_gap\n","\n","    return res_df\n"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"HuCb0phoPN83"}},{"cell_type":"code","source":["\n","    # ------ get candle_lastidx ------ #        \n","    # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","    # b1_shift = np_timeidx % tf_entry + 1  # dynamic\n","    # b1_candle_lastidx = (len_df_range - b1_shift).astype(float)\n","    # b2_candle_lastidx = (len_df_range - (b1_shift + tf_entry)).astype(float)\n","    # b3_candle_lastidx = (len_df_range - (b1_shift + 2 * tf_entry)).astype(float)\n","    # b1_candle_lastidx[b1_candle_lastidx < 0] = np.nan\n","    # b2_candle_lastidx[b2_candle_lastidx < 0] = np.nan\n","    # b3_candle_lastidx[b3_candle_lastidx < 0] = np.nan\n","\n","    # high_5T = res_df['high_5T'].to_numpy()\n","    # low_5T = res_df['low_5T'].to_numpy()\n","\n","    # b2_high_5T = get_line(b2_candle_lastidx, high_5T)\n","    # b2_low_5T = get_line(b2_candle_lastidx, low_5T)\n","    \n","        # # ------ bb_stream ------ #        \n","        # roll_high_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_low_bb_upper_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_high_bb_upper2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","        # roll_low_bb_upper2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_upper2_, roll_hl_cnt)\n","\n","        # roll_high_bb_lower_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_low_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_high_bb_lower2_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","        # roll_low_bb_lower2_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower2_, roll_hl_cnt)\n","\n","        # wave_base_ = res_df['dc_base_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","\n","        # roll_high_wave_base_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","        # roll_low_wave_base_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, wave_base_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_high_bb_lower_[:, -2] > roll_high_wave_base_[:, -2]) & (roll_high_wave_base_[:, -2] > roll_high_bb_lower2_[:, -2])\n","        # short_open_res *= (roll_low_bb_lower_[:, -1] > roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] > roll_low_bb_lower2_[:, -1])\n","        # short_open_res *= (roll_high_bb_lower_[:, -1] > roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] > roll_high_bb_lower2_[:, -1])\n","\n","        # long_open_res *= (roll_low_bb_upper_[:, -2] < roll_low_wave_base_[:, -2]) & (roll_low_wave_base_[:, -2] < roll_low_bb_upper2_[:, -2])\n","        # long_open_res *= (roll_high_bb_upper_[:, -1] < roll_high_wave_base_[:, -1]) & (roll_high_wave_base_[:, -1] < roll_high_bb_upper2_[:, -1])\n","        # long_open_res *= (roll_low_bb_upper_[:, -1] < roll_low_wave_base_[:, -1]) & (roll_low_wave_base_[:, -1] < roll_low_bb_upper2_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"bb_stream\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ candle_pattern  ------ #   \n","        # b3_bb_upper_ = get_line(b3_candle_lastidx, bb_upper_)\n","        # b3_bb_lower_ = get_line(b3_candle_lastidx, bb_lower_)\n","        # b3_bb_upper2_ = get_line(b3_candle_lastidx, bb_upper2_)\n","        # b3_bb_lower2_ = get_line(b3_candle_lastidx, bb_lower2_)\n","        # b3_close = get_line(b3_candle_lastidx, close)\n","\n","        # b2_bb_upper2_ = get_line(b2_candle_lastidx, bb_upper2_)\n","        # b2_bb_lower2_ = get_line(b2_candle_lastidx, bb_lower2_)\n","        # b2_bb_upper3_ = get_line(b2_candle_lastidx, bb_upper3_)\n","        # b2_bb_lower3_ = get_line(b2_candle_lastidx, bb_lower3_)\n","        # b2_close = get_line(b2_candle_lastidx, close)\n","\n","        # b1_bb_upper_ = get_line(b1_candle_lastidx, bb_upper_)\n","        # b1_bb_lower_ = get_line(b1_candle_lastidx, bb_lower_)\n","        # b1_bb_upper2_ = get_line(b1_candle_lastidx, bb_upper2_)\n","        # b1_bb_lower2_ = get_line(b1_candle_lastidx, bb_lower2_)\n","        # b1_close = get_line(b1_candle_lastidx, close)\n","        # b1_high_5T = get_line(b1_candle_lastidx, high_5T)\n","        # b1_low_5T = get_line(b1_candle_lastidx, low_5T)\n","\n","        # short_open_res *= (b3_bb_lower_ > b3_close) & (b3_close > b3_bb_lower2_)\n","        # short_open_res *= (b2_bb_lower2_ > b2_close) & (b2_close > b2_bb_lower3_)\n","        # short_open_res *= (b1_bb_lower_ > b1_close) & (b1_close > b1_bb_lower2_)\n","\n","        # long_open_res *= (b3_bb_upper_ < b3_close) & (b3_close < b3_bb_upper2_)\n","        # long_open_res *= (b2_bb_upper2_ < b2_close) & (b2_close < b2_bb_upper3_)\n","        # long_open_res *= (b1_bb_upper_ < b1_close) & (b1_close < b1_bb_upper2_)\n","\n","        # # short_open_res *= (b2_low_5T < b1_low_5T) & (b2_close < b1_close)\n","        # # long_open_res *= (b2_high_5T > b1_high_5T) & (b2_close > b1_close)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_pattern\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","\n","        # ------ low_confirm ------ #\n","        # short_open_res *= b1_high_5T > wave_high_fill_\n","        # long_open_res *= b1_low_5T < wave_low_fill_\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"low_confirm\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","        \n","        # ------ candle_ratio ------ #\n","        # b2_candle_range_5T = b2_high_5T - b2_low_5T\n","        # b1_candle_range_5T = b1_high_5T - b1_low_5T\n","        \n","        # short_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","        # long_open_res *= b1_candle_range_5T / b2_candle_range_5T < config.loc_set.point.crr\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"candle_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ wick_ratio ------ #\n","        # upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","        # b2_upper_wick_ratio_ = get_line(b2_candle_lastidx, upper_wick_ratio_)\n","        # b2_lower_wick_ratio_ = get_line(b2_candle_lastidx, lower_wick_ratio_)\n","\n","        # short_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.short_wick_ratio\n","        # long_open_res *= b2_upper_wick_ratio_ < config.loc_set.point.long_wick_ratio\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"wick_ratio\")\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1))) \n","\n","        # ------ large wave1_range ------ #          \n","        # roll_bb_upper_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper_, roll_hl_cnt)\n","        # roll_bb_lower_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower_, roll_hl_cnt)\n","        # roll_bb_upper3_ = get_roll_wave_data(valid_high_prime_idx, roll_high_idx_arr, len_df, bb_upper3_, roll_hl_cnt)\n","        # roll_bb_lower3_ = get_roll_wave_data(valid_low_prime_idx, roll_low_idx_arr, len_df, bb_lower3_, roll_hl_cnt)\n","\n","        # short_open_res *= (roll_bb_upper_[:, -2] < roll_high_[:, -2]) & (roll_low_[:, -1] < roll_bb_lower_[:, -1]) & (roll_low_[:, -1] > roll_bb_lower3_[:, -1])\n","        # long_open_res *= (roll_bb_upper_[:, -1] < roll_high_[:, -1]) & (roll_low_[:, -2] < roll_bb_lower_[:, -2]) & (roll_high_[:, -1] < roll_bb_upper3_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ low in bb_level3 ------ #  Todo, idx sync 맞춰야할 것\n","        # short_open_res *= (bb_upper2_ < wave_high_fill_) & (wave_high_fill_ < bb_upper3_)\n","        # long_open_res *= (bb_lower3_ < wave_low_fill_) & (wave_low_fill_ < bb_lower2_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ first_high ------ #        \n","        # wave_high_prime_idx_fill_= res_df['wave_high_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # wave_low_prime_idx_fill_= res_df['wave_low_prime_idx_fill_{}{}'.format(itv, period1)].to_numpy()\n","        # cu_prime_wave_base = get_line(cu_prime_idx_fill_, wave_base_)\n","        # co_prime_wave_base = get_line(co_prime_idx_fill_, wave_base_)\n","\n","        # # short_open_res *= (co_roll_high_[:, -1] > dc_base_) & (dc_base_ > co_roll_low_[:, -1])\n","        # # long_open_res *= (cu_roll_low_[:, -1] < dc_base_) & (dc_base_ < cu_roll_high_[:, -1])\n","\n","        # short_open_res *= (cu_prime_wave_base > dc_base_) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < dc_base_) & (dc_base_ < cu_prime_wave_base)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # cu_prime_dc_base = get_line(cu_prime_idx_fill_, dc_base_)        \n","        # co_prime_dc_base = get_line(co_prime_idx_fill_, dc_base_)\n","        \n","        # shift_size = to_itvnum(p1_itv1)\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(shift_size).to_numpy()\n","\n","        # short_open_res *= (b1_dc_base_ < dc_base_)\n","        # long_open_res *= (b1_dc_base_ > dc_base_)\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ b1_base_15T < wave_high ------ #\n","        # short_open_res *= (b1_dc_base_ > co_roll_low_[:, -1])\n","        # long_open_res *= (b1_dc_base_ < cu_roll_high_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))   \n","        \n","        \n","    # b1_itv_num = to_itvnum(config.tr_set.p2_itv0)\n","    # b2_itv_num = to_itvnum(config.tr_set.p2_itv0) * 2  # multi 2 for imb_v2\n","\n","    # res_df[short_tp_1_] = res_df['dc_lower_{}{}'.format(itv, period1)]\n","    # res_df[short_tp_0_] = res_df['dc_upper_{}{}'.format(itv, period2)]\n","    # # res_df[short_tp_0_] = res_df['dc_upper_15T4']\n","    # res_df[long_tp_1_] = res_df['dc_upper_{}{}'.format(itv, period1)]\n","    # res_df[long_tp_0_] = res_df['dc_lower_{}{}'.format(itv, period2)]\n","    # # res_df[long_tp_0_] = res_df['dc_lower_15T4']\n","    \n","        # ------ base_cc ------ #\n","        dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].to_numpy()\n","\n","        # close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # b1_dc_base_ = res_df['dc_base_{}{}'.format(p1_itv1, p1_period1)].shift(tf_entry).to_numpy()\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","\n","        # short_open_res *= ((b1_close_ > dc_base_) & (dc_base_ > close_)) | ((b1_close_ > b1_dc_base_) & (dc_base_ > close_))\n","        # long_open_res *= ((b1_close_ < dc_base_) & (dc_base_ < close_)) | ((b1_close_ < b1_dc_base_) & (dc_base_ < close_))\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","        \n","        # ------ tf_entry ------ #\n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        \n","        # short_open_res *= np_timeidx % tf_entry == (tf_entry - 1)\n","        # long_open_res *= np_timeidx % tf_entry == (tf_entry - 1) \n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","    \n","        # ------ cppr 로 양음봉 check ------ # \n","        # tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","\n","        # res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)] = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry)\n","        # b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","        # cppr_ = res_df['cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= (b1_cppr_ > 0) & (cppr_ < 0)\n","        # long_open_res *= (b1_cppr_ < 0) & (cppr_ > 0)\n","\n","        # res_df['b1_updbr'] = res_df['dc_upper_15T4_br'].shift(tf_entry).to_numpy()\n","        # res_df['b1_lwdbr'] = res_df['dc_lower_15T4_br'].shift(tf_entry).to_numpy()\n","        \n","        # res_df['b1_updbr_cppr'] = b1_cppr_ * res_df['b1_updbr'].to_numpy()\n","        # res_df['b1_lwdbr_cppr'] = b1_cppr_ * res_df['b1_lwdbr'].to_numpy()\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ dc_cross ------ #\n","        # b1_dc_upper_15T4 = res_df['dc_upper_15T4'].shift(tf_entry).to_numpy()\n","        # b1_dc_lower_15T4 = res_df['dc_lower_15T4'].shift(tf_entry).to_numpy()\n","        # b1_high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # b1_low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_high_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_low_ < b1_dc_lower_15T4\n","        \n","        # ------ dc_cc ------ #\n","        # b1_close_ = res_df['close_{}'.format(config.loc_set.point.tf_entry)].shift(tf_entry).to_numpy()\n","        # short_open_res *= b1_close_ > b1_dc_upper_15T4\n","        # long_open_res *= b1_close_ < b1_dc_lower_15T4\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ empty_space ------ #       \n","        # dc_upper_15T4 = res_df['dc_upper_15T4'].to_numpy()\n","        # dc_lower_15T4 = res_df['dc_lower_15T4'].to_numpy() \n","        # high_ = res_df['high_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # low_ = res_df['low_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","        # short_open_res *= high_ < dc_upper_15T4\n","        # long_open_res *= low_ > dc_lower_15T4\n","        \n","        # ------ candle_pattern ------ #  \n","        # pattern_column = \"{}_{}\".format(config.loc_set.point.candle_pattern, config.loc_set.point.tf_entry)\n","        # short_open_res *= res_df[pattern_column].to_numpy() < 0\n","        # long_open_res *= res_df[pattern_column].to_numpy() > 0\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","\n","        # ------ lower_touch > upper_touch (long) ------ #\n","        # short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['short_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","        # long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > res_df['long_upper_touch_idx_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy()\n","\n","        # ------ base_3T cross ------ #\n","        # dc_base_3T = res_df['dc_base_3T'].to_numpy()\n","        # b1_close = res_df['close'].shift(1).to_numpy()\n","        # short_open_res *= (b1_close > dc_base_3T) & (dc_base_3T > close)\n","        # long_open_res *= (b1_close < dc_base_3T) & (dc_base_3T < close)\n","\n","        # ------ wave_low < base_5T (long) ------ #\n","        # dc_base_5T = res_df['dc_base_5T'].to_numpy()        \n","        # short_open_res *= res_df['short_upper_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() > dc_base_5T\n","        # long_open_res *= res_df['long_lower_touch_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy() < dc_base_5T      \n","\n","        # ------ ppr ------ #\n","        # pumping_ratio(res_df, config, p1_itv1, p1_period1, p1_period2)  "],"metadata":{"id":"-DNPumVZi0xs"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"aTV4h3LjTZBp"}},{"cell_type":"code","source":["\n","    \n","    short_tp_1_, long_tp_1_ = 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id)\n","    short_tp_0_, long_tp_0_ = 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)\n","    short_tp_gap_, long_tp_gap_ = 'short_tp_gap_{}'.format(selection_id), 'long_tp_gap_{}'.format(selection_id)\n","\n","    short_ep_1_, long_ep_1_ = 'short_ep_1_{}'.format(selection_id), 'long_ep_1_{}'.format(selection_id)\n","    short_ep_0_, long_ep_0_ = 'short_ep_0_{}'.format(selection_id), 'long_ep_0_{}'.format(selection_id)\n","    short_ep_gap_, long_ep_gap_ = 'short_ep_gap_{}'.format(selection_id), 'long_ep_gap_{}'.format(selection_id)\n","\n","    short_epout_1_, long_epout_1_ = 'short_epout_1_{}'.format(selection_id), 'long_epout_1_{}'.format(selection_id)\n","    short_epout_0_, long_epout_0_ = 'short_epout_0_{}'.format(selection_id), 'long_epout_0_{}'.format(selection_id)\n","    short_epout_gap_, long_epout_gap_ = 'short_epout_gap_{}'.format(selection_id), 'long_epout_gap_{}'.format(selection_id)\n","    \n","    # ================== convert unit -> numpy ================== #   \n","    # tp_cols = [short_tp_1_, short_tp_0_, short_tp_gap_, long_tp_1_, long_tp_0_, long_tp_gap_]\n","    # epout_cols = [short_epout_1_, short_epout_0_, short_epout_gap_, long_epout_1_, long_epout_0_, long_epout_gap_]\n","\n","    # short_tp_1, short_tp_0, short_tp_gap, long_tp_1, long_tp_0, long_tp_gap = [res_df[col_].to_numpy() for col_ in tp_cols]\n","    # short_epout_1, short_epout_0, short_epout_gap, long_epout_1, long_epout_0, long_epout_gap = [res_df[col_].to_numpy() for col_ in epout_cols]\n","\n","    if p2_itv1 != \"None\":  # vectorized point2\n","        short_point1_on2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                    min_periods=1).max().to_numpy()  # period 내의 max_point1_idx\n","        long_point1_on2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)], len_df_range, np.nan)).rolling(point1_to2_period,\n","                                                                                                                                   min_periods=1).max().to_numpy()\n","\n","        short_point2_idx = pd.Series(\n","            np.where(res_df['short_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","        long_point2_idx = pd.Series(\n","            np.where(res_df['long_wave_point_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)], len_df_range, np.nan)).to_numpy()\n","\n","        res_df['short_point_idxgap_{}'.format(selection_id)] = short_point2_idx - short_point1_on2_idx\n","        res_df['long_point_idxgap_{}'.format(selection_id)] = long_point2_idx - long_point1_on2_idx\n","\n","        # ------ p1 & p2 ------ #\n","        short_open_res *= ~np.isnan(res_df['short_point_idxgap_{}'.format(selection_id)].to_numpy())\n","        long_open_res *= ~np.isnan(res_df['long_point_idxgap_{}'.format(selection_id)].to_numpy())\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ p2 amax > p1_idx (long) ------ #\n","        short_open_res *= res_df['short_upper_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > short_point1_on2_idx\n","        long_open_res *= res_df['long_lower_touch_idx_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy() > long_point1_on2_idx\n","\n","        if show_detail:\n","          sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","          sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ #\n","        # short_a_line1_on2_ = get_line(short_point1_on2_idx, res_df['short_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","        # long_a_line1_on2_ = get_line(long_point1_on2_idx, res_df['long_a_line_{}{}{}'.format(p1_itv1, p1_period1, p1_period2)].to_numpy())\n","\n","        # short_a_line2_ = res_df['short_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","        # long_a_line2_ = res_df['long_a_line_{}{}{}'.format(p2_itv1, p2_period1, p2_period2)].to_numpy()\n","\n","        # short_open_res *= short_a_line1_on2_ >= short_a_line2_\n","        # long_open_res *= long_a_line1_on2_ <= long_a_line2_\n","\n","        # print(np.sum(long_open_res == 1))\n","\n","        # ------ higher high (long) ------ #\n","        # short_open_res *= co_roll_low_[:, -2] > co_roll_low_[:, -1]\n","        # long_open_res *= cu_roll_high_[:, -2] < cu_roll_high_[:, -1]\n","\n","        # short_open_res *= co_roll_low_[:, -3] > co_roll_low_[:, -2]\n","        # long_open_res *= cu_roll_high_[:, -3] < cu_roll_high_[:, -2]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))\n","\n","        # ------ higher low (long) ------ # \n","        # short_open_res *= co_roll_high_[:, -2] > co_roll_high_[:, -1]\n","        # long_open_res *= cu_roll_low_[:, -2] < cu_roll_low_[:, -1]\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # ------ tf2_base < wave_low ------ #\n","        # short_open_res *= (dc_base_ > co_roll_high_[:, -1])\n","        # long_open_res *= (dc_base_ < cu_roll_low_[:, -1])\n","\n","        # if show_detail:\n","        #   sys_log.warning(\"np.sum(short_open_res == 1) : {}\".format(np.sum(short_open_res == 1)))\n","        #   sys_log.warning(\"np.sum(long_open_res == 1) : {}\".format(np.sum(long_open_res == 1)))  \n","\n","        # short_open_res *= (cu_prime_wave_base > cu_prime_dc_base) & (dc_base_ > co_prime_wave_base)\n","        # long_open_res *= (co_prime_wave_base < co_prime_dc_base) & (dc_base_ < cu_prime_wave_base)\n","\n","        short_open_res *= (co_prime_dc_base < co_roll_low_[:, -2])\n","        long_open_res *= (cu_prime_dc_base > cu_roll_high_[:, -2])  #  b1_cu_prime_idx’s tf2_base > b1_high -> b1 이 아님 (error)\n","\n","\n","        res_df[short_epout_1_] = res_df['short_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        res_df[short_epout_0_] = res_df['short_new_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_1_] = res_df['long_wave_high_{}{}{}'.format(itv, period1, period2)]\n","        res_df[long_epout_0_] = res_df['long_new_wave_low_{}{}{}'.format(itv, period1, period2)]\n","        \n","# ------ get candle_lastidx ------ #        \n","        tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","        b1_candle_shift = np_timeidx % tf_entry + 1\n","        b2_candle_shift = b1_candle_shift + tf_entry\n","        b3_candle_shift = b1_candle_shift + 2 * tf_entry\n","\n","        print(b3_candle_shift)\n","\n","        # bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].to_numpy()\n","        # bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].to_numpy()\n","        # bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].to_numpy()\n","\n","        # ------ compare by back_idx  ------ #   \n","        b3_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b3_candle_shift).to_numpy()\n","        b3_close = res_df['close'].shift(b3_candle_shift).to_numpy()\n","\n","        b2_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_upper3_ = res_df['bb_upper3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_bb_lower3_ = res_df['bb_lower3_{}{}'.format('T', 60)].shift(b2_candle_shift).to_numpy()\n","        b2_close = res_df['close'].shift(b2_candle_shift).to_numpy()\n","\n","        b1_bb_upper_ = res_df['bb_upper_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower_ = res_df['bb_lower_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_upper2_ = res_df['bb_upper2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_bb_lower2_ = res_df['bb_lower2_{}{}'.format('T', 60)].shift(b1_candle_shift).to_numpy()\n","        b1_close = res_df['close'].shift(b1_candle_shift).to_numpy()\n"],"metadata":{"id":"dc49JPmoTaPQ"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"HKdUKKl-483N"},"source":["### utils_public"]},{"cell_type":"code","execution_count":6,"metadata":{"id":"nzOYWA2kqZ0d","executionInfo":{"status":"ok","timestamp":1654265148785,"user_tz":-540,"elapsed":2781,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# from funcs.funcs_indicator import *\n","# from funcs.funcs_trader import *\n","# import logging\n","# from ast import literal_eval\n","\n","pd.set_option('mode.chained_assignment',  None)\n","sys_log = logging.getLogger()\n","\n","\n","class OrderSide:\n","    BUY = \"BUY\"\n","    SELL = \"SELL\"\n","    INVALID = None\n","\n","\n","def lvrg_set(res_df, config, open_side, ep_, out_, fee, limit_leverage=50):\n","    selection_id = config.selection_id\n","    if not pd.isnull(out_) and not config.lvrg_set.static_lvrg:\n","        if selection_id in ['v3']:\n","            if open_side == OrderSide.SELL:\n","                loss = out_ / ep_\n","            else:\n","                loss = ep_ / out_\n","        else:  # 이 phase 가 정석, 윗 phase 는 결과가 수익 극대화라 사용함\n","            if open_side == OrderSide.SELL:\n","                loss = ep_ / out_\n","            else:\n","                loss = out_ / ep_\n","\n","        config.lvrg_set.leverage = config.lvrg_set.target_pct / abs(loss - 1 - (fee + config.trader_set.market_fee))\n","\n","    # ------------ leverage rejection ------------ #\n","    # 감당하기 힘든 fluc. 의 경우 진입하지 않음 - dynamic_lvrg 사용 경우\n","    if config.lvrg_set.leverage < 1 and config.lvrg_set.lvrg_rejection:\n","        # if config.lvrg_set.leverage >= 1 and config.lvrg_set.lvrg_rejection:\n","        return None\n","\n","    if not config.lvrg_set.allow_float:\n","        config.lvrg_set.leverage = int(config.lvrg_set.leverage)\n","\n","    config.lvrg_set.leverage = min(limit_leverage, max(config.lvrg_set.leverage, 1))\n","\n","    return config.lvrg_set.leverage\n","\n","\n","def sync_check(df_, config, order_side=\"OPEN\", row_slice=True):\n","    try:\n","        make_itv_list = [m_itv.replace('m', 'T') for m_itv in literal_eval(config.trader_set.itv_list)]\n","        row_list = literal_eval(config.trader_set.row_list)\n","        rec_row_list = literal_eval(config.trader_set.rec_row_list)\n","        offset_list = literal_eval(config.trader_set.offset_list)\n","\n","        assert len(make_itv_list) == len(offset_list), \"length of itv & offset_list should be equal\"\n","        htf_df_list = [to_htf(df_, itv_=itv_, offset=offset_) for itv_idx, (itv_, offset_)\n","                       in enumerate(zip(make_itv_list, offset_list)) if itv_idx != 0]  #\n","        htf_df_list.insert(0, df_)\n","\n","        # for htf_df_ in htf_df_list:\n","        #     print(htf_df_.tail())\n","\n","        #       Todo        #\n","        #        1. row_list calc.\n","        #           a. indi. 를 만들기 위한 최소 period 가 존재하고, 그 indi. 를 사용한 lb_period 가 존재함\n","        #           b. => default_period + lb_period\n","        #               i. from sync_check, public_indi, ep_point2, ep_dur 의 tf 별 max lb_period check\n","        #                   1. default_period + max lb_period check\n","        #                       a. 현재까지 lb_period_list\n","        #                           h_prev_idx (open / close) 60\n","        #                           dc_period 135\n","        #                           zone_dc_period 135\n","\n","        # --------- slicing (in trader phase only) --------- #\n","        #               --> latency 영향도가 높은 곳은 이곳\n","        if row_slice:  # recursive 가 아닌 indi. 의 latency 를 고려한 slicing\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = [df_s.iloc[-row_list[row_idx]:].copy() for row_idx, df_s in enumerate(htf_df_list)]\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = [df_s.iloc[-rec_row_list[row_idx]:].copy() for row_idx, df_s\n","                                                                                         in\n","                                                                                         enumerate(htf_df_list)]\n","        else:\n","            df, df_3T, df_5T, df_15T, df_30T, df_H, df_4H = htf_df_list\n","            rec_df, rec_df_3T, rec_df_5T, rec_df_15T, rec_df_30T, rec_df_H, rec_df_4H = htf_df_list\n","\n","        # --------- add indi. --------- #\n","\n","        #        1. 필요한 indi. 는 enlist_epouttp & mr_check 보면서 삽입\n","        #        2. min use_rows 계산을 위해서, tf 별로 gathering 함        #\n","        # start_0 = time.time()\n","\n","        # ------ T ------ #\n","        # df = dc_line(df, None, 'T', dc_period=20)\n","        # df = bb_line(df, None, 'T')\n","        #\n","        # ------ 3T ------ #\n","        # df = dc_line(df, df_3T, '3T')\n","\n","        # ------ 5T ------ #\n","        h_candle_v3(res_df, '5T')\n","        df = dc_line(df, df_5T, '5T')\n","        df = bb_line(df, df_5T, '5T')\n","        #\n","        # ------ 15T ------ #\n","        h_candle_v3(res_df, '15T')\n","        df = dc_line(df, df_15T, '15T')\n","        df = bb_line(df, df_15T, '15T')\n","        #\n","        # ------ 30T ------ #\n","        # df = bb_line(df, df_30T, '30T')\n","        #\n","        # ------ H ------ #\n","        h_candle_v3(res_df, 'H')\n","        # df = dc_line(df, df_H, 'H')\n","\n","        # ------ 4H ------ #\n","        # df = bb_line(df, df_4H, '4H')\n","\n","        # rec_df['rsi_1m'] = rsi(rec_df, 14)  # Todo - recursive, 250 period\n","        # df = df.join(to_lower_tf_v2(df, rec_df.iloc[:, [-1]], [-1], backing_i=0), how='inner')  # <-- join same_tf manual\n","        #\n","        # if order_side in [\"OPEN\"]:\n","        #     rec_df_5T['ema_5T'] = ema(rec_df_5T['close'], 195)  # Todo - recursive, 1100 period (5T)\n","        #     df = df.join(to_lower_tf_v2(df, rec_df_5T, [-1]), how='inner')\n","\n","    except Exception as e:\n","        sys_log.error(\"error in sync_check :\", e)\n","    else:\n","        return df\n","\n","\n","def public_indi(res_df, config, np_timeidx, order_side=\"OPEN\"):\n","\n","    selection_id = config.selection_id\n","\n","    wave_itv1 = config.tr_set.wave_itv1\n","    wave_itv2 = config.tr_set.wave_itv2\n","    wave_period1 = config.tr_set.wave_period1\n","    wave_period2 = config.tr_set.wave_period2\n","    roll_hl_cnt = 3\n","  \n","    # assert to_itvnum(wave_itv1) > 1  # wave_itv2 == 'T' and \n","    # ====== public ====== #\n","    # res_df = wave_range_dcbase_v11_3(res_df, config, over_period=2) \n","    \n","    # ------------ wave_period1 ------------ #\n","    if to_itvnum(wave_itv1) > 1: \n","      offset = '1h' if wave_itv1 != 'D' else '9h'\n","      htf_df = to_htf(res_df, wave_itv1, offset=offset)\n","      htf_df = wave_range_cci_v2(htf_df, wave_period1)\n","      \n","      cols = list(htf_df.columns[-15:-4])  # except idx col\n","\n","      valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = get_roll_wave_data_v2(htf_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      cols += list(htf_df.columns[-roll_hl_cnt:])\n","\n","      htf_df = wave_range_ratio_v4_2(htf_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      cols += list(htf_df.columns[-4:])\n","\n","      # ------ 필요한 cols 만 join (htf's idx 정보는 ltf 와 sync. 가 맞지 않음 - join 불가함) ------ #\n","      res_df.drop(cols, inplace=True, axis=1, errors='ignore')\n","      res_df = res_df.join(to_lower_tf_v3(res_df, htf_df, cols, backing_i=0), how='inner') \n","    else:\n","      res_df = wave_range_cci_v2(res_df, wave_period1)\n","\n","      valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv1, wave_period1), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv1, wave_period1, roll_hl_cnt=roll_hl_cnt)\n","\n","    # ------------ wave_period2 ------------ #\n","    if wave_itv1 != wave_itv2 or wave_period1 != wave_period2:\n","      res_df = wave_range_cci_v2(res_df, wave_period2)\n","\n","      valid_high_prime_idx, valid_low_prime_idx, roll_prev_high_idx_arr, roll_prev_low_idx_arr = roll_wave_hl_idx_v4(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_high_prime_idx, roll_prev_high_idx_arr, 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","      res_df = get_roll_wave_data_v2(res_df, valid_low_prime_idx, roll_prev_low_idx_arr, 'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), roll_hl_cnt)\n","\n","      res_df = wave_range_ratio_v4_2(res_df, wave_itv2, wave_period2, roll_hl_cnt=roll_hl_cnt)\n","\n","\n","    # ------ wave_loc_pct (bb) ------ #\n","    # res_df = wave_loc_pct_v2(res_df, config, 'T', 60)\n","    # res_df = wave_loc_pct(res_df, config, 'T', 60)\n","\n","    # future_cols = ['cu_es_15T1', 'co_es_15T1', 'upper_wick_ratio_15T', 'lower_wick_ratio_15T']\n","    # itv_list = ['15T', '15T', '15T', '15T']\n","    # res_df = backing_future_data(res_df, future_cols, itv_list)\n","\n","    # ====== intervaly ====== #    \n","    # ------ 5T ------ #\n","    # res_df = dc_level(res_df, '5T', 1)\n","    # res_df = bb_level(res_df, '5T', 1)\n","\n","    # res_df = st_level(res_df, '5T', 1)\n","\n","    # ------ 15T ------ #\n","    # res_df = dc_level(res_df, '15T', 1)\n","    # res_df = bb_level(res_df, '15T', 1)\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    # res_df = st_level(res_df, '15T', 1)\n","\n","    # ------ 30T ------ #\n","    # res_df = dc_level(res_df, '30T', 1)\n","    # res_df = bb_level(res_df, '30T', 1)\n","    # res_df = st_level(res_df, '30T', 1)\n","\n","    # ------ H ------ #\n","    # res_df = bb_level(res_df, 'H', 1)\n","\n","    # ------ 4H ------ #\n","    # res_df = bb_level(res_df, '4H', 1)\n","\n","    # res_df['dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.dc_period).max()   # Todo, consider dc_period\n","    # res_df['dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.dc_period).min()\n","\n","    # res_df['zone_dc_upper_v2'.format(selection_id)] = res_df['high'].rolling(config.loc_set.zone.zone_dc_period).max()   # Todo, consider zone_dc_period\n","    # res_df['zone_dc_lower_v2'.format(selection_id)] = res_df['low'].rolling(config.loc_set.zone.zone_dc_period).min()\n","\n","    # if order_side in [\"OPEN\"]:\n","        # candle_score_v3(res_df, 'T', unsigned=False)\n","        # candle_score_v3(res_df, config.loc_set.point1.exp_itv, unsigned=False)\n","\n","    #     temp indi.    #\n","    # res_df[\"ma30_1m\"] = res_df['close'].rolling(30).mean()\n","    # res_df[\"ma60_1m\"] = res_df['close'].rolling(60).mean()\n","    # res_df = dtk_plot(res_df, dtk_itv2='15T', hhtf_entry=15, use_dtk_line=config.loc_set.zone.use_dtk_line, np_timeidx=np_timeidx)\n","\n","    return res_df\n","\n","\n","def expiry_v0(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_1_ = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_1_[tp_j] - short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_1_ = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_1_[tp_j] + long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","def expiry(res_df, config, op_idx, e_j, tp_j, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            short_tp_ = res_df['short_tp_{}'.format(selection_id)].to_numpy()  # id 에 따라 dynamic 변수라 이곳에서 numpy 화 진행\n","            short_tp_gap_ = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if low[e_j] <= short_tp_[tp_j] + short_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","        else:\n","            long_tp_ = res_df['long_tp_{}'.format(selection_id)].to_numpy()  # iloc 이 빠를까, to_numpy() 가 빠를까  # 3.94 ms --> 5.34 ms (iloc)\n","            long_tp_gap_ = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()\n","            if high[e_j] >= long_tp_[tp_j] - long_tp_gap_[tp_j] * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def expiry_p1(res_df, config, op_idx1, i, op_idx2, np_datas, open_side):\n","def expiry_p1(res_df, config, op_idx1, op_idx2, tp1, tp0, tp_gap, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","    touch_idx = None\n","\n","    # if config.tr_set.expire_tick != \"None\":\n","    #     if e_j - op_idx >= config.tr_set.expire_tick:\n","    #         expire = 1\n","\n","    # Todo, p1's tp1, 0 cannot be vectorized\n","    #   a. expiration 의 조건은 wave1, 0 의 broken\n","    idx_range = np.arange(op_idx1, op_idx2)\n","    if config.tr_set.expire_k1 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            touch_idx = np.where((low[op_idx1:op_idx2] <= tp1 + tp_gap * config.tr_set.expire_k1) | \\\n","                                 (high[op_idx1:op_idx2] >= tp0 - tp_gap * config.tr_set.expire_k1),\n","                                 idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:  # touch 가 존재하면, \n","            # if low[op_idx1:op_idx2].min() <= tp1 + tp_gap * config.tr_set.expire_k1 or \\\n","            # high[op_idx1:op_idx2].max() >= tp0 - tp_gap * config.tr_set.expire_k1:   # p2_box loc. 이 있어서, op_idx2 + 1 안함\n","                expire = 1\n","        else:\n","            touch_idx = np.where((high[op_idx1:op_idx2] >= tp1 - tp_gap * config.tr_set.expire_k1) | \\\n","                                  (low[op_idx1:op_idx2] <= tp0 + tp_gap * config.tr_set.expire_k1),\n","                                  idx_range, np.nan)\n","            if np.sum(~np.isnan(touch_idx)) > 0:                                  \n","            # if high[op_idx1:op_idx2].max() >= tp1 - tp_gap * config.tr_set.expire_k1 or \\\n","            # low[op_idx1:op_idx2].min() <= tp0 + tp_gap * config.tr_set.expire_k1:\n","                expire = 1\n","\n","    return expire, np.nanmin(touch_idx)\n","\n","\n","def expiry_p2(res_df, config, op_idx, e_j, wave1, wave2, np_datas, open_side):\n","    high, low = np_datas\n","    selection_id = config.selection_id\n","    expire = 0\n","\n","    if config.tr_set.expire_tick != \"None\":\n","        if e_j - op_idx >= config.tr_set.expire_tick:\n","            expire = 1\n","\n","    if config.tr_set.expire_k2 != \"None\":\n","        if open_side == OrderSide.SELL:\n","            if low[e_j] <= wave1 + wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","        else:\n","            if high[e_j] >= wave1 - wave2 * config.tr_set.expire_k2:\n","                expire = 1\n","\n","    return expire\n","\n","\n","# def ep_loc_point2_v2(res_df, config, i, out_j, side=OrderSide.SELL):\n","#     allow_ep_in = 1\n","#     if config.selection_id in ['v5_2']:\n","#         if side == OrderSide.SELL:\n","#             dc_upper_T = res_df['dc_upper_T'].to_numpy()\n","#             dc_upper_15T = res_df['dc_upper_15T'].to_numpy()\n","#             allow_ep_in *= (dc_upper_T[i - 1] <= dc_upper_15T[i]) & \\\n","#                            (dc_upper_15T[i - 1] != dc_upper_15T[i])\n","#         else:\n","#             dc_lower_T = res_df['dc_lower_T'].to_numpy()\n","#             dc_lower_15T = res_df['dc_lower_15T'].to_numpy()\n","#             allow_ep_in *= (dc_lower_T[i - 1] >= dc_lower_15T[i]) & \\\n","#                            (dc_lower_15T[i - 1] != dc_lower_15T[i])\n","\n","#     if config.selection_id in ['v3_4']:\n","#         wick_score_list = literal_eval(config.ep_set.point2.wick_score_list)\n","#         wick_scores = [res_df['wick_score_{}'.format(s_itv)].to_numpy() for s_itv in literal_eval(config.ep_set.point2.score_itv_list)]\n","#         close = res_df['close'].to_numpy()\n","#         if side == OrderSide.SELL:\n","#             sup_T = res_df['sup_T'].to_numpy()\n","#             allow_ep_in *= close[i] < sup_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] < -wick_score_list[0]\n","#         else:\n","#             resi_T = res_df['resi_T'].to_numpy()\n","#             allow_ep_in *= close[i] > resi_T[i - 1]\n","#             if len(wick_score_list) != 0:\n","#                 allow_ep_in *= wick_scores[0][i] > wick_score_list[0]\n","\n","#     if allow_ep_in:\n","#         out_j = i\n","#     return allow_ep_in, out_j\n","\n","\n","# vectorized calc.\n","# multi-stem 에 따라 dynamic vars.가 입력되기 때문에 class 내부 vars. 로 종속시키지 않음\n","def ep_loc_p1_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ tr_thresh ============ #  # vectorize allow only for p1_hhm\n","    if config.loc_set.point1.short_tr_thresh != \"None\" and not config.tr_set.check_hlm:\n","        if ep_loc_side == OrderSide.SELL:\n","            short_tr_ = res_df['short_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= short_tr_ >= config.loc_set.point1.short_tr_thresh\n","            # mr_res *= short_tr_ <= config.loc_set.point1.short_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_tr_ >= short_tr_thresh : {:.5f} {:.5f} ({})\".format(short_tr_[c_i], config.loc_set.point1.short_tr_thresh, mr_res[c_i]))\n","        else:\n","            long_tr_ = res_df['long_tr_{}'.format(selection_id)].to_numpy()\n","            mr_res *= long_tr_ >= config.loc_set.point1.long_tr_thresh\n","            # mr_res *= long_tr_ <= config.loc_set.point1.long_tr_thresh + 0.1\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_tr_ >= long_tr_thresh : {:.5f} {:.5f} ({})\".format(long_tr_[c_i], config.loc_set.point1.long_tr_thresh, mr_res[c_i]))\n","\n","    # ============ spread - independent to tr_set ============ #  --> Todo, 사용 안하고 싶은 wave_point1\n","    if config.loc_set.point1.short_spread != \"None\":\n","        if selection_id in ['v3']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_base_5T = res_df['bb_base_5T'].to_numpy()  # to_numpy() 는 ep_loc 에서 진행됨\n","                bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                short_spread = (bb_base_5T - bb_lower_5T - tp_fee * bb_base_5T) / (bb_base_5T - bb_lower_5T + out_fee * bb_base_5T)\n","                mr_res *= short_spread >= config.loc_set.point1.short_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"short_spread >= config.loc_set.point1.short_spread : {:.5f} {:.5f} ({})\".format(short_spread[c_i], config.loc_set.point1.short_spread, mr_res[c_i]))\n","            else:\n","                bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","                dc_lower_5T = res_df['dc_lower_5T'].to_numpy()\n","                # mr_res *= (bb_base_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_base_5T - dc_lower_5T + out_fee * bb_base_5T) >= config.loc_set.point1.long_spread\n","                long_spread = (bb_upper_5T - dc_lower_5T - tp_fee * bb_upper_5T) / (bb_upper_5T - dc_lower_5T + out_fee * bb_upper_5T)\n","                mr_res *= long_spread >= config.loc_set.point1.long_spread\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"long_spread >= config.loc_set.point1.long_spread : {:.5f} {:.5f} ({})\".format(long_spread[c_i], config.loc_set.point1.long_spread, mr_res[c_i]))                  \n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    if config.loc_set.point1.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21\n","        mr_res *= cu_wrr_21_ >= config.loc_set.point1.cu_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point1.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point1.cu_wrr_21, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_21_ <= config.loc_set.point1.co_wrr_21\n","        mr_res *= co_wrr_21_ >= config.loc_set.point1.co_wrr_21 - 0.2\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_21_ <= config.loc_set.point1.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point1.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point1.wrr_32 != \"None\":            \n","      wave_itv1 = config.tr_set.wave_itv1\n","      wave_period1 = config.tr_set.wave_period1\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point1.wrr_32  # + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point1.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point1.wrr_32  # + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point1.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point1.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point1.wrr_32, mr_res[c_i]))\n","\n","    # ------ enough_space - Todo, future_data ------ #\n","    if config.loc_set.point1.co_es != \"None\":      \n","      itv, period1 = config.tr_set.p1_itv1, config.tr_set.p1_period1 \n","      b1_cu_es_ = res_df['b1_cu_es_{}{}'.format(itv, period1)].to_numpy()\n","      b1_co_es_ = res_df['b1_co_es_{}{}'.format(itv, period1)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_co_es_ >= config.loc_set.point1.co_es\n","        mr_res *= b1_co_es_ <= config.loc_set.point1.co_es + 2\n","        if show_detail:\n","            sys_log.warning(\"b1_co_es_ >= config.loc_set.point1.co_es : {:.5f} {:.5f} ({})\".format(b1_co_es_[c_i], config.loc_set.point1.co_es, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cu_es_ >= config.loc_set.point1.cu_es\n","        mr_res *= b1_cu_es_ <= config.loc_set.point1.cu_es + 1\n","        if show_detail:\n","            sys_log.warning(\"b1_cu_es_ >= config.loc_set.point1.cu_es : {:.5f} {:.5f} ({})\".format(b1_cu_es_[c_i], config.loc_set.point1.cu_es, mr_res[c_i]))\n","\n","    # ------------ wick_ratio - Todo, future_data ------------ #\n","    # if config.loc_set.point1.short_wick_ratio != \"None\":\n","    #   b1_upper_wick_ratio_ = res_df['b1_upper_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()\n","    #   b1_lower_wick_ratio_ = res_df['b1_lower_wick_ratio_{}'.format(config.loc_set.point1.wick_itv)].to_numpy()      \n","    #   if ep_loc_side == OrderSide.SELL:\n","    #       # mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_lower_wick_ratio_ >= config.loc_set.point1.short_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_lower_wick_ratio_[c_i], config.loc_set.point1.short_wick_ratio, mr_res[c_i]))\n","    #   else:\n","    #       # mr_res *= b1_lower_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       mr_res *= b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio\n","    #       if show_detail:\n","    #           sys_log.warning(\"b1_upper_wick_ratio_ >= config.loc_set.point1.long_wick_ratio : {:.5f} {:.5f} ({})\".format(b1_upper_wick_ratio_[c_i], config.loc_set.point1.long_wick_ratio, mr_res[c_i]))\n","\n","    # ------ candle_range_ratio - Todo, future_data ------ #\n","    # if config.loc_set.point1.crr != \"None\":   \n","    #   tf_entry = to_itvnum(config.loc_set.point1.tf_entry)\n","    #   b1_crr_ = res_df['crr_{}'.format(config.loc_set.point1.tf_entry)].shift(tf_entry).to_numpy()\n","    #   mr_res *= b1_crr_ >= config.loc_set.point1.crr\n","    #   if show_detail:\n","    #       sys_log.warning(\"b1_crr_ >= config.loc_set.point1.crr : {:.5f} {:.5f} ({})\".format(b1_crr_[c_i], config.loc_set.point1.crr, mr_res[c_i]))\n","    \n","    # ------ dc_over_body_ratio ------ #\n","    if config.loc_set.point1.dbr != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:        \n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr, mr_res[c_i]))\n","            \n","    if config.loc_set.point1.dbr2 != \"None\":\n","      b1_lwdbr = res_df['b1_lwdbr'].to_numpy()\n","      b1_updbr = res_df['b1_updbr'].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:    \n","        mr_res *= b1_updbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_updbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_updbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_lwdbr >= config.loc_set.point1.dbr2\n","        if show_detail:\n","            sys_log.warning(\n","                \"b1_lwdbr >= config.loc_set.point1.dbr2 : {:.5f} {:.5f} ({})\".format(b1_lwdbr[c_i], config.loc_set.point1.dbr2, mr_res[c_i]))\n","\n","    # ------ wick_body_ratio ------ #\n","    if config.loc_set.point1.wbr != \"None\":\n","        wave_body_ratio = res_df['wave_body_ratio'].to_numpy()\n","        mr_res *= wave_body_ratio >= config.loc_set.point1.wbr\n","        if show_detail:\n","            sys_log.warning(\n","                \"wave_body_ratio >= config.loc_set.point1.wbr : {:.5f} {:.5f} ({})\".format(wave_body_ratio[c_i], config.loc_set.point1.wbr, mr_res[c_i]))\n","            \n","    # ------ body_rel_ratio ------ #\n","    if config.loc_set.point1.brr != \"None\":\n","        body_rel_ratio_ = res_df['body_rel_ratio_{}'.format(config.loc_set.point1.tf_entry)].to_numpy()\n","        mr_res *= body_rel_ratio_ <= config.loc_set.point1.brr\n","        if show_detail:\n","            sys_log.warning(\n","                \"body_rel_ratio_ <= config.loc_set.point1.brr : {:.5f} {:.5f} ({})\".format(body_rel_ratio_[c_i], config.loc_set.point1.brr, mr_res[c_i]))\n","\n","    # ------ pumping_ratio ------ #\n","    if config.loc_set.point1.ppr != \"None\":\n","      if ep_loc_side == OrderSide.SELL:\n","        short_ppr_ = res_df['short_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= short_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"short_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(short_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n","      else:\n","        long_ppr_ = res_df['long_ppr_{}'.format(selection_id)].to_numpy()\n","        mr_res *= long_ppr_ >= config.loc_set.point1.ppr\n","        if show_detail:\n","            sys_log.warning(\"long_ppr_ >= config.loc_set.point1.ppr : {:.5f} {:.5f} ({})\".format(long_ppr_[c_i], config.loc_set.point1.ppr, mr_res[c_i]))\n"," \n","    # ============ rtc_zone  ============ #  --> Todo, 사용 안하고 싶은 wave_dur., 추후 zone 으로 옮길 것\n","    # ------ dtk ------ #\n","    if config.loc_set.zone.dt_k != \"None\":\n","        # ------ dc_v2 ------ #\n","        dc_lower_v2 = res_df['dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_1_ = res_df['short_dtk_1_{}'.format(selection_id)].to_numpy() - \\\n","                       res_df['short_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        dc_upper_v2 = res_df['dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_1_ = res_df['long_dtk_1_{}'.format(selection_id)].to_numpy() + \\\n","                      res_df['long_dtk_gap_{}'.format(selection_id)].to_numpy() * config.loc_set.zone.dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            mr_res *= dc_lower_v2 >= short_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_lower_v2 >= short_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_lower_v2[c_i], short_dtk_1_[c_i], mr_res[c_i]))\n","        else:\n","            mr_res *= dc_upper_v2 <= long_dtk_1_\n","            if show_detail:\n","                sys_log.warning(\n","                    \"dc_upper_v2 <= long_dtk_1_ : {:.5f} {:.5f} ({})\".format(dc_upper_v2[c_i], long_dtk_1_[c_i], mr_res[c_i]))\n","                \n","    # ============ zone ============ #\n","    # ------ config var. 이 등록되지 않은 dur. 은 selection_id 으로 조건문을 나눔 (lvrg_set 과 동일) ------ #\n","    # if config.loc_set.zone.use_zone:\n","\n","\n","    # -------------- zoned tr_set - post_work -------------- #\n","    if config.tr_set.c_ep_gap != \"None\" or config.tr_set.t_out_gap != \"None\":\n","        #       by zone_dtk       #\n","        #         c_zone        #\n","        zone_dc_upper_v2_ = res_df['zone_dc_upper_v2'.format(selection_id)].to_numpy()\n","        long_dtk_plot_1 = res_df['long_dtk_plot_1'].to_numpy() + res_df['long_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        zone_dc_lower_v2_ = res_df['zone_dc_lower_v2'.format(selection_id)].to_numpy()\n","        short_dtk_plot_1 = res_df['short_dtk_plot_1'].to_numpy() - res_df['short_dtk_plot_gap'].to_numpy() * config.loc_set.zone.zone_dt_k\n","        if ep_loc_side == OrderSide.SELL:\n","            zone_res = zone_dc_upper_v2_ > long_dtk_plot_1  # mr_res 와는 별개임\n","            pos = 'short'\n","        else:\n","            zone_res = zone_dc_lower_v2_ < short_dtk_plot_1\n","            pos = 'long'\n","\n","        # static 여부에 따른 vectorized adj. - dynamic 은 vectorize 불가\n","        if config.ep_set.static_ep and config.tr_set.c_ep_gap != \"None\":\n","            res_df['{}_ep_{}'.format(pos, selection_id)][zone_res] = res_df['{}_ep2_{}'.format(pos, selection_id)][zone_res]\n","        if config.out_set.static_out and config.tr_set.t_out_gap != \"None\":\n","            res_df['{}_out_{}'.format(pos, selection_id)][~zone_res] = res_df['{}_out2_{}'.format(pos, selection_id)][\n","                ~zone_res]  # t_zone 에 대한 out2 setting\n","        zone_arr = np.where(zone_res == 1, 'c', 't')\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal\n","\n","\n","def ep_loc_p2_v3(res_df, config, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL):\n","    # ------- param init ------- #\n","    selection_id = config.selection_id\n","    c_i = config.trader_set.complete_index\n","    len_df = len(res_df)\n","    mr_res = np.ones(len_df)\n","    zone_arr = np.full(len_df, 'n')\n","\n","    # ------ process 한번에 처리해서 param_check 만 ver. 별로 하면 될 것 ------ #\n","    #     => public_indi() 가 될 것\n","    #     1. 사용한 param 정보와 matching 된 data 병렬로 나열 logging 될 것\n","    # tp_fee, out_fee = calc_tp_out_fee_v2(config)\n","\n","    # ============ point1 ratios ============ #\n","    # ------ wave_range_ratio ------ #\n","    # if config.loc_set.point2.cu_wrr_21 != \"None\":   # for excessive range rejection         \n","    #   wave_itv1 = config.tr_set.wave_itv1\n","    #   wave_period1 = config.tr_set.wave_period1\n","    #   co_wrr_21_ = res_df['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   cu_wrr_21_ = res_df['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","    #   if ep_loc_side == OrderSide.SELL:\n","    #     mr_res *= cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21\n","    #     mr_res *= cu_wrr_21_ >= config.loc_set.point2.cu_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"cu_wrr_21_ <= config.loc_set.point2.cu_wrr_21 : {:.5f} {:.5f} ({})\".format(cu_wrr_21_[c_i], config.loc_set.point2.cu_wrr_21, mr_res[c_i]))\n","    #   else:\n","    #     mr_res *= co_wrr_21_ <= config.loc_set.point2.co_wrr_21\n","    #     mr_res *= co_wrr_21_ >= config.loc_set.point2.co_wrr_21 - 0.2\n","    #     if show_detail:\n","    #         sys_log.warning(\"co_wrr_21_ <= config.loc_set.point2.co_wrr_21 : {:.5f} {:.5f} ({})\".format(co_wrr_21_[c_i], config.loc_set.point2.co_wrr_21, mr_res[c_i]))\n","\n","    if config.loc_set.point2.wrr_32 != \"None\":            \n","      wave_itv2 = config.tr_set.wave_itv2\n","      wave_period2 = config.tr_set.wave_period2\n","      co_wrr_32_ = res_df['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      cu_wrr_32_ = res_df['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= cu_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= cu_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(cu_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","      else:\n","        mr_res *= co_wrr_32_ <= config.loc_set.point2.wrr_32  #  + 0.1  # 0.1 0.05\n","        # mr_res *= co_wrr_32_ >= config.loc_set.point2.wrr_32\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_32_ <= config.loc_set.point2.wrr_32 : {:.5f} {:.5f} ({})\".format(co_wrr_32_[c_i], config.loc_set.point2.wrr_32, mr_res[c_i]))\n","\n","\n","    return mr_res, zone_arr  # mr_res 의 True idx 가 open signal"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"EQ63Jwpvr7qA"}},{"cell_type":"code","source":["      \n","    # ------ hl_loc_pct ------ #\n","    if config.loc_set.zone.hl_loc_pct != \"None\":      \n","      wave_high_loc_pct_ = res_df['wave_high_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","      wave_low_loc_pct_ = res_df['wave_low_loc_pct_{}{}'.format(wave_itv1, wave_period1)].to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_high_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_high_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_high_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","      else:\n","        mr_res *= wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct\n","        mr_res *= wave_low_loc_pct_ <= config.loc_set.zone.hl_loc_pct + 0.5\n","        if show_detail:\n","            sys_log.warning(\"wave_low_loc_pct_ >= config.loc_set.zone.hl_loc_pct : {:.5f} {:.5f} ({})\".format(wave_low_loc_pct_[c_i], config.loc_set.zone.hl_loc_pct, mr_res[c_i]))\n","\n","            \n","        # ------------------ wave_biaser (sr_confirmer) ------------------ #\n","        if selection_id in ['3_9']:     \n","          itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2          \n","\n","          if ep_loc_side == OrderSide.SELL:\n","            short_wave_high_ = res_df['short_wave_high_{}{}{}'.format(itv, period1, period2)]\n","            bb_lower_5T_amax = get_line(res_df['short_wave_high_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_lower_5T'].to_numpy())\n","            mr_res *= short_wave_high_ <= bb_lower_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"short_wave_high_ <= bb_lower_5T_amax : {:.5f} {:.5f} ({})\".format(short_wave_high_[c_i], bb_lower_5T_amax[c_i], mr_res[c_i]))\n","          else:\n","            long_wave_low_ = res_df['long_wave_low_{}{}{}'.format(itv, period1, period2)]\n","            bb_upper_5T_amax = get_line(res_df['long_wave_low_idx_{}{}{}'.format(itv, period1, period2)].to_numpy(), res_df['bb_upper_5T'].to_numpy())\n","            mr_res *= long_wave_low_ >= bb_upper_5T_amax\n","            if show_detail:\n","                sys_log.warning(\"long_wave_low_ >= bb_upper_5T_amax : {:.5f} {:.5f} ({})\".format(long_wave_low_[c_i], bb_upper_5T_amax[c_i], mr_res[c_i]))\n","\n","\n","        if selection_id in ['4_3', '3_5', '3_51']:\n","            dc_base_T20 = res_df['dc_base_T20'].to_numpy()\n","            dc_base_3T20 = res_df['dc_base_3T20'].to_numpy()\n","            # b1_dc_base_3T20 = res_df['dc_base_3T20'].shift(3).to_numpy()\n","            # dc_base_5T = res_df['dc_base_5T'].to_numpy()\n","            # dc_base_15T = res_df['dc_base_15T'].to_numpy()\n","            # dc_base_30T = res_df['dc_base_30T'].to_numpy()\n","            dc_base_H20 = res_df['dc_base_H20'].to_numpy()\n","            # dc_base_4H = res_df['dc_base_4H'].to_numpy()\n","            # dc_base_D = res_df['dc_base_D'].to_numpy()\n","\n","            itv, period1, period2 = config.tr_set.p1_itv1, config.tr_set.p1_period1, config.tr_set.p1_period2\n","            if ep_loc_side == OrderSide.SELL:\n","                # ------ short_base_ <= dc_base_3T20 ------ #\n","                short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= short_base_ <= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"short_base_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= short_base_ <= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"short_base_ <= dc_base_T20 : {:.5f} {:.5f} ({})\".format(short_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_upper_ = res_df['dc_upper_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_upper_ <= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper_ <= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_upper_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                # Todo, 부호 조심\n","                # dc_upper2_ = res_df['dc_upper_{}{}'.format(itv, period2)].to_numpy()\n","                # mr_res *= dc_upper2_ >= dc_base_H\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_upper2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_upper2_[c_i], dc_base_H[c_i], mr_res[c_i]))  \n","\n","                # long 과 동일한 dur.\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))  \n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_min ------ #\n","                dc_base_3T20_rollmin = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).min().to_numpy()\n","                mr_res *= dc_base_3T20_rollmin == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmin == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmin[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","            else:\n","                # ------ long_base >= dc_base_3T20 ------ #\n","                long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)].to_numpy()\n","                mr_res *= long_base_ >= dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\"long_base_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # mr_res *= long_base_ >= dc_base_T20\n","                # if show_detail:\n","                #     sys_log.warning(\"long_base_ >= dc_base_T20 : {:.5f} {:.5f} ({})\".format(long_base_[c_i], dc_base_T20[c_i], mr_res[c_i]))\n","\n","                # ------ reject csd ------ #\n","                # dc_lower_ = res_df['dc_lower_{}{}'.format(itv, period1)].to_numpy()\n","                # mr_res *= dc_lower_ >= dc_base_3T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower_ >= dc_base_3T20 : {:.5f} {:.5f} ({})\".format(dc_lower_[c_i], dc_base_3T[c_i], mr_res[c_i]))\n","\n","                dc_lower2_ = res_df['dc_lower_{}{}'.format(itv, period2)].to_numpy()\n","                mr_res *= dc_lower2_ >= dc_base_H20\n","                if show_detail:\n","                    sys_log.warning(\"dc_lower2_ >= dc_base_H20 : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], dc_base_H20[c_i], mr_res[c_i]))\n","\n","                # bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","                # mr_res *= dc_lower2_ >= bb_lower_5T\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_lower2_ >= bb_lower_5T : {:.5f} {:.5f} ({})\".format(dc_lower2_[c_i], bb_lower_5T[c_i], mr_res[c_i]))\n","\n","                # ------ alignment ------ #\n","                # mr_res *= (dc_base_3T20 > dc_base_5T) & (dc_base_5T > dc_base_15T) & (dc_base_15T > dc_base_30T)\n","\n","                # ------ consecutive base ascender ------ #\n","                # ------ 1. roll_max ------ #\n","                dc_base_3T20_rollmax = res_df['dc_base_3T20'].rolling(config.loc_set.zone.base_roll_period).max().to_numpy()\n","                mr_res *= dc_base_3T20_rollmax == dc_base_3T20\n","                if show_detail:\n","                    sys_log.warning(\n","                        \"dc_base_3T20_rollmax == dc_base_3T2020 : {:.5f} {:.5f} ({})\".format(dc_base_3T20_rollmax[c_i], dc_base_3T20[c_i], mr_res[c_i]))\n","\n","                # ------ 2. roll_max_v2 - ascender  ------ #\n","                # dc_base_3T_ascend = (res_df['dc_base_3T'] >= res_df['dc_base_3T'].shift(3)).rolling(config.loc_set.zone.base_roll_period).sum().to_numpy()\n","                # # mr_res *= dc_base_3T_ascend == config.loc_set.zone.base_roll_period\n","                # mr_res *= dc_base_3T_ascend != config.loc_set.zone.base_roll_period\n","                # if show_detail:\n","                #     sys_log.warning(\"dc_base_3T_ascend == config.loc_set.zone.base_roll_period : {:.5f} {:.5f} ({})\".format(dc_base_3T_ascend[c_i], config.loc_set.zone.base_roll_period, mr_res[c_i]))\n","\n","\n","    if config.loc_set.point.wrr != \"None\":            \n","      wave_itv = 'T'\n","      wave_period = config.tr_set.wave_period\n","      co_wrr_ = res_df['co_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      cu_wrr_ = res_df['cu_wrr_{}{}'.format(wave_itv, wave_period)].to_numpy()\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= co_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"co_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(co_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","      else:\n","        mr_res *= cu_wrr_ <= config.loc_set.point.wrr\n","        if show_detail:\n","            sys_log.warning(\"cu_wrr_ <= config.loc_set.point.wrr : {:.5f} {:.5f} ({})\".format(cu_wrr_[c_i], config.loc_set.point.wrr, mr_res[c_i]))\n","            \n","      # if ep_loc_side == OrderSide.SELL:\n","      #   mr_res *= cu_es_ >= config.loc_set.point.cu_es\n","      #   mr_res *= cu_es_ <= config.loc_set.point.cu_es + 2\n","      #   if show_detail:\n","      #       sys_log.warning(\"cu_es_ >= config.loc_set.point.cu_es : {:.5f} {:.5f} ({})\".format(cu_es_[c_i], config.loc_set.point.cu_es, mr_res[c_i]))\n","      # else:\n","      #   mr_res *= co_es_ >= config.loc_set.point.co_es\n","      #   mr_res *= co_es_ <= config.loc_set.point.co_es + 1\n","      #   if show_detail:\n","      #       sys_log.warning(\"co_es_ >= config.loc_set.point.co_es : {:.5f} {:.5f} ({})\".format(co_es_[c_i], config.loc_set.point.co_es, mr_res[c_i]))\n","\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          # mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          mr_res *= upper_wick_ratio_ <= config.loc_set.point.wick_ratio + 0.1\n","          # mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","              \n","      crr_ = res_df['crr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()\n","      mr_res *= crr_ >= config.loc_set.point.crr\n","     \n","      if show_detail:\n","          sys_log.warning(\"crr_ >= config.loc_set.point.crr : {:.5f} {:.5f} ({})\".format(crr_[c_i], config.loc_set.point.crr, mr_res[c_i]))\n","\n","      b1_upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","      b1_lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].shift(itv_num).to_numpy()\n","\n","      if ep_loc_side == OrderSide.SELL:\n","          upper_wick_ratio_ = res_df['upper_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= upper_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"upper_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(upper_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","      else:\n","          lower_wick_ratio_ = res_df['lower_wick_ratio_{}'.format(config.loc_set.point.wick_itv)].to_numpy()\n","          mr_res *= lower_wick_ratio_ >= config.loc_set.point.wick_ratio\n","          if show_detail:\n","              sys_log.warning(\"lower_wick_ratio_ >= config.loc_set.point.wick_ratio : {:.5f} {:.5f} ({})\".format(lower_wick_ratio_[c_i], config.loc_set.point.wick_ratio, mr_res[c_i]))\n","\n","    if config.loc_set.point.cppr != \"None\":   \n","      tf_entry = to_itvnum(config.loc_set.point.tf_entry)\n","      b1_cppr_ = res_df['b1_cppr_{}'.format(config.loc_set.point.tf_entry)].to_numpy()  # check b1's cppr in ep_loc\n","      if ep_loc_side == OrderSide.SELL:\n","        mr_res *= b1_cppr_ >= config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ >= config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","      else:\n","        mr_res *= b1_cppr_ <= -config.loc_set.point.cppr\n","        if show_detail:\n","            sys_log.warning(\"b1_cppr_ <= -config.loc_set.point.cppr : {:.5f} {:.5f} ({})\".format(b1_cppr_[c_i], config.loc_set.point.cppr, mr_res[c_i]))\n","            \n","    # ------------ candle_score ------------ #\n","    wick_score_list = literal_eval(config.loc_set.point.wick_score_list)\n","    if len(wick_score_list) != 0:\n","        score_itv_list = literal_eval(config.loc_set.point.score_itv_list)\n","        # ------ candle_score_v0 (1m initial tick 기준임) ------ #  Todo - higher timeframe 경우 back_data 사용해야함\n","        for wick_score_, score_itv_ in zip(wick_score_list, score_itv_list):\n","            wick_score = res_df['wick_score_{}'.format(score_itv_)].to_numpy()\n","            if ep_loc_side == OrderSide.SELL:\n","                mr_res *= wick_score <= -wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score <= -wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], -wick_score_, mr_res[c_i]))\n","            else:\n","                mr_res *= wick_score >= wick_score_\n","                if show_detail:\n","                    sys_log.warning(\"wick_score >= wick_score_ : {:.5f} {:.5f} ({})\".format(wick_score[c_i], wick_score_, mr_res[c_i]))\n","            \n","\n","        # ------------------ swing_middle ------------------ #\n","        # ------------ 1. envelope ------------ #\n","\n","        # ------ a. dc ------ #\n","        # ep_loc check 기준 idx 가 entry 기준이라는 걸 명심\n","        if selection_id in ['v3_2']:\n","            hc_itv = '15T'\n","            dc_itv = '15T'\n","            shift_num = [0, to_itvnum(hc_itv)]\n","            div_res = [1, 0]\n","            for itv_num, res in zip(shift_num, div_res):\n","                close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()  # close_bar timein 사용하는 경우, 특수로 shift(0) 사용가능\n","                if ep_loc_side == OrderSide.SELL:\n","                    dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ < dc_lower_) == res\n","                else:\n","                    dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","                    mr_res *= (close_ > dc_upper_) == res\n","\n","        # ------------ 2. degree ------------ #\n","        # ------ a. norm_body_ratio ------ #\n","        if config.loc_set.zone.abs_ratio != \"None\":\n","            itv = config.loc_set.point.tf_entry\n","            abs_ratio_ = res_df['abs_ratio_{}'.format(itv)].to_numpy()\n","            mr_res *= abs_ratio_ >= config.loc_set.zone.abs_ratio\n","            # mr_res *= abs_ratio_ <= config.loc_set.zone.abs_ratio\n","\n","    # ------------ 2. imbalance_ratio ------------ #\n","    if config.loc_set.zone.ir != \"None\":\n","        itv = config.loc_set.point.tf_entry\n","        itv_num = to_itvnum(itv)\n","        if ep_loc_side == OrderSide.SELL:\n","            short_ir_ = res_df['short_ir_{}'.format(itv)].to_numpy()\n","            # short_ir_ = res_df['short_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= short_ir_ >= config.loc_set.zone.ir     # greater\n","            mr_res *= short_ir_ <= config.loc_set.zone.ir  # lesser\n","            if show_detail:\n","                sys_log.warning(\n","                    \"short_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(short_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","        else:\n","            long_ir_ = res_df['long_ir_{}'.format(itv)].to_numpy()\n","            # long_ir_ = res_df['long_ir_{}'.format(itv)].shift(itv_num).to_numpy()\n","\n","            # mr_res *= long_ir_ >= config.loc_set.zone.ir\n","            mr_res *= long_ir_ <= config.loc_set.zone.ir\n","            if show_detail:\n","                sys_log.warning(\n","                    \"long_ir_ <= config.loc_set.zone.ir : {:.5f} {:.5f} ({})\".format(long_ir_[c_i], config.loc_set.zone.ir, mr_res[c_i]))\n","                \n","        # if selection_id in ['3_6']:\n","        #   itv, period1, period2 = config.loc_set.point.p1_itv0, config.loc_set.point.p1_period1, config.loc_set.point.p1_period2          \n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     high_5T = res_df['high_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     short_base_ = res_df['short_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= high_5T < short_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"high_5T < short_base_ : {:.5f} {:.5f} ({})\".format(high_5T[c_i], short_base_[c_i], mr_res[c_i]))\n","        #   else:\n","        #     low_5T = res_df['low_5T'].to_numpy()  # Todo, tf_entry - 1 open 기준이라 future_data 사용 가능\n","        #     long_base_ = res_df['long_base_{}{}{}'.format(itv, period1, period2)]\n","        #     mr_res *= low_5T > long_base_\n","        #     if show_detail:\n","        #         sys_log.warning(\n","        #             \"low_5T > long_base_ : {:.5f} {:.5f} ({})\".format(low_5T[c_i], long_base_[c_i], mr_res[c_i]))'\n","        \n","        # ------ dc_base ------ #\n","        # if selection_id in ['4']:  # 'v3_3', 'v3_4',\n","        #   hc_itv = '5T'\n","        #   dc_itv = '5T'\n","        #   itv_num = to_itvnum(hc_itv)\n","        #   close_ = res_df['close_{}'.format(hc_itv)].shift(itv_num).to_numpy()   # 따라서 future_data 사용시, shifting 필요함\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ < dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_%s' % dc_itv].shift(itv_num).to_numpy()\n","        #     mr_res *= close_ > dc_upper_\n","\n","        # ------ ema ------ #\n","        # if selection_id in ['v5_2']: # 'v3'\n","        #   ema_5T = res_df['ema_5T'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= close < ema_5T\n","        #   else:\n","        #     mr_res *= close > ema_5T\n","        \n","        # ------ b. bb ------ #\n","        # close = res_df['close'].to_numpy()\n","\n","        # if selection_id in ['v3_3']:\n","        #   open = res_df['open'].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     bb_lower_1m = res_df['bb_lower_1m'].to_numpy()\n","        #     # mr_res *= close <= bb_lower_1m\n","        #     mr_res *= open <= bb_lower_1m\n","        #   else:\n","        #     bb_upper_1m = res_df['bb_upper_1m'].to_numpy()\n","        #     # mr_res *= close >= bb_upper_1m\n","        #     mr_res *= open >= bb_upper_1m\n","\n","        if selection_id in ['4_1']:\n","            if ep_loc_side == OrderSide.SELL:\n","                bb_lower_15T = res_df['bb_lower_15T'].to_numpy()\n","                short_ep_ = res_df['short_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_lower_15T >= short_ep_\n","            else:\n","                bb_upper_15T = res_df['bb_upper_15T'].to_numpy()\n","                long_ep_ = res_df['long_ep_{}'.format(selection_id)].to_numpy()\n","                mr_res *= bb_upper_15T <= long_ep_\n","\n","        # if selection_id in ['v5_2']:\n","        #   bb_upper2_ = res_df['bb_upper2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   bb_lower2_ = res_df['bb_lower2_%s' % config.loc_set.zone.bbz_itv].to_numpy()\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= bb_upper2_ < close\n","        #   else:\n","        #     mr_res *= bb_lower2_ > close\n","\n","        # degree_list = literal_eval(config.loc_set.zone.degree_list)\n","        # if len(degree_list) != 0:\n","        # # if selection_id in ['v3_3', 'v3_4']:\n","        #   norm_close_15 = res_df['norm_close_15'].to_numpy()   # -> 이거 뭘로 만들었는지 불분명함,,\n","        #   b1_norm_close_15 = res_df['norm_close_15'].shift(15).to_numpy()\n","\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     mr_res *= norm_close_15 <= -degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 <= -degree_list[1]\n","        #   else:\n","        #     mr_res *= norm_close_15 >= degree_list[0]\n","        #     # mr_res *= b1_norm_close_15 >= degree_list[1]\n","\n","        # ------ b. dc ------ #\n","        # if selection_id in ['v3_3']:\n","        #   if ep_loc_side == OrderSide.SELL:\n","        #     dc_lower_ = res_df['dc_lower_1m'].to_numpy()\n","        #     b1_dc_lower_ = res_df['dc_lower_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_lower_ < b1_dc_lower_\n","        #   else:\n","        #     dc_upper_ = res_df['dc_upper_1m'].to_numpy()\n","        #     b1_dc_upper_ = res_df['dc_upper_1m'].shift(1).to_numpy()\n","        #     mr_res *= dc_upper_ > b1_dc_upper_\n","\n","        # ------ c. sar ------ #\n","        # if selection_id in ['v3_3']:\n","        # sar_uptrend_3T = res_df['sar_uptrend_3T'].to_numpy()\n","        # if ep_loc_side == OrderSide.SELL:\n","        #   mr_res *= sar_uptrend_3T == 0\n","        # else:\n","        #   mr_res *= sar_uptrend_3T == 1"],"metadata":{"id":"csZwxsP5r_Pz"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"JjKHyqftzhD7"},"source":["### set config (override available)"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"q_4E-zH02WJy","executionInfo":{"status":"ok","timestamp":1654265148785,"user_tz":-540,"elapsed":5,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["#     caution : MARKET / LIMIT spelling   #\n","#      json doesn't support single quotes     #\n","\n","param_dict = {\n","  \"selection_id\": \"5_45\",\n","  \"trader_set\": {\n","    \"backtrade\": 0,\n","    \"back_data_path\": \"C:\\\\Users\\\\Lenovo\\\\PycharmProjects\\\\System_Trading\\\\JnQ\\\\candlestick_concated\\\\database_bn\\\\2022-02-17\\\\2022-02-17 ETHUSDT_1m.ftr\",\n","    \"start_datetime\": \"2020-09-05 00:00:59.999\",\n","    \"run\": 1,\n","    \"df_log\": 0,\n","    \"latest_index\": -1,\n","    \"complete_index\": -2,\n","    \"limit_fee\": 1e-10,\n","    \"market_fee\": 1e-10,\n","    \"initial_asset\": 24500,\n","    \"asset_changed\": 0,\n","    \"symbol\": \"ETHUSDT\",\n","    \"symbol_changed\": 0,\n","    \"itv_list\": \"['T', '3T', '5T', '15T', '30T', 'H', '4H']\",\n","    \"row_list\": \"[100, 50, 1, 1, 1, 50, 1]\",\n","    \"rec_row_list\": \"[1, 1, 1, 1, 1, 1, 1]\",\n","    \"offset_list\": \"['1h', '1h', '1h', '1h', '1h', '1h', '1h']\",\n","    \"bar_close_second\": 59,\n","    \"realtime_term\": 0.01,\n","    \"order_term\": 0.25,\n","    \"api_retry_term\": 1,\n","    \"check_entry_sec\": 10,\n","    \"entry_execution_wait\": 60,\n","    \"breakout_qty_ratio\": 0.97,\n","    \"qty_check_term\": 30,\n","    \"exit_execution_wait\": 60,\n","    \"close_complete_term\": 5,\n","    \"save_stacked_df\": 0,\n","    \"stacked_df_exist\": 1\n","  },\n","  \"pos_set\": {\n","    \"short_inversion\": 0,\n","    \"long_inversion\": 0,\n","    \"short_ban\": 0,\n","    \"long_ban\": 0\n","  },\n","  \"loc_set\": {      \n","    \"point1\": {\n","      \"exp_itv\": \"5T\",\n","      \"tf_entry\": \"15T\",\n","      \"candle_pattern\": \"CDLMARUBOZU\",\n","      \"short_spread\": \"None\",\n","      \"long_spread\": \"None\",\n","      \"short_tr_thresh\": \"None\",\n","      \"long_tr_thresh\": \"None\",\n","      \"short_wick_ratio\": \"None\",\n","      \"long_wick_ratio\": \"None\",\n","      \"wick_itv\": \"5T\",\n","      \"cu_wrr_21\": \"None\",\n","      \"co_wrr_21\": \"None\",\n","      \"wrr_32\": 0.3,\n","      \"co_es\": \"None\",\n","      \"cu_es\": \"None\",\n","      \"crr\": \"None\",\n","      \"cppr\": \"None\",\n","      \"ppr\": \"None\",\n","      \"wbr\": \"None\",\n","      \"dbr\": \"None\",\n","      \"dbr2\": \"None\",\n","      \"brr\": \"None\",\n","      \"ir\": \"None\",\n","      \"abs_ratio\": \"None\"\n","    },\n","    \"point2\": {\n","      \"wrr_32\": 0.3,\n","    },\n","    \"zone\": {\n","      \"use_zone\": 0,\n","      \"base_roll_period\": 50,\n","      \"degree_list\": \"[]\",\n","      \"dtk_itv\": \"5T\",\n","      \"dt_k\": \"None\",\n","      \"dc_period\": 135,\n","      \"use_dtk_line\": 0,\n","      \"zone_dt_k\": 0.4,\n","      \"zone_dc_period\": 135\n","    }\n","  },\n","  \"tr_set\": {\n","    \"check_hlm\": 0,\n","    \"wave_itv1\" : 'T',\n","    \"wave_period1\": 30,\n","    \"wave_itv2\" : 'T',    \n","    \"wave_period2\": 30,\n","    \"wave_greater1\": 0,\n","    \"wave_greater2\": 0,\n","    \"wave_lesser1\": 2,\n","    \"wave_lesser2\": 2,\n","    \"expire_k1\": 0.0,\n","    \"expire_k2\": 0.0,\n","    \"expire_tick\": \"None\",\n","    \"p2_box_k1\" : 0,\n","    \"p2_box_k2\" : 0,\n","    \"tp_gap\": 0.0,\n","    \"ep_gap1\": -0.12,\n","    \"ep_gap2\": -0.12,\n","    \"out_gap\": 0,\n","    \"decay_gap\": \"None\",\n","    \"c_ep_gap\": \"None\",\n","    \"t_out_gap\": \"None\",\n","    \"wb_tp_gap\": 0,\n","    \"wb_out_gap\": 0,\n","    \"bias_info_tick\": 30000\n","  },\n","  \"ep_set\": {\n","    \"entry_type\": \"LIMIT\",\n","    \"static_ep\": 1,\n","    \"point2\": {\n","      \"use_point2\": 0,\n","      \"entry_type\": \"MARKET\"\n","    }\n","  },\n","  \"tp_set\": {\n","    \"non_tp\": 0,\n","    \"static_tp\": 1,\n","    \"tp_onexec\": 0,\n","    \"decay_term\": 60,\n","    \"p_ranges\": \"[1]\",\n","    \"p_qty_ratio\": \"[1]\"\n","  },\n","  \"out_set\": {\n","    \"hl_out\": 1,\n","    \"static_out\": 1,\n","    \"out_onexec\": 0,\n","    \"tf_exit\": \"None\",\n","    \"rsi_exit\": 0\n","  },\n","  \"lvrg_set\": {\n","    \"leverage\": 2,\n","    \"static_lvrg\": 0,\n","    \"allow_float\": 0,\n","    \"target_pct\": 0.03,\n","    \"lvrg_rejection\": 0\n","  }\n","}\n","\n","config = EasyDict(param_dict)"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"MuD_2vY7TI_8"}},{"cell_type":"code","source":[",\n","      \"hc_itv\": 60,\n","      \"osc_band\": 20\n","      \n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"[]\",,\n","\n","      \"wick_score_list\": \"[]\",\n","      \"body_score_list\": \"[]\",\n","      \"score_itv_list\": \"['T']\""],"metadata":{"id":"EKag94Y2TMCO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"rLI8unIyroiC"},"source":["## run"]},{"cell_type":"code","execution_count":8,"metadata":{"id":"qBJfPsmJzVIr","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1654265148786,"user_tz":-540,"elapsed":5,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"123d255a-5d66-4a43-8787-5e44d09d2460"},"outputs":[{"output_type":"stream","name":"stdout","text":["\"5_45\" {\n"," \"point1\": {\n","  \"exp_itv\": \"5T\",\n","  \"tf_entry\": \"15T\",\n","  \"candle_pattern\": \"CDLMARUBOZU\",\n","  \"short_spread\": \"None\",\n","  \"long_spread\": \"None\",\n","  \"short_tr_thresh\": \"None\",\n","  \"long_tr_thresh\": \"None\",\n","  \"short_wick_ratio\": \"None\",\n","  \"long_wick_ratio\": \"None\",\n","  \"wick_itv\": \"5T\",\n","  \"cu_wrr_21\": \"None\",\n","  \"co_wrr_21\": \"None\",\n","  \"wrr_32\": 0.3,\n","  \"co_es\": \"None\",\n","  \"cu_es\": \"None\",\n","  \"crr\": \"None\",\n","  \"cppr\": \"None\",\n","  \"ppr\": \"None\",\n","  \"wbr\": \"None\",\n","  \"dbr\": \"None\",\n","  \"dbr2\": \"None\",\n","  \"brr\": \"None\",\n","  \"ir\": \"None\",\n","  \"abs_ratio\": \"None\"\n"," },\n"," \"point2\": {\n","  \"wrr_32\": 0.3\n"," },\n"," \"zone\": {\n","  \"use_zone\": 0,\n","  \"base_roll_period\": 50,\n","  \"degree_list\": \"[]\",\n","  \"dtk_itv\": \"5T\",\n","  \"dt_k\": \"None\",\n","  \"dc_period\": 135,\n","  \"use_dtk_line\": 0,\n","  \"zone_dt_k\": 0.4,\n","  \"zone_dc_period\": 135\n"," }\n","} {\n"," \"check_hlm\": 0,\n"," \"wave_itv1\": \"T\",\n"," \"wave_period1\": 30,\n"," \"wave_itv2\": \"T\",\n"," \"wave_period2\": 30,\n"," \"wave_greater1\": 0,\n"," \"wave_greater2\": 0,\n"," \"wave_lesser1\": 2,\n"," \"wave_lesser2\": 2,\n"," \"expire_k1\": 0.0,\n"," \"expire_k2\": 0.0,\n"," \"expire_tick\": \"None\",\n"," \"p2_box_k1\": 0,\n"," \"p2_box_k2\": 0,\n"," \"tp_gap\": 0.0,\n"," \"ep_gap1\": -0.12,\n"," \"ep_gap2\": -0.12,\n"," \"out_gap\": 0,\n"," \"decay_gap\": \"None\",\n"," \"c_ep_gap\": \"None\",\n"," \"t_out_gap\": \"None\",\n"," \"wb_tp_gap\": 0,\n"," \"wb_out_gap\": 0,\n"," \"bias_info_tick\": 30000\n","} {\n"," \"entry_type\": \"LIMIT\",\n"," \"static_ep\": 1,\n"," \"point2\": {\n","  \"use_point2\": 0,\n","  \"entry_type\": \"MARKET\"\n"," }\n","} {\n"," \"non_tp\": 0,\n"," \"static_tp\": 1,\n"," \"tp_onexec\": 0,\n"," \"decay_term\": 60,\n"," \"p_ranges\": \"[1]\",\n"," \"p_qty_ratio\": \"[1]\"\n","} {\n"," \"hl_out\": 1,\n"," \"static_out\": 1,\n"," \"out_onexec\": 0,\n"," \"tf_exit\": \"None\",\n"," \"rsi_exit\": 0\n","} {\n"," \"leverage\": 2,\n"," \"static_lvrg\": 0,\n"," \"allow_float\": 0,\n"," \"target_pct\": 0.03,\n"," \"lvrg_rejection\": 0\n","} "]}],"source":["# funcs = [expire_v2, ep_loc_point2_v2, lvrg_set]  # expire for p1 & p2\n","funcs = [expiry_p1, expiry_p2, lvrg_set]     # expire for p1-only\n","# funcs = [expire_v0, ep_loc_point2_v2, lvrg_set]  # expire for v3\n","\n","id_idx_list = [0]  # ID_arr 에서 import 할 id_idx 선택\n","public_override = 1\n","utils_override = 1\n","config_override = 1\n","\n","# ------ config_list 와 같은 org_var 에 override 하는거 다시 생각하기 ------ #\n","ID_list = ID_arr[id_idx_list]\n","utils_list = utils_arr[id_idx_list]\n","config_list = config_arr[id_idx_list]\n","\n","if config_override or utils_override:\n","  assert len(config_list) == 1\n","  if config_override:    \n","    config_list[0] = config\n","    ID_list[0] = config.selection_id\n","  \n","config = config_list[0]  # base config = config_list[0]\n","tp_fee, out_fee = calc_tp_out_fee_v2(config)   # -> rev_pr 때문에 일단 이곳에도 선언함\n","\n","# ------- inversion set ------- #\n","inversion = 0\n","fdist_thresh = 1\n","# ------- plot param ------- #\n","show_detail = 0\n","# ------- temp param ------- #\n","allow_osc_touch = 0\n","rsi_gap = 5\n","\n","# ------- just printing config ------- #\n","_ = [print(json.dumps(config[key_], indent=1), end=' ') for key_ in ['selection_id', 'loc_set', 'tr_set', 'ep_set', 'tp_set', 'out_set', 'lvrg_set']] #  'trader_set',"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"afUV2b1jaggN"},"outputs":[],"source":["# config.trader_set.start_datetime = \"2020-09-05 00:00:59.999\" #  \"2020-09-05 00:00:59.999\" # 2022-02-01 16:34:59.999000 2022-01-14 16:34:59.999000  \"2020-09-05 00:00:59.999\" \"2022-01-10 00:00:59.999\" \"2021-10-04 02:39:59.999000\"\n","config_list[0].tr_set.wave_itv1 = 'T'\n","config_list[0].tr_set.wave_period1 = 20\n","config_list[0].tr_set.wave_itv2 = 'T'\n","config_list[0].tr_set.wave_period2 = 20"]},{"cell_type":"code","execution_count":9,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2181,"status":"ok","timestamp":1654265150964,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"WstWVNihCNH8","outputId":"b3c08ef4-519c-425d-acf4-f0e240f17f22"},"outputs":[{"output_type":"stream","name":"stdout","text":["public_indi elapsed time : 0.9049303531646729\n","make data_list elapsed time : 0.00017333030700683594\n"]}],"source":["# ------ slicing res_df ------ #\n","res_df = res_df_.loc[pd.to_datetime(config.trader_set.start_datetime):]\n","\n","np_timeidx = np.array([intmin_np(date_) for date_ in res_df.index.to_numpy()])\n","\n","# ------------ public_indi ------------ # - 딱히 반복될 이유가 없는 phase - annot. 달때, why 까지 적어주면 좋음\n","start_0 = time.time()\n","if public_override:\n","    res_df = public_indi(res_df, config_list[0], np_timeidx)  # 현재 대부분의 시간은 h_candle 에서 소비되고 있음\n","else:\n","    res_df = utils_public.public_indi(res_df, config_list[0], np_timeidx)\n","print(\"public_indi elapsed time :\", time.time() - start_0)\n","\n","# ------------ make data_list ------------ # - 반복될 이유가 없는 phase - public_indo 에 종속\n","start_0 = time.time()\n","ohlc_cols = ['open', 'high', 'low', 'close']\n","ohlc_list = [res_df[col_].to_numpy() for col_ in ohlc_cols]\n","print(\"make data_list elapsed time :\", time.time() - start_0)"]},{"cell_type":"markdown","metadata":{"id":"RqRF1eyZ0xBL"},"source":["### idep_plot"]},{"cell_type":"code","execution_count":10,"metadata":{"id":"_iYcJk8nK8Yq","executionInfo":{"status":"ok","timestamp":1654265150965,"user_tz":-540,"elapsed":4,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit utils config ------ #\n","config_list[0].tr_set.check_hlm = 1\n","# config_list[0].loc_set.point.candle_pattern = talib.get_function_groups()['Pattern Recognition'][51]   # \"None\" # 0.5 0.7\n","# config_list[0].pos_set.short_ban = 0\n","# config_list[0].tr_set.wave_lesser = 3\n","# config_list[0].tr_set.wave_greater1 = 0\n","# config_list[0].tr_set.wave_greater2 = 0\n","# config_list[0].tr_set.p1_period1 = 5\n","# config_list[0].tr_set.p1_period2 = 5\n","# # config_list[0].tr_set.p2_period1 = 20\n","# # config_list[0].tr_set.p2_period2 = 20\n","# config_list[0].ep_set.entry_type = \"LIMIT\" # \"LIMIT\" # \"MARKET\"\n","# config_list[0].tr_set.tp_gap = 0.5\n","# config_list[0].tr_set.ep_gap1 = -0.65 # -0.618 -0.23 -0.382 0.19 0.8 -0.12\n","# config_list[0].tr_set.ep_gap2 = -0.12 # -0.618 -0.23 -0.382 0.19 \n","# config_list[0].tr_set.out_gap = 0\n","# config_list[0].tr_set.wb_tp_gap = 0.5\n","# config_list[0].tr_set.wb_out_gap = -0.5\n","# config_list[0].tr_set.bias_info_tick = 30000\n","# config_list[0].trader_set.limit_fee = 1e-10 # 1e-10  0.0002  # utils 로 이곳에 배치\n","# config_list[0].trader_set.market_fee = 1e-10 # 1e-10  0.0004\n","\n","# config_list[0].loc_set.point.short_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.long_wick_ratio = 0.2 # \"None\" # 2.5\n","# config_list[0].loc_set.point.crr = 0.5"]},{"cell_type":"code","execution_count":11,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":423,"status":"ok","timestamp":1654265151706,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"iI39YI_5GguK","outputId":"8b9553e9-72ce-4571-acb8-bbebba939843"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32838\n","np.sum(short_open_res2 == 1) : 32874\n","np.sum(long_open_res2 == 1) : 32843\n"]},{"output_type":"stream","name":"stdout","text":["enlist_tr elapsed time : 0.33233141899108887\n"]}],"source":["if utils_override:   # 현재, utils_override 하는 경우 1개의 ID 만 허용함 \n","  # start_0 = time.time()\n","  # res_df = enlist_rtc(res_df, config_list[0], np_timeidx)\n","  # print(\"enlist_rtc elapsed time :\", time.time() - start_0)\n","  start_0 = time.time()\n","  res_df = enlist_tr(res_df, config_list[0], np_timeidx)    # 36995.0 -> 152766.0 # 4044 np.sum(long_open_res == 1) : 4325\n","  print(\"enlist_tr elapsed time :\", time.time() - start_0)\n","else:\n","    start_0 = time.time()\n","    for utils_, config_ in zip(utils_list, config_list):\n","        # res_df = utils_.enlist_rtc(res_df, config_, np_timeidx)\n","        res_df = utils_.enlist_tr(res_df, config_, np_timeidx)\n","    print(\"elapsed time :\", time.time() - start_0)"]},{"cell_type":"code","execution_count":12,"metadata":{"id":"gfDSOGMd91rE","executionInfo":{"status":"ok","timestamp":1654265153514,"user_tz":-540,"elapsed":2,"user":{"displayName":"7th June","userId":"08178289703395036410"}}},"outputs":[],"source":["# ------ edit loc_set config ------ #\n","config_list[0].loc_set.point1.cu_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.co_wrr_21 = \"None\" # \"None\" 5 2.5\n","config_list[0].loc_set.point1.wrr_32 = 0.3 # \"None\" 1 0.5 0.382 0.302\n","config_list[0].loc_set.point2.wrr_32 = 0.4 # \"None\" 1 0.5 0.382 0.302 0.25\n","# config_list[0].loc_set.zone.hl_loc_pct = \"None\" # \"None\" 1 0.5\n","# config_list[0].loc_set.point1.cu_es = \"None\" # \"None\" # -2\n","# config_list[0].loc_set.point1.co_es = \"None\" # \"None\" # -3\n","# config_list[0].loc_set.point1.cppr = 0.5   # \"None\" # 0.5 0.7\n","# config_list[0].loc_set.point1.wbr = \"None\" # 0.7\n","# config_list[0].loc_set.point1.dbr = \"None\"   # 0.7\n","# config_list[0].loc_set.point1.dbr2 = \"None\"  # 0.7\n","# config_list[0].loc_set.point1.brr = \"None\"   # 0.8\n","# config_list[0].loc_set.point1.ir = \"None\" # \"None\" 0.8\n","# config_list[0].loc_set.point1.wick_score_list = \"[]\"\n","# config_list[0].loc_set.point1.score_itv_list = \"['H']\"\n","# # config_list[0].loc_set.point1.abs_ratio = \"None\"  # 0.7\n","config_list[0].loc_set.point1.short_tr_thresh = \"None\"  #  \"None\" 0.5 2 0.8 # # 0.7 # tr_thresh 엄청 민감함\n","config_list[0].loc_set.point1.long_tr_thresh = 0.5  #  \"None\" 2 0.8 ## 0.7\n","# config_list[0].loc_set.zone.use_zone = 0\n","# # config_list[0].loc_set.zone.base_roll_period = 60"]},{"cell_type":"code","execution_count":13,"metadata":{"executionInfo":{"elapsed":2276,"status":"ok","timestamp":1654265156789,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"9DPgykxQ92mU","colab":{"base_uri":"https://localhost:8080/"},"outputId":"70ae3f4c-5250-45ad-d37e-c4e83d993969"},"outputs":[{"output_type":"stream","name":"stderr","text":["cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.199404001235962\n"]},{"output_type":"stream","name":"stderr","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.0435888767242432\n"]}],"source":["open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=2)\n","open_info_df_list = [open_info_df1, open_info_df2]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KqVkg236t_f2"},"outputs":[],"source":["# ------ edit entry & exit (ep, tp, out, ..) config ------ #\n","# config_list[0].tr_set.expire_k = -0.5\n","# config_list[0].tr_set.expire_tick = \"None\"\n","# config_list[0].loc_set.tr_set.p2_box_k1 = 0\n","# config_list[0].tr_set.p2_box_k2 = 0.0\n","# # # config_list[0].ep_set.point2.use_point2 = 1\n","# # # config_list[0].ep_set.point2.entry_type = \"LIMIT\"\n","# # # config_list[0].ep_set.point2.wick_score_list = str([])\n","# # # config_list[0].tp_set.static_tp = 1\n","# # # config_list[0].tp_set.non_tp = 0 # 0 1\n","# config_list[0].tp_set.p_ranges = \"[1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[1]\"\n","# config_list[0].tp_set.p_ranges = \"[0.2, 0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.25, 0.25, 0.5]\"\n","# config_list[0].tp_set.p_ranges = \"[0.66, 1]\"\n","# config_list[0].tp_set.p_qty_ratio = \"[0.3, 0.7]\"\n","# # # config_list[0].out_set.hl_out = 1\n","# # # config_list[0].out_set.tf_exit = \"None\" # 15 \"None\"\n","# config_list[0].lvrg_set.leverage = 1\n","# config_list[0].lvrg_set.static_lvrg = 0\n","# config_list[0].lvrg_set.target_pct = 0.03\n","# # config_list[0].lvrg_set.allow_float = 0\n","# config_list[0].lvrg_set.lvrg_rejection = 0"]},{"cell_type":"code","execution_count":14,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":646},"executionInfo":{"elapsed":2477,"status":"ok","timestamp":1654265159263,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"id":"HHq6cr9GPBot","outputId":"6180841d-4e1c-48a4-949b-ffc0047e2adf"},"outputs":[{"output_type":"stream","name":"stdout","text":["en_ex_pairing elapsed time : 0.29639220237731934\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 6 Axes>"],"image/png":"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EREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVmZVU7MTp48GVlZWdBoNFi0aJE1piQiIuoRmLFERESdj/lKRETW0OUnZu3s7PD5558jIiICDzzwAKZPn47777+/q6clIiK67TFjiYiIOh/zlYiIrKXLT8yOHDkSOTk5yMvLw/Xr17Fjxw5Mmzatq6clIiK67TFjiYiIOh/zlYiIrMWhqyfw8/NDQUGBcrmwsBChoaEt9ps3bx7mz58PAOjXrx8Q0s4JxndgH9PLXp0wR3u1NtbN5jB3fWf2BbT9OLR3rtb2Mx17fCt/b89YHX0MzfXR3ts7tmPsjjyHXTFGV8xryb4dXSs3Ow5vRVvrrbV+zf2zVUfGae/15u7/ra5pS297K8dWe25jSa9tzZloYS+3sfZkrFG+VvQDgtsYsCPPteHz2tGs6srjvy2dnaOdqT25Q22z5vN7qz8nGbrV40HN6/pW3Mr96q7XGKB7no/W7u/4duzDjAXQwfewhTfJ2FvVnevYVvEbdaiz8eczuhWtZKxqXqrWrVuHkJAQhISEoLy8vLvbISIiui0wX4mIiLoGM5aIiG5Vl//GbFFREQICApTL/v7+KCoqavM2gwcPRmKibf1zbb9+/WwyjG2xb1vsGWDf1mSLPQPsu70CAwOtNpfaWZqxtpivAI8Na7LFngHb7NsWewbYtzV1R8/M2GY95T0swGPDmmyxb1vsGWDf1mSLPQPqy1jpyrK3t5fc3FwJCgoSR0dHSUlJkQceeKDN2yQmJnZpT11RttizrfZtiz2zb/bMvlldUZZmrK0+V+ybPd+Ofdtiz+ybPfeU6invYW21b1vs2Vb7tsWe2Td7trW+u/w3ZpuamvDHP/4R3333Hezt7fHll1/i7NmzXT0t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BWDb+QrYTsYyX627Rpix1uub+dpzqClfAXUfF3rMWGbszTBjrbu2bSlfgdszY1VzYjYxMRGDBg1CUFAQHB0dERUVhf3793dbP/v378fs2bMBALNnz8a3336rbNd/y1xoaCi0Wi1KSkrw3XffITw8HJ6envD09ER4eDi+++47lJSUoLq6GqGhoQCav63OcCxzc7TX+vXrkZmZiU8++cQm+u7Xrx/69u0LAOjduzcmTZqEzMxMHDt2DJGRkWZ71s8TGRmJuLg4ZXtUVBScnJwQFBSEQYMG4fTp022uodbmaI8lS5YgICAAwcHBiIqKQlxcHGbOnKn6vl1cXODm5qb8PTw8HBkZGapeI5cvX0ZBQQHuvfdeAMCECRNw9uxZVfdsaPr06cp/AWlrTLX0nZ+fj1GjRqFPnz4Afn281b62yXJqyli1HxeA7eUrYJsZy3y17hphxlqvb+Zrz6GmfAXUfVzoMWOZsW1hxlr/mLSlfAVu34ztlA+r7YyKiIiQc+fOSU5OjixZssRq827btk0uXbok165dk4KCApk7d67ccccdcvToUcnOzpbvv/9evLy8lP0/++wzycnJkbS0NBkxYoSyfc6cOaLRaESj0cjzzz+vbB8xYoSkp6dLTk6OrF69Wtne1hw3q7CwMBERSU1NleTkZElOTpaIiAhV9/3www9LUlKSpKamSnp6uixdulQASHBwsCQkJIhGo5GdO3eKk5OTABBnZ2fZuXOnaDQaSUhIkODgYGWsJUuWSE5OjmRlZSnf7NfWGmptDktr3Lhxygenq73v4OBgSUlJkZSUFMnIyFDGVfMaASBDhgyRxFvTNfYAAADsSURBVMRESU1NlX379omnp6fqewYgLi4uUl5eLh4eHu0aUy19L1++XDIzMyU9PV2++uorcXJyUv3aZnWsuiNjma/W69vWM5b5ap3XfGas9fpmvvac4ntYZqzaj2lmLDO2tbLFfAVuv4zt9ctfiIiIiIiIiIiIiMhKVPNRBkREREREREREREQ9BU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVkZT8wSERERERERERERWRlPzBIRERERERERERFZGU/MEhEREREREREREVnZ/wORWsDOmqB8FQAAAABJRU5ErkJggg==\n"},"metadata":{}}],"source":["test_ratio = 0.0\n","short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_bias_arr, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","      long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_bias_arr, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0 = \\\n","get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=0, show_detail=0)   # open 이 많을 수록 en_ex_pairing elapsed time : 11.58370590209961"]},{"cell_type":"code","source":["~# ------ inversion ------ #\n","_ = get_res_v5(res_df, open_info_df, ohlc_list, config_list, np_timeidx, funcs, inversion=True, test_ratio=test_ratio, plot_is=1, signi=False)"],"metadata":{"id":"8lYgsqH-rfAM"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"n6gc7lERC4VE"},"source":["### statistics (stem 별로 진행)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"HHjIdn2MC4VE"},"outputs":[],"source":["selection_id = config.selection_id\n","\n","short_p1_idx = short_obj[-1].astype(int)\n","long_p1_idx = long_obj[-1].astype(int)\n","\n","short_open_tp_1 = res_df['short_tp_1_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_1 = res_df['long_tp_1_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_0 = res_df['short_tp_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_tp_0 = res_df['long_tp_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_tp_gap = res_df['short_tp_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_tp_gap = res_df['long_tp_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_0 = res_df['short_out_0_{}'.format(selection_id)].to_numpy()[short_p1_idx]\n","long_open_out_0 = res_df['long_out_0_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","short_open_out_gap = res_df['short_out_gap_{}'.format(selection_id)].to_numpy()[short_p1_idx]  # use open_i\n","long_open_out_gap = res_df['long_out_gap_{}'.format(selection_id)].to_numpy()[long_p1_idx]\n","\n","# ------ out case 의 max_high check (long) ------ #\n","short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_tp_gap)\n","long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_tp_gap)\n","# short_max_tpg = get_max_tpg_v2(\"SELL\", ohlc_list, short_pr, short_obj[:4], short_open_tp_1, short_open_out_gap)\n","# long_max_tpg = get_max_tpg_v2(\"BUY\", ohlc_list, long_pr, long_obj[:4], long_open_tp_1, long_open_out_gap)\n","\n","# ------ true_bias 의 outg 확인 ------ #\n","short_max_outg = get_max_outg_v4(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_tp_0, short_open_tp_gap)\n","long_max_outg = get_max_outg_v4(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_tp_0, long_open_tp_gap)\n","\n","current_tpg = config.tr_set.tp_gap\n","current_outg = config.tr_set.out_gap"]},{"cell_type":"markdown","source":["#### consecutive dur. value survey on bias"],"metadata":{"id":"tOFkzUX2imQu"}},{"cell_type":"code","source":["res_df.dtypes"],"metadata":{"id":"CgvSrXaZEkMZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gnSvYKIzC4VF"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols, public_cols = [], []\n","\n","devided_cols.append('tr_{}'.format(selection_id))\n","\n","wave_itv1 = 'T'\n","wave_period1 = config.tr_set.wave_period1\n","\n","# public_cols.append('cu_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('cu_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","# public_cols.append('co_wrr_21_{}{}'.format(wave_itv1, wave_period1))\n","public_cols.append('co_wrr_32_{}{}'.format(wave_itv1, wave_period1))\n","\n","# public_cols.append('wave_high_terms_cnt_fill_T5')\n","# public_cols.append('wave_low_terms_cnt_fill_T5')\n","# public_cols.append('wave_high_loc_pct_T5')\n","# public_cols.append('wave_low_loc_pct_T5')\n","\n","# public_cols.append('b1_co_es_15T1')\n","# public_cols.append('b1_cu_es_15T1')\n","# public_cols.append('b1_upper_wick_ratio_15T')\n","# public_cols.append('b1_lower_wick_ratio_15T')\n","\n","#  'co_wrr_T5', 'cu_wrr_T5', 'b1_cppr_15T', 'b1_updbr', 'b1_lwdbr', 'b1_updbr_cppr', 'b1_lwdbr_cppr' 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","# devided_cols = ['tr_{}'.format(selection_id)]  # , 'ir_5T'\n","# public_cols = ['wave_high_terms_cnt_fill_T5', 'wave_low_terms_cnt_fill_T5', 'wave_high_loc_pct_T5', 'wave_low_loc_pct_T5', \n","#                'b1_co_es_15T1', 'b1_cu_es_15T1', 'b1_upper_wick_ratio_15T', 'b1_lower_wick_ratio_15T']\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","source":["plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(14, len(titles) * 5))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","num_samples = 30\n","alpha = 0.8\n","xmin = 0\n","xmax = 10\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=2, ncols=2)\n","\n","  short_open_data = short_data[short_p1_idx]\n","  long_open_data = long_data[long_p1_idx]\n","\n","  short_true_data = short_open_data[short_bias_arr.ravel()]\n","  # short_false_data = short_open_data[short_false_bias_arr.ravel()]\n","  short_false_data = short_open_data[~short_bias_arr.ravel()]\n","  long_true_data = long_open_data[long_bias_arr.ravel()]\n","  # long_false_data = long_open_data[long_false_bias_arr.ravel()]\n","  long_false_data = long_open_data[~long_bias_arr.ravel()]\n","  \n","  short_true_valid_idx = np.ones_like(short_true_data).astype(bool)\n","  short_false_valid_idx = np.ones_like(short_false_data).astype(bool)\n","  long_true_valid_idx = np.ones_like(long_true_data).astype(bool)\n","  long_false_valid_idx = np.ones_like(long_false_data).astype(bool)\n","\n","  short_true_valid_idx *= ~np.isinf(short_true_data)\n","  short_false_valid_idx *= ~np.isinf(short_false_data)\n","  long_true_valid_idx *= ~np.isinf(long_true_data)\n","  long_false_valid_idx *= ~np.isinf(long_false_data)\n","\n","  try:\n","    short_true_valid_idx *= short_true_data > xmin\n","    short_false_valid_idx *= short_false_data > xmin\n","    long_true_valid_idx *= long_true_data > xmin\n","    long_false_valid_idx *= long_false_data > xmin\n","\n","  except:\n","    pass\n","\n","  try:\n","    short_true_valid_idx *= short_true_data < xmax\n","    short_false_valid_idx *= short_false_data < xmax\n","    long_true_valid_idx *= long_true_data < xmax\n","    long_false_valid_idx *= long_false_data < xmax\n","    \n","  except:\n","    pass\n","    \n","  plt.subplot(inner_gs[0])\n","  ns, bins, patches = plt.hist([short_true_data[short_true_valid_idx], short_false_data[short_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')  \n","  plt.title('short_' + title)  \n","\n","  plt.subplot(inner_gs[2])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","  \n","\n","  plt.subplot(inner_gs[1])\n","  ns, bins, patches = plt.hist([long_true_data[long_true_valid_idx], long_false_data[long_false_valid_idx]], \n","           bins=num_samples, alpha=alpha, color=['#00ff00', '#ff0000'], edgecolor='black')\n","  plt.title('long_' + title)\n","  \n","  plt.subplot(inner_gs[3])\n","  total_ns = np.sum(ns, axis=0)\n","  hist_ratio = ns[0] / total_ns\n","  # valid_idx = total_ns > 1\n","  valid_idx = np.full(len(hist_ratio), True)\n","  valid_hist_ratio = hist_ratio[valid_idx]\n","  plt.hist(bins[:-1][valid_idx], weights=valid_hist_ratio, bins=num_samples, color='#00ff00', edgecolor='black')\n","  plt.ylim(0, 1)\n","\n","  \n","# plt.suptitle(title)\n","plt.show()"],"metadata":{"id":"Sahvc-R0jD1A","colab":{"base_uri":"https://localhost:8080/","height":968},"executionInfo":{"status":"ok","timestamp":1653807810574,"user_tz":-540,"elapsed":3342,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"6b83ac35-819d-487b-bf38-42144ad04c3b"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  return asarray(a).size\n","/usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1008x1080 with 12 Axes>"],"image/png":"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a7311lu1vu7ChQtas2aN5syZo5YtW6p3796aNGmSS3MWFRXpuuuuq1O8gwYNUq9evdSsWTN17NhRf/zjH7V582adOnWq2te899576t69u/r376/+/fvr17/+tdLT09W/f39duHChTmMC3kDhg0ajV69eGj58uIKCgvTtt9/qm2++0YULF2p8zY4dO3TmzBnNmDFDAQEBio2N1dixY5WSklLta4qLi11OGO70vVLfvn3Vr18/+fn5qXXr1nrxxRdVUFCgrKysal+TmZmpiIgIZ3J5+OGHVVxcrP79+ysvL69OYwIAvOf555/XP//5T33xxRfKyMjQzp079fzzz7v02qlTp6p9+/YqKirS0qVLtWLFCpdOV5szZ46Sk5N14sQJ/fjHP3Yr3uuuu07vv/++ysrKlJmZqbNnz1Y6Pbwq586dU3FxsbOVlpbq/PnzKi4urvOYgLdYfqERjeZK+973vmd27NhhTp06ZY4dO2bWr19vunTpYmbPnm2WLl3q7HdpgYFLF4v27dvXfPzxx+bkyZNmz549Zty4cc6+VS1k0LNnT5Oenm5OnDhh1q5dW2NMd999t8nNzTUnTpwwTzzxxFVz19SGDx9u9u3bZ8rLy01xcbFZu3at6dmzp1v75MrFDTwxJo1Go9F8s82bN88sWbLE8jhotMbamv37fwAAAOBDevfuraCgIGVkZCg6OlobNmzQww8/rHXr1lkdGtAocaobAACAD2rbtq3WrFmj06dP6+2339aLL76odevW6bbbblNZWVmVzRVPPfVUla/dsGFDja+rbs7bbrvNE28X8DqO+AA1iIiI0N69e6t8rm/fvrWu3jZx4kS9/vrrVz2em5urm266qdrXZWZmVrlYwc9//nMtX768lqgBAABwJQofAAAAALYXYHUAklRSUlLp5l4AgIYXGRmpa6+91uowfBJ5CgCsV9885ROFT25urqKjo60OAwCaNIfDYXUIPos8BQDWq2+eYnEDAAAAALZH4QMAAADA9ih8AAAAANgehQ8AAAAA2/OJxQ2anHaSgi7bPifplEWxAAAaL/IJALiMwscKQZLeu2w7zqpAAACNGvkEAFzGqW4AAAAAbI/CBwAAAIDtcaqbr+P8bQAAAKDeKHx8HedvAwB8GV/QAWgkKHwAAEDd8QUdgEaCa3wAAAAA2B6FDwAAAADb41Q3AACaAneuxeG6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icIHHrdixQoNHTrUec3M/Pnza+xfWFioiIgINWvWzPlYt27dKn1g1vVDOi8vT926davyup36JpdLhY87ycWd2K8UGBhYKVGOGjVKSUlJGjt2rDIzM+s0Zk0uTy779+9XQEBApYtYSS4A7GLFihV69tlnFRISok6dOunXv/613nrrrVpfd+HCBa1Zs0Zz5sxRy5Yt1bt3b02aNKnW17377rvq0qWLHnvsMQUFBalNmzYaNGiQJGnXrl2666671KFDB3Xu3Nl5dkRttmzZouHDh6tly5YqKCjQ1q1bNXr0aHXq1Enp6ekujVGbkSNHqn///vLz81Pbtm310ksv6cSJE8rKypIkTZw4US+88ILuvPNO5eTkeGTOyZMn65prrpF0cTntp556ynk9VHZ2tnbt2qXZs2erefPmGjdunL7//e9r9erVHpkb9kPhA4/q1auXhg8frqCgIH377bf65ptvdOHChRpfs2PHDp05c0YzZsxQQECAYmNjNXbs2EpLZF6puLi42m/LLvf555/r8OHDmjdvnlq1aqXmzZs7l4XetWuXbr/9dkVERKhdu3bOFXVq8+mnn6p3794aNGiQPv/8c+3du1eRkZEaPHiw/vGPf7g0Rm0GDx6smJgYBQYGqkWLFpoxY4Y6d+6sHTt2SJKGDx+uZcuW6Z577pHD4fDInBMnTnR+U9mtWzf97//+rzO5nDlzRmvWrNFvfvMbtWrVSrfeeqvi4+O5NxMAW3j++ef1z3/+U1988YUyMjK0c+fOSqta1mTq1Klq3769ioqKtHTpUq1YsaLW08bKy8t15513auzYsSoqKlJ2draGDx8u6eKp4Lt379bXX3+tjRs36u2333YpjuzsbJWXlztXlCsrK9PBgwe1bdu2WvOwq4KDg7VixQqVlpbqq6++0vXXX6/Ro0c73+/zzz+vTp06yeFwOG+X8Nprr9VrzpiYGGVkZKi8vFwbNmzQhg0b9PTTTzufHz9+vG655RadOHFC8+bN07333qujR4/Wa07Ym+UXGtHs0773ve+ZHTt2mFOnTpljx46Z9evXmy5dutS6kEDfvn3Nxx9/bE6ePGn27Nljxo0b5+xb1UIGPXv2NOnp6ebEiRNm7dq1NcYUERFh1q5da44ePWqOHDliXnnlFedzf/7zn82JEydMdna2efjhh2td3OBS+/TTT01aWppz+5133jF7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YPr16+f1OLxVGjRocM20wMDAKuvfeuutpnnz5kaSadGihVm3bp156aWXjCTTrl0789JLL5nw8HATGBhokpOTzZEjR0zjxo0dimXUqFFm8+bN10zv3LmzPc6EhARz6tQpEx4ebiSZTp06mVOnTplevXqZxo0bm0WLFpklS5Z4vV0pvls444N6JzCw/m225d+I1TSt3Ndff62ePXsqNDRUt956q4KCgvTmm29KkoKCglRYWKjevXurefPmeu2117R06VJFR0dXOb/FixeradOmatq0qRITE1VSUmJ/3bRpU0nSX//6V8XExKh58+Z66KGH9Oabb+rOO++UJLVq1UqfffaZ/vznP6tly5b67rvv9Mknn9SlSQDAZ4SEhGj69OkqLi5WcXGxpk+frpCQEElS7969VVhYqJdfflmHDh1SSUmJnnrqKftnW7ZsqbS0NJ08eVLffvut3njjDW3evLnGZXbq1EmrV6/WsWPHdPDgQU2aNKnGWKqyceNGPfroo5KkX/3qVzLGaNCgQZKkvn37KjMzU5I0atQobdmyRR988IGOHj2q119/XXPnztVHH32kL7/8UmfOnNF9991X5XL27t2rkydPSpICAgJ06dIltW/fXtLlywanT5+ugwcP6tKlS0pJSVFISIg6duxYY1tUJycnR2VlZZIkY4yCg4MVFRUlSRoxYoQ+//xzbd68WWfPntWf//xnPfroo2rSpEmdlgn/Vf/+g4TPe+WVV1RUVKRTp04pPz9fffv2lXT5YD5//nydOnVKubm5uuuuu+yfuf3227VhwwYdP35cubm5Gjx4sP29qw/KY8aM0YgRI/TKK6/o9OnTSktLqzaeyMhIffrppzp8+LCOHj2qDz/8UNLlg/arr76qffv26dChQ5o/f76aNWtW7bzmzZunl19+WZJ0yy23yBijP/zhD5KkW2+9VceOHVNAQIC9o3zllVd04MABzZ07V1OmTNE///lPLVy4UCdPnqzQcV6tqKhIx44ds78uKyuzdy7nzp3T1KlTtX//fhlj9OWXX6qgoKBCe9bGzp07VVpaKuly52KM0W233SZJevTRR5WXl6dly5bp559/1uuvv64uXbrUuUMDAF/w6quv6u6771bXrl3VpUsXJSQk6LXXXrO/Hx4erubNmysiIkJjxozRrFmzFBoaKkmaNWuWzp49q/DwcI0aNUqjRo2qcXlNmjTR2rVr9e9//1u33HKL2rdvr3Xr1jkUS2U2bdqkPn36SLqcqO3Zs0e//vWv7a83bdpkr9ujRw/t3btXbdq00VtvvSVJGj58uN566y01bdpUW7ZsqXZZw4YN08mTJ3Xs2DF16dJFH3/8caX1unTpopCQENlsthrboyaff/65zp8/r2+//VYbN27Ud999J0m64447lJWVZa+3d+9elZaWqkOHDnVeJvyX1087UfyndOjQwfz444/m5ptvNpJMdHS0ufXWW82UKVPM+fPnTWJiogkMDDRvv/222bp1q5FkgoKCjNVqNZMmTTLBwcHmvvvuM6dOnTIdOnQw0uXL2k6cOGF+9atfmYCAANOwYUOHL3ULDAw0O3bsMB988IG58cYbTcOGDU3Pnj2NJDN69GhjtVpNu3btTOPGjc2nn35qFixYUO38Ro8ebdLS0owkM2zYMGOz2Uxqaqr9vX/9619Gkundu7e5cOGCmTZtmgkJCTGNGjUyU6ZMMaWlpSYpKckEBASYRo0aVbusnj17mhMnThhjjDlz5ox54IEHKq130003mfPnz5uOHTs69Dfq3bu3KSwsrPS9WbNmmbNnzxpjjPn+++/tlyjMmDHDfPTRRxXq5uTkmEcffdTr2xyFQqHUtpRf6maz2UxiYqJ9ev/+/U1BQYGRLh8zz507V+GysEOHDpkePXqYwMBAU1paau+vJJk33nij0ku2rixDhw4127dvr/S96mKpqvTt29dkZWUZSWblypVmzJgx9j5248aN5pFHHjHS5cvJ9u/fX+Gzc+fONfPnz3e67dq3b2/+8pe/mDZt2lzzXtOmTU12draZOHGiw/Or6lK38hIUFGQGDhxov7ROklm7dq0ZN25chXpFRUWmd+/eXt+2KL5ZOOMDlyorK1PDhg3VqVMnBQUFaf/+/dq7d68kacuWLVq5cqUuXbqkhQsXqkuXLpKku+++W02aNNG0adN04cIFbdiwQV988YWGDRtmn++KFSv0zTffyBijn3/+2eF4EhISdMstt+hPf/qTzp07p59//llff/21pMunyD/44AMVFBTo7NmzmjRpkoYOHVrtJWibNm3Svffeq4CAAP3617/Wu+++q549e0q69lu1S5cuacqUKSotLdV//vMfSdLWrVu1YsUKGWPs06ry9ddfKzQ0VBEREXrvvfe0b9++a+oEBQVp0aJFmj9/vn744QeH26Uqzz77rJo2bap7771Xn332mb2tmzRpYr+8odzJkyftl8kBQH12yy23aP/+/fbX+/fv1y233GJ/fezYMfvlVtLlM+9NmjRR69atFRwcrMLCQvt7V/5elaioKO3Zs6dWsVRm69at6tChg2666SZ17dpVCxYsUFRUlFq1aqWEhAR99dVX1cbnSMxXs9lsysvL00cffVRheqNGjfT5559r27ZtmjZtmtPzrcrFixf173//W/3797dfFXLmzJlrrtRo1qyZTp8+7bLlwr+Q+MCl9uzZoxdffFGvv/66Dh8+rCVLlujmm2+WJB08eNBe79y5c7rhhhvUoEED3XLLLSosLJQxxv7+/v37FRERYX9dm4OydLlz2b9/f4UOq1xlnUtwcLDatGlT5fz27t2rs2fPqmvXrurVq5e++OILlZSUqEOHDtckPkeOHLkmSavNepSUlOjf//63UlNTK0wPCAjQwoULVVpaqvHjxzs936pcunRJX3/9tSIjI/X73/9eEp0LAP9WUlJS4T7Jtm3bqqSkpMbPHTlyRBcuXFBkZKR9Wvn9J9UpLCzUrbfe6rJYzp8/r++//14vvPCCcnNzdeHCBX3zzTd6+eWXtWfPngqXTl/Z11Y3zRFBQUH2S6Kly5e0/+tf/1JRUZHGjRtXq3k6s8y8vDz7l6iS1K5dOzVs2FC7d+92y7JR/5H4wOWWLFmiXr16KTo6WsYYvfPOO9XWLykpUVRUlAICAuzT2rZtq+LiYvvrqw/Kjh6kCwsL1bZt20rP4lTWuVy4cEGHDh2qdp6bNm3SY489ppCQEJWUlGjTpk0aNWqUWrRooR07dlQbo6s6F0maM2eO2rRpoyFDhujixYu1mq+jy7y6c7nxxht12223KS8vz+XLBQBPW7JkiV577TWFhYWpVatW+u///m/94x//qPFzly5d0meffabXX39dN9xwgzp27KiRI0fW+LkvvvhCN998s1544QWFhISoSZMm9qGfaxvLpk2bNH78ePsXcBs3bqzw2hXGjBmj1q1bS5Li4uI0adIk+71JQUFBWrZsmc6fP69Ro0bVur+7UseOHTVw4EA1atRIQUFBGjFihH7961/b12nRokUaPHiw7r33Xt144436y1/+os8++0xnzpyp87Lhn0h84FIdOnTQfffdp5CQEP3nP//R+fPndenSpWo/k5GRoXPnzumVV15RUFCQevfurcGDB19zhuNKhw4dqvLbsit9++23OnDggKZNm6Ybb7xRDRs21K9+9StJlzuXl156STExMWrcuLHefvttffLJJ5WeHbpSeedSfulAeeeyZcuWGtfVUcOHD7d/a9i2bVu99dZb9s5FkmbPnq24uDgNHjy4xkvmHNG6dWs98cQTaty4sQIDA9W/f38NGzbMvszly5frF7/4hR599FE1bNhQ//3f/63s7GyXXF4HAN725ptv6rvvvlN2drZycnK0fft2+0iaNRk/fryaN2+ugwcPauHChVqyZEmNl2SfOXNGDzzwgAYPHqyDBw/KarXaR1OrbSybNm1Ss2bN7H3T1a9doWfPnsrJydGZM2eUnp6u9PR0TZ48WdLl0eQGDx6s/v3768SJE/bn8dx77721Xl5AQID9CpIjR47ohRde0BNPPGEfpW7nzp165plntGjRIh0+fFhNmza1DzgEVMXrNxpR/Kd07tzZZGRkmFOnTpljx46Zzz//3Nx8883XPMcnOjraGGPsN4t26tTJbNy40Zw4ccLk5eWZhx9+2F63soEM2rdvbzIzM83x48fN8uXLq40pKirKLF++3Bw9etQcOXLEzJw500gyAQEB5s9//rP58ccfzeHDh83ChQtNaGhojevYoUMHY4wxI0eONJJMs2bNzIULF8wrr7xir1PZAALOPMvozTffNIWFhebMmTOmsLDQfPzxx6Zly5ZGkmnbtq0xxpjz589XeBbP8OHDHZp3ZbGFhYWZjRs3muPHj5uTJ0+a7Oxs87vf/a5CnX79+pldu3aZc+fOmQ0bNpjo6Givb28UCoXia2XatGlm3rx5Xo+DQqFcWwL+9xcAAAA4qWPHjgoJCVFOTo7i4+OVnp6u3/3ud1qxYoW3QwNwFS51AwAAqKWmTZvqs88+09mzZ/XJJ5/o/fff14oVK3TvvffaL/e6utTGpEmTKp1Xenq6S9cnNze30uUMHz681vOcPXt2pfOcPXu2CyMHHOP1004USl1KVFRUhUu+rixRUVFOz2/48OGVzis3N9elcaenp1e6nEmTJtV6npMmTap0nunp6V7/O1EoFAqFQqF4s3CpGwAAAAC/F+TtACTp8OHDFZ6nAgDwvOjoaN10003eDsMn0U8BgPfVtZ/yicRn//79io+P93YYAHBds1gs3g7BZ9FPAYD31bWf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fCCv16v8/PygltlXJD5BSEtLU2trq/91W1ub0tLSOpUZM2aMxowZo3fffVcHDhxQYWFhtMOMuGDa4emnn9aDDz6o1tZWbd26VUuXLo12mLYKpo36k4ULF2rbtm12hxF1f/M3f6P7779fr7zyit2hIMrCtQ/Iy8tTUlKSjh075p/385//XLW1tXrhhReUlJQUlnil0GMePHiwXC6XDhw44P/jZOTIkTp//rwuXbrUp2VGOuYOs2bN0uuvv95pXqTaWbIe9+X70ECfTUtLU1tbW9DLjGbMl4vlPn1lzHb06XDE3SGa/TrYmH/84x/L6/Xqueee06OPPtrjZyP5txSJT5gMGjRI2dnZKigo0OzZs1VeXq7hw4fbHVbUzZ49W+vXr1dGRoamTZumTZs2acCAAXaHBRsUFBRo4cKFYb82Nx6sWrVKZWVl/qNagBWpqanatGmTFixY4O9DTz75pG6++Wbl5eXp2muvjantKjMzU3l5eZozZ45WrVqlb33rW3aHFJTU1FSNGzdO27dv98+LpXaeO3euJk6cqOeff962GKwKFHMs9+nuYo6HPt1TW8div3755Zc1evRolZWV6ac//WnU19+BxCcIPp9PGRkZ/tfp6eny+XydyrS1tamqqkoXL17UBx98oObmZmVnZ0c71IgKph0WLlyoyspKSV+fgh08eLBSUlKiGqedgmmj/mDcuHH6j//4D5WUlPR6SZgTTZw4URUVFWppadEDDzygl19+OWyn6RHbQt0HDB06VG+//baWL1/uv3RJkk6ePClJam9v17p165Sfnx8zMXdc0tzS0qJ9+/YpNzdXZ8+eVXJysgYOHNinZUY6ZkmaOXOm3nrrLV28eNE/L5LtLAUf9x133KHly5fr3nvvVXt7e4+f9fl8nS53squtu4tZiu0+HShmO/p0OOKWot+vrW6LFRUV/ksEe+rTkfxbKiI/dnLSNHDgQHPs2DGTlZXl/5HV2LFjO5UpLCw069evN5LMyJEjzZ/+9Cdz7bXX2h57tNth69atZv78+UaSufnmm43P57M97nBPmZmZAX/UPm3atE43N6ipqbE93mi3QUZGhvF4PGby5Mm2x2lXG1w+RfrH0kyxNQWznwzUNxITE82uXbvMY4891qVsamqq//8vvvii+cUvfhETMScnJ5ukpCQjfT32NTc3+3+EXFlZ2emH4D/60Y9i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\n"},"metadata":{}}]},{"cell_type":"markdown","metadata":{"id":"Arnb-kXlC4VF"},"source":["#### tpg & outg survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jHh0uFkXC4VF","colab":{"base_uri":"https://localhost:8080/","height":741},"executionInfo":{"status":"ok","timestamp":1652336000146,"user_tz":-540,"elapsed":2191,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"0f96fffd-6b9a-4f7e-88ff-692d53ae921e"},"outputs":[{"output_type":"stream","name":"stdout","text":["661\n","661\n","661\n","661\n","pkx : [0.16567421 0.37261006 0.43912516 0.62388931]\n","pkx : [0.13770337 0.25029868 0.60309732]\n","\n","293\n","293\n","293\n","293\n","pkx : [-0.52628423 -0.45473521 -0.33365224 -0.2070655  -0.1300127  -0.02544105]\n","pkx : [-0.46075458 -0.25025689 -0.14500805 -0.04852994]\n","\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 864x576 with 4 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# 1. outg 는 partial 을 위한 histogram 작성 진행\n","# 현재, outg 내부에는 tp 한것과 out 한것이 공존하는 상태\n","titles = ['outg', 'tpg']\n","short_max_datas = [short_max_outg[short_bias_arr], short_max_tpg]\n","long_max_datas = [long_max_outg[long_bias_arr], long_max_tpg]\n","\n","# titles = ['tpg']\n","# short_max_datas = [short_max_tpg]\n","# long_max_datas = [long_max_tpg]\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 8))\n","nrows, ncols = 2, 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","  \n","for ings_idx, (title, short_max_data, long_max_data) in enumerate(zip(titles, short_max_datas, long_max_datas)):\n","\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","  if ings_idx == 0:\n","    axvline = current_outg\n","    title_add = 'true_' + title\n","  else:\n","    axvline = current_tpg\n","    title_add = 'false_' + title\n","\n","  print(len(long_max_data))\n","\n","  short_plot_idx = np.ones_like(short_max_data).astype(bool)\n","  long_plot_idx = np.ones_like(long_max_data).astype(bool)\n","  # short_plot_idx = short_max_data <= axvline\n","  # long_plot_idx = long_max_data <= axvline\n","\n","  print(np.sum(long_plot_idx))    \n","\n","  short_plot_idx *= ~np.isnan(short_max_data)\n","  long_plot_idx *= ~np.isnan(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_max_data)\n","  long_plot_idx *= ~np.isinf(long_max_data)  # nan 과 inf 때문에 이 방식 채택\n","  \n","  print(np.sum(long_plot_idx))\n","    \n","  plt.subplot(inner_gs[0])\n","  kde_plot_v2(*np.unique(short_max_data[short_plot_idx], return_counts=True))\n","  plt.title('short_' + title_add)  \n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  plt.subplot(inner_gs[1])\n","  kde_plot_v2(*np.unique(long_max_data[long_plot_idx], return_counts=True))\n","  plt.title('long_' + title_add)\n","  plt.axvline(axvline, color='red', linewidth=3)\n","\n","  print()\n","\n","# plt.suptitle(title)\n","plt.show()"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"mScdfR9hmjVu"}},{"cell_type":"markdown","metadata":{"id":"xivLUsSGC4VF"},"source":["##### outg survey for precision (eploc vars. dependency)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"LB28R3QIjCDc"},"outputs":[],"source":["# ------------ dependent vars. ------------ #\n","# res_df 에 존재하는 col 는 모두 사용가능함\n","# ------ 1. 도출한 outg 와 vars. pairing 진행 (by valid_idx) ------ #\n","devided_cols = ['tr_{}'.format(strat_version)]  # , 'ir_5T'\n","public_cols = ['wave_body_ratio']  # 'abs_ratio_5T', 'rel_ratio_5T', 'body_rel_ratio_5T'\n","\n","short_datas = [res_df['short_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","long_datas = [res_df['long_' + col].to_numpy() for col in devided_cols] + [res_df[col].to_numpy() for col in public_cols]\n","\n","titles = devided_cols + public_cols"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nX9TpLcvFu7T"},"outputs":[],"source":["plot_outg_range = (-1, 10)\n","plot_data_range = (-10, 100)\n","\n","plt.style.use(['dark_background', 'fast'])\n","fig = plt.figure(figsize=(12, 18))\n","nrows, ncols = len(short_datas), 1\n","gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                        ncols=ncols\n","                        )\n","\n","for ings_idx, (title, short_data, long_data) in enumerate(zip(titles, short_datas, long_datas)):\n","  inner_gs = gs[ings_idx].subgridspec(nrows=1, ncols=2)\n","\n","  print(len(long_max_outg))\n","\n","  short_plot_idx = (plot_outg_range[0] <= short_max_outg) & (short_max_outg <= plot_outg_range[1])\n","  long_plot_idx = (plot_outg_range[0] <= long_max_outg) & (long_max_outg <= plot_outg_range[1])  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_open_data = short_data[short_open_idx]\n","  long_open_data = long_data[long_open_idx]\n","  \n","  short_plot_idx *= (plot_data_range[0] <= short_open_data) * (short_open_data <= plot_data_range[1])\n","  long_plot_idx *= (plot_data_range[0] <= long_open_data) * (long_open_data <= plot_data_range[1]) # nan 과 inf 때문에 이 방식 채택\n","\n","  short_plot_idx *= ~np.isnan(short_open_data)\n","  long_plot_idx *= ~np.isnan(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_plot_idx *= ~np.isinf(short_open_data)\n","  long_plot_idx *= ~np.isinf(long_open_data)  # nan 과 inf 때문에 이 방식 채택\n","\n","  print(np.sum(long_plot_idx))\n","\n","  short_true_idx = short_plot_idx * short_true_open_idxth\n","  long_true_idx = long_plot_idx * long_true_open_idxth\n","  \n","  short_false_idx = short_plot_idx * ~short_true_open_idxth\n","  long_false_idx = long_plot_idx * ~long_true_open_idxth\n","\n","  plt.subplot(inner_gs[0])\n","  # ------ true_bias ------ #\n","  x, y = short_max_outg[short_true_idx].ravel(), short_open_data[short_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = short_max_outg[short_false_idx].ravel(), short_open_data[short_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  plt.subplot(inner_gs[1])    \n","  # ------ true_bias ------ #\n","  x, y = long_max_outg[long_true_idx].ravel(), long_open_data[long_true_idx].ravel()  \n","  plt.scatter(x, y, color='white', alpha=0.5)\n","  # ------ false_bias ------ #\n","  x, y = long_max_outg[long_false_idx].ravel(), long_open_data[long_false_idx].ravel()\n","  plt.scatter(x, y, color='fuchsia', alpha=0.3)\n","  plt.axvline(current_outg, color='red', linewidth=3)\n","  plt.title(\"{} coef : {:0.3f}\".format(title, np.corrcoef(-x, y)[0, 1]))\n","\n","  print()  \n","\n","# plt.suptitle(title)\n","plt.show()\n","# print()"]},{"cell_type":"markdown","source":["#### dump"],"metadata":{"id":"983aUwM76s6X"}},{"cell_type":"code","source":["# len(np.unique(long_obj[-1]))\n","p1_hhm_p1_idx = long_obj[-1]"],"metadata":{"id":"p_e8PtFXa7mc"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["p1_hlm_p1_idx = long_obj[-1]"],"metadata":{"id":"nLZDkNNxbZPO"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# len(p1_hhm_p1_idx[~np.isin(p1_hhm_p1_idx, p1_hlm_p1_idx)])\n","p1_hlm_p1_idx[~np.isin(p1_hlm_p1_idx, p1_hhm_p1_idx)]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"WhCPOi1qbkHS","executionInfo":{"status":"ok","timestamp":1653452376525,"user_tz":-540,"elapsed":261,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"e3b8db71-3e48-4177-a3fe-9f891a362596"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([350065., 440065., 502833., 735204., 836258.])"]},"metadata":{},"execution_count":161}]},{"cell_type":"code","source":["org_p1_idx = long_p2_idx_arr  # long_obj[-1]"],"metadata":{"id":"wgERZ65F5RBB"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["new_p1_idx = long_p2_idx_arr  # long_obj[-1]"],"metadata":{"id":"rAao95SEnOY0"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["uniq_org_p1_idx = np.unique(org_p1_idx)\n","uniq_new_p1_idx = np.unique(new_p1_idx)\n","print(len(uniq_org_p1_idx))\n","print(len(uniq_new_p1_idx))\n","uniq_new_p1_idx[~np.isin(uniq_new_p1_idx, uniq_org_p1_idx)]\n","# np.unique(new_p1_idx).remove(np.unique(org_p1_idx))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"OEQ9KWXVnQ2J","executionInfo":{"status":"ok","timestamp":1653119592395,"user_tz":-540,"elapsed":267,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"85c3e998-5c1e-4b5a-8366-28fe8cc3639b"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["153\n","163\n"]},{"output_type":"execute_result","data":{"text/plain":["array([ 35609, 105164, 188999, 347399, 358994, 379304, 379544, 397274, 482474, 550919, 656774, 833129])"]},"metadata":{},"execution_count":220}]},{"cell_type":"code","source":["open_idx = open_info_df.index.to_numpy()\n","# len_df = len(res_df)\n","# s_idx = (open_idx < int(len_df * (1 - test_ratio))) == plot_is\n","# s_open_info_df = open_info_df[s_idx]\n","# s_open_idx = open_idx[s_idx]\n","\n","# open_info_list = [s_open_info_df[col_].to_numpy() for col_ in s_open_info_df.columns]\n","# side_arr, zone_arr, id_arr, id_idx_arr = open_info_list\n","\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","short_open_ = res_df['short_open_{}'.format(config.selection_id)].to_numpy()\n","\n","long_open_idx = get_index_bybool(long_open_, np.arange(len(res_df)))\n","short_open_idx = get_index_bybool(short_open_, np.arange(len(res_df)))"],"metadata":{"id":"hOtCGUeBQ4hn"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["valid_long_open_idx = long_open_idx[~np.isnan(long_open_idx)]\n","valid_short_open_idx = short_open_idx[~np.isnan(short_open_idx)]\n","\n","# print(valid_long_open_idx[valid_long_open_idx > 4000][:10])\n","# print(valid_short_open_idx[valid_short_open_idx > 4000][:10])\n","\n","print(open_idx[open_idx > 4000][:10])\n","\n","print(np.hstack((long_obj[-1], long_obj[3]))[:10])\n","print(np.hstack((short_obj[-1], short_obj[3]))[:10])\n","# print([:10])"],"metadata":{"id":"QPhjkZQhRLqr"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# short_max_outg, short_outg_open_idx = get_max_outg_v2(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_outg_open_idx = get_max_outg_v2(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)\n","# short_max_outg, short_open_idx, short_true_open_idxth = get_max_outg_v3(\"SELL\", config, ohlc_list, short_obj, short_tpout_arr, short_open_epout_0, short_open_epout_gap)\n","# long_max_outg, long_open_idx, long_true_open_idxth = get_max_outg_v3(\"BUY\", config, ohlc_list, long_obj, long_tpout_arr, long_open_epout_0, long_open_epout_gap)"],"metadata":{"id":"cFd7Fz0Y6ucU"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EtjwB7Qk-Grj"},"source":["### significance_v4"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"oVifICO4-Grk","colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"status":"ok","timestamp":1653799570633,"user_tz":-540,"elapsed":60241,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"c71b4911-9a06-4d45-ab06-15c25f9cf3e3"},"outputs":[{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.1806657314300537\n"]},{"output_type":"stream","name":"stderr","text":["co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 1.092789649963379\n","en_ex_pairing elapsed time : 0.4772791862487793\n","idep_plot elapsed time : 0.1937720775604248\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.990755558013916\n","get_open_info_df elapsed time : 0.9821205139160156\n","en_ex_pairing elapsed time : 0.505638837814331\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21705174446105957\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9740583896636963\n","get_open_info_df elapsed time : 0.9981691837310791\n","en_ex_pairing elapsed time : 0.48220157623291016\n","idep_plot elapsed time : 0.19390153884887695\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9641737937927246\n","get_open_info_df elapsed time : 0.9710850715637207\n","en_ex_pairing elapsed time : 0.4888038635253906\n","idep_plot elapsed time : 0.19829702377319336\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9784555435180664\n","get_open_info_df elapsed time : 0.9720392227172852\n","en_ex_pairing elapsed time : 0.4841792583465576\n","idep_plot elapsed time : 0.18765616416931152\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9653613567352295\n","get_open_info_df elapsed time : 0.9848084449768066\n","en_ex_pairing elapsed time : 0.4875767230987549\n","idep_plot elapsed time : 0.18749618530273438\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9785594940185547\n","get_open_info_df elapsed time : 1.0015513896942139\n","en_ex_pairing elapsed time : 0.5098857879638672\n","idep_plot elapsed time : 0.18916702270507812\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.961845874786377\n","get_open_info_df elapsed time : 0.9726910591125488\n","en_ex_pairing elapsed time : 0.5064475536346436\n","idep_plot elapsed time : 0.1915733814239502\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.983177900314331\n","get_open_info_df elapsed time : 0.9889011383056641\n","en_ex_pairing elapsed time : 0.5240886211395264\n","idep_plot elapsed time : 0.20049166679382324\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.965012788772583\n","get_open_info_df elapsed time : 0.9634482860565186\n","en_ex_pairing elapsed time : 0.546140193939209\n","idep_plot elapsed time : 0.1926100254058838\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9612619876861572\n","get_open_info_df elapsed time : 0.9781711101531982\n","en_ex_pairing elapsed time : 0.5495872497558594\n","idep_plot elapsed time : 0.19498419761657715\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9525973796844482\n","get_open_info_df elapsed time : 0.9727447032928467\n","en_ex_pairing elapsed time : 0.55924391746521\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n","point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2027285099029541\n","get_open_info_df elapsed time : 0.9718382358551025\n","get_open_info_df elapsed time : 0.9588122367858887\n","en_ex_pairing elapsed time : 0.5727212429046631\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21284961700439453\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9724109172821045\n","get_open_info_df elapsed time : 1.0205960273742676\n","en_ex_pairing elapsed time : 0.5751299858093262\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2143847942352295\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9557604789733887\n","get_open_info_df elapsed time : 0.9771854877471924\n","en_ex_pairing elapsed time : 0.6090230941772461\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.21773362159729004\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9733049869537354\n","get_open_info_df elapsed time : 0.9980106353759766\n","en_ex_pairing elapsed time : 0.5743117332458496\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.23618173599243164\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9538712501525879\n","get_open_info_df elapsed time : 0.9689164161682129\n","en_ex_pairing elapsed time : 0.586374044418335\n"]},{"output_type":"stream","name":"stderr","text":["wave_point\n","np.sum(short_open_res1 == 1) : 33720\n","np.sum(long_open_res1 == 1) : 33938\n","np.sum(short_open_res2 == 1) : 33720\n","np.sum(long_open_res2 == 1) : 33938\n","reject update_hl\n","np.sum(short_open_res1 == 1) : 32885\n","np.sum(long_open_res1 == 1) : 32850\n","np.sum(short_open_res2 == 1) : 32885\n","np.sum(long_open_res2 == 1) : 32850\n","wave_mm\n","np.sum(short_open_res1 == 1) : 32882\n","np.sum(long_open_res1 == 1) : 32849\n","np.sum(short_open_res2 == 1) : 32882\n","np.sum(long_open_res2 == 1) : 32849\n"]},{"output_type":"stream","name":"stdout","text":["idep_plot elapsed time : 0.2239532470703125\n"]},{"output_type":"stream","name":"stderr","text":["point validation\n","np.sum(short_open_res1 == 1) : 32874\n","np.sum(long_open_res1 == 1) : 32843\n","np.sum(short_open_res2 == 1) : 23166\n","np.sum(long_open_res2 == 1) : 23648\n","cu_wrr_32_ <= config.loc_set.point1.wrr_32 : 1.00000 0.30000 (0.0)\n","co_wrr_32_ <= config.loc_set.point1.wrr_32 : 4.46870 0.30000 (0.0)\n","cu_wrr_32_ <= config.loc_set.point2.wrr_32 : 1.00000 0.40000 (0.0)\n","co_wrr_32_ <= config.loc_set.point2.wrr_32 : 4.46870 0.40000 (0.0)\n"]},{"output_type":"stream","name":"stdout","text":["get_open_info_df elapsed time : 0.9713571071624756\n","get_open_info_df elapsed time : 0.9754712581634521\n","en_ex_pairing elapsed time : 0.5813820362091064\n","idep_plot elapsed time : 0.2305433750152588\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1728x576 with 36 Axes>"],"image/png":"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D+Lq1asIDQ3F4cOH4ePjAwDYtGkT/Pz8cPbsWcTFxaGoqAhz5swB8HCIgy+//BIXLlxAVlYWnJ2dpXwKREpFAw8HryUiIiIiUgmrVq2ChYUFpk6dKnUUIiIiIqJa4Zm1RERERKTUOnXqhG7dugEAnJycMH36dP4ChoiIiIiUkrbUAYiIiIiI6sLIyAg7duyApaUl0tLSsGbNGhw8eFDqWEREREREtcZhEIiIiIiIiIiIiIhkgMMgEBEREREREREREckAO2uJiIiIiIiIiIiIZICdtUREREREREREREQywM5aIiIiIiIiIiIiIhlgZy0RERERERERERGRDLCzloiIiIiIiIiIiEgG2FlLREREREREREREJAPsrCUiIiIiIiIiIiKSAXbWEhEREREREREREckAO2uJiIiIiIiIiIiIZICdtUREREREREREREQywM5aIiIiIiIiIiIiIhlgZy0RERERERERERGRDLCzloiIiIiIiIiIiEgG2FlLREREREREREREJAPsrCUiIiIiIiIiIiKSAXbWEhEREREREREREckAO2uJiIiIiIiIiIiIZICdtUREREREREREREQywM5aIiIiIiIiIiIiIhlgZy0RERERERERERGRDLCzloiIiIiIiIiIiEgG2FlLREREREREREREJAPsrCUiIiIiIiIiIiKSAXbWEhEREREREREREckAO2uJiIiIiIiIiIiIZICdtUREREREREREREQywM5aIiIiIiIiIiIiIhlgZy0RAQBsbW0REhKCBw8eYM6cOVLHoWps3rwZK1asqHG+Jk2awN/fH9nZ2di9e3cjJCMiouqwxioH1lgiIuXDGit/rK+1pxKdtXFxcXB1dX3i/gEDBiAhIUGCRPQo7h/lsGjRIpw5cwbGxsb48ccfG2w9zZo1w/79+5GXl4c7d+5g0qRJ1c5rYmKCLVu2IC0tDWlpafDy8qo03draGqdPn0Z+fj6ioqKq/D9TV+PGjYO5uTnMzMwwYcKEWj22Ntt1/PjxuHDhAvLz83HmzJknpjs4OODKlSvIz8/HlStX4ODgUOvnQtLh+7f8cR8pB2WssXFxcSgoKEBubi5yc3Nx/PjxBsutbFhjqT7w/Vv+uI+UA2us6mB9/X8q0VkrR/PmzUNKSgpycnLg4+MDXV3dauedPn06YmJikJubi6NHj6JVq1aVpq9atQr3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VVUUERFBEydOJKFQSK+//jrt27eP869Lly6l/Px82rp1K+dfraysSCgUklgslumrOvOxpaWl9NJLL3G2SUxMJCKid955R8o2stqKd999l2JjY7m6W/UvKyujjIwMio6OJkB2O858bP/6WENDQ7py5QpJJBKKjIzk6r19+zZdvny5U7ssX76cysvLpewyb948ys/Plzqv8vaxLi4uVFJSQhKJhEpLS8nOzq6dXQBw7ZmdnZ2UjxWLxZSfn08ZGRlUXl5OFRUVtHPnTql7pry8nBoaGigrK4v+/ve/ExHR3r17CQAtXryYhEIh52PPnTvHjXrrrn+NiIiggoICmjVrFqf3pk2b6OrVq926Z27evEm///47V/fjI7CZ9G0bzXws87GyfGx/vcMCoHXr1lFlZSVX99atW6myspIqKyupvLyc3nrrLbn7V+DJfGxJSQmJxWKqqKjo8NoDQGvWrKH6+nr6z3/+I+Vjk5OTqaGhgRobG+nKlStSdjl9+jQ1NjaSSCSizMxMiomJ4eo+ffo0paamklAopNLSUhIKhZSXl9ftd1jmY5mP7YHIvxHsTiO5dOlS7veRI0fov//9L/d75cqVdPz48XbDn6OioujDDz/kyq1YsYLCw8M73VdrHS4uLtyybdu2cYYPDg7mhlD3VNavX08HDx6UWvbTTz9RcHBwp9vxeDyaPHkyffjhh1wsD21tbRo3bhzx+XwyNTWlX3/9VWoIt6JJVlYWzZw5k4KDg7kb5aOPPpI6H62dMa1TADIzM6UamaCgIKmGobuSkZEhVY9AICAiIltb2063aw258PiypqYmqWvD0dGRiEiu53bJkiVkbm5OKioq9NJLL3HTSpcsWUL5+fk0fvx4AkAODg5kY2NDPB6P4uPj6YsvviAtLS1SV1enyZMnd7qP1lg9y5YtIx6PR5s3b6acnBz65ptvSE1NjWbNmkXV1dWckzt48CAdPnyYtLS0aNSoUZSfn885HyMjI6quriY/Pz8SCAS0evVqamxs7HHjtXDhQkpJSZFatnPnTvr666873W758uXtwiCsXr2aTp8+LbUsLCyM3nvvvR7p5OzsTLm5uWRubk5AS3syYsSIbjm57jzId7bv1rZr9+7dpK6uTrNmzSKRSETHjx8nExMTrt5nnnmGANCbb75JqampZGVlRQYGBhQZGSnVfl69epV27NhBampq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\n"},"metadata":{}}],"source":["# from google.colab import output\n","# ------------ survey param ------------ #\n","# itv_num_list = [1, 3, 5, 15]\n","# itv_list = ['15m', '30m', '1h', '4h']\n","# itv_list = ['3m', '5m', '15m', '30m', '1h', '4h']\n","# val_list = np.arange(-0.5, -0.9, -0.1)     # prcn 1\n","# val_list = np.arange(-0.0, -0.5, -0.03)  # prcn 2\n","val_list = np.arange(-0.1, -1, -0.05)  # prcn 2\n","# val_list = np.arange(-0.5, -0.6, -0.005)    # prcn 3\n","# val_list = np.arange(0.944, 0.945, 0.0001)    # prcn 4\n","# val_list = np.arange(70, 80, 1)   # prcn -1\n","# val_list = np.arange(200, 180, -5)   # prcn -2\n","# val_list = talib.get_function_groups()['Pattern Recognition']\n","\n","# ------------ get survey_res ------------ #\n","result = []\n","res_shape = (3, 12)  # short, long, both x data\n","config_list_copy = copy.deepcopy(config_list)\n","for set_val in val_list:\n","  # ------------ open 결정 이전의 인자값 ------------ #\n","  # ------ point * dur. ------ #\n","  # config_list_copy[0].loc_set.point1.wrr_32 = set_val\n","  # config_list_copy[0].loc_set.point1.candle_pattern = set_val\n","  # config_list_copy[0].loc_set.zone.degree_list = set_val\n","  # config_list_copy[0].loc_set.point2.wick_score_list = str([set_val])\n","  # config_list_copy[0].loc_set.zone.ir = set_val  \n","  # config_list_copy[0].loc_set.zone.abs_ratio = set_val  \n","\n","  # ------------ open 결정 이후의 인자값 ------------ #\n","  # ------ utils ------ #\n","  # config_list_copy[0].tr_set.tp_gap = set_val  \n","  config_list_copy[0].tr_set.ep_gap1 = set_val \n","  # config_list_copy[0].tr_set.out_gap = set_val  \n","\n","  # config_list_copy[0].tr_set.tp_gap = abs(set_val) - 0.5\n","  # config_list_copy[0].tr_set.out_gap = set_val + 0.5\n","  # config_list_copy[0].tr_set.wb_tp_gap = config_list_copy[0].tr_set.tp_gap\n","  # config_list_copy[0].tr_set.wb_out_gap = config_list_copy[0].tr_set.out_gap\n","\n","  # ------ entry, exit (ep, tp, out vars.) ------ #\n","  # config_list_copy[0].tr_set.expire_k = set_val\n","  # config_list_copy[0].ep_set.expire_tick = set_val  \n"," \n","  for utils_, config_ in zip(utils_list, config_list_copy):\n","    enlist_tr(res_df, config_, np_timeidx)\n","  # open_info_df = get_open_info_df(ep_loc_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list)   # point * mr_res 이기 때문에 utils_tr & rtc 의 영향을 충분히 받음\n","  open_info_df1 = get_open_info_df_v2(ep_loc_p1_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=1)  # --> point * dur. 관련 (loc_set) param 에 종속 (open_info 가 변경되는게 아니라면, 재실행할 필요없음)\n","  open_info_df2 = get_open_info_df_v2(ep_loc_p2_v3, res_df, np_timeidx, ID_list, config_list_copy, id_idx_list, open_num=2)\n","  open_info_df_list = [open_info_df1, open_info_df2]\n","\n","  try:\n","    result.append(get_res_v9(res_df, open_info_df_list, ohlc_list, config_list_copy, np_timeidx, funcs, test_ratio=test_ratio, plot_is=1, signi=True))    \n","  except:\n","    result.append(np.full(res_shape, np.nan))\n","    # pass\n","\n","survey_res_list = [np.array(result)[:, s_i::3] for s_i in range(3)]   # 3 for s, l, b\n","# short_res, long_res, both_res = survey_res_list\n","\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['hhm', 'hlm', 'frq', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()\n","# print(\"\\n\")"]},{"cell_type":"code","source":["\n","# ------------ plot survey_res ------------ #\n","title_list = [\"short\", \"long\", \"both\"]\n","sub_title_list = ['prcn', 'wb', 'len_pr', 'dpf', 'wr', 'sr', 'acc_pr', 'sum_pr', 'min_pr', 'liqd', 'acc_mdd', 'sum_mdd']\n","space_ = \" \" * 120\n","\n","fig = plt.figure(figsize=(24, 8))\n","plt.style.use('dark_background')\n","gs = gridspec.GridSpec(nrows=1,\n","                        ncols=3,\n","                        # height_ratios=[1, 1, 1]\n","                      )\n","# nrows, ncols, h_r = 3, 3, [1, 1, 1]\n","nrows, ncols, h_r = 3, 4, [1, 1, 1]\n","# nrows, ncols, h_r = 4, 3, [1, 1, 1, 1]\n","# if d_idx == 0:\n","# else:\n","  # nrows, ncols, h_r = 2, 2, [1, 1]\n","\n","for d_idx, (title_name, survey_res) in enumerate(zip(title_list, survey_res_list)):  \n","  inner_gs = gs[d_idx].subgridspec(nrows=nrows,\n","                        ncols=ncols,\n","                        height_ratios=h_r\n","                      )\n","  for in_idx, (data_, sub_title) in enumerate(zip(survey_res.T, sub_title_list)):\n","    plt.subplot(inner_gs[in_idx])\n","    data = data_.ravel()\n","    valid_idx = ~np.isnan(data)\n","    if np.sum(valid_idx) > 0:\n","      if type(val_list[0]) == str:\n","        x, y = np.arange(len(val_list))[valid_idx], data[valid_idx]\n","      else:\n","        x, y = val_list[valid_idx], data[valid_idx]\n","      plt.plot(x, y)  # 앞에서부터 len(result) 만큼만    \n","      plt.title(sub_title + '_{:.2f}'.format(x[np.argmax(y)]))\n","    else:\n","      plt.title(sub_title)\n","\n","plt.suptitle(space_.join(title_list))\n","plt.show()"],"metadata":{"id":"oE5zkT75Beiy"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EJ4f-3Zf4ImT"},"source":["### backtrader validation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pbYUlJl34ImU"},"outputs":[],"source":["# ------ open validation ------ #\n","long_open_ = res_df['long_open_{}'.format(config.selection_id)].to_numpy()\n","long_open_ts = list(map(lambda x : str(x), res_df.index[long_open_ == 1]))  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"wyYMYcxx4ImV"},"outputs":[],"source":["long_index = open_info_df.side == 'BUY'\n","\n","for ts in res_df.index[open_info_df.index[long_index]]:\n","  print(ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"BPI-9QX74ImW"},"outputs":[],"source":["trade_log_name = \"ETHUSDT_1650120909.pkl\"\n","trade_log_dir_path = \"./trade_log/0405_wave_trader_realterm\"\n","\n","with open(os.path.join(trade_log_dir_path, trade_log_name), 'rb') as f:\n","  trade_log = pickle.load(f)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FMXhzaTK4ImX"},"outputs":[],"source":["trade_log"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"DiTKuq9T4ImY"},"outputs":[],"source":["# 1. ts 에 pair 된 en_p, ex_p 만 비교하면 될 것\n","#   -> open_idx, en_idx, ex_idx 조회하면 될 것\n","\n","pos_side = \"BUY\" # SELL BUY\n","val_obj = short_obj if pos_side == \"SELL\" else long_obj\n","\n","# ------ get idep trade_info ------ #\n","en_ts = list(map(lambda x : str(x), res_df.index[val_obj[2].astype(int).ravel()])) \n","ex_ts = list(map(lambda x : str(x), res_df.index[val_obj[3].astype(int).ravel()])) \n","en_p = val_obj[0].ravel()\n","ex_p = val_obj[1].ravel()\n","\n","# ------ execute ts comparison ------ #\n","logged_en_ts = [k for k, v in trade_log.items() if 'entry' in v if pos_side in v]\n","\n","lacked_ts = [ts for ts in en_ts if not ts in logged_en_ts]   # trade_log 에 없는 거래\n","added_ts = [ts for ts in logged_en_ts if not ts in en_ts]    # trade_log 에만 있는 거래\n","\n","print(lacked_ts)\n","print(added_ts)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VnTmGTJI4ImZ"},"outputs":[],"source":["# ------ check added_ts ------ #\n","keys = list(trade_log.keys())\n","\n","for k_i in range(len(keys)):\n","  if keys[k_i] in added_ts:\n","    # print(trade_log[keys[k_i]])\n","    # print(trade_log[keys[k_i + 1]])\n","    print(keys[k_i], trade_log[keys[k_i]])\n","    print(keys[k_i + 1], trade_log[keys[k_i + 1]])"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Vn5x7mcP4ImZ"},"outputs":[],"source":["# ------ price sync_check ------ #\n","accept_price_gap = 0.1\n","for i in range(len(en_ts)):\n","  try:\n","    print(en_ts[i], trade_log[en_ts[i]][0] - en_p[i])\n","    # print(trade_log[str(ex_ts[i])])\n","    # print(ex_ts[i], trade_log[ex_ts[i]][0] - ex_p[i])\n","    print(ex_ts[i])\n","    print()\n","\n","  except Exception as e:\n","    print(e)\n"]},{"cell_type":"markdown","metadata":{"id":"1GVZ03zDyU2N"},"source":["### legacy"]},{"cell_type":"markdown","metadata":{"id":"IWO7KkqltMFt"},"source":["#### main_functions"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"MY1csdNRLGsk"},"outputs":[],"source":["def get_open_info_df_v2(ep_loc_v2, res_df, np_timeidx, ID_list, config_list, id_idx_list, open_num=1):\n","  start_0 = time.time()\n","  # ------ get mr_res, zone_arr ------ #\n","  short_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.SELL) for config_ in config_list])\n","  long_mr_res_obj = np.array([ep_loc_v2(res_df, config_, np_timeidx, show_detail=True, ep_loc_side=OrderSide.BUY) for config_ in config_list])\n","  short_open_idx_list = [np.where(res_df['short_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, short_mr_res_obj[:, 0].astype(np.float64))]   # \"point * mr_Res\"\n","  long_open_idx_list = [np.where(res_df['long_open{}_{}'.format(open_num, id)].to_numpy() * mr_res)[0] for id, mr_res in zip(ID_list, long_mr_res_obj[:, 0].astype(np.float64))]  # zip 으로 zone (str) 과 묶어서 dtype 변경됨\n","\n","  # ------ open_info_arr ------ #\n","  short_side_list = [np.full(len(list_), OrderSide.SELL) for list_ in short_open_idx_list]\n","  long_side_list = [np.full(len(list_), OrderSide.BUY) for list_ in long_open_idx_list]\n","\n","  short_zone_list = [zone_res[short_open_idx] for zone_res, short_open_idx in zip(short_mr_res_obj[:, 1], short_open_idx_list)]\n","  long_zone_list = [zone_res[long_open_idx] for zone_res, long_open_idx in zip(long_mr_res_obj[:, 1], long_open_idx_list)]\n","\n","  short_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, short_open_idx_list)]\n","  long_id_list = [np.full(len(list_), id) for id, list_ in zip(ID_list, long_open_idx_list)]\n","\n","  selected_id_idx = np.arange(len(id_idx_list))\n","  short_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, short_open_idx_list)]\n","  long_id_idx_list = [np.full(len(list_), id) for id, list_ in zip(selected_id_idx, long_open_idx_list)]\n","\n","  # ------ get open_info_df ------ #\n","  #   series 만들어서 short / long 끼리 합치고 둘이 합치고, 중복은 우선 순위 정해서 제거\n","  short_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(short_open_idx_list, zip(short_side_list, short_zone_list, short_id_list, short_id_idx_list))]\n","  long_open_df_list = [pd.DataFrame(index=index_, data=np.vstack((data_)).T, columns=['side', 'zone', 'id', 'id_idx']) for index_, data_ in zip(long_open_idx_list, zip(long_side_list, long_zone_list, long_id_list, long_id_idx_list))]\n","\n","  open_info_df = pd.concat(short_open_df_list + long_open_df_list)\n","  # ------ sorting + unique ------ #\n","  open_info_df.sort_index(inplace=True)\n","  # print(len(open_info_df))\n","  # print(len(open_info_df))\n","  # open_info_df.head()\n","  print(\"get_open_info_df elapsed time :\", time.time() - start_0)\n","  return open_info_df[~open_info_df.index.duplicated(keep='first')]  # 먼저 순서를 우선으로 지정  "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eiQ36_SLLE3w"},"outputs":[],"source":["def get_res_v9(res_df, open_info_df_list, ohlc_list, config_list, np_timeidx, funcs, inversion=False, test_ratio=0.3, plot_is=True, signi=False, show_detail=False):\n","  # ------------ make open_info_list ------------ #\n","  open_idx1, open_idx2 = [open_info_df.index.to_numpy() for open_info_df in open_info_df_list]\n","  len_df = len(res_df)\n","\n","  sample_len = int(len_df * (1 - test_ratio))\n","  sample_idx1 = (open_idx1 < sample_len) == plot_is  # in / out sample plot 여부\n","  sample_open_idx1 = open_idx1[sample_idx1]  \n","  sample_idx2 = (open_idx2 < sample_len) == plot_is  # in / out sample plot 여부\n","\n","  # ------------ open_info_list 기준 = p1 ------------ #\n","  sample_open_info_df1, sample_open_info_df2 = [df_[idx_] for df_, idx_ in zip(open_info_df_list, [sample_idx1, sample_idx2])]\n","  open_info1 = [sample_open_info_df1[col_].to_numpy() for col_ in sample_open_info_df1.columns]\n","\n","  if config_list[0].tr_set.check_hlm in [0, 1]:   # 여기서 open_info 자동화하더라도, utils info 는 직접 실행해주어야함\n","    sample_open_idx2 = sample_open_idx1\n","    open_info2 = open_info1\n","  else:\n","    sample_open_idx2 = open_idx2[sample_idx2]\n","    open_info2 = [sample_open_info_df2[col_].to_numpy() for col_ in sample_open_info_df2.columns]\n","\n","  # ------------ get paired_res ------------ #\n","  start_0 = time.time()\n","  paired_res = en_ex_pairing_v9(res_df, [sample_open_idx1, sample_open_idx2], [open_info1, open_info2], ohlc_list, config_list, np_timeidx, funcs, show_detail)\n","  # valid_openi_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr = paired_res\n","  print(\"en_ex_pairing elapsed time :\", time.time() - start_0)  #  0.37 --> 0.3660471439361572 --> 0.21(lesser if)\n","\n","  # ------------ idep_plot ------------ #\n","  start_0 = time.time()\n","  high, low = ohlc_list[1:3]\n","  res = idep_plot_v16(res_df, len_df, config_list[0], high, low, sample_open_info_df1, paired_res, inversion=inversion, sample_ratio=1 - test_ratio, signi=signi)\n","  print(\"idep_plot elapsed time :\", time.time() - start_0)   # 1.40452 (v6) 1.4311 (v5)\n","\n","  return res"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xafHpMLwESKf"},"outputs":[],"source":["def idep_plot_v16(res_df, len_df, config, high, low, open_info_df1, paired_res, inversion=False, sample_ratio=0.7, title_position=(0.5, 0.5),\n","                  fontsize=15, signi=False):  # open_idx, side_arr\n","    if not signi:\n","        plt.style.use(['dark_background', 'fast'])\n","        plt.figure(figsize=(24, 8))\n","        gs = gridspec.GridSpec(nrows=2,  # row 몇 개\n","                               ncols=3,  # col 몇 개\n","                               height_ratios=[10, 1]\n","                               # height_ratios=[10, 10, 1]\n","                               )\n","    gs_idx = 0\n","    # plt.suptitle(key)\n","\n","    p_ranges, p_qty_ratio = literal_eval(config.tp_set.p_ranges), literal_eval(config.tp_set.p_qty_ratio)\n","    assert np.sum(p_qty_ratio) == 1.0\n","    assert len(p_ranges) == len(p_qty_ratio)\n","\n","    if sample_ratio is not None:\n","        sample_len = int(len_df * sample_ratio)\n","    else:\n","        sample_len = len_df\n","\n","    # ------ short & long data preparation ------ #\n","    # start_0 = time.time()\n","\n","    net_p1_idx_arr, p1_idx_arr, p2_idx_arr, pair_idx_arr, pair_price_arr, lvrg_arr, fee_arr, tpout_arr, tr_arr = paired_res\n","    assert len(p1_idx_arr) != 0, \"assert len(p1_idx_arr) != 0\"\n","\n","    short_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.SELL)[0]]\n","    long_net_p1_idx_arr = net_p1_idx_arr[np.where(open_info_df1.side.loc[net_p1_idx_arr] == OrderSide.BUY)[0]]\n","\n","    short_net_p1_frq = len(short_net_p1_idx_arr)\n","    long_net_p1_frq = len(long_net_p1_idx_arr)\n","    # print(\"len(short_net_p1_true_bias_bool) :\", len(short_net_p1_idx_arr))\n","    # print(\"len(long_net_p1_true_bias_bool) :\", len(long_net_p1_idx_arr))\n","\n","    short_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.SELL)[0]  # p1_idx_arr 에 대한 idx, # side_arr,\n","    long_p1_openi_idx = np.where(open_info_df1.side.loc[p1_idx_arr] == OrderSide.BUY)[0]\n","\n","    # p1_idx = open_idx[p1_openi_arr].reshape(-1, 1)   # != p1_idx_arr, p1_openi_arr 은 exit_done 기준임\n","\n","    np_obj = np.hstack((pair_price_arr, pair_idx_arr, p1_idx_arr.reshape(-1, 1)))  # p1_idx_arr is 1d, need to be changed to 2d (for stacking)\n","    short_obj = np_obj[short_p1_openi_idx]\n","    long_obj = np_obj[long_p1_openi_idx]\n","    both_obj = np.vstack((short_obj, long_obj))\n","    # print(\"short_obj.shape :\", short_obj.shape)\n","    # print(\"long_obj.shape :\", long_obj.shape)\n","\n","    short_obj, long_obj, both_obj = [np.split(obj_, 5, axis=1) for obj_ in [short_obj, long_obj, both_obj]]\n","\n","    short_p2_idx_arr, long_p2_idx_arr = [p2_idx_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_lvrg_arr, long_lvrg_arr = [lvrg_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_fee_arr, long_fee_arr = [fee_arr[openi_idx_].reshape(-1, 1) for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tpout_arr, long_tpout_arr = [tpout_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # short_bias_arr, long_bias_arr = [bias_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    short_tr_arr, long_tr_arr = [tr_arr[openi_idx_] for openi_idx_ in [short_p1_openi_idx, long_p1_openi_idx]]\n","    # print(\"long_bias_arr.shape :\", long_bias_arr.shape)\n","    # print(\"short / long arr setting elapsed time :\", time.time() - start_0)\n","\n","    # start_0 = time.time()\n","\n","    short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1, short_tp_0, long_tp_1, long_tp_0, short_out_1, short_out_0, long_out_1, long_out_0, short_ep2_0, long_ep2_0 = \\\n","      get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj)\n","\n","    # print(\"get_wave_bias elapsed time :\", time.time() - start_0)\n","\n","    len_short, len_long = len(short_p1_openi_idx), len(long_p1_openi_idx)\n","\n","    # ------ plot_data ------ #\n","    try:\n","        # start_0 = time.time()\n","        if len_short == 0:\n","            short_pr = []\n","            gs_idx += 1\n","        else:\n","            short_tr = short_tr_arr.mean()\n","            short_pr, short_liqd = get_pr_v4(OrderSide.SELL, high, low, short_obj, short_tpout_arr, short_lvrg_arr, short_fee_arr, p_ranges,\n","                                             p_qty_ratio, inversion)\n","            short_total_pr = to_total_pr(len_df, short_pr, short_obj[-2])\n","            short_cum_pr = np.cumprod(short_total_pr)\n","            short_hlm = hlm(short_pr, short_p2_true_bias_bool)\n","            short_trade_ticks = np.mean(short_obj[-2] - short_obj[-1])\n","            if signi:\n","                short_idep_res_obj = (short_tpbox_p2exec_hhm, short_hlm) + get_res_info_nb_v2(sample_len, short_pr, short_total_pr, short_cum_pr, short_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, short_tr, short_tpbox_hhm, short_tpbox_p2exec_hhm, short_outbox_hhm, short_hlm, short_trade_ticks, short_net_p1_frq, short_pr, short_total_pr,\n","                                      short_cum_pr, short_liqd, short_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"short plot_data elapsed time :\", time.time() - start_0)\n","\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in short plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_long == 0:\n","            long_pr = []\n","            gs_idx += 1\n","        else:\n","            long_tr = long_tr_arr.mean()\n","            long_pr, long_liqd = get_pr_v4(OrderSide.BUY, high, low, long_obj, long_tpout_arr, long_lvrg_arr, long_fee_arr, p_ranges, p_qty_ratio,\n","                                           inversion)\n","            long_total_pr = to_total_pr(len_df, long_pr, long_obj[-2])\n","            long_cum_pr = np.cumprod(long_total_pr)\n","            # long_hhm = long_net_p1_hhm\n","            long_hlm = hlm(long_pr, long_p2_true_bias_bool)\n","            long_trade_ticks = np.mean(long_obj[-2] - long_obj[-1])\n","            if signi:\n","                long_idep_res_obj = (long_tpbox_p2exec_hhm, long_hlm) + get_res_info_nb_v2(sample_len, long_pr, long_total_pr, long_cum_pr, long_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, long_tr, long_tpbox_hhm, long_tpbox_p2exec_hhm, long_outbox_hhm, long_hlm, long_trade_ticks, long_net_p1_frq, long_pr, long_total_pr,\n","                                      long_cum_pr, long_liqd, long_lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"long plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in long plot_data :\", e)\n","\n","    try:\n","        # start_0 = time.time()\n","        if len_short * len_long == 0:\n","            both_pr = []\n","            gs_idx += 1\n","        else:\n","            both_tr = (short_tr + long_tr) / 2\n","            both_pr = np.vstack((short_pr, long_pr))  # for 2d arr, obj 를 1d 로 만들지 않는 이상, pr 은 2d 유지될 것\n","            both_total_pr = to_total_pr(len_df, both_pr, both_obj[-2])\n","            both_cum_pr = np.cumprod(both_total_pr)\n","            both_liqd = min(short_liqd, long_liqd)\n","            both_p2_true_bias_bool = np.hstack((short_p2_true_bias_bool, long_p2_true_bias_bool))  # hstack for 1d arr, vstack for 2d arr\n","            both_tpbox_hhm = (short_tpbox_hhm + long_tpbox_hhm) / 2\n","            both_tpbox_p2exec_hhm, both_hlm = (short_tpbox_p2exec_hhm + long_tpbox_p2exec_hhm) / 2, (short_hlm + long_hlm) / 2\n","            both_outbox_hhm = (short_outbox_hhm + long_outbox_hhm) / 2\n","            both_trade_ticks = np.mean(both_obj[-2] - both_obj[-1])\n","            both_net_p1_frq = short_net_p1_frq + long_net_p1_frq\n","            if signi:\n","                both_idep_res_obj = (both_tpbox_p2exec_hhm, both_hlm) + get_res_info_nb_v2(sample_len, both_pr, both_total_pr, both_cum_pr, both_liqd)\n","            else:\n","                gs_idx = plot_info_v8(gs, gs_idx, len_df, sample_len, both_tr, both_tpbox_hhm, both_tpbox_p2exec_hhm, both_outbox_hhm, both_hlm, both_trade_ticks, both_net_p1_frq, both_pr, both_total_pr,\n","                                      both_cum_pr, both_liqd, lvrg_arr.mean(), title_position, fontsize)\n","        # print(\"both plot_data elapsed time :\", time.time() - start_0)\n","    except Exception as e:\n","        gs_idx += 1\n","        print(\"error in both plot_data :\", e)\n","\n","    if not signi:\n","        if len_short * len_long > 0:\n","            for obj, bias_arr, cum_pr in zip([short_obj, long_obj, both_obj], [short_p2_true_bias_bool, long_p2_true_bias_bool, both_p2_true_bias_bool],\n","                                             [short_cum_pr, long_cum_pr, both_cum_pr]):\n","                try:\n","                    # start_0 = time.time()\n","                    gs_idx = frq_dev_plot_v4(gs, gs_idx, len_df, sample_len, obj[-2], bias_arr, cum_pr[-1], fontsize)\n","                    # print(\"frq_dev_plot elapsed time :\", time.time() - start_0)\n","                except Exception as e:\n","                    gs_idx += 1\n","                    print(\"error in frq_dev_plot :\", e)\n","            plt.show()\n","            plt.close()\n","\n","        return short_pr, short_obj, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_tr_arr, short_p2_true_bias_bool, short_p2_idx_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0, \\\n","               long_pr, long_obj, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_tr_arr, long_p2_true_bias_bool, long_p2_idx_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0  # long_net_p1_idx_arr long_p2_idx_arr\n","\n","    else:\n","        return [short_idep_res_obj[:-1], long_idep_res_obj[:-1], both_idep_res_obj[:-1]]"]},{"cell_type":"code","source":["def plot_info_v8(gs, gs_idx, len_df, sample_len, tr, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, pr, total_pr, cum_pr, liqd, leverage, title_position, fontsize):\n","  try:\n","    plt.subplot(gs[gs_idx])\n","    idep_res_obj = get_res_info_nb_v2(sample_len, pr, total_pr, cum_pr, liqd)\n","    plt.plot(cum_pr)\n","    plt.plot(idep_res_obj[-1], color='gold')\n","    if sample_len is not None:\n","      plt.axvline(sample_len, alpha=1., linestyle='--', color='#ffeb3b')\n","    plt.xlim(0, len_df)\n","\n","    title_str = \"tr : {:.3f}\\n tpbox_hhm : {:.3f}\\n tpbox_p2exec_hhm : {:.3f}\\n outbox_hhm : {:.3f}\\n hlm : {:.3f}\\n bars_in : {:.3f}\\n net_p1_frq : {}\\n frq : {}\\n dpf : {:.3f}\\n wr : {:.3f}\\n sr : {:.3f}\\n acc_pr : {:.3f}\\n sum_pr : {:.3f}\\n\" +\\\n","              \"min_pr : {:.3f}\\n liqd : {:.3f}\\n acc_mdd : -{:.3f}\\n sum_mdd : -{:.3f}\\n leverage {:.3f}\"\n","    plt.title(title_str.format(tr, hhm, p2_hhm, out_hhm, hlm, bars_in, net_p1_frq, *idep_res_obj[:-1], leverage), position=title_position, fontsize=fontsize) #, color='yellow')\n","  except Exception as e:\n","    print(\"error in plot_info :\", e)\n","\n","  return gs_idx + 1"],"metadata":{"id":"I9GysZ5_vv5J"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"EFyWTuscH8VH"},"source":["#### get paired_res function"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"qfbtFVMR01UJ"},"outputs":[],"source":["def en_ex_pairing_v9(res_df, open_idx_list, open_info_list, ohlc_list, config_list, np_timeidx, funcs, show_detail=False):  # 이미 충분히 줄여놓은 idx 임\n","\n","    open_info1, open_info2 = open_info_list\n","    side_arr1, _, _, id_idx_arr1 = open_info1\n","    side_arr2, _, _, _ = open_info2\n","\n","    expiry_p1, expiry_p2, lvrg_set = funcs\n","\n","    net_p1_idx_list, p1_idx_list, p2_idx_list, pair_idx_list, pair_price_list, lvrg_list, fee_list, tpout_list, tr_list = [[] for li in range(9)]\n","    len_df = len(res_df)\n","\n","    close = ohlc_list[3]\n","    \n","    open_idx1, open_idx2 = open_idx_list\n","    len_open_idx1 = len(open_idx1)\n","    len_open_idx2 = len(open_idx2)\n","    i, open_i1, open_i2 = 0, -1, -1  # i for total_res_df indexing\n","\n","    while 1:   # for p1's loop\n","\n","        # Todo, \n","        #   1. (갱신) p1's open_i + 1 과 op_idx 를 꺼내오는 건, eik1 또는 tp 체결의 경우만 해당됨, \n","        #   2. out 의 경우 p2's op_idx 기준으로 retry 필요\n","        #     a. 또한, p2's op_idx > p1's op_idx\n","\n","        # ============ get p1_info ============ #\n","        # if eik1 or tp_done or first loop:\n","        open_i1 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","        if open_i1 >= len_open_idx1:\n","            break\n","\n","        op_idx1 = open_idx1[open_i1]  # open_i1 는 i 와 별개로 운영\n","        if op_idx1 < i:  # i = 이전 거래 끝난후의 res_df index - \"거래 종료후 거래 시작\", '<' : 거래 종료시점 진입 가능하다는 의미\n","            continue\n","\n","        # ------ set loop index i ------ #\n","        i = op_idx1      # + 1 --> op_idx1 = op_idx2 가능함 # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","        if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","            break        \n","\n","        # ------ dynamic arr info by ID ------ #\n","        #     1. 해당 id 로 config 재할당해야함\n","        #       a. use open_i1\n","        open_side = side_arr1[open_i1]\n","        id_idx = id_idx_arr1.astype(int)[open_i1]\n","        config = config_list[id_idx]\n","        selection_id = config.selection_id\n","        check_hlm = config.tr_set.check_hlm        \n","        if show_detail:\n","          print(\"check_hlm :\", check_hlm)\n","\n","        # check_net_hhm = 1 if (config.tr_set.wave_itv1 == config.tr_set.wave_itv2) and (config.tr_set.wave_period1 == config.tr_set.wave_period2) else 0\n","\n","        side_pos = 'short' if open_side == OrderSide.SELL else 'long'   \n","        if show_detail:\n","          print(\"============ op_idx1 : {} {} ======\".format(op_idx1, open_side))\n","\n","        # ------ load tr_data ------ #\n","        tp_arr = res_df['{}_tp_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep1_arr = res_df['{}_ep1_{}'.format(side_pos, selection_id)].to_numpy()\n","        ep2_arr = res_df['{}_ep2_{}'.format(side_pos, selection_id)].to_numpy()\n","        out_arr = res_df['{}_out_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()  # just for p1_hhm\n","\n","        tp_1_ = res_df['{}_tp_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]  # for p2_box location & p1's exipiry\n","        tp_0_ = res_df['{}_tp_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]\n","        tp_gap_ = res_df['{}_tp_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx1]    \n","\n","        # if not check_net_hhm:  # this phase exist for p1 entry (net hhm sync.) in p2_platform\n","        exec_j, ep_j, tp_j, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx1, tp_1_, tp_gap_, len_df, open_side,\n","                                                                                [*ohlc_list, ep1_arr], expiry_p2)        \n","        i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","        if not entry_done:\n","            if show_detail:\n","              print(\"p1's expiry on p1_loop continue\")\n","            continue   \n","        # else:        \n","        #   tp_j = op_idx1\n","\n","        prev_open_i2 = open_i2\n","        net_p1_idx_list.append(op_idx1)\n","        if check_hlm in [0, 1]:\n","          i = op_idx1  # allow op_idx2 = op_idx1\n","        allow_exit = 1\n","        # ============ entry loop ============ #\n","        while 1:  # for p2's loop (allow retry)\n","\n","          # ============ get p2_info ============ #\n","          open_i2 += 1  # 확인 끝났으면 조기 이탈(+1), 다음 open_idx 조사 진행\n","          if open_i2 >= len_open_idx2:  # open_i2 소진\n","              break\n","\n","          if show_detail:\n","            print(\"open_i2 :\", open_i2, side_arr2[open_i2])\n","\n","          # ------ check side sync. ------ #\n","          if open_side != side_arr2[open_i2]:\n","            continue\n","\n","          op_idx2 = open_idx2[open_i2]  # open_i2 는 i 와 별개로 운영\n","          if op_idx2 < i:   # p1 execution 이후의 i 를 허용 (old, 이곳 i = op_idx1 + 1 or p2's exec_j or exit_loop's i + 1)\n","            continue\n","          \n","          if show_detail:\n","            print(\"op_idx1, op_idx2 :\", op_idx1, op_idx2, side_arr2[open_i2])\n","          \n","          i = op_idx2 + 1  # open_signal 이 close_bar.shift(1) 이라고 가정하고 다음 bar 부터 체결확인한다는 의미\n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          tp_ = tp_arr[op_idx1]          \n","          ep2_ = ep2_arr[op_idx2]\n","          out_ = out_arr[op_idx2]\n","\n","          out_1_ = res_df['{}_out_1_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_0_ = res_df['{}_out_0_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          out_gap_ = res_df['{}_out_gap_{}'.format(side_pos, selection_id)].to_numpy()[op_idx2]\n","          \n","          # ------ check p1's expiry - Todo, priority ------ # - p2_box 생성 이전의 hl_survey\n","          # 1. op_idx1 ~ op_idx2 까지의 hl_check \n","          if check_hlm:  # p1_hlm, p2_hlm\n","            if op_idx1 < op_idx2:\n","              expire, touch_idx = expiry_p1(res_df, config, op_idx1, op_idx2, tp_1_, tp_0_, tp_gap_, ohlc_list[1:3], open_side)\n","              if expire:   # p1's expiry\n","                  if show_detail:\n","                    print(\"expiry_p1 break {}\".format(touch_idx))\n","                  i = touch_idx  #  + 1  --> 이거 아닌것 같음 # op_idx1 과 op_idx2 사이의 op_idx1' 을 살리기 위함, 즉 바로 다음 op_idx1 로 회귀 (건너뛰지 않고)\n","                  open_i2 = prev_open_i2\n","                  break   # change op_idx1\n","          \n","          # ------ point validation ------ # p1_loop 로 return 되는 정확한 i 를 반환하기 위해서 expiry_p1 에 순서 양보  # Todo, 새로운 tp, ep, out 에 대한 처리 필요 (p1_hlm 사용시)\n","          if open_side == OrderSide.SELL:\n","            if not (tp_ < ep2_):  # tr_set validation & reject hl_out open_exec.\n","              break  # change op_idx1\n","            elif not (ep2_ < out_ and close[op_idx2] < out_):\n","              continue  # change op_idx2\n","          else:\n","            if not (tp_ > ep2_):              \n","              break\n","            elif not (ep2_ > out_ and close[op_idx2] > out_):\n","              continue\n","\n","          if check_hlm == 2:\n","            # ------ p2_box location ------ #\n","            if open_side == OrderSide.SELL:\n","              if not ((tp_1_ + tp_gap_ * config.tr_set.p2_box_k1 <= out_1_) and (out_0_ <= tp_0_ - tp_gap_ * config.tr_set.p2_box_k2)):  # tp1, tp0 에 닿으면 expiry\n","                if show_detail:\n","                    print(\"p2_box continue\")\n","                continue\n","            else:\n","              if not ((tp_1_ - tp_gap_ * config.tr_set.p2_box_k1 >= out_1_) and (out_0_ >= tp_0_ + tp_gap_ * config.tr_set.p2_box_k2)):\n","                if show_detail:\n","                    print(\"p2_box continue\")\n","                continue\n","                  \n","            # ------ check p2's expiry ------ #\n","            exec_j, ep_j, _, out_j, entry_done, en_p, fee = check_entry_v5(res_df, config, op_idx2, out_1_, out_gap_, len_df, open_side,\n","                                                                                    [*ohlc_list, ep2_arr], expiry_p2)   # tp_j 는 op_idx1 사용\n","            i = exec_j  # = entry_loop 를 돌고 나온 e_j\n","            if not entry_done:   # p2's expiry\n","                if show_detail:\n","                    print(\"expiry_p2 continue {}\".format(i))\n","                continue  # change op_idx2            \n","            \n","          # ------ tr_threshold ------ #   # en_p 에 대해 하는게 맞을 것으로봄\n","          if check_hlm:   \n","            if open_side == OrderSide.SELL:\n","              tr_ = abs((en_p / tp_ - config.trader_set.limit_fee - 1) / (en_p / out_ - config.trader_set.market_fee - 1))              \n","              if config.loc_set.point1.short_tr_thresh != \"None\":\n","                if tr_ < config.loc_set.point1.short_tr_thresh:\n","                  continue\n","            else:\n","              tr_ = abs((tp_ / en_p - config.trader_set.limit_fee - 1) / (out_ / en_p - config.trader_set.market_fee - 1))\n","              if config.loc_set.point1.short_tr_thresh != \"None\":  # thresh 여부는 short 기준 공통\n","                if tr_ < config.loc_set.point1.long_tr_thresh:\n","                  continue\n","          else:\n","            tr_ = tr_arr[op_idx1]\n","\n","          # ------ leverage ------ #\n","          # out = out_arr[out_j]  # lvrg_set use out on out_j (out_j shoud be based on p2)\n","          leverage = lvrg_set(res_df, config, open_side, en_p, out_, fee)  # res_df 변수 사용됨 - 주석 처리 된 상태일뿐\n","          if leverage is None:\n","              if show_detail:\n","                    print(\"leverage is None continue\")\n","              if check_hlm:\n","                continue  # change op_idx2\n","              else:\n","                break   # change op_idx1\n","\n","          exit_done, cross_on = 0, 0\n","          # ------ check tpout_onexec ------ #\n","          # if not config.ep_set.static_ep and config.ep_set.entry_type == \"LIMIT\" and config.ep_set.tpout_onexec:\n","          if config.ep_set.entry_type == \"LIMIT\":\n","              if config.tp_set.tp_onexec:  # dynamic 은 tp_onexec 사용하는 의미가 없음\n","                  tp_j = exec_j\n","              if config.out_set.out_onexec:  # dynamic 은 out_onexec 사용하는 의미가 없음\n","                  out_j = exec_j\n","\n","          # ============ exit loop ============ # --> p1_hlm 의 경우, 1번만 실행\n","          if not allow_exit:\n","            continue\n","\n","          while 1:\n","              if not config.tp_set.static_tp:  # 앞으로 왠만하면 static 만 사용할 예정\n","                  tp_j = i\n","              if not config.out_set.static_out:\n","                  out_j = i\n","\n","              # ------------ out ------------ #  # out 우선 (보수적 검증)\n","              # ------ signal_out ------ #\n","              if not exit_done:\n","                  exit_done, cross_on, ex_p, fee = check_signal_out_v3(res_df, config, open_i2, i, len_df, fee, open_side, cross_on, exit_done, [*ohlc_list, np_timeidx])\n","              # ------ hl_out ------ #\n","              if config.out_set.hl_out != \"None\":\n","                  if not exit_done:  # and i != len_df - 1:\n","                      exit_done, ex_p, fee = check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, [*ohlc_list, out_arr])\n","\n","              # ------------ tp ------------ #\n","              if not config.tp_set.non_tp and i != exec_j:\n","                if not exit_done:\n","                  exit_done, ex_p, fee = check_limit_tp_exec(res_df, config, open_i2, i, tp_j, len_df, fee, open_side, exit_done,\n","                                                            [*ohlc_list, [tp_arr]])  # 여기서는 j -> i 로 변경해야함\n","                  # if config.tp_set.tp_type in ['LIMIT']:  # 'BOTH' -> 앞으로는, LIMIT 밖에 없을거라 주석처리함\n","                  # if not exit_done and config.tp_set.tp_type in ['MARKET', 'BOTH']:\n","\n","              if exit_done:  # 이 phase 는 exit_phase 뒤에도 있어야할 것 - entry_done var. 사용은 안하겠지만\n","                  # ------ append dynamic vars. ------ #\n","                  p1_idx_list.append(op_idx1)  # side, zone, start_ver arr 모두 openi_list 로 접근하기 위해 open_i 를 담음\n","                  p2_idx_list.append(op_idx2)\n","                  pair_idx_list.append([exec_j, i])  # entry & exit (체결 기준임)\n","                  pair_price_list.append([en_p, ex_p])\n","                  lvrg_list.append(leverage)\n","                  fee_list.append(fee)\n","                  tpout_list.append([tp_arr[tp_j], out_arr[out_j]])  # for tpout_line plot_check\n","                  tr_list.append(tr_)   # Todo, tr vectorize 불가함, 직접 구해주어야할 건데.. (오래걸리지 않을까 --> tr_set 데이터만 모아서 vecto 계산이 나을 것)\n","\n","                  # open_i += 1  # 다음 open_idx 조사 진행\n","                  break\n","\n","              # 1. 아래있으면, 체결 기준부터 tp, out 허용 -> tp 가 entry_idx 에 체결되는게 다소 염려되기는 함, 일단 진행 (그런 case 가 많지 않았으므로)\n","              # 2. 위에있으면, entry 다음 tick 부터 exit 허용\n","              i += 1\n","              if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","                  break\n","          \n","          if i >= len_df:  # res_df 의 last_index 까지 돌아야함\n","              break\n","\n","          if exit_done == 1:  # tp_done\n","            if show_detail:\n","                    print(\"exit_done = {} break {}\".format(exit_done, i))\n","            break   # change op_idx1\n","          else:\n","            if check_hlm:\n","              if check_hlm == 1:   # exit only once in p1_hlm mode\n","                allow_exit = 0\n","              if show_detail:\n","                      print(\"exit_done = {} continue {}\".format(exit_done, i))\n","              continue  # change op_idx2\n","            else:\n","              if show_detail:\n","                      print(\"exit_done = {} break {}\".format(exit_done, i))\n","              break   # change op_idx1    \n","\n","        if i >= len_df:  # or open_i >= len_open_idx:  # res_df 의 last_index 까지 돌아야함\n","            break\n","        else:\n","            continue\n","\n","    return np.array(net_p1_idx_list), np.array(p1_idx_list), np.array(p2_idx_list), np.array(pair_idx_list), np.array(pair_price_list), np.array(lvrg_list), np.array(\n","        fee_list), np.array(tpout_list), np.array(tr_list)\n","\n","\n","def check_entry_v5(res_df, config, op_idx, wave1, wave0, len_df, open_side, np_datas, expiry):\n","    open, high, low, close, ep_arr = np_datas\n","    ep_j = op_idx\n","    tp_j = op_idx\n","    out_j = op_idx\n","\n","    # print(\"ep_arr[op_idx] :\", ep_arr[op_idx])\n","\n","    selection_id = config.selection_id    \n","    # allow_ep_in = 0 if config.ep_set.point2.use_point2 else 1\n","    entry_done = 0\n","    ep = None\n","\n","    if config.ep_set.entry_type == \"LIMIT\":\n","        fee = config.trader_set.limit_fee\n","\n","        for e_j in range(op_idx + 1, len_df):\n","            # ------ index setting for dynamic options ------ #\n","            if not config.ep_set.static_ep:\n","                ep_j = e_j  # dynamic_ep 를 위한 ep_index var.\n","                out_j = e_j  # dynamic_out 를 위한 out_index var. - 조건식이 static_ep 와 같이 있는 이유 모름 => dynamic_lvrg 로 사료됨\n","\n","            if not config.tp_set.static_tp:\n","                tp_j = e_j\n","\n","            # ------ expire_k & expire_tick ------ # - limit 사용하면 default 로 expire_k 가 존재해야함\n","            if expiry(res_df, config, op_idx, e_j, wave1, wave0, [high, low], open_side):  # tp_j, \n","              break\n","\n","            # ------ point2 ------ #\n","            # if not allow_ep_in:\n","            #     allow_ep_in, out_j = ep_loc_point2(res_df, config, e_j, out_j, side=OrderSide.SELL)\n","            #     if allow_ep_in:\n","            #       if config.ep_set.point2.entry_type == \"LIMIT\":\n","            #         ep_j = e_j\n","            #         # print(\"e_j in point2 :\", e_j)\n","            #         continue\n","\n","            # ------ check ep_exec ------ #\n","            # if allow_ep_in:\n","              # if config.ep_set.point2.use_point2 and config.ep_set.point2.entry_type == 'MARKET':\n","              #   entry_done = 1\n","              #   ep = c[e_j]\n","              #   break\n","              # else:\n","\n","            if open_side == OrderSide.SELL:\n","              if high[e_j] >= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] >= ep_arr[ep_j]:  # open comp 는 결국, 수익률에 얹어주는 logic (반보수) -> 사용 보류\n","                      ep = open[e_j]\n","                  break\n","            else:\n","              if low[e_j] <= ep_arr[ep_j]:\n","                  entry_done = 1\n","                  ep = ep_arr[ep_j]\n","                  if open[e_j] <= ep_arr[ep_j]:\n","                      ep = open[e_j]\n","                  break\n","\n","    else:  # market entry\n","        e_j = op_idx + 1\n","        entry_done = 1\n","        ep = close[op_idx]\n","        fee = config.trader_set.market_fee\n","\n","    return e_j, ep_j, tp_j, out_j, entry_done, ep, fee  # 다음 start_i <-- e_j 로 변경\n","    #   e_j => 다음 phase 의 시작 index <-> ep_j : ep 의 기준 index\n","    #   ep_j, tp_j, out_j 가 return 되어야함 - exit phase 에서 이어가기 위함\n","\n","\n","def check_limit_tp_exec(res_df, config, open_i, i, tp_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, tps = np_datas\n","    tp = None\n","    selection_id = config.selection_id\n","    len_tps = len(tps)\n","\n","    for tp_i, tp_arr in enumerate(tps):\n","\n","        #     decay adjustment    #\n","        #     tp_j includes dynamic_j - functionalize  #\n","        # try:\n","        #     if config.tr_set.decay_gap != \"None\":\n","        #         decay_share = (j - open_i) // config.tp_set.decay_term\n","        #         decay_remain = (j - open_i) % config.tp_set.decay_term\n","        #         if j != open_i and decay_remain == 0:\n","        #             if open_side == OrderSide.SELL:\n","        #                 tp_arr[tp_j] += res_df['short_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        #             else:\n","        #                 tp_arr[tp_j] -= res_df['long_tp_gap_{}'.format(selection_id)].iloc[open_i] * config.tr_set.decay_gap * decay_share\n","        # except:\n","        #     pass\n","\n","        if open_side == OrderSide.SELL:\n","            if low[i] <= tp_arr[tp_j]:  # and partial_tp_cnt == tp_i:  # we use static tp now\n","                # if low[i] <= tp_arr[i] <= h[i]: --> 이건 잘못되었음\n","                # partial_tp_cnt += 1 --> partial_tp 보류\n","\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    # tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[i]:\n","                        tp = open[i]\n","                    # tp limit 이 가능한 경우 - open 이 아직, tp 를 넘지 않은 경우\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    #   tp limit 이 불가한 경우 - open 이 이미, tp 를 넘은 경우\n","                    if open[i] < tp_arr[tp_j]:  # static 해놓고 decay 사용하면 dynamic 이니까\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]  # tp_j -> open_i 를 가리키기 때문에 decay 는 한번만 진행되는게 맞음\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","        else:\n","            if high[i] >= tp_arr[tp_j]:\n","                # ------ dynamic tp ------ #\n","                if tp_arr[i] != tp_arr[i - 1] and not config.tp_set.static_tp:\n","                    if open[i] > tp_arr[i]:\n","                        tp = open[i]\n","                    else:\n","                        tp = tp_arr[i]\n","\n","                # ------ static tp ------ #\n","                else:\n","                    if open[i] > tp_arr[tp_j]:\n","                        if config.tr_set.decay_gap != \"None\" and decay_remain == 0:\n","                            tp = open[i]\n","                        else:\n","                            tp = tp_arr[tp_j]\n","                    else:\n","                        tp = tp_arr[tp_j]\n","\n","                if tp_i == len_tps - 1:\n","                    exit_done = 1  # partial 을 고려해 exit_done = 1 상태는 tp_i 가 last_index 로 체결된 경우만 해당\n","\n","    if exit_done:\n","        fee += config.trader_set.limit_fee\n","\n","    return exit_done, tp, fee\n","\n","\n","def check_signal_out_v3(res_df, config, open_i, i, len_df, fee, open_side, cross_on, exit_done, np_datas):    \n","\n","    _, _, _, close, np_timeidx = np_datas\n","    ex_p = None\n","    selection_id = config.selection_id\n","\n","    # ------ timestamp ------ #\n","    if config.out_set.tf_exit != \"None\":\n","        if np_timeidx[i] % config.out_set.tf_exit == config.out_set.tf_exit - 1 and i != open_i:\n","            exit_done = -1\n","\n","    # ------ rsi ------ # -> vectorize 가능함 => 추후 적용\n","    if config.out_set.rsi_exit:\n","        rsi_T = res_df['rsi_T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if (rsi_T[i - 1] >= 50 - config.loc_set.point.osc_band) & (rsi_T[i] < 50 - config.loc_set.point.osc_band):\n","                exit_done = -1\n","        else:\n","            if (rsi_T[i - 1] <= 50 + config.loc_set.point.osc_band) & (rsi_T[i] > 50 + config.loc_set.point.osc_band):\n","                exit_done = -1\n","\n","    # ------ heikin_ashi ------ #\n","    # if selection_id in ['v3_3']:\n","    #     if open_side == OrderSide.SELL:\n","    #       if (ha_o[i] < ha_c[i]):# & (ha_o[i] == ha_l[i]):   # 양봉 출현\n","    #           exit_done = -1\n","    #     else:\n","    #       if (ha_o[i] > ha_c[i]):# & (ha_o[i] == ha_h[i]):  # 음봉 출현\n","    #           exit_done = -1\n","\n","    # ------------ early out ------------ #\n","    # ------ bb ------ # --> cross_on 기능은 ide latency 개선 여부에 해당되지 않음\n","    if selection_id in ['v5_2']:\n","        bb_upper_5T = res_df['bb_upper_5T'].to_numpy()\n","        bb_lower_5T = res_df['bb_lower_5T'].to_numpy()\n","\n","        if open_side == OrderSide.SELL:\n","            if close[i] < bb_lower_5T[i] < close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] > bb_upper_5T[i] > close[i - 1]:\n","                exit_done = -1\n","        else:\n","            if close[i] > bb_upper_5T[i] > close[i - 1]:\n","                cross_on = 1\n","            if cross_on == 1 and close[i] < bb_lower_5T[i] < close[i - 1]:\n","                exit_done = -1\n","\n","    if exit_done:\n","        ex_p = close[i]\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, cross_on, ex_p, fee\n","\n","\n","def check_hl_out_v2(config, i, out_j, len_df, fee, open_side, exit_done, np_datas):\n","\n","    open, high, low, close, out_arr = np_datas\n","    ex_p = None\n","\n","    if config.out_set.hl_out:\n","        if open_side == OrderSide.SELL:\n","            if high[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if low[i] <= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","    else:  # close_out\n","        if open_side == OrderSide.SELL:\n","            if close[i] >= out_arr[out_j]:  # check out only once\n","                exit_done = -1\n","        else:\n","            if close[i] <= out_arr[out_j]:  # check out only once\n","                ex_p = close[i]\n","                exit_done = -1\n","\n","    if exit_done:\n","        if config.out_set.hl_out:\n","            ex_p = out_arr[out_j]\n","        else:\n","            ex_p = close[i]\n","\n","        if open_side == OrderSide.SELL:\n","            if open[i] >= out_arr[out_j]:\n","                ex_p = open[i]\n","        else:\n","            if open[i] <= out_arr[out_j]:\n","                ex_p = open[i]\n","\n","        fee += config.trader_set.market_fee\n","\n","    return exit_done, ex_p, fee"]},{"cell_type":"markdown","metadata":{"id":"zQ-roiifspcX"},"source":["#### ep_loc.point & zone legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Js5eL87VspcX"},"outputs":[],"source":["\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                 (res_df['close'] < res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] >= res_df['bb_lower_1m']) &\n","    #                 # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) <= res_df['bb_lower_1m']) &\n","    #                 (res_df['close'] < res_df['bb_lower_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] - 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['cloud_bline_%s' % cb_itv]) &\n","    #                   (res_df['close'] > res_df['cloud_bline_%s' % cb_itv])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","    # res_df['entry_{}'.format(selection_id)] = np.where((res_df['open'] <= res_df['bb_upper_1m']) &\n","    #                   # (res_df['close'].shift(config.loc_set.point.tf_entry * 1) >= res_df['bb_upper_1m']) &\n","    #                   (res_df['close'] > res_df['bb_upper_1m'])\n","    #                 , res_df['entry_{}'.format(selection_id)] + 1, res_df['entry_{}'.format(selection_id)])\n","\n","\n","    \n","   # --------------- ema --------------- #   \n","  # res_df['ema5_1m'] = ema(res_df['close'], 5).shift(1)\n","\n","  #   # --------------- cloud bline --------------- #   \n","  # res_df['cloud_bline_1m'] = cloud_bline(res_df, 26).shift(1)\n","  \n","    #       stochastic      #\n","  # res_df['stoch'] = stoch(res_df, 5, 3, 3)\n","\n","    #       fisher      #\n","  # res_df['fisher30'] = fisher(res_df, 30)\n","  # res_df['fisher60'] = fisher(res_df, 60)\n","  # res_df['fisher120'] = fisher(res_df, 120)\n","\n","    #       cctbbo      #\n","  # res_df['cctbbo'], _ = cct_bbo(res_df, 21, 13)\n","\n","    #       ema_roc      #\n","  # res_df['ema_roc'] = ema_roc(res_df['close'], 13, 9)\n","\n","\n","   # ------------------------------ htf data ------------------------------ #    \n","\n","  #             Todo              #\n","  # htf_df = pd.read_excel(date_path2 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # htf_df = pd.read_excel(date_path3 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # htf_df = pd.read_excel(date_path4 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # htf_df = pd.read_excel(date_path5 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","  # # # # # # htf_df = pd.read_excel(date_path6 + key.replace(\"_st1h_backi2\", \"\"), index_col=0)\n","\n","  # # ---- htf index slicing ---- #\n","  # htf_df = htf_df.loc[:res_df.index[-1]]\n","  \n","  # print(\"res_df.index[-1] :\", res_df.index[-1])\n","  # print(\"htf_df.index[-1] :\", htf_df.index[-1])\n","\n","  # res_df = dc_line(res_df, htf_df, '5m')\n","  # res_df = dc_level(res_df, '5m', 1)\n","\n","\n","  # # # if \"sma4\" in res_df.columns:\n","  # # #   res_df.drop(\"sma4\", axis=1, inplace=1)\n","\n","  # # htf_df['sma'] = htf_df['close'].rolling(60).mean()\n","  # # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1]), columns=['sma_30m']))\n","  \n","  # htf_df['stoch'] = stoch(htf_df, 13, 3, 3)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, htf_df, [-1], backing_i=-1), columns=['stoch_5m']))\n","\n","   \n","  # fifth_df['ema'] = ema(fifth_df['close'], 5)\n","  # res_df = res_df.join(pd.DataFrame(index=res_df.index, data=to_lower_tf_v2(res_df, fifth_df, [-1]), columns=['ema5']))\n","\n","        # ------------------------------------ short ------------------------------------ # \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 0:\n","        #   mr_score += 1          \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 0:\n","        #   mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_upper_1m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_upper_3m'].iloc[i] <= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_upper_5m'].iloc[i] <= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == 'MARKET':\n","        #   mr_const_cnt += 1\n","        #   if (res_df['close'].iloc[i] - res_df['short_tp'].iloc[i]) / (res_df['short_out'].iloc[i] - res_df['close'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error):  \n","        #     mr_score += 1\n","\n","           \n","        # ------- entry once ------- #   \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == 1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == -1:\n","        #     prev_entry_cnt += 1          \n","        # # # print(\"prev_entry_cnt :\", prev_entry_cnt)\n","\n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] < res_df['bb_lower_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_lower2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] < res_df['bb_base_1h'].iloc[i]:\n","\n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] < res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","  \n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['low'].iloc[i] > res_df['short_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","\n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1\n","\n","\n","\n","        # ------------------------------------ long ------------------------------------ # \n","          \n","\n","        # --------- by sar --------- # \n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_3m'].iloc[i] == 1:\n","        #   mr_score += 1   \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_5m'].iloc[i] == 1:\n","        #   mr_score += 1     \n","\n","        # mr_const_cnt += 1\n","        # if res_df['sar_uptrend_15m'].iloc[i] == 1:\n","          # mr_score += 1\n","\n","          #      dc & sar      # \n","        # mr_const_cnt += 1\n","        # # if res_df['dc_lower_1m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        # if res_df['dc_lower_3m'].iloc[i] >= res_df['sar_5m'].iloc[i]:\n","        # # if res_df['dc_lower_5m'].iloc[i] >= res_df['sar_15m'].iloc[i]:\n","        #   mr_score += 1\n","\n","        # -------------- dr scheduling -------------- #\n","        # if config.ep_set.entry_type == \"MARKET\":\n","          # mr_const_cnt += 1        \n","          # if (res_df['long_tp'].iloc[i] - res_df['close'].iloc[i]) / (res_df['close'].iloc[i] - res_df['long_out'].iloc[i]) <= config.ep_set.tr_thresh * (1 + config.ep_set.dr_error): # 일반적으로 dr 상에서 tp 비율이 더 커짐 (tr 보다)\n","          #   mr_score += 1\n","\n","        # -------------- ep limit -------------- #    \n","        # mr_const_cnt += 1\n","        # # if (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # if config.ep_set.min_eplim_pct < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        # # if 0 < (res_df['open'].iloc[i] - res_df['long_ep'].iloc[i]) / res_df['open'].iloc[i] < config.ep_set.max_eplim_pct:\n","        #   # if res_df['st_gap_15m'].iloc[i] / res_df['open'].iloc[i] < 0:\n","        #   #   print(\"i, res_df['st_gap_15m'].iloc[i] :\", i, res_df['st_gap_15m'].iloc[i])\n","        #   mr_score += 1\n","\n","\n","        # -------------- entry once -------------- #    \n","        # prev_entry_cnt = 0\n","        # for back_i in range(i - 1, 0, -1):\n","        #   if res_df['entry'][back_i] == -1:\n","        #     break\n","\n","        #   elif res_df['entry'][back_i] == 1:\n","        #     prev_entry_cnt += 1\n","          \n","        # mr_const_cnt += 1\n","        # # if prev_entry_cnt <= config.ep_set.entry_incycle:\n","        # # if prev_entry_cnt == config.ep_set.entry_incycle:\n","        # if prev_entry_cnt >= config.ep_set.entry_incycle:\n","        #   mr_score += 1\n","\n","\n","        # ------- htf zoning ------- #   \n","        # mr_const_cnt += 1\n","          \n","        #   #       bb zone     #\n","        # if res_df['close'].iloc[i] > res_df['bb_upper_%s' % bbz_interval].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_upper2_1h'].iloc[i]:\n","        # # if res_df['close'].iloc[i] > res_df['bb_base_1h'].iloc[i]:\n","        \n","        #   #       cbline zone     #\n","        # # if res_df['close'].iloc[i] > res_df['cloud_bline_%s' % cb_interval].iloc[i]:\n","\n","        #   mr_score += 1\n","\n","\n","        # ------- ben ep_in's tp done ------- #   \n","        # mr_const_cnt += 1\n","        # if res_df['high'].iloc[i] < res_df['long_tp'].iloc[i]:\n","        #   mr_score += 1\n","\n","\n","        # -------------- feature dist const. -------------- #\n","        # if initial_i < input_size:\n","        #   i += 1\n","        #   if i >= len(res_df):\n","        #     break\n","        #   continue\n","          \n","        # entry_input_x = min_max_scale(res_df[selected_price_colname].iloc[initial_i - input_size:initial_i].values)\n","       \n","        # re_entry_input_x = expand_dims(entry_input_x)\n","\n","        # entry_vector = model.predict(re_entry_input_x, verbose=0)\n","        # # print(test_result.shape)\n","\n","        # f_dist = vector_dist(entry_vector, selected_vector)\n","        # print(\"f_dist :\", f_dist)\n","\n","        # if f_dist < fdist_thresh:\n","          # mr_score += 1"]},{"cell_type":"markdown","source":["#### legacy"],"metadata":{"id":"qM6H6fmrKtsA"}},{"cell_type":"code","source":["res_df.low.rolling(100) #> 1000"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"oLDZobRcgg6E","executionInfo":{"status":"ok","timestamp":1653436951068,"user_tz":-540,"elapsed":260,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"2f07e665-41ba-4c7e-b5d7-43fc14d09cd5"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["Rolling [window=100,center=False,axis=0,method=single]"]},"metadata":{},"execution_count":92}]},{"cell_type":"code","source":["def get_touch_idx_fill(tp_1_touch_idxs, net_p1_pair, net_p1_idx, len_df):\n","\n","    tp_1_touch_idx = np.full(len_df, np.nan)\n","    tp_1_touch_idx[net_p1_idx] = [np.nanmin(tp_1_touch_idxs[iin:iout]) for iin, iout in net_p1_pair]\n","    \n","    return fill_arr(tp_1_touch_idx)\n","    \n","def get_wave_bias_v5(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int)  # .reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel()  # .reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  # .reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  # .reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range,\n","                                    last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range,\n","                                      last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range,\n","                                     last_idx)  # .rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    # print(\"np.sum(long_p2_false_bias_bool != ~long_p2_true_bias_bool) :\", np.sum(long_p2_false_bias_bool != ~long_p2_true_bias_bool))\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_tpbox_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_tpbox_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_tpbox_p2exec_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_tpbox_p2exec_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_outbox_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_outbox_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_tpbox_hhm, short_p2_hhm, short_outbox_hhm :\", short_tpbox_hhm, short_p2_hhm, short_outbox_hhm)\n","\n","    return short_tpbox_hhm, long_tpbox_hhm, short_tpbox_p2exec_hhm, long_tpbox_p2exec_hhm, short_outbox_hhm, long_outbox_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"],"metadata":{"id":"uB-I09hKKvmu"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["def get_wave_bias_v4(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj,\n","                     long_obj):\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(),\n","                            short_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(),\n","                             short_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)  # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ------------------ touch idx ------------------ #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    short_tp_1_touch_idx = pd.Series(np.where(low <= short_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_tp_0_touch_idx = pd.Series(np.where(high >= short_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_1_touch_idx = pd.Series(np.where(high >= long_tp_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_tp_0_touch_idx = pd.Series(np.where(low <= long_tp_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_out_1_touch_idx = pd.Series(np.where(low <= short_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    short_out_0_touch_idx = pd.Series(np.where(high >= short_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_1_touch_idx = pd.Series(np.where(high >= long_out_1, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","    long_out_0_touch_idx = pd.Series(np.where(low <= long_out_0, len_df_range, last_idx)).rolling(bias_info_tick, min_periods=1).min().shift(\n","        -shift_range).to_numpy()\n","\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]  # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]  # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    # print(np.sum(np.isnan(short_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(short_tp_0_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_1_unq_p1_touch_idx)))\n","    # print(np.sum(np.isnan(long_tp_0_unq_p1_touch_idx)))\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]  # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]  # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = nan value\n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    # short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    # long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","    \n","    # print(\"np.sum(short_net_p1_true_bias_bool) :\", np.sum(short_net_p1_true_bias_bool))\n","    # print(\"np.sum(long_net_p1_true_bias_bool) :\", np.sum(long_net_p1_true_bias_bool))\n","\n","    # print(\"np.sum(short_unq_p1_true_bias_bool) :\", np.sum(short_unq_p1_true_bias_bool))\n","    # print(\"np.sum(short_unq_p1_false_bias_bool) :\", np.sum(short_unq_p1_false_bias_bool))\n","    # print(\"np.sum(long_unq_p1_true_bias_bool) :\", np.sum(long_unq_p1_true_bias_bool))\n","    # print(\"np.sum(long_unq_p1_false_bias_bool) :\", np.sum(long_unq_p1_false_bias_bool))\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","           short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","           short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], \\\n","           long_ep2_0[long_en_idx]  # plot_check 을 위해 en_idx 넣음"],"metadata":{"id":"FuIwazc3P5d1"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"_blyFhQJUd5X"},"source":["#### dump"]},{"cell_type":"code","source":["\n","def hlm(pr_list, true_bool):   # true_pr in true_bias / true_bias\n","  true_bias_pr = pr_list[true_bool].ravel()\n","  print(\"len(pr_list) :\", len(pr_list))\n","  print(\"len(true_bias_pr) :\", len(true_bias_pr))\n","  print(\"np.sum(pr_list > 1) :\", np.sum(pr_list > 1))\n","  print(\"np.sum(true_bias_pr > 1) :\", np.sum(true_bias_pr > 1))\n","  return np.sum(true_bias_pr > 1) / len(true_bias_pr)  # 차원을 고려한 계산"],"metadata":{"id":"6YcqQQzsl6Ys"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","def get_wave_bias_v5_1(res_df, config, high, low, len_df, short_net_p1_idx_arr, long_net_p1_idx_arr, short_p2_idx_arr, long_p2_idx_arr, short_obj, long_obj):\n","\n","    short_net_p1_idx = short_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    short_p1_idx = short_obj[-1].astype(int).ravel()\n","    short_p2_idx = short_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    short_en_idx = short_obj[2].astype(int)\n","\n","    short_prime_net_p1_bool = short_net_p1_idx - pd.Series(short_net_p1_idx).shift(1).to_numpy() > 1\n","    short_prime_net_p1_bool[0] = True\n","    short_prime_net_p1_idx = short_net_p1_idx[short_prime_net_p1_bool]\n","    \n","    short_prime_p2_bool = short_p2_idx - pd.Series(short_p2_idx).shift(1).to_numpy() > 1\n","    short_prime_p2_bool[0] = True\n","    short_prime_p2_idx = short_p2_idx[short_prime_p2_bool]\n","    \n","    short_tp_1 = ffill_line(res_df['short_tp_1_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)  # net_p1_idx ~ net_p1_idx' 사이에 대한 momentum 조사 (net 이유는 logic's validation)\n","    short_tp_0 = ffill_line(res_df['short_tp_0_{}'.format(config.selection_id)].to_numpy(), short_prime_net_p1_idx)\n","    short_out_1 = ffill_line(res_df['short_out_1_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    short_out_0 = ffill_line(res_df['short_out_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    short_ep2_0 = ffill_line(res_df['short_ep2_0_{}'.format(config.selection_id)].to_numpy(), short_prime_p2_idx)\n","    # short_net_wave_1 = ffill_line(res_df['short_wave_1_{}'.format(config.selection_id)].to_numpy(), short_op_idx)  # en_idx 에 sync 된 open_idx 를 사용해야함\n","    # short_net_wave_0 = ffill_line(res_df['short_wave_0_{}'.format(config.selection_id)].to_numpy(), short_op_idx)\n","\n","    long_net_p1_idx = long_net_p1_idx_arr.astype(int) #.reshape(-1, 1)\n","    long_p1_idx = long_obj[-1].astype(int).ravel()\n","    long_p2_idx = long_p2_idx_arr.astype(int).ravel() #.reshape(-1, 1)\n","    long_en_idx = long_obj[2].astype(int)\n","\n","    long_prime_net_p1_bool = long_net_p1_idx - pd.Series(long_net_p1_idx).shift(1).to_numpy() > 1\n","    long_prime_net_p1_bool[0] = True\n","    long_prime_net_p1_idx = long_net_p1_idx[long_prime_net_p1_bool]\n","    \n","    long_prime_p2_bool = long_p2_idx - pd.Series(long_p2_idx).shift(1).to_numpy() > 1\n","    long_prime_p2_bool[0] = True\n","    long_prime_p2_idx = long_p2_idx[long_prime_p2_bool]\n","    \n","    long_tp_1 = ffill_line(res_df['long_tp_1_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_tp_0 = ffill_line(res_df['long_tp_0_{}'.format(config.selection_id)].to_numpy(), long_prime_net_p1_idx)\n","    long_out_1 = ffill_line(res_df['long_out_1_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)  # 체결된, p2_idx ~ p2_idx' 사이에 대한 momentum 조사\n","    long_out_0 = ffill_line(res_df['long_out_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","    long_ep2_0 = ffill_line(res_df['long_ep2_0_{}'.format(config.selection_id)].to_numpy(), long_prime_p2_idx)\n","\n","    short_unq_p1_idx = np.unique(short_p1_idx)  #.reshape(-1, 1)   # 통일성을 위해 2d 로 설정\n","    long_unq_p1_idx = np.unique(long_p1_idx)  #.reshape(-1, 1)\n","\n","    bias_info_tick = config.tr_set.bias_info_tick\n","\n","    # print(\"long_net_p1_idx.shape :\", long_net_p1_idx.shape)\n","    # print(\"long_en_idx.shape :\", long_en_idx.shape)\n","\n","    # ================== touch idx ================== #\n","    # 1. min 에 초점을 맞추는 거니까, touch 없을시 len_df 로 설정\n","    # 2. future_data 사용이니까, shift(-bias_info_tick) 설정\n","    # 3. entry 다음 idx 부터 -> tp & out 체결 logic 이 현재 entry_idx 부터 되어있어서 취소\n","    # Todo, high 와 low 중 어디에 먼저닿느냐가 중요함을 key 로 잡고만든 logic 임\n","    len_df_range = np.arange(len_df)\n","    last_idx = len_df - 1  # nan 발생하면 대소 비교로 hhm 확인이 불가능해짐\n","    shift_range = bias_info_tick - 1  # entry_idx 까지 포함해서 wave_bias check\n","\n","    # ------------ pair & idxs ------------ #\n","    short_net_p1_pair = list(zip(short_net_p1_idx, np.append(short_net_p1_idx[1:], last_idx)))\n","    long_net_p1_pair = list(zip(long_net_p1_idx, np.append(long_net_p1_idx[1:], last_idx)))\n","\n","    short_p2_pair = list(zip(short_p2_idx, np.append(short_p2_idx[1:], last_idx)))\n","    long_p2_pair = list(zip(long_p2_idx, np.append(long_p2_idx[1:], last_idx)))\n","\n","    short_tp_1_touch_idxs = np.where(low <= short_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_tp_0_touch_idxs = np.where(high >= short_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_1_touch_idxs = np.where(high >= long_tp_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_tp_0_touch_idxs = np.where(low <= long_tp_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    short_out_1_touch_idxs = np.where(low <= short_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    short_out_0_touch_idxs = np.where(high >= short_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_1_touch_idxs = np.where(high >= long_out_1, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","    long_out_0_touch_idxs = np.where(low <= long_out_0, len_df_range, last_idx)   #.rolling(bias_info_tick, min_periods=1).min().shift(-shift_range).to_numpy()\n","\n","    # ------------ min touch_idx ------------ #\n","    short_tp_1_touch_idx = get_touch_idx_fill(short_tp_1_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)  # pair means 구간\n","    short_tp_0_touch_idx = get_touch_idx_fill(short_tp_0_touch_idxs, short_net_p1_pair, short_net_p1_idx, len_df)\n","    long_tp_1_touch_idx = get_touch_idx_fill(long_tp_1_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","    long_tp_0_touch_idx = get_touch_idx_fill(long_tp_0_touch_idxs, long_net_p1_pair, long_net_p1_idx, len_df)\n","\n","    short_out_1_touch_idx = get_touch_idx_fill(short_out_1_touch_idxs, short_p2_pair, short_p2_idx, len_df)  # pair means 구간\n","    short_out_0_touch_idx = get_touch_idx_fill(short_out_0_touch_idxs, short_p2_pair, short_p2_idx, len_df)\n","    long_out_1_touch_idx = get_touch_idx_fill(long_out_1_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","    long_out_0_touch_idx = get_touch_idx_fill(long_out_0_touch_idxs, long_p2_pair, long_p2_idx, len_df)\n","\n","    # ------------ point's touch_idx ------------ #\n","    short_tp_1_net_p1_touch_idx = short_tp_1_touch_idx[short_net_p1_idx]   # for tp_box's net_hhm\n","    short_tp_0_net_p1_touch_idx = short_tp_0_touch_idx[short_net_p1_idx]\n","    long_tp_1_net_p1_touch_idx = long_tp_1_touch_idx[long_net_p1_idx]\n","    long_tp_0_net_p1_touch_idx = long_tp_0_touch_idx[long_net_p1_idx]\n","    # print(\"long_tp_1_net_p1_touch_idx :\", long_tp_1_net_p1_touch_idx)\n","\n","    short_tp_1_unq_p1_touch_idx = short_tp_1_touch_idx[short_unq_p1_idx]    # p2 까지 체결된 p1's hhm\n","    short_tp_0_unq_p1_touch_idx = short_tp_0_touch_idx[short_unq_p1_idx]\n","    long_tp_1_unq_p1_touch_idx = long_tp_1_touch_idx[long_unq_p1_idx]\n","    long_tp_0_unq_p1_touch_idx = long_tp_0_touch_idx[long_unq_p1_idx]\n","\n","    short_tp_1_p2_touch_idx = short_tp_1_touch_idx[short_p2_idx]    # hlm 을 위한 hhm (on p2)\n","    short_tp_0_p2_touch_idx = short_tp_0_touch_idx[short_p2_idx]\n","    long_tp_1_p2_touch_idx = long_tp_1_touch_idx[long_p2_idx]\n","    long_tp_0_p2_touch_idx = long_tp_0_touch_idx[long_p2_idx]\n","\n","    short_out_1_p2_touch_idx = short_out_1_touch_idx[short_p2_idx]   # for out_box's executed_hhm\n","    short_out_0_p2_touch_idx = short_out_0_touch_idx[short_p2_idx]\n","    long_out_1_p2_touch_idx = long_out_1_touch_idx[long_p2_idx]\n","    long_out_0_p2_touch_idx = long_out_0_touch_idx[long_p2_idx]\n","\n","    # ------------------ bias_bool & hhm ------------------ #\n","    short_net_p1_true_bias_bool = short_tp_1_net_p1_touch_idx < short_tp_0_net_p1_touch_idx  # true_bias 의 조건\n","    short_net_p1_false_bias_bool = short_tp_1_net_p1_touch_idx >= short_tp_0_net_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx\n","    long_net_p1_true_bias_bool = long_tp_1_net_p1_touch_idx < long_tp_0_net_p1_touch_idx\n","    long_net_p1_false_bias_bool = long_tp_1_net_p1_touch_idx >= long_tp_0_net_p1_touch_idx\n","\n","    short_unq_p1_true_bias_bool = short_tp_1_unq_p1_touch_idx < short_tp_0_unq_p1_touch_idx  # true_bias 의 조건\n","    short_unq_p1_false_bias_bool = short_tp_1_unq_p1_touch_idx >= short_tp_0_unq_p1_touch_idx  # false_bias 의 조건, ~true_bias_bool 와 같지 않음, why ..? = en_idx    \n","    long_unq_p1_true_bias_bool = long_tp_1_unq_p1_touch_idx < long_tp_0_unq_p1_touch_idx\n","    long_unq_p1_false_bias_bool = long_tp_1_unq_p1_touch_idx >= long_tp_0_unq_p1_touch_idx\n","\n","    short_p2_true_bias_bool = short_tp_1_p2_touch_idx < short_tp_0_p2_touch_idx\n","    short_p2_false_bias_bool = short_tp_1_p2_touch_idx >= short_tp_0_p2_touch_idx\n","    long_p2_true_bias_bool = long_tp_1_p2_touch_idx < long_tp_0_p2_touch_idx\n","    long_p2_false_bias_bool = long_tp_1_p2_touch_idx >= long_tp_0_p2_touch_idx\n","\n","    short_p2_out_true_bias_bool = short_out_1_p2_touch_idx < short_out_0_p2_touch_idx\n","    short_p2_out_false_bias_bool = short_out_1_p2_touch_idx >= short_out_0_p2_touch_idx\n","    long_p2_out_true_bias_bool = long_out_1_p2_touch_idx < long_out_0_p2_touch_idx\n","    long_p2_out_false_bias_bool = long_out_1_p2_touch_idx >= long_out_0_p2_touch_idx\n","\n","    short_net_p1_hhm = hhm(short_net_p1_true_bias_bool, short_net_p1_false_bias_bool)\n","    long_net_p1_hhm = hhm(long_net_p1_true_bias_bool, long_net_p1_false_bias_bool)\n","\n","    short_p1_hhm = hhm(short_unq_p1_true_bias_bool, short_unq_p1_false_bias_bool)\n","    long_p1_hhm = hhm(long_unq_p1_true_bias_bool, long_unq_p1_false_bias_bool)\n","\n","    # short_p2_hhm = hhm(short_p2_true_bias_bool, short_p2_false_bias_bool)\n","    # long_p2_hhm = hhm(long_p2_true_bias_bool, long_p2_false_bias_bool)\n","\n","    short_out_hhm = hhm(short_p2_out_true_bias_bool, short_p2_out_false_bias_bool)\n","    long_out_hhm = hhm(long_p2_out_true_bias_bool, long_p2_out_false_bias_bool)\n","\n","    # print(\"short_net_p1_hhm, short_p2_hhm, short_out_hhm :\", short_net_p1_hhm, short_p2_hhm, short_out_hhm)\n","\n","    return short_net_p1_hhm, long_net_p1_hhm, short_p1_hhm, long_p1_hhm, short_out_hhm, long_out_hhm, short_p2_true_bias_bool, long_p2_true_bias_bool, \\\n","          short_tp_1[short_en_idx], short_tp_0[short_en_idx], long_tp_1[long_en_idx], long_tp_0[long_en_idx], \\\n","          short_out_1[short_en_idx], short_out_0[short_en_idx], long_out_1[long_en_idx], long_out_0[long_en_idx], short_ep2_0[short_en_idx], long_ep2_0[long_en_idx]   # plot_check 을 위해 en_idx 넣음\n","          "],"metadata":{"id":"t7a5Hyyyd5Lk"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["\n","        # tr_arr = res_df['{}_tr_{}'.format(side_pos, selection_id)].to_numpy()\n","\n","        # ------ point1 & 2's tp_j ------ #\n","        # point_idxgap = point_idxgap_arr[op_idx]\n","        # if np.isnan(point_idxgap):\n","        #     continue\n","        # else:\n","        #     # ------ allow point2 only next to point1 ------ #\n","        #     open_arr = res_df['{}_open_{}'.format(side_pos, selection_id)].to_numpy()\n","        #     tp_j = int(op_idx - point_idxgap)\n","        #     if np.sum(open_arr[tp_j:op_idx]) != 0:\n","        #         continue"],"metadata":{"id":"dsI-R8Zz7ls1"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() < 1,\n","                facecolor='#ff00ff', alpha=1, transform=ax2.get_xaxis_transform())\n","plt.show()"],"metadata":{"id":"gMur2u8WeQ2K","colab":{"base_uri":"https://localhost:8080/","height":157},"executionInfo":{"status":"ok","timestamp":1652751452213,"user_tz":-540,"elapsed":350,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"7b506c38-7a8f-4bd1-a021-8a065d009882"},"execution_count":null,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1152x144 with 2 Axes>"],"image/png":"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NmzYYN58883Y+127dpldu3ZlpO/KysoFG9ShoSFTWlpqpLkENDQ0ZCSZ559/3oRCoSX1QqGQef7552PHr9QrLS01g4ODsePz6yXqI5Xy97//3dx9991ZE/fVV19tPvjgA1NfX2/Onj1rCgoKlqyBN99802zYsMFIMgUFBebs2bNx18WVesnWT6I+7JSysjLz9ttvm29/+9uxJOn3mKX4G1Q/r4/rr7/enDhxYslxP8e8uNxzzz3mX//6l+/jvummm8zJkydNcXGxKSgoMO3t7aaxsTEr1jVlecpy5udsKtmWi/1csjX3+rnkQp71YyGnxi858yu+ZWVlGhsbi70fHx9XWVnZssRy44036tSpU5KkU6dO6cYbb0waY7Lj4+PjS44n68OpyspK1dXV6ejRo76POz8/Xz09PTpz5ow6Ozs1MjKizz//XLOzs0v6mR/b7OysZmZmtHbtWsdjWbt2bcI+7Pjtb3+rn/zkJ7p06ZIkJW3PLzFLkjFGb731lrq7u7V9+3ZJ/l7X1dXVOnv2rP74xz/q2LFj2r9/v6655hpfx7xYKBTSX/7yl6Rt+iHuyclJ/epXv9LJkyf16aefamZmRh988EFWrGssDz/lZ7/KplycDbI19/pZLuRZPyKnxpczG1Q/M8b4so9rr71Wr732mh5//HF98cUXnrTplJM+Ll26pLq6OpWXl6u+vl5f+9rX0hiZe9/97nd15syZrPza729961tav369tmzZokcffVS33377kjp+Wh+rVq3SunXrtHfvXq1bt07//e9/tWvXrpTbcyOVPgoLC7V161YdOnTIszadsttHIBBQU1OTqqurddNNN+naa6/V5s2b0xwdkLuyLRf7XTbnXj/L9jzrV+TU+HJmgzoxMaGKiorY+/Lyck1MTCxLLKdPn1ZpaakkqbS0VGfOnEkaY7Lj5eXlS44n68OuVatW6bXXXtNLL72k119/PWvilqSZmRm98847+uY3v6lAIKCCgoIl/cyPraCgQGvWrNFnn33meCyfffZZwj6sbNy4UVu3btXo6KhaW1v1ne98R3v27PF1zFdMTk5Kks6ePavXX39d9fX1vl4f4+PjGh8f1/vvvy9JevXVV7Vu3Tpfxzzfli1bdOzYsdi1fo777rvv1ujoqKampnTx4kX97W9/08aNG7NiXWN5+Ck/+00252K/yubc62fZnmf9ipwaX85sUMPhsGpqalRVVaXCwkKFQiG1tbUtSyxtbW3atm2bJGnbtm164403YsevfFtZQ0ODZmZmdOrUKXV0dKixsVGBQECBQECNjY3q6OjQqVOn9J///EcNDQ2S5r71bH5b8fqw68CBAxocHNRvfvObrIi7pKREa9askSStXr1a99xzjwYHB/XOO+/o3nvvjRvzlX7uvfdeHTlyJHY8FAqpqKhIVVVVqqmp0fvvv590/STqw8qTTz6piooKVVdXKxQK6ciRI/rBD37g65gl6ZprrtF1110X+3NjY6OOHz/u6/Vx+vRpjY2N6ZZbbpEk3XXXXRoYGPB1zPPdf//9sV/vTdamH+I+efKkNmzYoKuvvnrBXPt9XWP5+Ck/+0225eJskK251++yPc/6FTk1sWX/h7BelS1btpiPP/7YRKNR8+STT2akz5dfftlMTk6a8+fPm7GxMfPDH/7QfOUrXzFvv/22GR4eNp2dnaa4uDhW/3e/+52JRqPmww8/NOvXr48df/DBB00kEjGRSMQ88MADsePr1683/f39JhqNmueeey52PFkfVmXjxo3GGGP6+vpMT0+P6enpMVu2bPF13F//+tfNsWPHTF9fn+nv7zc/+9nPjCRTXV1tjh49aiKRiHnllVdMUVGRkWSuuuoq88orr5hIJGKOHj1qqqurY209+eSTJhqNmqGhodg3xCVbP4n6cFLuuOOO2Bc1+D3m6upq09vba3p7e83x48dj7fp5fUgyt956qwmHw6avr8+8/vrrJhAI+D5mSeaaa64xU1NT5vrrr7fVph/ifuqpp8zg4KDp7+83L774oikqKvL9uqYsb1mO/Oz3ko25ONtKNuXebCjZmmf9XsipS0ve5T8AAAAAALCscuZXfAEAAAAA2Y0NKgAAAADAF9igAgAAAAB8gQ0qAAAAAMAX2KACAAAAAHyBDSoAAAAAwBfYoAIAAAAAfIENKgAAAADAF/4fj/mXQjWbHIMAAAAASUVORK5CYII=\n"},"metadata":{}}]},{"cell_type":"code","source":["# ------ bias frquency ------ #\n","len_df = len(res_df)\n","\n","plt.figure(figsize=(16, 2))\n","\n","ax1 = plt.subplot(121)\n","plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() > 0,\n","                facecolor='#00ff00', alpha=1, transform=ax1.get_xaxis_transform())   # 00ff00\n","# plt.fill_between(short_obj[-2].ravel(), 0, 1, where=short_bias_arr.ravel() < 1,\n","#                 facecolor='#ff00ff', alpha=1, transform=ax1.get_xaxis_transform())\n","\n","ax2 = plt.subplot(122)\n","plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')\n","plt.vlines(long_obj[-2][~long_bias_arr], ymin=0, ymax=1, color='#ff00ff')\n","# [plt.axvline(x_, color='#ff00ff') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if not bias_]\n","plt.show()"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":157},"id":"eoXMxRm3qdz2","executionInfo":{"status":"ok","timestamp":1652756329304,"user_tz":-540,"elapsed":872,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"98c90b55-4c14-402c-e2d4-d7b88f9e2e62"},"execution_count":null,"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 1152x144 with 2 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAAA6gAAACMCAYAAABxlISVAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAZuElEQVR4nO3df0zU9x3H8dfuhLrZ1GOalnhQ4A+24JJ2qKgJWd3WCtol8odLStcF2xibdmNNuz+GcX8w23/ULeuMc9bQ6uzSDn90XSGRUo2Y7Q+hZ6UWC8idssqds/46zbKZiPDZH8i33HH3vaPclS/H80E+we/n+7nP5/P9fD9f374Ld/2aJCMAAAAAAKaYa6onAAAAAACARIIKAAAAAHAIElQAAAAAgCOQoAIAAAAAHIEEFQAAAADgCCSoAAAAAABHmDXVE4h2+fJlffbZZ6npbImkkzbH0XVLYvQRfe7kmNcsSdAmVh/R4090HrHaJ6qz62eiku3P7lrj9TW2v2TGiXVPkuk73vmxfcUbM3r8WPc++lyi83b7NN4eU5x6uzHt5m/X3m5Mu709mT2Q6HoSPS+x5hprjFjfo+eXaD7JjBU9/7F92/U30efXbj3jjRXvfifzzI1tF2s/2H2PNTe7Z3oSCgoKdP/996emsxkqpbEZADDjJYrNxq688cYb5vPPPzddXV1x22zfvt34/X5z+vRpU1paatXX1NSYvr4+09fXZ2pqamzHGS0+ny+pdkkVk+A4ui7WV/Q5RX23axPrfDJztZtHstcSr69UrGky/SUzVjLrbTdOrHuS7BrG+4p1Xydyz+z2Xrzzsdravc5uvezGTOb5mMgesruGye6BRNdjtyZ26xOrj1h9Rl9DMntoovcomf7i9fVl1jNeO7vnKtEzl2g/2H23u5fJ7p8kS0rjikPKtI7NFAqFQpnxJUFcsX/x9773PVNaWho3CK5evdocPnzYSDLLli0z7e3tRpLJyckx586dMzk5Ocbj8Zhz584Zj8cz2clOrMT6R5ldm2T+gauo73ZtEv2D9MvMI9lriddXKtY0mf4m84/pZMex+8dsojWM9xXrvk7kntntvXjnY7W1e53detmNmczzMZE9ZHcNk90Dia7Hbk3s1idWH7H6jL6GZPbQRO9RMv3F6+vLrGe8dnbPVaJnLtF+sPtudy+T3T9JlkxMrqZ1bKZQKBTKjC92cSXhe1D/+c9/6vr163HPV1VV6c0335QkdXR0yOPxKDc3V5WVlTpy5IjC4bBu3LihI0eOaNWqVYmGAwAACRCbAQCZatIfkuT1ejUwMGAdB4NBeb3euPUAACC9iM0AgOnKEZ/iu2HDBvl8Pvl8Ps2fP3+qpwMAwIyXjtjcVt6mQfegwnPD0qDUpja1rRgpg+5BDboH1fZwm8L3hRWeG1bbI20j31e0ScNS24o2hTVSP3o8em7QPahB1+BIv2Pq21aM9DHavzV+WBHnw/eF1VbeNlI/5tywhkfmtaLNms9w1NfoeG0r2jToGtSwhhW+LywNj/QTnhu2riN83xevH60b7XfQPTgyh7HzmhMeWZM5YWvuo9cxtp/o+tE5j84h3pqMvZ7ofkdfY82/vG2k3O1ntF6DGiljrne077bykXsWnhuOfM3wyDq3lbdFrI91L+/Of+zcRq81Yn3ujhVrLaLv07h1CeuL/fJIW8T+GP0+Oi9r/Pu+OB50Ra6xtdaPjNxnq785d+9j+Rd7bVT0fhq9rpjzfqQtcs535z36PGh45NzYuUavbfSaRl/z6B5se2TkXqtNUtvIsxpvTUf7ihhrUFY/Cmvcmo4+36N7Yuy9GfuMRNRHXcvY/TT23Nh92/ZIW8SzNPo1+pyOXQPr74ao5yV6fjHnPLp+rsFxz0f0nEb/ronet4PuwZG9MShr3mP3etsjd+/H3T1g/Z0xpn+F796vsev1SJu1Z8auSVt528jfLWOeGev61TZu7tbfjV9s37SZdIIaCoWUn59vHefl5SkUCsWtj6WhoUFlZWUqKyvT1atXJzslAABmNGIzAGC6mnSC2tTUpJqaGknSsmXLdPPmTV26dEmtra2qqKiQx+ORx+NRRUWFWltbJz1hAABgj9gMAJiuEv5/UN9++219//vf1/z58zUwMKD6+nplZWVJknbv3q3Dhw/r8ccfVyAQ0P/+9z8988wzkqRwOKxXXnlFPp9PkvTyyy8rHP4KfiYMAECGIzYDADJVwgT1Jz/5ScJOamtrY9bv3btXe/funfisAABAXMRmAECmcsSHJAEAAAAAQIIKAAAAAHAEElQAAAAAgCOQoAIAAAAAHIEEFQAAAADgCCSoAAAAAABHIEEFAAAAADgCCSoAAAAAwBFIUAEAAAAAjkCCCgAAAABwBBJUAAAAAIAjkKACAAAAAByBBBUAAAAA4AgkqAAAAAAARyBBBQAAAAA4AgkqAAAAAMARkkpQKysr1dvbK7/fr7q6unHnf//736uzs1OdnZ06e/aswuGwde7OnTvWuffeey91MwcAYAYjNgMAMtGsRA1cLpd27typlStXKhgMyufzqampST09PVabX/7yl9afa2trVVpaah3funUr4hgAAEwOsRkAkKkS/gR16dKlCgQC6u/v1+DgoBobG1VVVRW3/ZNPPqm//vWvKZ0kAAD4ArEZAJCpEiaoXq9XAwMD1nEwGJTX643Z9sEHH1RRUZGOHTtm1c2ePVs+n08nTpywDZ4AACA5xGYAQKZK+Cu+E1FdXa1Dhw5peHjYqisoKNDFixet4NjV1aXz589HvG7Dhg169tlnJUnz589P5ZQAAJjRiM0AgOkk4U9QQ6GQ8vPzreO8vDyFQqGYbaurq8f9CtHFixclSf39/Tp+/HjM97w0NDSorKxMZWVlunr16oQuAACAmYbYDADIVAkTVJ/Pp+LiYhUWFiorK0vV1dVqamoa1+7b3/62cnJydOLECavO4/EoOztbkjRv3jyVl5eru7s7hdMHAGDmITYDADJVwl/xHRoaUm1trVpbW+V2u7Vnzx51d3dr8+bNOnnypJqbmyWN/BfaxsbGiNeWlJRo9+7dGh4elsvl0pYtWyI+YRAAAEwcsRkAkKmSeg9qS0uLWlpaIurq6+sjjjdv3jzudSdOnNBDDz00iekBAIBYiM0AgEyU8Fd8AQAAAAD4KpCgAgAAAAAcgQQVAAAAAOAIJKgAAAAAAEcgQQUAAAAAOAIJKgAAAADAEUhQAQAAAACOQIIKAAAAAHAEElQAAAAAgCOQoAIAAAAAHIEEFQAAAADgCCSoAAAAAABHIEEFAAAAADgCCSoAAAAAwBFIUAEAAAAAjkCCCgAAAABwhKQS1MrKSvX29srv96uurm7c+XXr1uny5cvq7OxUZ2en1q9fb52rqalRX1+f+vr6VFNTk7qZAwAwgxGbAQCZaFaiBi6XSzt37tTKlSsVDAbl8/nU1NSknp6eiHb79+/XL37xi4i6nJwc1dfXa8mSJTLG6KOPPlJTU5Nu3LiR2qsAAGAGITYDADJVwp+gLl26VIFAQP39/RocHFRjY6OqqqqS6ryyslJHjhxROBzWjRs3dOTIEa1atWrSkwYAYCYjNgMAMlXCBNXr9WpgYMA6DgaD8nq949qtXbtWp0+f1sGDB5WXlzeh127YsEE+n08+n0/z58//UhcCAMBMQWwGAGSqlHxIUnNzswoLC/Xwww/ryJEj2rdv34Re39DQoLKyMpWVlenq1aupmBIAADMasRkAMB0lTFBDoZDy8/Ot47y8PIVCoYg2169f1+3btyVJr7/+uhYvXpz0awEAwMQQmwEAmSphgurz+VRcXKzCwkJlZWWpurpaTU1NEW1yc3OtP69Zs8b6kIbW1lZVVFTI4/HI4/GooqJCra2tKb4EAABmFmIzACBTJfwU36GhIdXW1qq1tVVut1t79uxRd3e3Nm/erJMnT6q5uVkvvPCC1qxZozt37uj69et6+umnJUnhcFivvPKKfD6fJOnll19WOBxO6wUBAJDpiM0AgEyVMEGVpJaWFrW0tETU1dfXW3/etGmTNm3aFPO1e/fu1d69eycxRQAAEI3YDADIRCn5kCQAAAAAACaLBBUAAAAA4AgkqAAAAAAARyBBBQAAAAA4AgkqAAAAAMARSFABAAAAAI5AggoAAAAAcAQSVAAAAACAI5CgAgAAAAAcgQQVAAAAAOAIJKgAAAAAAEcgQQUAAAAAOAIJKgAAAADAEUhQAQAAAACOQIIKAAAAAHCEpBLUyspK9fb2yu/3q66ubtz5l156SZ9++qlOnz6to0eP6sEHH7TO3blzR52dners7NR7772XupkDADCDEZsBAJloVqIGLpdLO3fu1MqVKxUMBuXz+dTU1KSenh6rTWdnp5YsWaJbt27pueee07Zt21RdXS1JunXrlkpLS9N3BQAAzDDEZgBApkr4E9SlS5cqEAiov79fg4ODamxsVFVVVUSb48eP69atW5Kk9vZ25eXlpWe2AACA2AwAyFgJE1Sv16uBgQHrOBgMyuv1xm2/fv16tbS0WMezZ8+Wz+fTiRMnxgVPAAAwccRmAECmSvgrvhPx1FNPacmSJVqxYoVVV1BQoIsXL6qoqEjHjh1TV1eXzp8/H/G6DRs26Nlnn5UkzZ8/P5VTAgBgRiM2AwCmk4Q/QQ2FQsrPz7eO8/LyFAqFxrV79NFH9etf/1pr1qzR7du3rfqLFy9Kkvr7+3X8+PGY73lpaGhQWVmZysrKdPXq1S91IQAAzBTEZgBApkqYoPp8PhUXF6uwsFBZWVmqrq5WU1NTRJvvfve72r17t9asWaMrV65Y9R6PR9nZ2ZKkefPmqby8XN3d3Sm+BAAAZhZiMwAgUyX8Fd+hoSHV1taqtbVVbrdbe/bsUXd3tzZv3qyTJ0+qublZv/3tb3Xvvffq4MGDkqQLFy6oqqpKJSUl2r17t4aHh+VyubRly5aITxgEAAATR2wGAGSqpN6D2tLSEvHhCpJUX19v/XnlypUxX3fixAk99NBDk5geAACIhdgMAMhECX/FFwAAAACArwIJKgAAAADAEUhQAQAAAACOQIIKAAAAAHAEElQAAAAAgCOQoAIAAAAAHIEEFQAAAADgCCSoAAAAAABHIEEFAAAAADgCCSoAAAAAwBFIUAEAAAAAjkCCCgAAAABwBBJUAAAAAIAjkKACAAAAAByBBBUAAAAA4AgkqAAAAAAAR0gqQa2srFRvb6/8fr/q6urGnc/OzlZjY6P8fr/a29tVUFBgndu4caP8fr96e3tVUVGRupkDADCDEZsBAJkoYYLqcrm0c+dOrV69WgsXLtSTTz6pkpKSiDbr169XOBxWcXGxXn31VW3dulWSVFJSourqan3nO9/RqlWr9Kc//UkuFz+0BQBgMojNAIBMlTAiLV26VIFAQP39/RocHFRjY6Oqqqoi2lRVVWnfvn2SpEOHDunRRx+16hsbG3X79m3961//UiAQ0NKlS9NwGQAAzBzEZgBApkqYoHq9Xg0MDFjHwWBQXq83bpuhoSHdvHlT8+bNS+q1AABgYojNAIBMZuzK2rVrTUNDg3X805/+1OzYsSOiTVdXl/F6vdZxIBAw8+bNMzt27DBPPfWUVf/666+btWvXjhtjw4YNxufzGZ/PZ/r7+23nM6FiEhxH18X6ij6nqO92bWKdT2audvNI9lri9ZWKNU2mv2TGSma97caJdU+SXcN4X7Hu60Tumd3ei3c+Vlu719mtl92YyTwfE9lDdtcw2T2Q6Hrs1sRufWL1EavP6GtIZg9N9B4l01+8vr7MesZrZ/dcJXrmEu0Hu+929zLZ/ZNk8fl8KevLKWVax2YKhUKhzPhiF5sT/gQ1FAopPz/fOs7Ly1MoFIrbxu12a+7cubp27VpSr5WkhoYGlZWVqaysTFevXk00JQAAZjRiMwAgUyVMUH0+n4qLi1VYWKisrCxVV1erqakpok1TU5PWrVsnSfrxj3+sY8eOWfXV1dXKzs5WYWGhiouL9eGHH6bhMgAAmDmIzQCATDUrUYOhoSHV1taqtbVVbrdbe/bsUXd3tzZv3qyTJ0+qublZb7zxhv7yl7/I7/fr+vXrqq6uliR1d3frwIED6u7u1p07d/Tzn/9cw8PDab8oAAAyGbEZAJCpvqaR3/V1DJ/Pp7KystR0ZjRyhfGOo+tirUT0udEV+1pUXaw2sfqIHn+i84jVPlGdXT8TlWx/dtcar6+x/SUzTqx7kkzf8c6P7SvemNHjx7r30ecSnbfbp/H2mOLU241pN3+79nZj2u3tyeyBRNeT6HmJNddYY8T6Hj2/RPNJZqzo+Y/t266/iT6/dusZb6x49zuZZ25su1j7we57rLnZPdOTkNK4MkOxhgCAVLKLK45LUC9fvqzPPvts0v3Mnz+f98ykAeuaHqxr6rGm6TEd17WgoED333//VE9jWiM2Oxvrmh6sa+qxpukxHdc1UWye8k9xSkfJxE9tdEJhXVnX6VJYU9aV4rzC/mFdp1NhXVnT6VIybV0TfkgSAAAAAABfBRJUAAAAAIAjuCX9ZqonkS6nTp2a6ilkJNY1PVjX1GNN04N1xWSwf9KDdU0P1jX1WNP0yKR1ddyHJAEAAAAAZiZ+xRcAAAAA4AgZmaBWVlaqt7dXfr9fdXV1Uz0dR8jLy9OxY8f06aef6syZM3rhhRckSTk5Ofrggw/U19enDz74QB6Px3rN9u3b5ff7dfr0aZWWllr1NTU16uvrU19fn2pqaqz6RYsW6ZNPPpHf79f27dutersxMoXL5dKpU6fU3NwsSSosLFR7e7v8fr8aGxuVlZUlScrOzlZjY6P8fr/a29tVUFBg9bFx40b5/X719vaqoqLCqo+3n+ONkQnmzp2rgwcPqqenR93d3Vq+fDl7NQVefPFFnTlzRl1dXXr77bd1zz33sFfxlSAux0ZsTh/icuoRm9OD2BzblH+UcCqLy+UygUDAFBUVmaysLPPxxx+bkpKSKZ/XVJfc3FxTWlpqJJl7773XnD171pSUlJitW7eauro6I8nU1dWZLVu2GElm9erV5vDhw0aSWbZsmWlvbzeSTE5Ojjl37pzJyckxHo/HnDt3zng8HiPJdHR0mGXLlhlJ5vDhw2bVqlVGUtwxMqm89NJL5q233jLNzc1Gktm/f7954oknjCSza9cu89xzzxlJ5vnnnze7du0ykswTTzxhGhsbjSRTUlJiPv74Y5OdnW0KCwtNIBAwLpfLdj/HGyMTyp///Gezfv16I8lkZWWZuXPnslcnWRYsWGDOnz9vZs+ebe2fdevWsVcpaS/E5fiF2Jy+QlxOfSE2p74Qm+OWKZ9ASsvy5cvN+++/bx1v3LjRbNy4ccrn5bTy97//3Tz22GOmt7fX5ObmGmkkUPb29hpJ5rXXXjPV1dVW+9F21dXV5rXXXrPqR9vl5uaanp4eq35su3hjZErxer3m6NGj5gc/+IEVCK9cuWLcbreRIvfk+++/b5YvX24kGbfbba5cuWKk8ft0tJ3dfo43xnQv9913nzl//vy4evbq5MqCBQvMhQsXTE5OjnG73aa5udlUVFSwVylpL8Tl5AuxOTWFuJz6QmxOTyE2xy4Z9yu+Xq9XAwMD1nEwGJTX653CGTlPQUGBSktL1dHRoQceeECXLl2SJF26dEkPPPCApPjraFcfDAbH1UuKO0am+MMf/qBf/epXGh4eliTNmzdPN27c0NDQkKTItRi7fkNDQ7p586bmzZs34fW2G2O6Kyoq0pUrV7R3716dOnVKDQ0N+sY3vsFenaSLFy/qd7/7nS5cuKB///vfunnzpj766CP2KtKOuJwcYnPqEJdTj9icHsTm2DIuQYW9OXPm6J133tGLL76o//znP+POG2PSPoevYoyvyo9+9CNdvnw5oz7ae6rNmjVLixYt0q5du7Ro0SL997//1caNG8e1Y69OjMfjUVVVlYqKirRgwQLNmTNHq1atmuppARCxOZWIy+lBbE4PYnNsGZeghkIh5efnW8d5eXkKhUJTOCPnmDVrlt555x299dZbevfddyVJn3/+uXJzcyVJubm5unz5sqT462hXn5eXN67eboxMUF5erjVr1qi/v1+NjY364Q9/qO3bt8vj8cjtdkuKXIux6+d2uzV37lxdu3Ztwut97dq1uGNMd8FgUMFgUB9++KEk6dChQ1q0aBF7dZIee+wx9ff36+rVq7pz547+9re/qby8nL2KtCMu2yM2pxZxOT2IzelBbI5vyn/POJXF7Xabc+fOmcLCQuvNwAsXLpzyeTmh7Nu3z7z66qsRddu2bYt44/nWrVuNJPP4449HvLm9o6PDSCNvbj9//rzxeDzG4/GY8+fPm5ycHCONf3P76tWrbcfItLJixQrrvS4HDhyIeOP5888/bySZn/3sZxFvbt+/f7+RZBYuXBjx5vZz584Zl8tlu5/jjZEJ5R//+If51re+ZSSZ+vp6s23bNvbqJMvSpUvNmTNnzNe//nUjjXzYRW1tLXuVkvZCXLYvxOb0FeJyaguxOfWF2By3TPkEUl5Wr15tzp49awKBgNm0adOUz8cJpby83BhjzOnTp01nZ6fp7Ow0q1evNt/85jfN0aNHTV9fnzly5Ij1l4Qk88c//tEEAgHzySefmMWLF1v1zzzzjPH7/cbv95unn37aql+8eLHp6uoygUDA7Nixw6q3GyOTythAWFRUZDo6Oozf7zcHDhww2dnZRpK55557zIEDB4zf7zcdHR2mqKjIev2mTZtMIBAwvb291ifXSfH3c7wxMqE8/PDDxufzmdOnT5t3333XeDwe9moKym9+8xvT09Njurq6zJtvvmmys7PZq5SvpBCXYxdic3oLcTm1hdicnkJsHl++dvcPAAAAAABMqYx7DyoAAAAAYHoiQQUAAAAAOAIJKgAAAADAEUhQAQAAAACOQIIKAAAAAHAEElQAAAAAgCOQoAIAAAAAHIEEFQAAAADgCP8Hg+DIkCIqdRIAAAAASUVORK5CYII=\n"},"metadata":{}}]},{"cell_type":"code","source":["%timeit -n1 -r10 plt.vlines(long_obj[-2][long_bias_arr], ymin=0, ymax=1, color='#00ff00')  # 528 ms per loop --> 8.71 ms per loop\n","%timeit -n1 -r10 [plt.axvline(x_, color='#00ff00') for x_, bias_ in zip(long_obj[-2], long_bias_arr) if bias_]\n","\n","# np.sum(long_bias_arr == ~long_bias_arr)"],"metadata":{"id":"dm7ZqzS9vqhm"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# %timeit -n1 -r10 [plt.axvline(x_) for x_, bias_ in zip(long_obj[-2].ravel(), long_bias_arr.ravel()) if bias_]\n","%timeit -n1 -r10 plt.fill_between(long_obj[-2].ravel(), 0, 1, where=long_bias_arr.ravel() > 0, facecolor='#00ff00', alpha=1, transform=ax2.get_xaxis_transform())"],"metadata":{"id":"qOE2YSzntx8v"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"dHFkv6Ar1ojU"},"source":["## plot_check_v2"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"FCpPCl931ojV"},"outputs":[],"source":["# res_df = wave_range_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","# res_df = h_candle_v4(res_df, 20, ltf_df=None, touch_lbperiod=50)\n","del np_plot_params"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"rMIwv1Nr1ojX"},"outputs":[],"source":["# ------------------ plot_config ------------------ #\n","save_mode = 0\n","\n","front_plot = 0    # 0 : p1_tick, 1 : p2_tick\n","back_plot = 4     # 0 : post_plot_size, 1 : open, 2 : p2_tick, 3 : ep_tick, 4 : tp_tick, 5 : bias_tick (사용 금지)\n","\n","bias_plot = 0     # 1 : true_bias only, -1 : false_bias only, 0 : both\n","\n","pr_descend = 1   # 1 : 큰 pr 부터, -1 : 작은 pr 부터, 0 : 순서대로\n","\n","position = 1      # -1 : short, 0 & 1 : long\n","\n","x_max = 500\n","x_margin_mult = 1/30\n","y_margin_mult = 1/30  # 0 \n","\n","prev_plotsize = 100 #  150 100 20 500\n","post_plotsize = 160 # config.tr_set.bias_info_tick -> excessive bit 는 감당 못함\n","\n","inversion = 0\n","hedge = 0\n","\n","# ------ show or save ------ #\n","if save_mode:\n","  plot_check_dir = current_path + \"plot_check/\" +  key.replace(\".ftr\", \"\")\n","  shutil.rmtree(plot_check_dir, ignore_errors=True)  # remove existing dir\n","  os.makedirs(plot_check_dir)\n","  print(plot_check_dir)\n","else:\n","  plot_check_dir = None\n","\n","# ------------ 한 방향에 대해 plot_check 함 (by position var.) ------------ #\n","#   obj by position  \n","if position == -1:\n","  pos_str = \"SELL\"\n","  pr_, obj_ = short_pr, short_obj\n","  arr_list = [short_p2_idx_arr, short_lvrg_arr, short_fee_arr, short_tpout_arr, short_bias_arr, short_tp_1, short_tp_0, short_out_1, short_out_0, short_ep2_0]\n","else:   # both option currently not supported\n","  pos_str = \"BUY\"\n","  pr_, obj_ = long_pr, long_obj\n","  arr_list = [long_p2_idx_arr, long_lvrg_arr, long_fee_arr, long_tpout_arr, long_bias_arr, long_tp_1, long_tp_0, long_out_1, long_out_0, long_ep2_0]\n","\n","if pr_descend:\n","    if pr_descend == -1:\n","      pr_descend = 0\n","    pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = sort_bypr_v4(pr_, obj_, arr_list, descending=pr_descend)  # --> pr_descend 의 의미가 사라짐.. (false -> true plot 으로 이동한 것뿐)\n","else:\n","  pr, obj, [p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, bias_arr, tp_1, tp_0, out_1, out_0, ep2_0] = pr_, obj_, arr_list\n","\n","pr_msg = \"%s\\n {} ~ {} -> {:.5f}\\n lvrg : {}\\n fee : {:.4f}\" % (pos_str)  # = data_window, pos_str 으로 이곳에서 정의함\n","\n","\n","if front_plot == 0:\n","  front_idx = obj[4]      # left_margin 기준 - open_idx\n","else:\n","  front_idx = p2_idx_arr  # left_margin 기준 - p2_idx\n","\n","left_end_idx = front_idx - prev_plotsize  \n","right_end_idx = obj[3] + post_plotsize\n","invalid_left_end = np.sum(left_end_idx < 0)\n","\n","np_plot_params = np.hstack((left_end_idx, right_end_idx, pr, *obj, p2_idx_arr, lvrg_arr, fee_arr, tpout_arr, tp_1, tp_0, out_1, out_0, ep2_0))[invalid_left_end:]  # all arr should have same dimension\n","\n","if bias_plot:\n","  if bias_plot == 1:\n","    bias_idx = bias_arr[invalid_left_end:].ravel()  # true_bias 만 plot\n","  else:\n","    bias_idx = ~bias_arr[invalid_left_end:].ravel()  # false_bias 만 plot\n","\n","  np_plot_params = np_plot_params[bias_idx]"]},{"cell_type":"markdown","metadata":{"id":"-4CXGqEN1ojY"},"source":["### session_plot"]},{"cell_type":"code","execution_count":19,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":788,"status":"ok","timestamp":1654266344351,"user":{"displayName":"7th June","userId":"08178289703395036410"},"user_tz":-540},"outputId":"36ef6b1b-51ab-4440-e523-2ec3ec3fc966","id":"2bjxKCIh1ojZ"},"outputs":[{"output_type":"stream","name":"stderr","text":["/content/drive/My Drive/Colab Notebooks/JnQ/funcs/funcs_plot_check.py:10: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n","  step_col_arr = np.array(col_list)\n"]}],"source":["selection_id = config.selection_id\n","\n","# ============ make col_idx_dict config ============ #\n","nonstep_col_list = []\n","step_col_list = []\n","step_col_list2 = []\n","stepmark_col_list = []\n","data_window_p1_col_list = []\n","data_window_p2_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '5T'\n","hc_tf2 = '15T'\n","\n","# step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_base ------ #\n","wave_itv1 = config.tr_set.wave_itv1\n","wave_itv2 = config.tr_set.wave_itv2\n","wave_period1 = config.tr_set.wave_period1\n","wave_period2 = config.tr_set.wave_period2\n","\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv1, wave_period1)], 1, '#5b9cf6', 1])\n","# step_col_list.append([['dc_base_{}{}'.format(wave_itv2, wave_period2)], 1, '#5b9cf6', 5])\n","\n","# step_col_list.append([['wave_low_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['wave_high_fill_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf, wave_period), 'dc_lower_{}{}'.format(wave_tf, wave_period)], 1, '#ffeb3b', 1])\n","\n","# ------ dc ------ #\n","dc_tf1 = 'T'\n","dc_period1 = 10\n","dc_tf2 = 'T'\n","dc_period2 = 20\n","\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ff00ff', 1]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 2]),  # inner #ffeb3b\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#ffee58', 3]) # ffee58 5b9cf6\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 60\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper2_{}{}'.format(bb_tf1, bb_period1), 'bb_lower2_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_upper3_{}{}'.format(bb_tf1, bb_period1), 'bb_lower3_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ step_col_list2 - add info(col, alpha, color, linewidth) ============ #\n","# ------ cci ------ #\n","step_col_list2.append([['cci_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3])\n","step_col_list2.append([['cci_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 1])\n","\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth, marker_style) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","# ------ wave_range ------ #\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#e91e63', 10, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv1, wave_period1)], 1, '#2962ff', 10, '*'])\n","\n","stepmark_col_list.append([['wave_low_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#ff00ff', 7, '*'])\n","stepmark_col_list.append([['wave_high_fill_{}{}'.format(wave_itv2, wave_period2)], 1, '#00ff00', 7, '*'])\n","  \n","# stepmark_col_list.append([['wave_co_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#00ff00', 3, 'o'])\n","# stepmark_col_list.append([['wave_cu_marker_{}{}'.format(wave_itv1, wave_period1)], 1, '#ff00ff', 3, 'o'])\n","\n","# ============ data_window_col_list ============ #\n","# ------ wrr ------ #\n","# data_window_col_list.append([['cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","# data_window_col_list.append([['co_wrr_21_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_21_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'cu_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p1_col_list.append([['co_wrr_32_{}{}'.format(wave_itv1, wave_period1)], 'co_wrr_32_{}{}'.format(wave_itv1, wave_period1)])\n","data_window_p2_col_list.append([['cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'cu_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","data_window_p2_col_list.append([['co_wrr_32_{}{}'.format(wave_itv2, wave_period2)], 'co_wrr_32_{}{}'.format(wave_itv2, wave_period2)])\n","\n","res_df['short_tr_{}'.format(selection_id)].iloc[short_obj[-1].astype(int).ravel()] = short_tr_arr\n","res_df['long_tr_{}'.format(selection_id)].iloc[long_obj[-1].astype(int).ravel()] = long_tr_arr\n","data_window_p1_col_list.append([['short_tr_{}'.format(selection_id)], 'short_tr_{}'.format(selection_id)])\n","data_window_p1_col_list.append([['long_tr_{}'.format(selection_id)], 'long_tr_{}'.format(selection_id)])\n","\n","\n","# ====== str to numbcol ====== #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","step_col_arr2 = strcol_tonumb(res_df, step_col_list2)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","data_window_p1_col_arr = strcol_tonumb(res_df, data_window_p1_col_list)\n","data_window_p2_col_arr = strcol_tonumb(res_df, data_window_p2_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  # \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"step_col_info2\": step_col_arr2,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"data_window_p1_col_info\": data_window_p1_col_arr,\n","  \"data_window_p2_col_info\": data_window_p2_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'short_tp_1_{}'.format(selection_id), 'long_tp_1_{}'.format(selection_id), 'short_tp_0_{}'.format(selection_id), 'long_tp_0_{}'.format(selection_id)])  \n","}   \n","#   'wave_low_fill_{}{}'.format(wave_itv2, wave_period2), 'wave_high_fill_{}{}'.format(wave_itv2, wave_period2)\n","#   'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","#   'wave_1_{}'.format(wave_itv2), 'wave_0_{}'.format(wave_itv2), 'dc_upper_15T', 'dc_lower_15T'"]},{"cell_type":"markdown","source":["#### session_plot main"],"metadata":{"id":"XfvH5ngyieS9"}},{"cell_type":"code","execution_count":null,"metadata":{"id":"OCLMABZT1ojb","colab":{"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1-Txs3FDSvN-8coNTiysGJOXRVClBqRhm"},"executionInfo":{"status":"error","timestamp":1654164067895,"user_tz":-540,"elapsed":119223,"user":{"displayName":"7th June","userId":"08178289703395036410"}},"outputId":"a26b45a7-08bc-42e1-e208-4daa1b3468ae"},"outputs":[{"output_type":"display_data","data":{"text/plain":"Output hidden; open in https://colab.research.google.com to view."},"metadata":{}}],"source":["_ = [plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"markdown","source":["### whole_plot"],"metadata":{"id":"sZAYhcdoXnm4"}},{"cell_type":"code","source":["s_id = config.selection_id\n","\n","# ------------ make col_idx_dict config ------------ #\n","nonstep_col_list = []\n","step_col_list = []\n","stepmark_col_list = []\n","\n","# ============ nonstep_col_list - add info(col, alpha, color, linewidth) ============ #\n","# nonstep_col_list.append([['close'], 1, '#ffffff', 2])\n","\n","# ============ step_col_list - add info(col, alpha, color, linewidth) ============ #\n","# ------ htf_candle ------ #\n","hc_tf1 = '15T'\n","hc_tf2 = 'H'\n","hc_tf3 = '4H'\n","\n","step_col_list.append([['open_{}'.format(hc_tf1), 'close_{}'.format(hc_tf1)], 1, '#ffffff', 1])\n","step_col_list.append([['open_{}'.format(hc_tf2), 'close_{}'.format(hc_tf2)], 1, '#ffffff', 2])\n","# step_col_list.append([['open_{}'.format(hc_tf3), 'close_{}'.format(hc_tf3)], 1, '#ffffff', 4])\n","\n","# ------ resi_sup ------ #\n","# rs_tf = 'T'\n","# step_col_list.append([['resi_{}'.format(rs_tf), 'sup_{}'.format(rs_tf)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['resi_out_{}'.format(rs_tf), 'sup_out_{}'.format(rs_tf)], 1, 'dodgerblue', 2])\n","\n","# ------ wave_range ------ #\n","wave_tf1 = config_list[0].tr_set.p1_itv1\n","wave_period1, wave_period2 = config_list[0].tr_set.p1_period1, config_list[0].tr_set.p1_period2\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period1), 'dc_lower_{}{}'.format(wave_tf1, wave_period1)], 1, '#ffeb3b', 1])\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf1, wave_period2), 'dc_lower_{}{}'.format(wave_tf1, wave_period2)], 1, '#ffeb3b', 1])\n","\n","# step_col_list.append([['dc_upper_{}{}'.format(wave_tf2, wave_period2), 'dc_lower_{}{}'.format(wave_tf2, wave_period2)], 1, '#e65100', 2])\n","\n","# ------ dc ------ #\n","dc_tf1 = '5T'\n","dc_period1 = 20\n","dc_tf2 = 'H'\n","dc_period2 = 20\n","# step_col_list.append([['dc_upper_{}{}'.format(dc_tf1, dc_period1), 'dc_lower_{}{}'.format(dc_tf1, dc_period1)], 1, '#ffeb3b', 1]),  # inner\n","# step_col_list.append([['dc_base_{}{}'.format(dc_tf1, dc_period1)], 1, '#5b9cf6', 1])\n","step_col_list.append([['dc_upper_{}{}'.format(dc_tf2, dc_period2), 'dc_lower_{}{}'.format(dc_tf2, dc_period2)], 1, '#ff00ff', 4]),  # inner\n","step_col_list.append([['dc_base_{}{}'.format(dc_tf2, dc_period2)], 1, '#5b9cf6', 4])\n","\n","# ------ bb ------ #\n","bb_tf1 = 'T'\n","bb_period1 = 20\n","\n","# step_col_list.append([['bb_upper_{}{}'.format(bb_tf1, bb_period1), 'bb_lower_{}{}'.format(bb_tf1, bb_period1)], 1, '#ffffff', 1])\n","# step_col_list.append([['bb_base_{}{}'.format(bb_tf1, bb_period1)], 1, '#00ff00', 1])\n","\n","# step_col_list.append([['bb_upper_{}'.format(tf2), 'bb_lower_{}'.format(tf2)], 1, '#e91e63', 4])\n","\n","# ------ ema ------ #\n","# step_col_list.append([['ema_5T'], 1, '#03ed30', 2])\n","\n","# ============ stepmark_col_list - add info(col, alpha, color, linewidth) ============ #\n","# stepmark_col_list.append([['sar_T'], 1, 'dodgerblue', 7])\n","\n","\n","# ============ str to numbcol ============ #\n","nonstep_col_arr = strcol_tonumb(res_df, nonstep_col_list)\n","step_col_arr = strcol_tonumb(res_df, step_col_list)\n","stepmark_col_arr = strcol_tonumb(res_df, stepmark_col_list)\n","\n","col_idx_dict = \\\n","{\n","  \"ohlc_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close']),\n","  \"vp_col_idxs\": get_col_idxs(res_df, ['close', 'volume']),\n","  # \"ohlc_col_idxs\": get_col_idxs(res_df, ['haopen', 'hahigh', 'halow', 'haclose']),  # heikin-ashi ver.\n","  \"nonstep_col_info\": nonstep_col_arr,\n","  \"step_col_info\": step_col_arr,\n","  \"stepmark_col_info\": stepmark_col_arr,\n","  \"ylim_col_idxs\": get_col_idxs(res_df, ['open', 'high', 'low', 'close', 'dc_upper_15T4', 'dc_lower_15T4'])  # , 'dc_upper_H', 'dc_lower_H', 'dc_upper_15T', 'dc_lower_15T', 'short_out_{}'.format(selection_id), 'long_out_{}'.format(selection_id)\n","}   # , 'wave_1_{}'.format(wave_tf2), 'wave_0_{}'.format(wave_tf2), 'dc_upper_15T', 'dc_lower_15T'"],"metadata":{"id":"jjFziVVIhgSr"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["#### whole_plot main"],"metadata":{"id":"50HXDIdJij28"}},{"cell_type":"code","source":["plot_op_idx_nums = 10\n","\n","win_idxs = (pr_ > 1).ravel()  # [-plot_op_idx_nums:]\n","selected_op_idxs = obj_[4].ravel().astype(int)  # [-plot_op_idx_nums:]\n","selected_ex_idxs = obj_[3].ravel().astype(int)  # [-plot_op_idx_nums:]\n","\n","len_idxs = len(win_idxs)\n","print(\"len_idxs :\", len_idxs)\n","\n","split_range = np.arange(plot_op_idx_nums, len_idxs, plot_op_idx_nums)\n","win_idxs_list = np.split(win_idxs, split_range, axis=0)\n","selected_op_idxs_list = np.split(selected_op_idxs, split_range, axis=0)\n","selected_ex_idxs_list = np.split(selected_ex_idxs, split_range, axis=0)"],"metadata":{"id":"-tbLsXN9eN2p"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["_ = [whole_plot_check(np_df, a, b, c, plot_check_dir=None, **col_idx_dict) for a, b, c in zip(win_idxs_list, selected_op_idxs_list, selected_ex_idxs_list)]"],"metadata":{"id":"FtILHO-4kVlO"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"iTW2ZuX61ojg"},"source":["### plot_funcs"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0l6joTK_1ojh"},"outputs":[],"source":["def whole_plot_check(data, win_idxs, selected_op_idxs, selected_ex_idxs, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 12))\n","  nrows, ncols = 1, 1\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                          ncols=ncols,\n","                          #height_ratios=[31, 1]\n","                          )\n","\n","  ax = fig.add_subplot(gs[0])\n","\n","  # ------------ add_col section ------------ #\n","  a_data = data[selected_op_idxs[0]:selected_op_idxs[-1] + 1]\n","\n","  plot_op_idxs = selected_op_idxs - selected_op_idxs[0]  \n","  plot_win_op_idxs = plot_op_idxs[win_idxs]\n","  plot_loss_op_idxs = plot_op_idxs[~win_idxs]\n","\n","  plot_ex_idxs = selected_ex_idxs - selected_op_idxs[0]\n","  plot_win_ex_idxs = plot_ex_idxs[win_idxs]\n","  plot_loss_ex_idxs = plot_ex_idxs[~win_idxs]\n","\n","\n","  # ------ add cols ------ #\n","  [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","  [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","  [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","  # [plt.axvline(op_idx, color='#00ff00') for op_idx in plot_win_op_idxs]\n","  # [plt.axvline(op_idx, color='#ff0000') for op_idx in plot_loss_op_idxs]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#00ff00') for op_idx, ex_idx in zip(plot_win_op_idxs, plot_win_ex_idxs)]\n","  [plt.axvspan(op_idx, ex_idx, alpha=0.5, color='#ff0000') for op_idx, ex_idx in zip(plot_loss_op_idxs, plot_loss_ex_idxs)]\n","  \n","  plt.show()\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/whole_plot_{}.png\".format(selected_op_idxs[0])\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def plot_check_v8(res_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, back_plot, plot_check_dir=None, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","\n","    iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0 = params\n","\n","    # print(\"en_p, ex_p :\", en_p, ex_p)\n","    # print(\"tp_line, out_line, ep2_0 :\", tp_line, out_line, ep2_0)\n","\n","    # temporary\n","    # if exit_idx - p1_idx < 50:\n","    # if exit_idx != entry_idx:\n","    #   break\n","\n","    # ============ define ax1 & ax2 ============ #\n","    ax1 = fig.add_subplot(gs[gs_idx])\n","    ax2 = fig.add_subplot(gs[gs_idx + 2])\n","\n","    # ------ date range ------ #\n","    a_data = res_df.iloc[int(iin):int(iout + 1)].to_numpy()\n","    # a_data = data[iin:iout]\n","\n","    # ------------ add_col section ------------ #\n","    # ------ candles ------ #\n","    candle_plot_v2(ax1, a_data[:, col_idx_dict['ohlc_col_idxs']], alpha=1.0, wickwidth=1.0)\n","\n","    # ------ add cols ------ #\n","    [nonstep_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot_v2(ax1, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['stepmark_col_info']]\n","\n","    [step_col_plot_v2(ax2, a_data[:, params_[0]], *params_[1:]) for params_ in col_idx_dict['step_col_info2']]\n","\n","    # ------ ep, tp + xlim ------ #\n","    try:\n","      eptp_hvline_v8(ax1, ax2, config, *params, back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict)\n","    except Exception as e:\n","      print(\"error in eptp_hvline :\", e)\n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    data_msg_list = [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p1_idx), params_[0]]) for params_ in col_idx_dict['data_window_p1_col_info']]  # * for unsupported format for arr\n","    data_msg_list += [\"\\n {} : {:.3f}\".format(*params_[1:], *res_df.iloc[int(p2_idx), params_[0]]) for params_ in col_idx_dict['data_window_p2_col_info']]\n","    ps_msg_expand = pr_msg.format(p1_idx, exit_idx, pr, lvrg, fee) + ''.join(data_msg_list)\n","    \n","    ax1.set_title(ps_msg_expand)   # set_title on ax1\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir + \"/{}.png\".format(int(entry_idx))\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)\n","\n","  return\n","\n","def eptp_hvline_v8(ax1, ax2, config, iin, iout, pr, en_p, ex_p, entry_idx, exit_idx, p1_idx, p2_idx, lvrg, fee, tp_line, out_line, tp_1, tp_0, out_1, out_0, ep2_0,\n","                   back_plot, x_max, x_margin_mult, y_margin_mult, a_data, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","  p1_tick = entry_tick - int(entry_idx - p1_idx)\n","  p2_tick = p1_tick + int(p2_idx - p1_idx)\n","  bias_info_tick = entry_tick + config.tr_set.bias_info_tick\n","\n","  if back_plot == 1:\n","    x_max = p1_tick + 20\n","  elif back_plot == 2:\n","    x_max = p2_tick + 20 \n","  elif back_plot == 3:\n","    x_max = entry_tick + 20 \n","  elif back_plot == 4:\n","    x_max = exit_tick + 20\n","  elif back_plot == 5:\n","    x_max = bias_info_tick + 20\n","\n","  # ============ xlim ============ #\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    ax1.set_xlim(0 - x_margin, x_max + x_margin)\n","    ax2.set_xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = ax1.get_xlim()\n","\n","  # ============ hlines ============ #\n","  # ------------ ax1 ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  ax1.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  ax1.text(x0, en_p, 'en_p :\\n {:.3f} \\n epg {}'.format(en_p, config.tr_set.ep_gap2), ha='right', va='center', fontweight='bold', fontsize=15)  # en_p line label\n","  ax1.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  ax1.text(x1, ex_p, 'ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold', fontsize=15)  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  ax1.axhline(tp_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  ax1.text(x0, tp_line, 'tpg {}'.format(config.tr_set.tp_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#00ff00')\n","  ax1.axhline(out_line, 0.05, 1, linewidth=2, linestyle='-', alpha=1, color='#ff0000')\n","  ax1.text(x0, out_line, 'outg {}'.format(config.tr_set.out_gap), ha='right', va='center', fontweight='bold', fontsize=15, color='#ff0000')\n","\n","  # ------ tp_box ------ #\n","  text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(tp_1, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_1, ' tp_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(tp_0, 0.2, 1, linewidth=4, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, tp_0, ' tp_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","\n","  # ------ out_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(out_1, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_1, ' out_1', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","  ax1.axhline(out_0, 0.2, 1, linewidth=2, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, out_0, ' out_0', ha='right', va='bottom', fontweight='bold', fontsize=15)  \n","  # ------ ep_box ------ #\n","  # text_x_pos = (x0 + x1) * 0.1\n","  ax1.axhline(ep2_0, 0.2, 1, linewidth=1, linestyle='-', alpha=1, color='#ffffff')\n","  ax1.text(text_x_pos, ep2_0, ' ep2_0', ha='right', va='bottom', fontweight='bold', fontsize=15)\n","\n","  # ------------ ax2 ------------ #\n","  # ------ band ------ #\n","  ax2.axhline(100, color=\"#ffffff\")\n","  ax2.axhline(-100, color=\"#ffffff\")\n","\n","  # ============ ylim ============ # - ax1 only\n","  if back_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including p1_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  \n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  ax1.set_ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ============ vline (p1_tick, entry_tick, exit_tick) ============ # - add p1_tick on ax2\n","  y0, y1 = ax1.get_ylim()\n","  low_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  p2_ymax, en_ymax, ex_ymax = [(low_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [p2_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  if p1_tick > 0:\n","    p1_ymax = (low_data[p1_tick] - y0) / (y1 - y0) - .01\n","    ax1.axvline(p1_tick, 0, p1_ymax, alpha=1, linewidth=2, linestyle='--', color='#ff0000')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","    ax2.axvline(p1_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ff0000')\n","  ax1.axvline(p2_tick, 0, p2_ymax, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax1.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax1.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(p2_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#2196f3')\n","  ax2.axvline(entry_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  ax2.axvline(exit_tick, 0, 1, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  if back_plot == 5:\n","    ax1.axvline(bias_info_tick, alpha=1, linewidth=2, linestyle='-', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","metadata":{"id":"8soVNGFt1ojj"},"source":["#### legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"narSQRCz1ojj"},"outputs":[],"source":["_ = [plot_check_v4(np_df, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir, 500, 0.07, 100, **col_idx_dict) for param_zip in zip(np_plot_params, np_plot_params[::-1])]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLiEIiMW1ojk"},"outputs":[],"source":["def plot_check_v4(data, config, param_zip, pr_msg, x_max, x_margin_mult, y_margin_mult, front_plot, plot_check_dir=None, vp_range=500, kde_factor=0.05, num_samples=100, **col_idx_dict):\n","  # start_0 = time.time()\n","  plt.style.use(['dark_background', 'fast'])\n","  fig = plt.figure(figsize=(30, 18))\n","  nrows, ncols = 2, 2\n","  gs = gridspec.GridSpec(nrows=nrows,  # row 부터 index 채우고 col 채우는 순서임 (gs_idx)\n","                         ncols=ncols,\n","                         height_ratios=[3, 1]\n","                         )\n","  for gs_idx, params in enumerate(param_zip):\n","    ax = fig.add_subplot(gs[gs_idx])\n","    iin, iout, pr, ep, tp, entry_idx, exit_idx, open_idx, lvrg, fee, tp_line, out_line, bias_info, bias_thresh = params\n","\n","    # ------------ add_col section ------------ #\n","    iin, iout = int(iin), int(iout)\n","    a_data = data[iin:iout]\n","    # ------ candles ------ #\n","    candle_plot(a_data[:, col_idx_dict['ohlc_col_idxs']], ax, alpha=1.0, wickwidth=1.0)\n","    \n","    # ------ add cols ------ #\n","    [nonstep_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['nonstep_col_info']]\n","    [step_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['step_col_info']]\n","    [stepmark_col_plot(a_data[:, params[0]], *params[1:]) for params in col_idx_dict['stepmark_col_info']]\n","\n","    # vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']]\n","    # vp_info = [vp_range, vp_data[:, 0], vp_data[:, 1], kde_factor, num_samples]\n","    vp_data = data[iin - vp_range:iin, col_idx_dict['vp_col_idxs']].T\n","    vp_info = [vp_range, *vp_data, kde_factor, num_samples]\n","\n","    # ------ ep, tp + xlim ------ #\n","    eptp_hvline_v4(config, ep, tp, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict)        \n","\n","    #     Todo    #\n","    #     3. outer_price plot 일 경우, gs_idx + nrows 하면 됨\n","\n","    # ------ trade_info ------ #\n","    plt.title(pr_msg.format(entry_idx, exit_idx, pr, lvrg, fee))\n","\n","  if plot_check_dir is None:\n","    plt.show()\n","    print()\n","  else:\n","    fig_name = plot_check_dir +  \"/%s.png\" % int(entry_idx)\n","    plt.savefig(fig_name)\n","    print(fig_name, \"saved !\")\n","  plt.close()\n","  # print(\"elapsed time :\", time.time() - start_0)  \n","\n","  return\n","\n","def eptp_hvline_v4(config, en_p, ex_p, entry_idx, exit_idx, open_idx, tp_line, out_line, bias_info, bias_thresh, \n","                   front_plot, iin, iout, x_max, x_margin_mult, y_margin_mult, a_data, vp_info, **col_idx_dict):\n","  # ------ get vertical ticks ------ #\n","  entry_tick = int(entry_idx - iin)\n","  open_tick = entry_tick - int(entry_idx - open_idx)\n","  exit_tick = entry_tick + int(exit_idx - entry_idx)\n","\n","  if front_plot == 1:\n","    x_max = open_tick\n","  elif front_plot == 2:\n","    x_max = entry_tick\n","  if (iout - iin) > x_max:\n","    x_margin = x_max * x_margin_mult\n","    plt.xlim(0 - x_margin, x_max + x_margin)\n","  x0, x1 = plt.gca().get_xlim()\n","  # ------------ hlines ------------ #\n","  # ------ entry & exit ------ #\n","  en_xmin = entry_tick / x1\n","  ex_xmin = exit_tick / x1\n","  plt.axhline(en_p, x0, en_xmin, linewidth=2, linestyle='--', alpha=1, color='lime')  # en_p line axhline\n","  plt.text(x0, en_p, ' en_p :\\n {}'.format(en_p), ha='right', va='center', fontweight='bold')  # en_p line label\n","  plt.axhline(ex_p, ex_xmin, 1, linewidth=2, linestyle='--', alpha=1, color='lime')  # ex_p line axhline (signal 도 포괄함, 존재 의미)\n","  plt.text(x1, ex_p, ' ex_p :\\n {}'.format(ex_p), ha='left', va='center', fontweight='bold')  # ex_p line label\n","\n","  # ------ tpout_line ------ #\n","  plt.axhline(tp_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#00ff00')  # ep 와 gap 비교 용이하기 위해 ex_xmin -> 0.1 사용\n","  plt.text(x0, tp_line, ' %s' % config.tr_set.tp_gap, ha='left', va='center', fontweight='bold')\n","  plt.axhline(out_line, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff0000')\n","  plt.text(x0, out_line, ' %s' % config.tr_set.out_gap, ha='left', va='center', fontweight='bold')\n","\n","  # ------ bias_line ------ #\n","  plt.axhline(bias_info, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='dodgerblue')\n","  plt.text(x0, bias_info, ' bias_info', ha='left', va='center', fontweight='bold')\n","  plt.axhline(bias_thresh, 0.1, 1, linewidth=4, linestyle='-', alpha=1, color='#ff8400')\n","  plt.text(x0, bias_thresh, ' bias_thresh', ha='left', va='center', fontweight='bold')\n","\n","  # ------ volume profile ------ #\n","  vp_range, close, volume, kde_factor, num_samples = vp_info\n","  if iin >= vp_range:\n","    start_0 = time.time()\n","    kde = stats.gaussian_kde(close, weights=volume, bw_method=kde_factor)\n","    kdx = np.linspace(close.min(), close.max(), num_samples)\n","    kdy = kde(kdx)\n","    print(\"kde elapsed_time :\", time.time() - start_0)\n","\n","    kdy_max = kdy.max()\n","    # peaks,_ = signal.find_peaks(kdy)\n","    peaks,_ = signal.find_peaks(kdy, prominence=kdy_max * 0.3)\n","    peak_list = kdx[peaks]   # peak_list\n","    [plt.axhline(peak, linewidth=6, linestyle='-', alpha=1, color='white') for peak in peak_list]\n","    \n","    kdy_ratio = entry_tick / kdy_max # 30 / 0.0001\n","    plt.plot(kdy * kdy_ratio, kdx, color='white')\n","    # plt.plot(pky, pkx, 'bo', color='yellow')\n","\n","  # ------ ylim ------ #\n","  if front_plot:\n","    y_lim_data = a_data[:x_max + 1, col_idx_dict['ylim_col_idxs']]  # +1 for including open_tick\n","  else:\n","    y_lim_data = a_data[:, col_idx_dict['ylim_col_idxs']]\n","  y_min = y_lim_data.min()\n","  y_max = y_lim_data.max()\n","  y_margin = (y_max - y_min) * y_margin_mult\n","  # plt.ylim(y_min - y_margin, y_max + y_margin)\n","\n","  # ------------ vline (open_tick, entry_tick, exit_tick) ------------ #\n","  y0, y1 = plt.gca().get_ylim()\n","  l_data = a_data[:exit_tick + 1, col_idx_dict['ohlc_col_idxs'][2]]  # +1 for including exit_tick\n","  open_ymax, en_ymax, ex_ymax = [(l_data[tick_] - y0) / (y1 - y0) - .01 for tick_ in [open_tick, entry_tick, exit_tick]]  # -.05 for margin\n","  plt.axvline(open_tick, 0, open_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')  # 추후, tick 별 세부 정의가 달라질 수 있음을 고려해 multi_line 작성 유지\n","  plt.axvline(entry_tick, 0, en_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","  plt.axvline(exit_tick, 0, ex_ymax, alpha=1, linewidth=2, linestyle='--', color='#ffeb3b')\n","\n","  return"]},{"cell_type":"markdown","source":["### dump"],"metadata":{"id":"ddL_BC24buq0"}},{"cell_type":"markdown","source":["#### whole_plot thing"],"metadata":{"id":"zgTrEWWqbwsT"}},{"cell_type":"code","source":["fig = go.Figure(data=[go.Candlestick(x=t_df.index,\n","                open=t_df.open,\n","                high=t_df.high,\n","                low=t_df.low,\n","                close=t_df.close)])\n","\n","fig.show()"],"metadata":{"id":"M4zn8wxibzAR"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cf.go_offline()\n","init_notebook_mode()"],"metadata":{"id":"4IhBjPMobzAS"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["qf = cf.QuantFig(t_df, title=\"Apple's stock price in 2021\", name='AAPL')\n","qf.iplot()"],"metadata":{"id":"n9WZkE9wbzAS"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"zmYbP-Gc1ojs"},"source":["#### brief np_pr survey"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"82a8Km8z1ojs"},"outputs":[],"source":["# plot_pr_list[:100]\n","plt.plot(np_pr)\n","plt.axhline(1)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"5rdQZm_71ojv"},"source":["#### plot indi. legacy"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"u11r-dU91ojw"},"outputs":[],"source":["\n","  # ---------------------- ma ---------------------- #\n","   # --------- ema --------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(ema_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#03ed30', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  #   # --------- sma --------- #\n","  # alpha = 1\n","  # for sm_i, sma in enumerate(sma_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 4\n","  #   plt.step(np.arange(len(plot_df)), plot_df[sma].values, alpha=alpha, color='#e91e63', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","  \n","  # ---------------------- cb ---------------------- #\n","  # alpha = 1\n","  # for sm_i, item in enumerate(cb_list):\n","  #   if sm_i > 0:\n","  #     lw = 5\n","  #   else:\n","  #     lw = 2\n","  #   plt.step(np.arange(len(plot_df)), plot_df[item].values, alpha=alpha, color='#5b9cf6', linewidth=lw)\n","  #   alpha -= 0.2\n","\n","\n","  \n","  # ---------------------- sar ---------------------- #\n","  # alpha = 1\n","  # markersize = 5\n","  # for sar in sar_list:\n","  #   plt.step(plot_df[sar].values, 'c*', alpha=alpha, markersize=markersize, color='dodgerblue')  # sar mic\n","  #   markersize += 1\n","  #   alpha -= 0.1\n","\n","  # plt.step(plot_df.values[:, [12]], 'co', alpha=1, markersize=7)  # sar mac\n","\n","  #               cloud               #\n","  # alpha = 0.7\n","  # for senkoua, senkoub in zip(senkoua_list, senkoub_list):\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values, # ichimoku\n","  #                     where=plot_df[senkoua].values >= plot_df[senkoub].values, facecolor='g', alpha=alpha) # ichimoku\n","  #   plt.fill_between(np.arange(len(plot_df)), plot_df[senkoua].values, plot_df[senkoub].values,\n","  #                     where=plot_df[senkoua].values <= plot_df[senkoub].values, facecolor='r', alpha=alpha)  \n","  #   alpha -= 0.05\n","  \n","\n","\n","  # ---------------------- outer price indi. ---------------------- #\n","  #           macd          #\n","  # plt.subplot(312)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for macd in macd_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[macd].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  # #           trix          #  \n","  # # plt.subplot(313)\n","  # plt.subplot(gs[2])\n","  # alpha = 1\n","  # for trix in trix_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[trix].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","\n","  \n","  #           fisher          #  \n","  # plt.subplot(313)\n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for fisher in fisher_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[fisher].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","    \n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=0.5, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # plt.axhline(0, linestyle='--')\n","  # plt.axhline(fisher_upper, linestyle='--')\n","  # plt.axhline(fisher_lower, linestyle='--')\n","\n","  #           stoch          #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for stoch_ in stoch_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[stoch_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(stoch_upper, linestyle='--')\n","  # plt.axhline(stoch_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- cctbbo ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for cctbbo in cctbbo_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[cctbbo].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axhline(50, linestyle='--')\n","  # plt.axhline(cctbbo_upper, linestyle='--')\n","  # plt.axhline(cctbbo_lower, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n","  # ---------- ema_roc ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for emaroc in emaroc_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[emaroc].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(0, linestyle='--')\n","  \n","  # ---------- bbw ---------- #  \n","  # plt.subplot(gs[1])\n","  # alpha = 1\n","  # for bbwp_ in bbwp_list:\n","  #   plt.step(np.arange(len(plot_df)), plot_df[bbwp_].values, 'g', alpha=alpha)\n","  #   # plt.fill_between(np.arange(len(plot_df)), 0, plot_df[macd].values, facecolor='g', alpha=alpha) \n","  #   alpha -= 0.2\n","  # plt.axvline(prev_plotsize, linestyle='--')\n","  # plt.axvline(prev_plotsize + (tp_idx_list_[-1] - ep_idx_list_[0]), alpha=1, linestyle='--')\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","  # plt.axhline(bbwp_thresh, linestyle='--')\n","\n","  # plt.axvline(prev_plotsize - (ep_idx_list_[0] - open_idx), alpha=0.5, linestyle='--', color='lime')\n","\n"]},{"cell_type":"markdown","metadata":{"id":"tApzvz_gK9lR"},"source":["## legacy"]},{"cell_type":"markdown","metadata":{"id":"OJqkmkpsLCYC"},"source":["### tr_tresh calc"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gcpo4MGd9Wm4"},"outputs":[],"source":["res_wr = 0.6\n","# tr_thresh = 1\n","# tr_thresh = ((1 - res_wr) / res_wr) ** 0.5\n","tr_thresh = ((1 - res_wr) / res_wr) + 0.01\n","# tr_thresh = 2.6\n","print(\"res_wr :\", res_wr)\n","print(\"tr_thresh :\", tr_thresh)\n","\n","\n","#   단리    #\n","trade_num = 1000\n","asset = 1 # thousand USDT\n","test_loss_gap = 0.95  # fee adjusted\n","test_pr_gap = 1 + (1 - test_loss_gap) * tr_thresh\n","\n","test_loss_cnt = trade_num * (1 - res_wr)\n","test_pr_cnt = trade_num * res_wr\n","\n","test_trade_list = [test_pr_gap] * int(test_pr_cnt) + [test_loss_gap] * int(test_loss_cnt)\n","random.shuffle(test_trade_list)\n","# print(\"len(test_trade_list) :\", len(test_trade_list))\n","print(test_trade_list[:10])\n","print()\n","\n","# print(\"%.5f\" % np.cumprod(test_trade_list)[-1])\n","for tr_thresh_ in np.arange(1, 3, 0.2):\n","  if (1 + (1 - test_loss_gap) * tr_thresh_) ** test_pr_cnt * test_loss_gap ** test_loss_cnt > 1:\n","    break\n","print(\"복리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumprod(test_trade_list)[-1] :\", np.cumprod(test_trade_list)[-1])\n","print(\"total_pr : \", np.cumprod(test_trade_list)[-1])\n","print()\n","#   복리 tr_thresh  #\n","#   1. trade_num 에 영향 받지 않음\n","#   2. loss_gap 에 비례함\n","\n","for tr_thresh_ in np.arange(1, 3, 0.01):\n","  if ((1 - test_loss_gap) * tr_thresh_) * test_pr_cnt + (test_loss_gap - 1) * test_loss_cnt > 0:\n","    break\n","np_test_trade = np.array(test_trade_list) - 1\n","print(np_test_trade[:10])\n","# print(\"%.3f\" % )\n","print(\"단리를 위한 tr_thresh_ :\", tr_thresh_)\n","# print(\"tr_thresh :\", tr_thresh)\n","print(\"np.cumsum(np_test_trade)[-1] :\", np.cumsum(np_test_trade)[-1])\n","print(\"total_pr : \", 1 + np.cumsum(np_test_trade)[-1])\n"]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":["Ic1mfmwWCIBu","YxCPUzoyidwH","x2yj2SwAXDLp","xpyP5t8Ht_pE","MuD_2vY7TI_8","983aUwM76s6X","_blyFhQJUd5X"],"name":"stem5_45_vec_backi2(0528_signi_v4).ipynb","toc_visible":true,"provenance":[],"authorship_tag":"ABX9TyNZvra+4tjbWSkK40UTJ7NX"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}